<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>《C语言入门教程》阮一峰 - 神社的储物间</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="神社的储物间"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="神社的储物间"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="转自阮一峰大佬的教程。专家写的教程确实不一样，非常简洁易懂。"><meta property="og:type" content="blog"><meta property="og:title" content="《C语言入门教程》阮一峰"><meta property="og:url" content="https://mxts.jiujiuer.xyz/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/%E3%80%8AC%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%AE%E4%B8%80%E5%B3%B0/"><meta property="og:site_name" content="神社的储物间"><meta property="og:description" content="转自阮一峰大佬的教程。专家写的教程确实不一样，非常简洁易懂。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mxts.jiujiuer.xyz/img/og_image.png"><meta property="article:published_time" content="2021-11-02T05:20:21.000Z"><meta property="article:modified_time" content="2024-06-30T20:02:30.505Z"><meta property="article:author" content="xeonds"><meta property="article:tag" content="C语言"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://mxts.jiujiuer.xyz/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mxts.jiujiuer.xyz/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/%E3%80%8AC%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%AE%E4%B8%80%E5%B3%B0/"},"headline":"《C语言入门教程》阮一峰","image":["https://mxts.jiujiuer.xyz/img/og_image.png"],"datePublished":"2021-11-02T05:20:21.000Z","dateModified":"2024-06-30T20:02:30.505Z","author":{"@type":"Person","name":"阮一峰"},"publisher":{"@type":"Organization","name":"神社的储物间","logo":{"@type":"ImageObject","url":"https://mxts.jiujiuer.xyz/img/favicon.ico"}},"description":"转自阮一峰大佬的教程。专家写的教程确实不一样，非常简洁易懂。"}</script><link rel="canonical" href="https://mxts.jiujiuer.xyz/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/%E3%80%8AC%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E3%80%8B%E9%98%AE%E4%B8%80%E5%B3%B0/"><link rel="alternate" href="/atom.xml" title="神社的储物间" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?59fd9f709f6626bf608f0b08415e0283";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/favicon.ico" alt="神社的储物间" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archive</a><a class="navbar-item" href="/categories">Category</a><a class="navbar-item" href="/tags">Tag</a><a class="navbar-item" href="/links">Link</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="My GitHub" href="https://github.com/xeonds"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-11-02T05:20:21.000Z" title="11/2/2021, 5:20:21 AM">2021-11-02</time>发表</span><span class="level-item"><time dateTime="2024-06-30T20:02:30.505Z" title="6/30/2024, 8:02:30 PM">2024-07-01</time>更新</span><span class="level-item"> 阮一峰 </span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/">计算机科学</a><span> / </span><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span> / </span><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C/">C·C++</a></span><span class="level-item">11 小时读完 (大约100972个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">《C语言入门教程》阮一峰</h1><div class="content"><blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2021/09/c-language-tutorial.html">https://www.ruanyifeng.com/blog/2021/09/c-language-tutorial.html</a><br>我把这些都转载到这里了</p>
</blockquote>
<h2 id="C-语言简介"><a href="#C-语言简介" class="headerlink" title="C 语言简介"></a>C 语言简介</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>C 语言最初是作为 Unix 系统的开发工具而发明的。</p>
<p>1969年，美国贝尔实验室的肯·汤普森（Ken Thompson）与丹尼斯·里奇（Dennis Ritchie）一起开发了 Unix 操作系统。Unix 是用汇编语言写的，无法移植到其他计算机，他们决定使用高级语言重写。但是，当时的高级语言无法满足他们的要求，汤普森就在 BCPL 语言的基础上发明了 B 语言。</p>
<p>1972年，丹尼斯·里奇和布莱恩·柯林汉（Brian Kernighan）又在 B 语言的基础上重新设计了一种新语言，这种新语言取代了 B 语言，所以称为 C 语言。</p>
<p>1973年，整个 Unix 系统都使用 C 语言重写。此后，这种语言开始快速流传，广泛用于各种操作系统和系统软件的开发。</p>
<p>1988年，美国国家标准协会（ANSI）正式将 C 语言标准化，标志着 C 语言开始稳定和规范化。</p>
<p>几十年后的今天，C 语言依然是最广泛使用、最流行的系统编程语言之一，Unix 和 Linux 系统现在还是使用 C 语言开发。</p>
<h3 id="C-语言的特点"><a href="#C-语言的特点" class="headerlink" title="C 语言的特点"></a>C 语言的特点</h3><p>C 语言能够长盛不衰、广泛应用，主要原因是它有一些鲜明的特点。</p>
<p>（1）低级语言</p>
<p>C 语言能够直接操作硬件、管理内存、跟操作系统对话，这使得它是一种非常接近底层的语言，也就是低级语言，非常适合写需要跟硬件交互、有极高性能要求的程序。</p>
<p>（2）可移植性</p>
<p>C 语言的原始设计目的，是将 Unix 系统移植到其他计算机架构。这使得它从一开始就非常注重可移植性，C 程序可以相对简单地移植到各种硬件架构和操作系统。</p>
<p>除了计算机，C 语言现在还是嵌入式系统的首选编程语言，汽车、照相机、家用电器等设备的底层系统都是用 C 语言编程，这也是因为它良好的可移植性。</p>
<p>（3）简单性</p>
<p>C 语言的语法相对简单，语法规则不算太多，也几乎没有语法糖。一般来说，如果两个语法可以完成几乎相同的事情，C 语言就只会提供一种，这样大大减少了语言的复杂性。</p>
<p>而且，C 语言的语法都是基础语法，不提供高级的数据结构，比如 C 语言没有“类”（class），复杂的数据结构都需要自己构造。</p>
<p>（4）灵活性</p>
<p>C 语言对程序员的限制很少。它假设程序员知道自己在干嘛，不会限制你做各种危险的操作，你干什么都可以，后果也由自己负责。</p>
<p>C 语言的哲学是“信任程序员，不要妨碍他们做事”。比如，它让程序员自己管理内存，不提供内存自动清理功能。另外，也不提供类型检查、数组的负索引检查、指针位置的检查等保护措施。</p>
<p>表面上看，这似乎很危险，但是对于高级程序员来说，却有了更大的编程自由。不过，这也使得 C 语言的 debug 不太容易。</p>
<p>（5）总结</p>
<p>上面这些特点，使得 C 语言可以写出性能非常强、完全发挥硬件潜力的程序，而且 C 语言的编译器实现难度相对较低。但是另一方面，C 语言代码容易出错，一般程序员不容易写好。</p>
<p>此外，当代很多流行语言都是以 C 语言为基础，比如 C++、Java、C#、JavaScript 等等。学好 C 语言有助于对这些语言加深理解。</p>
<h3 id="C-语言的版本"><a href="#C-语言的版本" class="headerlink" title="C 语言的版本"></a>C 语言的版本</h3><p>历史上，C 语言有过多个版本。</p>
<p>（1）K＆R C</p>
<p><code>K&amp;R C</code>指的是 C 语言的原始版本。1978年，C 语言的发明者丹尼斯·里奇（Dennis Ritchie）和布莱恩·柯林（Brian Kernighan）合写了一本著名的教材《C 编程语言》（The C programming language）。由于 C 语言还没有成文的语法标准，这本书就成了公认标准，以两位作者的姓氏首字母作为版本简称“K&amp;R C”。</p>
<p>（2）ANSI C（又称 C89 或 C90）</p>
<p>C 语言的原始版本非常简单，对很多情况的描述非常模糊，加上 C 语法依然在快速发展，要求将 C 语言标准化的呼声越来越高。</p>
<p>1989年，美国国家标准协会（ANSI）制定了一套 C 语言标准。1990年，国际标准化组织（ISO）通过了这个标准。它被称为“ANSI C”，也可以按照发布年份，称为“C89 或 C90”。</p>
<p>（3）C95</p>
<p>1995年，美国国家标准协会对1989年的那个标准，进行了补充，加入多字节字符和宽字符的支持。这个版本称为 C95。</p>
<p>（4）C99</p>
<p>C 语言标准的第一次大型修订，发生在1999年，增加了许多语言特性，比如双斜杠（<code>//</code>）的注释语法。这个版本称为 C99，是目前最流行的 C 版本。</p>
<p>（5）C11</p>
<p>2011年，标准化组织再一次对 C 语言进行修订，增加了 Unicode 和多线程的支持。这个版本称为 C11。</p>
<p>（6）C17</p>
<p>C11 标准在2017年进行了修补，但发布是在2018年。新版本只是解决了 C11 的一些缺陷，没有引入任何新功能。这个版本称为 C17。</p>
<p>（7）C2x</p>
<p>标准化组织正在讨论 C 语言的下一个版本，据说可能会在2023年通过，到时就会称为 C23。</p>
<h3 id="C-语言的编译"><a href="#C-语言的编译" class="headerlink" title="C 语言的编译"></a>C 语言的编译</h3><p>C 语言是一种编译型语言，源码都是文本文件，本身无法执行。必须通过编译器，生成二进制的可执行文件，才能执行。编译器将代码从文本翻译成二进制指令的过程，就称为编译阶段，又称为“编译时”（compile time），跟运行阶段（又称为“运行时”）相区分。</p>
<p>目前，最常见的 C 语言编译器是自由软件基金会推出的 GCC 编译器，它可以免费使用。本书也使用这个编译器。Linux 和 Mac 系统可以直接安装 GCC，Windows 系统可以安装 MinGW。但是，也可以不用这么麻烦，网上有在线编译器，能够直接在网页上模拟运行 C 代码，查看结果，下面就是两个这样的工具。</p>
<ul>
<li>CodingGround: <a target="_blank" rel="noopener" href="https://tutorialspoint.com/compile_c_online.php">https://tutorialspoint.com/compile_c_online.php</a></li>
<li>OnlineGDB: <a target="_blank" rel="noopener" href="https://onlinegdb.com/online_c_compiler">https://onlinegdb.com/online_c_compiler</a></li>
</ul>
<p>本书的例子都使用 GCC 在命令行进行编译。</p>
<h3 id="Hello-World-示例"><a href="#Hello-World-示例" class="headerlink" title="Hello World 示例"></a>Hello World 示例</h3><p>C 语言的源代码文件，通常以后缀名<code>.c</code>结尾。下面是一个简单的 C 程序<code>hello.c</code>。它就是一个普通的文本文件，任何文本编译器都能用来写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个程序的唯一作用，就是在屏幕上面显示“Hello World”。</p>
<p>这里不讲解这些代码是什么意思，只是作为一个例子，让大家看看 C 代码应该怎么编译和运行。假设你已经安装好了 GCC 编译器，可以打开命令行，执行下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c</span><br></pre></td></tr></table></figure>

<p>上面命令使用<code>gcc</code>编译器，将源文件<code>hello.c</code>编译成二进制代码。注意，<code>$</code>是命令行提示符，你真正需要输入的是<code>$</code>后面的部分。</p>
<p>运行这个命令以后，默认会在当前目录下生成一个编译产物文件<code>a.out</code>（assembler output 的缩写，Windows 平台为<code>a.exe</code>）。执行该文件，就会在屏幕上输出<code>Hello World</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>GCC 的<code>-o</code>参数（output 的缩写）可以指定编译产物的文件名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure>

<p>上面命令的<code>-o hello</code>指定，编译产物的文件名为<code>hello</code>（取代默认的<code>a.out</code>）。编译后就会生成一个名叫<code>hello</code>的可执行文件，相当于为<code>a.out</code>指定了名称。执行该文件，也会得到同样的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>GCC 的<code>-std=</code>参数（standard 的缩写）还可以指定按照哪个 C 语言的标准进行编译。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -std=c99 hello.c</span><br></pre></td></tr></table></figure>

<p>上面命令指定按照 C99 标准进行编译。</p>
<p>注意，<code>-std</code>后面需要用<code>=</code>连接参数，而不是像上面的<code>-o</code>一样用空格，并且<code>=</code>前后也不能有多余的空格。</p>
<h2 id="C-语言基本语法"><a href="#C-语言基本语法" class="headerlink" title="C 语言基本语法"></a>C 语言基本语法</h2><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>C 语言的代码由一行行语句（statement）组成。语句就是程序执行的一个操作命令。C 语言规定，语句必须使用分号结尾，除非有明确规定可以不写分号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面就是一个变量声明语句，声明整数变量<code>x</code>，并且将值设为<code>1</code>。</p>
<p>多个语句可以写在一行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x; x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例是两个语句写在一行。所以，语句之间的换行符并不是必需的，只是为了方便阅读代码。</p>
<p>一个语句也可以写成多行，这时就要依靠分号判断语句在哪一行结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">x</span><br><span class="line">=</span><br><span class="line"><span class="number">1</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>上面示例中，第二个语句<code>x = 1;</code>被拆成了四行。编译器会自动忽略代码里面的换行。</p>
<p>单个分号也是有效语句，称为“空语句”，虽然毫无作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>C 语言的各种计算，主要通过表达式完成。表达式（expression）是一个计算式，用来获取值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>上面代码就是一个表达式，用来获取<code>1 + 2</code>这个算术计算的结果。</p>
<p>表达式加上分号，也可以成为语句，但是没有实际的作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>;</span><br><span class="line"><span class="number">3</span> + <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例是两个表达式，加上分号以后成为语句。</p>
<p>表达式与语句的区别主要是两点：</p>
<ul>
<li>语句可以包含表达式，但是表达式本身不构成语句。</li>
<li>表达式都有返回值，语句不一定有。因为语句用来执行某个命令，很多时候不需要返回值，比如变量声明语句（<code>int x = 1</code>）就没有返回值。</li>
</ul>
<h3 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h3><p>C 语言允许多个语句使用一对大括号<code>&#123;&#125;</code>，组成一个块，也称为复合语句（compounded statement）。在语法上，语句块可以视为多个语句组成的一个复合语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，大括号形成了一个语句块。</p>
<p>大括号的结尾不需要添加分号。</p>
<h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>C 语言里面的空格，主要用来帮助编译器区分语法单位。如果语法单位不用空格就能区分，空格就不是必须的，只是为了增加代码的可读性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，赋值号（<code>=</code>）前后有没有空格都可以，因为编译器这里不借助空格，就能区分语法单位。</p>
<p>语法单位之间的多个空格，等同于单个空格。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>    x =     <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，各个语法单位之间的多个空格，跟单个空格的效果是一样的。</p>
<p>空格还用来表示缩进。多层级的代码有没有缩进，其实对于编译器来说并没有差别，没有缩进的代码也是完全可以运行的。强调代码缩进，只是为了增强代码可读性，便于区分代码块。</p>
<p>大多数 C 语言的风格要求是，下一级代码比上一级缩进4个空格。为了书写的紧凑，本书采用缩写两个空格。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缩进四个空格</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;positive\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩进两个空格</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;positive\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>只包含空格的行被称为空白行，编译器会完全忽略该行。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释是对代码的说明，编译器会忽略注释，也就是说，注释对实际代码没有影响。</p>
<p>C 语言的注释有两种表示方法。第一种方法是将注释放在<code>/*...*/</code>之间，内部可以分行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注释 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这种注释可以插在行内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span>* s <span class="comment">/* file name */</span>, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>/* file name */</code>用来对函数参数进行说明，跟在它后面的代码依然会有效执行。</p>
<p>这种注释一定不能忘记写结束符号<code>*/</code>，否则很容易导致错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a &quot;</span>); <span class="comment">/* 注释一</span></span><br><span class="line"><span class="comment">printf(&quot;b &quot;);</span></span><br><span class="line"><span class="comment">printf(&quot;c &quot;); /* 注释二 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d &quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例的原意是，第一行和第三行代码的尾部，有两个注释。但是，第一行注释忘记写结束符号，导致注释一延续到第三行结束。</p>
<p>第二种写法是将注释放在双斜杠<code>//</code>后面，从双斜杠到行尾都属于注释。这种注释只能是单行，可以放在行首，也可以放在一行语句的结尾。这是 C99 标准新增的语法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一行注释</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>; <span class="comment">// 这也是注释</span></span><br></pre></td></tr></table></figure>

<p>不管是哪一种注释，都不能放在双引号里面。双引号里面的注释符号，会成为字符串的一部分，解释为普通符号，失去注释作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;// hello /* world */ &quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，双引号里面的注释符号，都会被视为普通字符，没有注释作用。</p>
<p>编译时，注释会被替换成一个空格，所以<code>min/* space */Value</code>会变成<code>min Value</code>，而不是<code>minValue</code>。</p>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>本书的示例会大量用到<code>printf()</code>函数，这里先介绍一下这个函数。</p>
<p><code>printf()</code>的作用是将参数文本输出到屏幕。它名字里面的<code>f</code>代表<code>format</code>（格式化），表示可以定制输出文本的格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面命令会在屏幕上输出一行文字“Hello World”。</p>
<p><code>printf()</code>不会在行尾自动添加换行符，运行结束后，光标就停留在输出结束的地方，不会自动换行。为了让光标移到下一行的开头，可以在输出文本的结尾，添加一个换行符<code>\n</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果文本内部有换行，也是通过插入换行符来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello\nWorld\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例先输出一个<code>Hello</code>，然后换行，在下一行开头输出<code>World</code>，然后又是一个换行。</p>
<p>上面示例也可以写成两个<code>printf()</code>，效果完全一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;World\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>printf()</code>是在标准库的头文件<code>stdio.h</code>定义的。使用这个函数之前，必须在源码文件头部引入这个头文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，只有在源码头部加上<code>#include &lt;stdio.h&gt;</code>，才能使用<code>printf()</code>这个函数。<code>#include</code>指令的详细解释，请看《预处理器》一章。</p>
<h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><p><code>printf()</code>可以在输出文本中指定占位符。所谓“占位符”，就是这个位置可以用其他值代入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 There are 3 apples</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;There are %i apples\n&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>There are %i apples\n</code>是输出文本，里面的<code>%i</code>就是占位符，表示这个位置要用其他值来替换。占位符的第一个字符一律为百分号<code>%</code>，第二个字符表示占位符的类型，<code>%i</code>表示这里代入的值必须是一个整数。</p>
<p><code>printf()</code>的第二个参数就是替换占位符的值，上面的例子是整数<code>3</code>替换<code>%i</code>。执行后的输出结果就是<code>There are 3 apples</code>。</p>
<p>常用的占位符除了<code>%i</code>，还有<code>%s</code>表示代入的是字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s will come tonight\n&quot;</span>, <span class="string">&quot;Jane&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>%s</code>表示代入的是一个字符串，所以<code>printf()</code>的第二个参数就必须是字符串，这个例子是<code>Jane</code>。执行后的输出就是<code>Jane will come tonight</code>。</p>
<p>输出文本里面可以使用多个占位符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s says it is %i o&#x27;clock\n&quot;</span>, <span class="string">&quot;Ben&quot;</span>, <span class="number">21</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，输出文本<code>%s says it is %i o&#39;clock</code>有两个占位符，第一个是字符串占位符<code>%s</code>，第二个是整数占位符<code>%i</code>，分别对应<code>printf()</code>的第二个参数（<code>Ben</code>）和第三个参数（<code>21</code>）。执行后的输出就是<code>Ben says it is 21 o&#39;clock</code>。</p>
<p><code>printf()</code>参数与占位符是一一对应关系，如果有<code>n</code>个占位符，<code>printf()</code>的参数就应该有<code>n + 1</code>个。如果参数个数少于对应的占位符，<code>printf()</code>可能会输出内存中的任意值。</p>
<p><code>printf()</code>的占位符有许多种类，与 C 语言的数据类型相对应。下面按照字母顺序，列出常用的占位符，方便查找，具体含义在后面章节介绍。</p>
<ul>
<li><code>%a</code>：浮点数。</li>
<li><code>%A</code>：浮点数。</li>
<li><code>%c</code>：字符。</li>
<li><code>%d</code>：十进制整数。</li>
<li><code>%e</code>：使用科学计数法的浮点数，指数部分的<code>e</code>为小写。</li>
<li><code>%E</code>：使用科学计数法的浮点数，指数部分的<code>E</code>为大写。</li>
<li><code>%i</code>：整数，基本等同于<code>%d</code>。</li>
<li><code>%f</code>：小数（包含<code>float</code>类型和<code>double</code>类型）。</li>
<li><code>%g</code>：6个有效数字的浮点数。整数部分一旦超过6位，就会自动转为科学计数法，指数部分的<code>e</code>为小写。</li>
<li><code>%G</code>：等同于<code>%g</code>，唯一的区别是指数部分的<code>E</code>为大写。</li>
<li><code>%hd</code>：十进制 short int 类型。</li>
<li><code>%ho</code>：八进制 short int 类型。</li>
<li><code>%hx</code>：十六进制 short int 类型。</li>
<li><code>%hu</code>：unsigned short int 类型。</li>
<li><code>%ld</code>：十进制 long int 类型。</li>
<li><code>%lo</code>：八进制 long int 类型。</li>
<li><code>%lx</code>：十六进制 long int 类型。</li>
<li><code>%lu</code>：unsigned long int 类型。</li>
<li><code>%lld</code>：十进制 long long int 类型。</li>
<li><code>%llo</code>：八进制 long long int 类型。</li>
<li><code>%llx</code>：十六进制 long long int 类型。</li>
<li><code>%llu</code>：unsigned long long int 类型。</li>
<li><code>%Le</code>：科学计数法表示的 long double 类型浮点数。</li>
<li><code>%Lf</code>：long double 类型浮点数。</li>
<li><code>%n</code>：已输出的字符串数量。该占位符本身不输出，只将值存储在指定变量之中。</li>
<li><code>%o</code>：八进制整数。</li>
<li><code>%p</code>：指针。</li>
<li><code>%s</code>：字符串。</li>
<li><code>%u</code>：无符号整数（unsigned int）。</li>
<li><code>%x</code>：十六进制整数。</li>
<li><code>%zd</code>：<code>size_t</code>类型。</li>
<li><code>%%</code>：输出一个百分号。</li>
</ul>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p><code>printf()</code>可以定制占位符的输出格式。</p>
<p>（1）限定宽度</p>
<p><code>printf()</code>允许限定占位符的最小宽度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%5d\n&quot;</span>, <span class="number">123</span>); <span class="comment">// 输出为 &quot;  123&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>%5d</code>表示这个占位符的宽度至少为5位。如果不满5位，对应的值的前面会添加空格。</p>
<p>输出的值默认是右对齐，即输出内容前面会有空格；如果希望改成左对齐，在输出内容后面添加空格，可以在占位符的<code>%</code>的后面插入一个<code>-</code>号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-5d\n&quot;</span>, <span class="number">123</span>); <span class="comment">// 输出为 &quot;123  &quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，输出内容<code>123</code>的后面添加了空格。</p>
<p>对于小数，这个限定符会限制所有数字的最小显示宽度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 &quot;  123.450000&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%12f\n&quot;</span>, <span class="number">123.45</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>%12f</code>表示输出的浮点数最少要占据12位。由于小数的默认显示精度是小数点后6位，所以<code>123.45</code>输出结果的头部会添加2个空格。</p>
<p>（2）总是显示正负号</p>
<p>默认情况下，<code>printf()</code>不对正数显示<code>+</code>号，只对负数显示<code>-</code>号。如果想让正数也输出<code>+</code>号，可以在占位符的<code>%</code>后面加一个<code>+</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%+d\n&quot;</span>, <span class="number">12</span>); <span class="comment">// 输出 +12</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%+d\n&quot;</span>, <span class="number">-12</span>); <span class="comment">// 输出 -12</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>%+d</code>可以确保输出的数值，总是带有正负号。</p>
<p>（3）限定小数位数</p>
<p>输出小数时，有时希望限定小数的位数。举例来说，希望小数点后面只保留两位，占位符可以写成<code>%.2f</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 Number is 0.50</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Number is %.2f\n&quot;</span>, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果希望小数点后面输出3位（<code>0.500</code>），占位符就要写成<code>%.3f</code>。</p>
<p>这种写法可以与限定宽度占位符，结合使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出为 &quot;  0.50&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%6.2f\n&quot;</span>, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>%6.2f</code>表示输出字符串最小宽度为6，小数位数为2。所以，输出字符串的头部有两个空格。</p>
<p>最小宽度和小数位数这两个限定值，都可以用<code>*</code>代替，通过<code>printf()</code>的参数传入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%*.*f\n&quot;</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%6.2f\n&quot;</span>, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>%*.*f</code>的两个星号通过<code>printf()</code>的两个参数<code>6</code>和<code>2</code>传入。</p>
<p>（4）输出部分字符串</p>
<p><code>%s</code>占位符用来输出字符串，默认是全部输出。如果只想输出开头的部分，可以用<code>%.[m]s</code>指定输出的长度，其中<code>[m]</code>代表一个数字，表示所要输出的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 hello</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.5s\n&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，占位符<code>%.5s</code>表示只输出字符串“hello world”的前5个字符，即“hello”。</p>
<h3 id="标准库，头文件"><a href="#标准库，头文件" class="headerlink" title="标准库，头文件"></a>标准库，头文件</h3><p>程序需要用到的功能，不一定需要自己编写，C 语言可能已经自带了。程序员只要去调用这些自带的功能，就省得自己编写代码了。举例来说，<code>printf()</code>这个函数就是 C 语言自带的，只要去调用它，就能实现在屏幕上输出内容。</p>
<p>C 语言自带的所有这些功能，统称为“标准库”（standard library），因为它们是写入标准的，到底包括哪些功能，应该怎么使用的，都是规定好的，这样才能保证代码的规范和可移植。</p>
<p>不同的功能定义在不同的文件里面，这些文件统称为“头文件”（header file）。如果系统自带某一个功能，就一定还会自带描述这个功能的头文件，比如<code>printf()</code>的头文件就是系统自带的<code>stdio.h</code>。头文件的后缀通常是<code>.h</code>。</p>
<p>如果要使用某个功能，就必须先加载对应的头文件，加载使用的是<code>#include</code>命令。这就是为什么使用<code>printf()</code>之前，必须先加载<code>stdio.h</code>的原因。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>注意，加载头文件的<code>#include</code>语句不需要分号结尾，详见《预处理器》一章。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量（variable）可以理解成一块内存区域的名字。通过变量名，可以引用这块内存区域，获取里面存储的值。由于值可能发生变化，所以称为变量，否则就是常量了。</p>
<h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><p>变量名在 C 语言里面属于标识符（identifier），命名有严格的规范。</p>
<ul>
<li>只能由字母（包括大写和小写）、数字和下划线（<code>_</code>）组成。</li>
<li>不能以数字开头。</li>
<li>长度不能超过63个字符。</li>
</ul>
<p>下面是一些无效变量名的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$zj</span><br><span class="line">j**p</span><br><span class="line"><span class="number">2</span>cat</span><br><span class="line">Hot-tab</span><br><span class="line">tax rate</span><br><span class="line">don<span class="number">&#x27;</span>t</span><br></pre></td></tr></table></figure>

<p>上面示例中，每一行的变量名都是无效的。</p>
<p>变量名区分大小写，<code>star</code>、<code>Star</code>、<code>STAR</code>都是不同的变量。</p>
<p>并非所有的词都能用作变量名，有些词在 C 语言里面有特殊含义（比如<code>int</code>），另一些词是命令（比如<code>continue</code>），它们都称为关键字，不能用作变量名。另外，C 语言还保留了一些词，供未来使用，这些保留字也不能用作变量名。下面就是 C 语言主要的关键字和保留字。</p>
<blockquote>
<p>auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, inline, int, long, register, restrict, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while</p>
</blockquote>
<p>另外，两个下划线开头的变量名，以及一个下划线 + 大写英文字母开头的变量名，都是系统保留的，自己不应该起这样的变量名。</p>
<h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><p>C 语言的变量，必须先声明后使用。如果一个变量没有声明，就直接使用，会报错。</p>
<p>每个变量都有自己的类型（type）。声明变量时，必须把变量的类型告诉编译器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height;</span><br></pre></td></tr></table></figure>

<p>上面代码声明了变量<code>height</code>，并且指定类型为<code>int</code>（整数）。</p>
<p>如果几个变量具有相同类型，可以在同一行声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height, width;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="type">int</span> width;</span><br></pre></td></tr></table></figure>

<p>注意，声明变量的语句必须以分号结尾。</p>
<p>一旦声明，变量的类型就不能在运行时修改。</p>
<h3 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h3><p>C 语言会在变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。所以，变量一定要赋值以后才能使用。</p>
<p>赋值操作通过赋值运算符（<code>=</code>）完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line">num = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，第一行声明了一个整数变量<code>num</code>，第二行给这个变量赋值。</p>
<p>变量的值应该与类型一致，不应该赋予不是同一个类型的值，比如<code>num</code>的类型是整数，就不应该赋值为小数。虽然 C 语言会自动转换类型，但是应该避免赋值运算符两侧的类型不一致。</p>
<p>变量的声明和赋值，也可以写在一行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>多个相同类型变量的赋值，可以写在同一行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>注意，赋值表达式有返回值，等于等号右边的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = (x = <span class="number">2</span> * x);</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>y</code>的值就是赋值表达式（<code>x = 2 * x</code>）的返回值<code>2</code>。</p>
<p>由于赋值表达式有返回值，所以 C 语言可以写出多重赋值表达式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y, z, m, n;</span><br><span class="line"></span><br><span class="line">x = y = z = m = n = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>上面的代码是合法代码，一次为多个变量赋值。赋值运算符是从右到左执行，所以先为<code>n</code>赋值，然后依次为<code>m</code>、<code>z</code>、<code>y</code>和<code>x</code>赋值。</p>
<p>C 语言有左值（left value）和右值（right value）的概念。左值是可以放在赋值运算符左边的值，一般是变量；右值是可以放在赋值运算符右边的值，一般是一个具体的值。这是为了强调有些值不能放在赋值运算符的左边，比如<code>x = 1</code>是合法的表达式，但是<code>1 = x</code>就会报错。</p>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>作用域（scope）指的是变量生效的范围。C 语言的变量作用域主要有两种：文件作用域（file scope）和块作用域（block scope）。</p>
<p>文件作用域（file scope）指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>是在文件顶层声明的，从声明位置开始的整个当前文件都是它的作用域，可以在这个范围的任何地方读取这个变量，比如函数<code>main()</code>内部就可以读取这个变量。</p>
<p>块作用域（block scope）指的是由大括号（<code>&#123;&#125;</code>）组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">12</span>) &#123;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">99</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a, b);  <span class="comment">// 12 99</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);  <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b);  <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，变量<code>b</code>是在<code>if</code>代码块里面声明的，所以对于大括号外面的代码，这个变量是不存在的。</p>
<p>代码块可以嵌套，即代码块内部还有代码块，这时就形成了多层的块作用域。它的规则是：内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);  <span class="comment">// 20</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，内层和外层都有一个变量<code>i</code>，每个作用域都会优先使用当前作用域声明的<code>i</code>。</p>
<p>最常见的块作用域就是函数，函数内部声明的变量，对于函数外部是不可见的。<code>for</code>循环也是一个块作用域，循环变量只对循环体内部可见，外部是不可见的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>for</code>循环省略了大括号，但依然是一个块作用域，在外部读取循环变量<code>i</code>，编译器就会报错。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>C 语言的运算符非常多，一共有 50 多种，可以分成若干类。</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符专门用于算术运算，主要有下面几种。</p>
<ul>
<li><code>+</code>：正值运算符（一元运算符）</li>
<li><code>-</code>：负值运算符（一元运算符）</li>
<li><code>+</code>：加法运算符（二元运算符）</li>
<li><code>-</code>：减法运算符（二元运算符）</li>
<li><code>*</code>：乘法运算符</li>
<li><code>/</code>：除法运算符</li>
<li><code>%</code>：余值运算符</li>
</ul>
<p>（1）<code>+</code>，<code>-</code></p>
<p><code>+</code>和<code>-</code>既可以作为一元运算符，也可以作为二元运算符。所谓“一元运算符”，指的是只需要一个运算数就可以执行。一元运算符<code>-</code>用来改变一个值的正负号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">-12</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>-</code>将<code>12</code>这个值变成<code>-12</code>。</p>
<p>一元运算符<code>+</code>对正负值没有影响，是一个完全可以省略的运算符，但是写了也不会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">-12</span>;</span><br><span class="line"><span class="type">int</span> y = +x;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>y</code>的值还是<code>-12</code>，因为<code>+</code>不会改变正负值。</p>
<p>二元运算符<code>+</code>和<code>-</code>用来完成加法和减法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">4</span> + <span class="number">22</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">61</span> - <span class="number">23</span>;</span><br></pre></td></tr></table></figure>

<p>（2）<code>*</code></p>
<p>运算符<code>*</code>用来完成乘法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, num * num); <span class="comment">// 输出 25</span></span><br></pre></td></tr></table></figure>

<p>（3）<code>/</code></p>
<p>运算符<code>/</code>用来完成除法。注意，两个整数相除，得到还是一个整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x = <span class="number">6</span> / <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, x); <span class="comment">// 输出 1.000000</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，尽管变量<code>x</code>的类型是<code>float</code>（浮点数），但是<code>6 / 4</code>得到的结果是<code>1.0</code>，而不是<code>1.5</code>。原因就在于 C 语言里面的整数除法是整除，只会返回整数部分，丢弃小数部分。</p>
<p>如果希望得到浮点数的结果，两个运算数必须至少有一个浮点数，这时 C 语言就会进行浮点数除法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x = <span class="number">6.0</span> / <span class="number">4</span>; <span class="comment">// 或者写成 6 / 4.0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, x); <span class="comment">// 输出 1.500000</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>6.0 / 4</code>表示进行浮点数除法，得到的结果就是<code>1.5</code>。</p>
<p>下面是另一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> score = <span class="number">5</span>;</span><br><span class="line">score = (score / <span class="number">20</span>) * <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>上面的代码，你可能觉得经过运算，<code>score</code>会等于<code>25</code>，但是实际上<code>score</code>等于<code>0</code>。这是因为<code>score / 20</code>是整除，会得到一个整数值<code>0</code>，所以乘以<code>100</code>后得到的也是<code>0</code>。</p>
<p>为了得到预想的结果，可以将除数<code>20</code>改成<code>20.0</code>，让整除变成浮点数除法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">score = (score / <span class="number">20.0</span>) * <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>（4）<code>%</code></p>
<p>运算符<code>%</code>表示求模运算，即返回两个整数相除的余值。这个运算符只能用于整数，不能用于浮点数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">6</span> % <span class="number">4</span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>负数求模的规则是，结果的正负号由第一个运算数的正负号决定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> % <span class="number">-5</span> <span class="comment">// 1</span></span><br><span class="line"><span class="number">-11</span> % <span class="number">-5</span> <span class="comment">// -1</span></span><br><span class="line"><span class="number">-11</span> % <span class="number">5</span> <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，第一个运算数的正负号（<code>11</code>或<code>-11</code>）决定了结果的正负号。</p>
<p>（5）赋值运算的简写形式</p>
<p>如果变量对自身的值进行算术运算，C 语言提供了简写形式，允许将赋值运算符和算术运算符结合成一个运算符。</p>
<ul>
<li><code>+=</code></li>
<li><code>-=</code></li>
<li><code>*=</code></li>
<li><code>/=</code></li>
<li><code>%=</code></li>
</ul>
<p>下面是一些例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i += <span class="number">3</span>;  <span class="comment">// 等同于 i = i + 3</span></span><br><span class="line">i -= <span class="number">8</span>;  <span class="comment">// 等同于 i = i - 8</span></span><br><span class="line">i *= <span class="number">9</span>;  <span class="comment">// 等同于 i = i * 9</span></span><br><span class="line">i /= <span class="number">2</span>;  <span class="comment">// 等同于 i = i / 2</span></span><br><span class="line">i %= <span class="number">5</span>;  <span class="comment">// 等同于 i = i % 5</span></span><br></pre></td></tr></table></figure>

<h3 id="自增运算符，自减运算符"><a href="#自增运算符，自减运算符" class="headerlink" title="自增运算符，自减运算符"></a>自增运算符，自减运算符</h3><p>C 语言提供两个运算符，对变量自身进行<code>+ 1</code>和<code>- 1</code>的操作。</p>
<ul>
<li><code>++</code>：自增运算符</li>
<li><code>--</code>：自减运算符</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i++; <span class="comment">// 等同于 i = i + 1</span></span><br><span class="line">i--; <span class="comment">// 等同于 i = i - 1</span></span><br></pre></td></tr></table></figure>

<p>这两个运算符放在变量的前面或后面，结果是不一样的。<code>++var</code>和<code>--var</code>是先执行自增或自减操作，再返回操作后<code>var</code>的值；<code>var++</code>和<code>var--</code>则是先返回操作前<code>var</code>的值，再执行自增或自减操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">j = (i++ + <span class="number">10</span>);</span><br><span class="line"><span class="comment">// i: 43</span></span><br><span class="line"><span class="comment">// j: 52</span></span><br><span class="line"></span><br><span class="line">j = (++i + <span class="number">10</span>)</span><br><span class="line"><span class="comment">// i: 44</span></span><br><span class="line"><span class="comment">// j: 54</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，自增运算符的位置差异，会导致变量<code>j</code>得到不同的值。这样的写法很容易出现意料之外的结果，为了消除意外，可以改用下面的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写法一 */</span></span><br><span class="line">j = (i + <span class="number">10</span>);</span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写法二 */</span></span><br><span class="line">i++;</span><br><span class="line">j = (i + <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>i</code>的自增运算与返回值是分离的两个步骤，这样就不太会出错，也提高了代码的可读性。</p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>C 语言用于比较的表达式，称为“关系表达式”（relational expression），里面使用的运算符就称为“关系运算符”（relational operator），主要有下面6个。</p>
<ul>
<li><code>&gt;</code> 大于运算符</li>
<li><code>&lt;</code> 小于运算符</li>
<li><code>&gt;=</code> 大于等于运算符</li>
<li><code>&lt;=</code> 小于等于运算符</li>
<li><code>==</code> 相等运算符</li>
<li><code>!=</code> 不相等运算符</li>
</ul>
<p>下面是一些例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a == b;</span><br><span class="line">a != b;</span><br><span class="line">a &lt; b;</span><br><span class="line">a &gt; b;</span><br><span class="line">a &lt;= b;</span><br><span class="line">a &gt;= b;</span><br></pre></td></tr></table></figure>

<p>关系表达式通常返回<code>0</code>或<code>1</code>，表示真伪。C 语言中，<code>0</code>表示伪，所有非零值表示真。比如，<code>20 &gt; 12</code>返回<code>1</code>，<code>12 &gt; 20</code>返回<code>0</code>。</p>
<p>关系表达式常用于<code>if</code>或<code>while</code>结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x is 3.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，相等运算符<code>==</code>与赋值运算符<code>=</code>是两个不一样的运算符，不要混淆。有时候，可能会不小心写出下面的代码，它可以运行，但很容易出现意料之外的结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x = <span class="number">3</span>) ...</span><br></pre></td></tr></table></figure>

<p>上面示例中，原意是<code>x == 3</code>，但是不小心写成<code>x = 3</code>。这个式子表示对变量<code>x</code>赋值<code>3</code>，它的返回值为<code>3</code>，所以<code>if</code>判断总是为真。</p>
<p>为了防止出现这种错误，有的程序员喜欢将变量写在等号的右边。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">3</span> == x) ...</span><br></pre></td></tr></table></figure>

<p>这样的话，如果把<code>==</code>误写成<code>=</code>，编译器就会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 报错 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">3</span> = x) ...</span><br></pre></td></tr></table></figure>

<p>另一个需要避免的错误是，多个关系运算符不宜连用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i &lt; j &lt; k</span><br></pre></td></tr></table></figure>

<p>上面示例中，连续使用两个小于运算符。这是合法表达式，不会报错，但是通常达不到想要的结果，即不是保证变量<code>j</code>的值在<code>i</code>和<code>k</code>之间。因为关系运算符是从左到右计算，所以实际执行的是下面的表达式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &lt; j) &lt; k</span><br></pre></td></tr></table></figure>

<p>上面式子中，<code>i &lt; j</code>返回<code>0</code>或<code>1</code>，所以最终是<code>0</code>或<code>1</code>与变量<code>k</code>进行比较。如果想要判断变量<code>j</code>的值是否在<code>i</code>和<code>k</code>之间，应该使用下面的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i &lt; j &amp;&amp; j &lt; k</span><br></pre></td></tr></table></figure>

<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符提供逻辑判断功能，用于构建更复杂的表达式，主要有下面三个运算符。</p>
<ul>
<li><code>!</code>：否运算符（改变单个表达式的真伪）。</li>
<li><code>&amp;&amp;</code>：与运算符（两侧的表达式都为真，则为真，否则为伪）。</li>
<li><code>||</code>：或运算符（两侧至少有一个表达式为真，则为真，否则为伪）。</li>
</ul>
<p>下面是与运算符的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">10</span> &amp;&amp; y &gt; <span class="number">20</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Doing something!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，只有<code>x &lt; 10</code>和<code>y &gt; 20</code>同时为真，<code>x &lt; 10 &amp;&amp; y &gt; 20</code>才会为真。</p>
<p>下面是否运算符的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(x &lt; <span class="number">12</span>))</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x is not less than 12\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，由于否运算符<code>!</code>具有比<code>&lt;</code>更高的优先级，所以必须使用括号，才能对表达式<code>x &lt; 12</code>进行否运算。当然，合理的写法是<code>if (x &gt;= 12)</code>，这里只是为了举例。</p>
<p>对于逻辑运算符来说，任何非零值都表示真，零值表示伪。比如，<code>5 || 0</code>会返回<code>1</code>，<code>5 &amp;&amp; 0</code>会返回<code>0</code>。</p>
<p>逻辑运算符还有一个特点，它总是先对左侧的表达式求值，再对右边的表达式求值，这个顺序是保证的。如果左边的表达式满足逻辑运算符的条件，就不再对右边的表达式求值。这种情况称为“短路”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (number != <span class="number">0</span> &amp;&amp; <span class="number">12</span>/number == <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果<code>&amp;&amp;</code>左侧的表达式（<code>number != 0</code>）为伪，即<code>number</code>等于<code>0</code>时，右侧的表达式（<code>12/number == 2</code>）是不会执行的。因为这时左侧表达式返回<code>0</code>，整个<code>&amp;&amp;</code>表达式肯定为伪，就直接返回<code>0</code>，不再执行右侧的表达式了。</p>
<p>由于逻辑运算符的执行顺序是先左后右，所以下面的代码是有问题的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((x++ &lt; <span class="number">10</span>) &amp;&amp; (x + y &lt; <span class="number">20</span>))</span><br></pre></td></tr></table></figure>

<p>上面示例中，执行左侧表达式后，变量<code>x</code>的值就已经变了。等到执行右侧表达式的时候，是用新的值在计算，这通常不是原始意图。</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>C 语言提供一些位运算符，用来操作二进制位（bit）。</p>
<p>（1）取反运算符<code>～</code></p>
<p>取反运算符<code>～</code>是一个一元运算符，用来将每一个二进制位变成相反值，即<code>0</code>变成<code>1</code>，<code>1</code>变成<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 01101100</span></span><br><span class="line">~ <span class="number">10010011</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>~</code>对每个二进制位取反，就得到了一个新的值。</p>
<p>注意，<code>~</code>运算符不会改变变量的值，只是返回一个新的值。</p>
<p>（2）与运算符<code>&amp;</code></p>
<p>与运算符<code>&amp;</code>将两个值的每一个二进制位进行比较，返回一个新的值。当两个二进制位都为<code>1</code>，就返回<code>1</code>，否则返回<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 00010001</span></span><br><span class="line"><span class="number">10010011</span> &amp; <span class="number">00111101</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，两个八位二进制数进行逐位比较，返回一个新的值。</p>
<p>与运算符<code>&amp;</code>可以与赋值运算符<code>=</code>结合，简写成<code>&amp;=</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">3</span>;</span><br><span class="line">val = val &amp; <span class="number">0377</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写成</span></span><br><span class="line">val &amp;= <span class="number">0377</span>;</span><br></pre></td></tr></table></figure>

<p>（3）或运算符<code>|</code></p>
<p>或运算符<code>|</code>将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位只要有一个为<code>1</code>（包含两个都为<code>1</code>的情况），就返回<code>1</code>，否则返回<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 10111111</span></span><br><span class="line"><span class="number">10010011</span> | <span class="number">00111101</span></span><br></pre></td></tr></table></figure>

<p>或运算符<code>|</code>可以与赋值运算符<code>=</code>结合，简写成<code>|=</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">3</span>;</span><br><span class="line">val = val | <span class="number">0377</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写为</span></span><br><span class="line">val |= <span class="number">0377</span>;</span><br></pre></td></tr></table></figure>

<p>（4）异或运算符<code>^</code></p>
<p>异或运算符<code>^</code>将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位有且仅有一个为<code>1</code>，就返回<code>1</code>，否则返回<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 10101110</span></span><br><span class="line"><span class="number">10010011</span> ^ <span class="number">00111101</span></span><br></pre></td></tr></table></figure>

<p>异或运算符<code>^</code>可以与赋值运算符<code>=</code>结合，简写成<code>^=</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">3</span>;</span><br><span class="line">val = val ^ <span class="number">0377</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写为</span></span><br><span class="line">val ^= <span class="number">0377</span>;</span><br></pre></td></tr></table></figure>

<p>（5）左移运算符<code>&lt;&lt;</code></p>
<p>左移运算符<code>&lt;&lt;</code>将左侧运算数的每一位，向左移动指定的位数，尾部空出来的位置使用<code>0</code>填充。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1000101000</span></span><br><span class="line"><span class="number">10001010</span> &lt;&lt; <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>10001010</code>的每一个二进制位，都向左侧移动了两位。</p>
<p>左移运算符相当于将运算数乘以2的指定次方，比如左移2位相当于乘以4（2的2次方）。</p>
<p>左移运算符<code>&lt;&lt;</code>可以与赋值运算符<code>=</code>结合，简写成<code>&lt;&lt;=</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">val = val &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写为</span></span><br><span class="line">val &lt;&lt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>（6）右移运算符<code>&gt;&gt;</code></p>
<p>右移运算符<code>&gt;&gt;</code>将左侧运算数的每一位，向右移动指定的位数，尾部无法容纳的值将丢弃，头部空出来的位置使用<code>0</code>填充。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 00100010</span></span><br><span class="line"><span class="number">10001010</span> &gt;&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>10001010</code>的每一个二进制位，都向右移动两位。最低的两位<code>10</code>被丢弃，头部多出来的两位补<code>0</code>，所以最后得到<code>00100010</code>。</p>
<p>注意，右移运算符最好只用于无符号整数，不要用于负数。因为不同系统对于右移后如何处理负数的符号位，有不同的做法，可能会得到不一样的结果。</p>
<p>右移运算符相当于将运算数除以2的指定次方，比如右移2位就相当于除以4（2的2次方）。</p>
<p>右移运算符<code>&gt;&gt;</code>可以与赋值运算符<code>=</code>结合，简写成<code>&gt;&gt;=</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">val = val &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写为</span></span><br><span class="line">val &gt;&gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>逗号运算符用于将多个表达式写在一起，从左到右依次运行每个表达式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，有两个表达式（<code>x = 10</code>和<code>y = 20</code>），逗号使得它们可以放在同一条语句里面。</p>
<p>逗号运算符返回最后一个表达式的值，作为整个语句的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">x = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，逗号的优先级低于赋值运算符，所以先执行赋值运算，再执行逗号运算，变量<code>x</code>等于<code>1</code>。</p>
<h3 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h3><p>优先级指的是，如果一个表达式包含多个运算符，哪个运算符应该优先执行。各种运算符的优先级是不一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">4</span> * <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，表达式<code>3 + 4 * 5</code>里面既有加法运算符（<code>+</code>），又有乘法运算符（<code>*</code>）。由于乘法的优先级高于加法，所以会先计算<code>4 * 5</code>，而不是先计算<code>3 + 4</code>。</p>
<p>如果两个运算符优先级相同，则根据运算符是左结合，还是右结合，决定执行顺序。大部分运算符是左结合（从左到右执行），少数运算符是右结合（从右到左执行），比如赋值运算符（<code>=</code>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> * <span class="number">6</span> / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>*</code>和<code>/</code>的优先级相同，它们都是左结合运算符，所以从左到右执行，先计算<code>5 * 6</code>，再计算<code>6 / 2</code>。</p>
<p>运算符的优先级顺序很复杂。下面是部分运算符的优先级顺序（按照优先级从高到低排列）。</p>
<ul>
<li>圆括号（<code>()</code>）</li>
<li>自增运算符（<code>++</code>），自减运算符（<code>--</code>）</li>
<li>一元运算符（<code>+</code>和<code>-</code>）</li>
<li>乘法（<code>*</code>），除法（<code>/</code>）</li>
<li>加法（<code>+</code>），减法（<code>-</code>）</li>
<li>关系运算符（<code>&lt;</code>、<code>&gt;</code>等）</li>
<li>赋值运算符（<code>=</code>）</li>
</ul>
<p>由于圆括号的优先级最高，可以使用它改变其他运算符的优先级。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = (<span class="number">3</span> + <span class="number">4</span>) * <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，由于添加了圆括号，加法会先于乘法进行运算。</p>
<p>完全记住所有运算符的优先级没有必要，解决方法是多用圆括号，防止出现意料之外的情况，也有利于提高代码的可读性。</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>C 语言的程序是顺序执行，即先执行前面的语句，再执行后面的语句。开发者如果想要控制程序执行的流程，就必须使用流程控制的语法结构，主要是条件执行和循环执行。</p>
<h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p><code>if</code>语句用于条件判断，满足条件时，就执行指定的语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression) statement</span><br></pre></td></tr></table></figure>

<p>上面式子中，表达式<code>expression</code>为真（值不为<code>0</code>）时，就执行<code>statement</code>语句。</p>
<p><code>if</code>后面的判断条件<code>expression</code>外面必须有圆括号，否则会报错。语句体部分<code>statement</code>可以是一个语句，也可以是放在大括号里面的复合语句。下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">&quot;x is 10&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，当变量<code>x</code>为<code>10</code>时，就会输出一行文字。对于只有一个语句的语句体，语句部分通常另起一行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">10</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x is 10\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果有多条语句，就需要把它们放在大括号里面，组成一个复合语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (line_num == MAX_LINES) &#123;</span><br><span class="line">  line_num = <span class="number">0</span>;</span><br><span class="line">  page_num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code>语句可以带有<code>else</code>分支，指定条件不成立时（表达式<code>expression</code>的值为<code>0</code>），所要执行的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression) statement</span><br><span class="line"><span class="keyword">else</span> statement</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; j)</span><br><span class="line">  max = i;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  max = j;</span><br></pre></td></tr></table></figure>

<p>如果<code>else</code>的语句部分多于一行，同样可以把它们放在大括号里面。</p>
<p><code>else</code>可以与另一个<code>if</code>语句连用，构成多重判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression)</span><br><span class="line">  statement</span><br><span class="line"><span class="keyword">else</span> <span class="title function_">if</span> <span class="params">(expression)</span></span><br><span class="line">  statement</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="title function_">if</span> <span class="params">(expression)</span></span><br><span class="line">  statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p>如果有多个<code>if</code>和<code>else</code>，可以记住这样一条规则，<code>else</code>总是跟最接近的<code>if</code>匹配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">6</span>)</span><br><span class="line">  <span class="keyword">if</span> (number &lt; <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The number is more than 6, less than 12.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;It is wrong number.\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>else</code>部分匹配最近的<code>if</code>（即<code>number &lt; 12</code>），所以如果<code>number</code>等于6，就不会执行<code>else</code>的部分。</p>
<p>这样很容易出错，为了提供代码的可读性，建议使用大括号，明确<code>else</code>匹配哪一个<code>if</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">6</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (number &lt; <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The number is more than 6, less than 12.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;It is wrong number.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，使用了大括号，就可以清晰地看出<code>else</code>匹配外层的<code>if</code>。</p>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符 ?"></a>三元运算符 ?</h3><p>C 语言有一个三元表达式<code>?:</code>，可以用作<code>if...else</code>的简写形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;expression1&gt; ? &lt;expression2&gt; : &lt;expression3&gt;</span><br></pre></td></tr></table></figure>

<p>这个操作符的含义是，表达式<code>expression1</code>如果为<code>true</code>（非0值），就执行<code>expression2</code>，否则执行<code>expression3</code>。</p>
<p>下面是一个例子，返回两个值之中的较大值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &gt; j) ? i : j;</span><br></pre></td></tr></table></figure>

<p>上面的代码等同于下面的<code>if</code>语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; j)</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> j;</span><br></pre></td></tr></table></figure>

<h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>switch 语句是一种特殊形式的 if…else 结构，用于判断条件有多个结果的情况。它把多重的<code>else if</code>改成更易用、可读性更好的形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">  <span class="keyword">case</span> value1: statement</span><br><span class="line">  <span class="keyword">case</span> value2: statement</span><br><span class="line">  <span class="keyword">default</span>: statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，根据表达式<code>expression</code>不同的值，执行相应的<code>case</code>分支。如果找不到对应的值，就执行<code>default</code>分支。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;False&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;True&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Illegal&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，根据变量<code>grade</code>不同的值，会执行不同的<code>case</code>分支。如果等于<code>0</code>，执行<code>case 0</code>的部分；如果等于<code>1</code>，执行<code>case 1</code>的部分；否则，执行<code>default</code>的部分。<code>default</code>表示处理以上所有<code>case</code>都不匹配的情况。</p>
<p>每个<code>case</code>语句体的结尾，都应该有一个<code>break</code>语句，作用是跳出整个<code>switch</code>结构，不再往下执行。如果缺少<code>break</code>，就会导致继续执行下一个<code>case</code>或<code>default</code>分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;False&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;True&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Illegal&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>case 0</code>的部分没有<code>break</code>语句，导致这个分支执行完以后，不会跳出<code>switch</code>结构，继续执行<code>case 1</code>分支。</p>
<p>利用这个特点，如果多个<code>case</code>分支对应同样的语句体，可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;True&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Illegal&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>case 0</code>分支没有任何语句，导致<code>case 0</code>和<code>case 1</code>都会执行同样的语句体。</p>
<p><code>case</code>后面的语句体，不用放在大括号里面，这也是为什么需要<code>break</code>的原因。</p>
<p><code>default</code>分支用来处理前面的 case 都不匹配的情况，最好放在所有 case 的后面，这样就不用写<code>break</code>语句。这个分支是可选的，如果没有该分支，遇到所有的 case 都不匹配的情况，就会直接跳出整个 switch 代码块。</p>
<h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p><code>while</code>语句用于循环结构，满足条件时，不断执行循环体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression)</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果表达式<code>expression</code>为非零值（表示真），就会执行<code>statement</code>语句，然后再次判断<code>expression</code>是否为零；如果<code>expression</code>为零（表示伪）就跳出循环，不再执行循环体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; n)</span><br><span class="line">  i = i + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，只要<code>i</code>小于<code>n</code>，<code>i</code>就会不断增加2。</p>
<p>如果循环体有多个语句，就需要使用大括号将这些语句组合在一起。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression) &#123;</span><br><span class="line">  statement;</span><br><span class="line">  statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i is now %d!\n&quot;</span>, i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;All done!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，循环体会执行10次，每次将<code>i</code>增加<code>1</code>，直到等于<code>10</code>才退出循环。</p>
<p>只要条件为真，<code>while</code>会产生无限循环。下面是一种常见的无限循环的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例虽然是无限循环，但是循环体内部可以用<code>break</code>语句跳出循环。</p>
<h3 id="do…while-结构"><a href="#do…while-结构" class="headerlink" title="do…while 结构"></a>do…while 结构</h3><p><code>do...while</code>结构是<code>while</code>的变体，它会先执行一次循环体，然后再判断是否满足条件。如果满足的话，就继续执行循环体，否则跳出循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> statement</span><br><span class="line"><span class="title function_">while</span> <span class="params">(expression)</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，不管条件<code>expression</code>是否成立，循环体<code>statement</code>至少会执行一次。每次<code>statement</code>执行完毕，就会判断一次<code>expression</code>，决定是否结束循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> --i;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>i</code>先减去1，再判断是否大于0。如果大于0，就继续减去1，直到<code>i</code>等于<code>0</code>为止。</p>
<p>如果循环部分有多条语句，就需要放在大括号里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i is %d\n&quot;</span>, i);</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;All done!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面例子中，变量<code>i</code>并不满足小于<code>10</code>的条件，但是循环体还是会执行一次。</p>
<h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><p><code>for</code>语句是最常用的循环结构，通常用于精确控制循环次数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; continuation; action)</span><br><span class="line">  statement;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>for</code>语句的条件部分（即圆括号里面的部分）有三个表达式。</p>
<ul>
<li><code>initialization</code>：初始化表达式，用于初始化循环变量，只执行一次。</li>
<li><code>continuation</code>：判断表达式，只要为<code>true</code>，就会不断执行循环体。</li>
<li><code>action</code>：循环变量处理表达式，每轮循环结束后执行，使得循环变量发生变化。</li>
</ul>
<p>循环体部分的<code>statement</code>可以是一条语句，也可以是放在大括号里面的复合语句。下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i is %d\n&quot;</span>, i);</span><br></pre></td></tr></table></figure>

<p>上面示例中，循环变量<code>i</code>在<code>for</code>的第一个表达式里面声明，该变量只用于本次循环。离开循环体之后，就会失效。</p>
<p>条件部分的三个表达式，每一个都可以有多个语句，语句与语句之间使用逗号分隔。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">999</span>; i &lt; <span class="number">10</span>; i++, j--) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, i, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，初始化部分有两个语句，分别对变量<code>i</code>和<code>j</code>进行赋值。</p>
<p><code>for</code>的三个表达式都不是必需的，甚至可以全部省略，这会形成无限循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本行会无限循环地打印。\n&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例由于没有判断条件，就会形成无限循环。</p>
<h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h3><p><code>break</code>语句有两种用法。一种是与<code>switch</code>语句配套使用，用来中断某个分支的执行，这种用法前面已经介绍过了。另一种用法是在循环体内部跳出循环，不再进行后面的循环了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, i, j);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>break</code>语句使得循环跳到下一个<code>i</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，一旦读到换行符（<code>\n</code>），<code>break</code>命令就跳出整个<code>while</code>循环，不再继续读取了。</p>
<p>注意，<code>break</code>命令只能跳出循环体和<code>switch</code>结构，不能跳出<code>if</code>结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">2</span>) <span class="keyword">break</span>; <span class="comment">// 无效</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>break</code>语句是无效的，因为它不能跳出外层的<code>if</code>结构。</p>
<h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h3><p><code>continue</code>语句用于在循环体内部终止本轮循环，进入下一轮循环。只要遇到<code>continue</code>语句，循环体内部后面的语句就不执行了，回到循环体的头部，开始执行下一轮循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, i, j);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，有没有<code>continue</code>语句，效果一样，都表示跳到下一个<code>j</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">&#x27;\t&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，只要读到的字符是制表符（<code>\t</code>），就用<code>continue</code>语句跳过该字符，读取下一个字符。</p>
<h3 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h3><p>goto 语句用于跳到指定的标签名。这会破坏结构化编程，建议不要轻易使用，这里为了语法的完整，介绍一下它的用法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">top: ch = getchar();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">  <span class="keyword">goto</span> top;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>top</code>是一个标签名，可以放在正常语句的前面，相当于为这行语句做了一个标记。程序执行到<code>goto</code>语句，就会跳转到它指定的标签名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">infinite_loop:</span><br><span class="line">  print(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">goto</span> infinite_loop;</span><br></pre></td></tr></table></figure>

<p>上面的代码会产生无限循环。</p>
<p>goto 的一个主要用法是跳出多层循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(...) &#123;</span><br><span class="line">  <span class="keyword">for</span> (...) &#123;</span><br><span class="line">    <span class="keyword">while</span> (...) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (some_error_condition)</span><br><span class="line">          <span class="keyword">goto</span> bail;    </span><br><span class="line">      &#125; <span class="keyword">while</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">bail:</span><br><span class="line"><span class="comment">// ... ...</span></span><br></pre></td></tr></table></figure>

<p>上面代码有很复杂的嵌套循环，不使用 goto 的话，想要完全跳出所有循环，写起来很麻烦。</p>
<p>goto 的另一个用途是提早结束多重判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (do_something() == ERR)</span><br><span class="line">  <span class="keyword">goto</span> error;</span><br><span class="line"><span class="keyword">if</span> (do_something2() == ERR)</span><br><span class="line">  <span class="keyword">goto</span> error;</span><br><span class="line"><span class="keyword">if</span> (do_something3() == ERR)</span><br><span class="line">  <span class="keyword">goto</span> error;</span><br><span class="line"><span class="keyword">if</span> (do_something4() == ERR)</span><br><span class="line">  <span class="keyword">goto</span> error;</span><br></pre></td></tr></table></figure>

<p>上面示例有四个判断，只要有一个发现错误，就使用 goto 跳过后面的判断。</p>
<p>注意，goto 只能在同一个函数之中跳转，并不能跳转到其他函数。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>C 语言的每一种数据，都是有类型（type）的，编译器必须知道数据的类型，才能操作数据。所谓“类型”，就是相似的数据所拥有的共同特征，那么一旦知道某个值的数据类型，就能知道该值的特征和操作方式。</p>
<p>基本数据类型有三种：字符（char）、整数（int）和浮点数（float）。复杂的类型都是基于它们构建的。</p>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符类型指的是单个字符，类型声明使用<code>char</code>关键字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;B&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例声明了变量<code>c</code>是字符类型，并将其赋值为字母<code>B</code>。</p>
<p>C 语言规定，字符常量必须放在单引号里面。</p>
<p>在计算机内部，字符类型使用一个字节（8位）存储。C 语言将其当作整数处理，所以字符类型就是宽度为一个字节的整数。每个字符对应一个整数（由 ASCII 码确定），比如<code>B</code>对应整数<code>66</code>。</p>
<p>字符类型在不同计算机的默认范围是不一样的。一些系统默认为<code>-128</code>到<code>127</code>，另一些系统默认为<code>0</code>到<code>255</code>。这两种范围正好都能覆盖<code>0</code>到<code>127</code>的 ASCII 字符范围。</p>
<p>只要在字符类型的范围之内，整数与字符是可以互换的，都可以赋值给字符类型的变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="number">66</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;B&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>c</code>是字符类型，赋给它的值是整数66。这跟赋值为字符<code>B</code>的效果是一样的。</p>
<p>两个字符类型的变量可以进行数学运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;B&#x27;</span>; <span class="comment">// 等同于 char a = 66;</span></span><br><span class="line"><span class="type">char</span> b = <span class="string">&#x27;C&#x27;</span>; <span class="comment">// 等同于 char b = 67;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b); <span class="comment">// 输出 133</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，字符类型变量<code>a</code>和<code>b</code>相加，视同两个整数相加。占位符<code>%d</code>表示输出十进制整数，因此输出结果为133。</p>
<p>单引号本身也是一个字符，如果要表示这个字符常量，必须使用反斜杠转义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> t = <span class="string">&#x27;\&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>t</code>为单引号字符，由于字符常量必须放在单引号里面，所以内部的单引号要使用反斜杠转义。</p>
<p>这种转义的写法，主要用来表示 ASCII 码定义的一些无法打印的控制字符，它们也属于字符类型的值。</p>
<ul>
<li><code>\a</code>：警报，这会使得终端发出警报声或出现闪烁，或者两者同时发生。</li>
<li><code>\b</code>：退格键，光标回退一个字符，但不删除字符。</li>
<li><code>\f</code>：换页符，光标移到下一页。在现代系统上，这已经反映不出来了，行为改成类似于<code>\v</code>。</li>
<li><code>\n</code>：换行符。</li>
<li><code>\r</code>：回车符，光标移到同一行的开头。</li>
<li><code>\t</code>：制表符，光标移到下一个水平制表位，通常是下一个8的倍数。</li>
<li><code>\v</code>：垂直分隔符，光标移到下一个垂直制表位，通常是下一行的同一列。</li>
<li><code>\0</code>：null 字符，代表没有内容。注意，这个值不等于数字0。</li>
</ul>
<p>转义写法还能使用八进制和十六进制表示一个字符。</p>
<ul>
<li><code>\nn</code>：字符的八进制写法，<code>nn</code>为八进制值。</li>
<li><code>\xnn</code>：字符的十六进制写法，<code>nn</code>为十六进制值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> x = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="type">char</span> x = <span class="number">66</span>;</span><br><span class="line"><span class="type">char</span> x = <span class="string">&#x27;\102&#x27;</span>; <span class="comment">// 八进制</span></span><br><span class="line"><span class="type">char</span> x = <span class="string">&#x27;\x42&#x27;</span>; <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure>

<p>上面示例的四种写法都是等价的。</p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>整数类型用来表示较大的整数，类型声明使用<code>int</code>关键字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure>

<p>上面示例声明了一个整数变量<code>a</code>。</p>
<p>不同计算机的<code>int</code>类型的大小是不一样的。比较常见的是使用4个字节（32位）存储一个<code>int</code>类型的值，但是2个字节（16位）或8个字节（64位）也有可能使用。它们可以表示的整数范围如下。</p>
<ul>
<li>16位：-32,768 到 32,767。</li>
<li>32位：-2,147,483,648 到 2,147,483,647。</li>
<li>64位：-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。</li>
</ul>
<h4 id="signed，unsigned"><a href="#signed，unsigned" class="headerlink" title="signed，unsigned"></a>signed，unsigned</h4><p>C 语言使用<code>signed</code>关键字，表示一个类型带有正负号，包含负值；使用<code>unsigned</code>关键字，表示该类型不带有正负号，只能表示零和正整数。</p>
<p>对于<code>int</code>类型，默认是带有正负号的，也就是说<code>int</code>等同于<code>signed int</code>。由于这是默认情况，关键字<code>signed</code>一般都省略不写，但是写了也不算错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> a;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure>

<p><code>int</code>类型也可以不带正负号，只表示非负整数。这时就必须使用关键字<code>unsigned</code>声明变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure>

<p>整数变量声明为<code>unsigned</code>的好处是，同样长度的内存能够表示的最大整数值，增大了一倍。比如，16位的<code>signed int</code>最大值为32,767，而<code>unsigned int</code>的最大值增大到了65,535。</p>
<p><code>unsigned int</code>里面的<code>int</code>可以省略，所以上面的变量声明也可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> a;</span><br></pre></td></tr></table></figure>

<p>字符类型<code>char</code>也可以设置<code>signed</code>和<code>unsigned</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">char</span> c; <span class="comment">// 范围为 -128 到 127</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c; <span class="comment">// 范围为 0 到 255</span></span><br></pre></td></tr></table></figure>

<p>注意，C 语言规定<code>char</code>类型默认是否带有正负号，由当前系统决定。这就是说，<code>char</code>不等同于<code>signed char</code>，它有可能是<code>signed char</code>，也有可能是<code>unsigned char</code>。这一点与<code>int</code>不同，<code>int</code>就是等同于<code>signed int</code>。</p>
<h4 id="整数的子类型"><a href="#整数的子类型" class="headerlink" title="整数的子类型"></a>整数的子类型</h4><p>如果<code>int</code>类型使用4个或8个字节表示一个整数，对于小整数，这样做很浪费空间。另一方面，某些场合需要更大的整数，8个字节还不够。为了解决这些问题，C 语言在<code>int</code>类型之外，又提供了三个整数的子类型。这样有利于更精细地限定整数变量的范围，也有利于更好地表达代码的意图。</p>
<ul>
<li><code>short int</code>（简写为<code>short</code>）：占用空间不多于<code>int</code>，一般占用2个字节（整数范围为-32768～32767)。</li>
<li><code>long int</code>（简写为<code>long</code>）：占用空间不少于<code>int</code>，至少为4个字节。</li>
<li><code>long long int</code>（简写为<code>long long</code>）：占用空间多于<code>long</code>，至少为8个字节。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> b;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> c;</span><br></pre></td></tr></table></figure>

<p>上面代码分别声明了三种整数子类型的变量。</p>
<p>默认情况下，<code>short</code>、<code>long</code>、<code>long long</code>都是带符号的（signed），即<code>signed</code>关键字省略了。它们也可以声明为不带符号（unsigned），使得能够表示的最大值扩大一倍。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> b;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> c;</span><br></pre></td></tr></table></figure>

<p>C 语言允许省略<code>int</code>，所以变量声明语句也可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> a;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> b;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> b;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> c;</span><br></pre></td></tr></table></figure>

<p>不同的计算机，数据类型的字节长度是不一样的。确实需要32位整数时，应使用<code>long</code>类型而不是<code>int</code>类型，可以确保不少于4个字节；确实需要64位的整数时，应该使用<code>long long</code>类型，可以确保不少于8个字节。另一方面，为了节省空间，只需要16位整数时，应使用<code>short</code>类型；需要8位整数时，应该使用<code>char</code>类型。</p>
<h4 id="整数类型的极限值"><a href="#整数类型的极限值" class="headerlink" title="整数类型的极限值"></a>整数类型的极限值</h4><p>有时候需要查看，当前系统不同整数类型的最大值和最小值，C 语言的头文件<code>limits.h</code>提供了相应的常量，比如<code>SCHAR_MIN</code>代表 signed char 类型的最小值<code>-128</code>，<code>SCHAR_MAX</code>代表 signed char 类型的最大值<code>127</code>。</p>
<p>为了代码的可移植性，需要知道某种整数类型的极限值时，应该尽量使用这些常量。</p>
<ul>
<li><code>SCHAR_MIN</code>，<code>SCHAR_MAX</code>：signed char 的最小值和最大值。</li>
<li><code>SHRT_MIN</code>，<code>SHRT_MAX</code>：short 的最小值和最大值。</li>
<li><code>INT_MIN</code>，<code>INT_MAX</code>：int 的最小值和最大值。</li>
<li><code>LONG_MIN</code>，<code>LONG_MAX</code>：long 的最小值和最大值。</li>
<li><code>LLONG_MIN</code>，<code>LLONG_MAX</code>：long long 的最小值和最大值。</li>
<li><code>UCHAR_MAX</code>：unsigned char 的最大值。</li>
<li><code>USHRT_MAX</code>：unsigned short 的最大值。</li>
<li><code>UINT_MAX</code>：unsigned int 的最大值。</li>
<li><code>ULONG_MAX</code>：unsigned long 的最大值。</li>
<li><code>ULLONG_MAX</code>：unsigned long long 的最大值。</li>
</ul>
<h4 id="整数的进制"><a href="#整数的进制" class="headerlink" title="整数的进制"></a>整数的进制</h4><p>C 语言的整数默认都是十进制数，如果要表示八进制数和十六进制数，必须使用专门的表示法。</p>
<p>八进制使用<code>0</code>作为前缀，比如<code>017</code>、<code>0377</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">012</span>; <span class="comment">// 八进制，相当于十进制的10</span></span><br></pre></td></tr></table></figure>

<p>十六进制使用<code>0x</code>或<code>0X</code>作为前缀，比如<code>0xf</code>、<code>0X10</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0x1A2B</span>; <span class="comment">// 十六进制，相当于十进制的6699</span></span><br></pre></td></tr></table></figure>

<p>有些编译器使用<code>0b</code>前缀，表示二进制数，但不是标准。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0b101010</span>;</span><br></pre></td></tr></table></figure>

<p>注意，不同的进制只是整数的书写方法，不会对整数的实际存储方式产生影响。所有整数都是二进制形式存储，跟书写方式无关。不同进制可以混合使用，比如<code>10 + 015 + 0x20</code>是一个合法的表达式。</p>
<p><code>printf()</code>的进制相关占位符如下。</p>
<ul>
<li><code>%d</code>：十进制整数。</li>
<li><code>%o</code>：八进制整数。</li>
<li><code>%x</code>：十六进制整数。</li>
<li><code>%#o</code>：显示前缀<code>0</code>的八进制整数。</li>
<li><code>%#x</code>：显示前缀<code>0x</code>的十六进制整数。</li>
<li><code>%#X</code>：显示前缀<code>0X</code>的十六进制整数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dec = %d\n&quot;</span>, x); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;octal = %o\n&quot;</span>, x); <span class="comment">// 144</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hex = %x\n&quot;</span>, x); <span class="comment">// 64</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;octal = %#o\n&quot;</span>, x); <span class="comment">// 0144</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hex = %#x\n&quot;</span>, x); <span class="comment">// 0x64</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hex = %#X\n&quot;</span>, x); <span class="comment">// 0X64</span></span><br></pre></td></tr></table></figure>

<h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><p>任何有小数点的数值，都会被编译器解释为浮点数。所谓“浮点数”就是使用 m * b<sup>e</sup> 的形式，存储一个数值，<code>m</code>是小数部分，<code>b</code>是基数（通常是<code>2</code>），<code>e</code>是指数部分。这种形式是精度和数值范围的一种结合，可以表示非常大或者非常小的数。</p>
<p>浮点数的类型声明使用<code>float</code>关键字，可以用来声明浮点数变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> c = <span class="number">10.5</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>c</code>的就是浮点数类型。</p>
<p><code>float</code>类型占用4个字节（32位），其中8位存放指数的值和符号，剩下24位存放小数的值和符号。<code>float</code>类型至少能够提供（十进制的）6位有效数字，指数部分的范围为（十进制的）<code>-37</code>到<code>37</code>，即数值范围为10<sup>-37</sup>到10<sup>37</sup>。</p>
<p>有时候，32位浮点数提供的精度或者数值范围还不够，C 语言又提供了另外两种更大的浮点数类型。</p>
<ul>
<li><code>double</code>：占用8个字节（64位），至少提供13位有效数字。</li>
<li><code>long double</code>：通常占用16个字节。</li>
</ul>
<p>注意，由于存在精度限制，浮点数只是一个近似值，它的计算是不精确的，比如 C 语言里面<code>0.1 + 0.2</code>并不等于<code>0.3</code>，而是有一个很小的误差。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>C 语言允许使用科学计数法表示浮点数，使用字母<code>e</code>来分隔小数部分和指数部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">123.456e+3</span>; <span class="comment">// 123.456 x 10^3</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">double</span> x = <span class="number">123.456e3</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>e</code>后面如果是加号<code>+</code>，加号可以省略。注意，科学计数法里面<code>e</code>的前后，不能存在空格。</p>
<p>另外，科学计数法的小数部分如果是<code>0.x</code>或<code>x.0</code>的形式，那么<code>0</code>可以省略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.3E6</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="number">.3E6</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.0E6</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="number">3.E6</span></span><br></pre></td></tr></table></figure>

<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>C 语言原来并没有为布尔值单独设置一个类型，而是使用整数<code>0</code>表示伪，所有非零值表示真。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x is true!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>等于<code>1</code>，C 语言就认为这个值代表真，从而会执行判断体内部的代码。</p>
<p>C99 标准添加了类型<code>_Bool</code>，表示布尔值。但是，这个类型其实只是整数类型的别名，还是使用<code>0</code>表示伪，<code>1</code>表示真，下面是一个示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> isNormal;</span><br><span class="line"></span><br><span class="line">isNormal = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (isNormal)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Everything is OK.\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>头文件<code>stdbool.h</code>定义了另一个类型别名<code>bool</code>，并且定义了<code>true</code>代表<code>1</code>、<code>false</code>代表<code>0</code>。只要加载这个头文件，就可以使用这几个关键字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，加载头文件<code>stdbool.h</code>以后，就可以使用<code>bool</code>定义布尔值类型，以及<code>false</code>和<code>true</code>表示真伪。</p>
<h3 id="字面量的类型"><a href="#字面量的类型" class="headerlink" title="字面量的类型"></a>字面量的类型</h3><p>字面量（literal）指的是代码里面直接出现的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>x</code>是变量，<code>123</code>就是字面量。</p>
<p>编译时，字面量也会写入内存，因此编译器必须为字面量指定数据类型，就像必须为变量指定数据类型一样。</p>
<p>一般情况下，十进制整数字面量（比如<code>123</code>）会被编译器指定为<code>int</code>类型。如果一个数值比较大，超出了<code>int</code>能够表示的范围，编译器会将其指定为<code>long int</code>。如果数值超过了<code>long int</code>，会被指定为<code>unsigned long</code>。如果还不够大，就指定为<code>long long</code>或<code>unsigned long long</code>。</p>
<p>小数（比如<code>3.14</code>）会被指定为<code>double</code>类型。</p>
<h3 id="字面量后缀"><a href="#字面量后缀" class="headerlink" title="字面量后缀"></a>字面量后缀</h3><p>有时候，程序员希望为字面量指定一个不同的类型。比如，编译器将一个整数字面量指定为<code>int</code>类型，但是程序员希望将其指定为<code>long</code>类型，这时可以为该字面量加上后缀<code>l</code>或<code>L</code>，编译器就知道要把这个字面量的类型指定为<code>long</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">123L</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，字面量<code>123</code>有后缀<code>L</code>，编译器就会将其指定为<code>long</code>类型。这里<code>123L</code>写成<code>123l</code>，效果也是一样的，但是建议优先使用<code>L</code>，因为小写的<code>l</code>容易跟数字<code>1</code>混淆。</p>
<p>八进制和十六进制的值，也可以使用后缀<code>l</code>和<code>L</code>指定为 Long 类型，比如<code>020L</code>和<code>0x20L</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">0377L</span>;</span><br><span class="line"><span class="type">int</span> z = <span class="number">0x7fff</span>L;</span><br></pre></td></tr></table></figure>

<p>如果希望指定为无符号整数<code>unsigned int</code>，可以使用后缀<code>u</code>或<code>U</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">123U</span>;</span><br></pre></td></tr></table></figure>

<p><code>L</code>和<code>U</code>可以结合使用，表示<code>unsigned long</code>类型。<code>L</code>和<code>U</code>的大小写和组合顺序无所谓。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">123LU</span>;</span><br></pre></td></tr></table></figure>

<p>对于浮点数，编译器默认指定为 double 类型，如果希望指定为其他类型，需要在小数后面添加后缀<code>f</code>（float）或<code>l</code>（long double）。</p>
<p>科学计数法也可以使用后缀。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.2345e+10</span>F</span><br><span class="line"><span class="number">1.2345e+10</span>L</span><br></pre></td></tr></table></figure>

<p>总结一下，常用的字面量后缀有下面这些。</p>
<ul>
<li><code>f</code>和<code>F</code>：<code>float</code>类型。</li>
<li><code>l</code>和<code>L</code>：对于整数是<code>long int</code>类型，对于小数是<code>long double</code>类型。</li>
<li><code>ll</code>和<code>LL</code>：Long Long 类型，比如<code>3LL</code>。</li>
<li><code>u</code>和<code>U</code>：表示<code>unsigned int</code>，比如<code>15U</code>、<code>0377U</code>。</li>
</ul>
<p><code>u</code>还可以与其他整数后缀结合，放在前面或后面都可以，比如<code>10UL</code>、<code>10ULL</code>和<code>10LLU</code>都是合法的。</p>
<p>下面是一些示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>           x = <span class="number">1234</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span>      x = <span class="number">1234L</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> x = <span class="number">1234LL</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>           x = <span class="number">1234U</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>      x = <span class="number">1234UL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> x = <span class="number">1234ULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> x       = <span class="number">3.14f</span>;</span><br><span class="line"><span class="type">double</span> x      = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> x = <span class="number">3.14L</span>;</span><br></pre></td></tr></table></figure>

<h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>每一种数据类型都有数值范围，如果存放的数值超出了这个范围（小于最小值或大于最大值），需要更多的二进制位存储，就会发生溢出。大于最大值，叫做向上溢出（overflow）；小于最小值，叫做向下溢出（underflow）。</p>
<p>一般来说，编译器不会对溢出报错，会正常执行代码，但是会忽略多出来的二进制位，只保留剩下的位，这样往往会得到意想不到的结果。所以，应该避免溢出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> x = <span class="number">255</span>;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>加<code>1</code>，得到的结果不是<code>256</code>，而是<code>0</code>。因为<code>x</code>是<code>unsign char</code>类型，最大值是<code>255</code>（二进制<code>11111111</code>），加<code>1</code>后就发生了溢出，<code>256</code>（二进制<code>100000000</code>）的最高位<code>1</code>被丢弃，剩下的值就是<code>0</code>。</p>
<p>再看下面的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui = UINT_MAX;  <span class="comment">// 4,294,967,295</span></span><br><span class="line">ui++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ui = %u\n&quot;</span>, ui); <span class="comment">// 0</span></span><br><span class="line">ui--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ui = %u\n&quot;</span>, ui); <span class="comment">// 4,294,967,295</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，常量<code>UINT_MAX</code>是 unsigned int 类型的最大值。如果加<code>1</code>，对于该类型就会溢出，从而得到<code>0</code>；而<code>0</code>是该类型的最小值，再减<code>1</code>，又会得到<code>UINT_MAX</code>。</p>
<p>溢出很容易被忽视，编译器又不会报错，所以必须非常小心。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; --i) <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>上面代码表面看似乎没有问题，但是循环变量<code>i</code>的类型是 unsigned int，这个类型的最小值是<code>0</code>，不可能得到小于0的结果。当<code>i</code>等于0，再减去<code>1</code>的时候，并不会返回<code>-1</code>，而是返回 unsigned int 的类型最大值，这个值总是大于等于<code>0</code>，导致无限循环。</p>
<p>为了避免溢出，最好方法就是将运算结果与类型的极限值进行比较。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">if</span> (sum + ui &gt; UINT_MAX) too_big();</span><br><span class="line"><span class="keyword">else</span> sum = sum + ui;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">if</span> (ui &gt; UINT_MAX - sum) too_big();</span><br><span class="line"><span class="keyword">else</span> sum = sum + ui;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>sum</code>和<code>ui</code>都是 unsigned int 类型，它们相加的和还是 unsigned int 类型，这就有可能发生溢出。但是，不能通过相加的和是否超出了最大值<code>UINT_MAX</code>，来判断是否发生了溢出，因为<code>sum + ui</code>总是返回溢出后的结果，不可能大于<code>UINT_MAX</code>。正确的比较方法是，判断<code>UINT_MAX - sum</code>与<code>ui</code>之间的大小关系。</p>
<p>下面是另一种错误的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i - j &lt; <span class="number">0</span>) <span class="comment">// 错误</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;negative\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;positive\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例的运算结果，会输出<code>positive</code>。原因是变量<code>i</code>和<code>j</code>都是 unsigned int 类型，<code>i - j</code>的结果也是这个类型，最小值为<code>0</code>，不可能得到小于<code>0</code>的结果。正确的写法是写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j &gt; i) <span class="comment">// ....</span></span><br></pre></td></tr></table></figure>

<h3 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h3><p><code>sizeof</code>是 C 语言提供的一个运算符，返回某种数据类型或某个值占用的字节数量。它的参数可以是数据类型的关键字，也可以是变量名或某个具体的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为数据类型</span></span><br><span class="line"><span class="type">int</span> x = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为变量</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">sizeof</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为数值</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="number">3.14</span>);</span><br></pre></td></tr></table></figure>

<p>上面的第一个示例，返回得到<code>int</code>类型占用的字节数量（通常是<code>4</code>或<code>8</code>）。第二个示例返回整数变量占用字节数量，结果与前一个示例完全一样。第三个示例返回浮点数<code>3.14</code>占用的字节数量，由于浮点数的字面量一律存储为 double 类型，所以会返回<code>8</code>，因为 double 类型占用的8个字节。</p>
<p><code>sizeof</code>运算符的返回值，C 语言只规定是无符号整数，并没有规定具体的类型，而是留给系统自己去决定，<code>sizeof</code>到底返回什么类型。不同的系统中，返回值的类型有可能是<code>unsigned int</code>，也有可能是<code>unsigned long</code>，甚至是<code>unsigned long long</code>，对应的<code>printf()</code>占位符分别是<code>%u</code>、<code>%lu</code>和<code>%llu</code>。这样不利于程序的可移植性。</p>
<p>C 语言提供了一个解决方法，创造了一个类型别名<code>size_t</code>，用来统一表示<code>sizeof</code>的返回值类型。该别名定义在<code>stddef.h</code>头文件（引入<code>stdio.h</code>时会自动引入）里面，对应当前系统的<code>sizeof</code>的返回值类型，可能是<code>unsigned int</code>，也可能是<code>unsigned long</code>。</p>
<p>C 语言还提供了一个常量<code>SIZE_MAX</code>，表示<code>size_t</code>可以表示的最大整数。所以，<code>size_t</code>能够表示的整数范围为<code>[0, SIZE_MAX]</code>。</p>
<p><code>printf()</code>有专门的占位符<code>%zd</code>或<code>%zu</code>，用来处理<code>size_t</code>类型的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>上面代码中，不管<code>sizeof</code>返回值的类型是什么，<code>%zd</code>占位符（或<code>%zu</code>）都可以正确输出。</p>
<p>如果当前系统不支持<code>%zd</code>或<code>%zu</code>，可使用<code>%u</code>（unsigned int）或<code>%lu</code>（unsigned long int）代替。</p>
<h3 id="类型的自动转换"><a href="#类型的自动转换" class="headerlink" title="类型的自动转换"></a>类型的自动转换</h3><p>某些情况下，C 语言会自动转换某个值的类型。</p>
<h4 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h4><p>赋值运算符会自动将右边的值，转成左边变量的类型。</p>
<p>（1）浮点数赋值给整数变量</p>
<p>浮点数赋予整数变量时，C 语言直接丢弃小数部分，而不是四舍五入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>是整数类型，赋给它的值是一个浮点数。编译器会自动把<code>3.14</code>先转为<code>int</code>类型，丢弃小数部分，再赋值给<code>x</code>，因此<code>x</code>的值是<code>3</code>。</p>
<p>这种自动转换会导致部分数据的丢失（<code>3.14</code>丢失了小数部分），所以最好不要跨类型赋值，尽量保证变量与所要赋予的值是同一个类型。</p>
<p>注意，舍弃小数部分时，不是四舍五入，而是整个舍弃。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">12.99</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>x</code>等于<code>12</code>，而不是四舍五入的<code>13</code>。</p>
<p>（2）整数赋值给浮点数变量</p>
<p>整数赋值给浮点数变量时，会自动转为浮点数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> y = <span class="number">12</span> * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>y</code>的值不是<code>24</code>，而是<code>24.0</code>，因为等号右边的整数自动转为了浮点数。</p>
<p>（3）窄类型赋值给宽类型</p>
<p>字节宽度较小的整数类型，赋值给字节宽度较大的整数变量时，会发生类型提升，即窄类型自动转为宽类型。</p>
<p>比如，<code>char</code>或<code>short</code>类型赋值给<code>int</code>类型，会自动提升为<code>int</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i = x + y;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x</code>的类型是<code>char</code>，由于赋值给<code>int</code>类型，所以会自动提升为<code>int</code>。</p>
<p>（4）宽类型赋值给窄类型</p>
<p>字节宽度较大的类型，赋值给字节宽度较小的变量时，会发生类型降级，自动转为后者的类型。这时可能会发生截值（truncation），系统会自动截去多余的二进制位，导致难以预料的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = <span class="number">321</span>;</span><br><span class="line">char ch = i; <span class="comment">// ch 的值是 65 （321 - 256）</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，变量<code>ch</code>是<code>char</code>类型，宽度是8个二进制位。变量<code>i</code>是<code>int</code>类型，将<code>i</code>赋值给<code>ch</code>，后者只能容纳<code>i</code>（二进制形式为<code>101000001</code>，共9位）的后八位，前面多出来的二进制位被丢弃，保留后八位就变成了<code>01000001</code>（十进制的65，相当于字符<code>A</code>）。</p>
<p>浮点数赋值给整数类型的值，也会发生截值，浮点数的小数部分会被截去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">int</span> i = pi; <span class="comment">// i 的值为 3</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>i</code>等于<code>3</code>，<code>pi</code>的小数部分被截去了。</p>
<h4 id="混合类型的运算"><a href="#混合类型的运算" class="headerlink" title="混合类型的运算"></a>混合类型的运算</h4><p>不同类型的值进行混合计算时，必须先转成同一个类型，才能进行计算。转换规则如下：</p>
<p>（1）整数与浮点数混合运算时，整数转为浮点数类型，与另一个运算数类型相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">1.2</span> <span class="comment">// 4.2</span></span><br></pre></td></tr></table></figure>

<p>上面示例是<code>int</code>类型与<code>float</code>类型的混合计算，<code>int</code>类型的<code>3</code>会先转成<code>float</code>的<code>3.0</code>，再进行计算，得到<code>4.2</code>。</p>
<p>（2）不同的浮点数类型混合运算时，宽度较小的类型转为宽度较大的类型，比如<code>float</code>转为<code>double</code>，<code>double</code>转为<code>long double</code>。</p>
<p>（3）不同的整数类型混合运算时，宽度较小的类型会提升为宽度较大的类型。比如<code>short</code>转为<code>int</code>，<code>int</code>转为<code>long</code>等，有时还会将带符号的类型<code>signed</code>转为无符号<code>unsigned</code>。</p>
<p>下面例子的执行结果，可能会出人意料。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">-5</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="keyword">sizeof</span>(<span class="type">int</span>)）</span><br><span class="line">  do_something();</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>是带符号整数，<code>sizeof(int)</code>是<code>size_t</code>类型，这是一个无符号整数。按照规则，signed int 自动转为 unsigned int，所以<code>a</code>会自动转成无符号整数<code>4294967291</code>（转换规则是<code>-5</code>加上无符号整数的最大值，再加1），导致比较失败，<code>do_something()</code>不会执行。</p>
<p>所以，最好避免无符号整数与有符号整数的混合运算。因为这时 C 语言会自动将<code>signed int</code>转为<code>unsigned int</code>，可能不会得到预期的结果。</p>
<h4 id="整数类型的运算"><a href="#整数类型的运算" class="headerlink" title="整数类型的运算"></a>整数类型的运算</h4><p>两个相同类型的整数运算时，或者单个整数的运算，一般来说，运算结果也属于同一类型。但是有一个例外，宽度小于<code>int</code>的类型，运算结果会自动提升为<code>int</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((-a) &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;negative\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;positive\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>a</code>是 unsigned char 类型，这个类型不可能小于0，但是<code>-a</code>不是 unsigned char 类型，会自动转为 int 类型，导致上面的代码输出 negative。</p>
<p>再看下面的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">255</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((a - <span class="number">5</span>) &lt; <span class="number">0</span>) do_something();</span><br><span class="line"><span class="keyword">if</span> ((b + c) &gt; <span class="number">300</span>) do_something();</span><br></pre></td></tr></table></figure>

<p>上面示例中，表达式<code>a - 5</code>和<code>b + c</code>都会自动转为 int 类型，所以函数<code>do_something()</code>会执行两次。</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数的参数和返回值，会自动转成函数定义里指定的类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dostuff</span><span class="params">(<span class="type">int</span>, <span class="type">unsigned</span> <span class="type">char</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> m = <span class="number">42</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> n = <span class="number">43</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> c = dostuff(m, n);</span><br></pre></td></tr></table></figure>

<p>上面示例中，参数变量<code>m</code>和<code>n</code>不管原来的类型是什么，都会转成函数<code>dostuff()</code>定义的参数类型。</p>
<p>下面是返回值自动转换类型的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数内部的变量<code>a</code>是<code>int</code>类型，但是返回的值是<code>char</code>类型，因为函数定义中返回的是这个类型。</p>
<h3 id="类型的显式转换"><a href="#类型的显式转换" class="headerlink" title="类型的显式转换"></a>类型的显式转换</h3><p>原则上，应该避免类型的自动转换，防止出现意料之外的结果。C 语言提供了类型的显式转换，允许手动转换类型。</p>
<p>只要在一个值或变量的前面，使用圆括号指定类型<code>(type)</code>，就可以将这个值或变量转为指定的类型，这叫做“类型指定”（casting）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>) ch</span><br></pre></td></tr></table></figure>

<p>上面示例将变量<code>ch</code>转成无符号的字符类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> y = (<span class="type">long</span> <span class="type">int</span>) <span class="number">10</span> + <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>(long int)</code>将<code>10</code>显式转为<code>long int</code>类型。这里的显示转换其实是不必要的，因为赋值运算符会自动将右边的值，转为左边变量的类型。</p>
<h3 id="可移植类型"><a href="#可移植类型" class="headerlink" title="可移植类型"></a>可移植类型</h3><p>C 语言的整数类型（short、int、long）在不同计算机上，占用的字节宽度可能是不一样的，无法提前知道它们到底占用多少个字节。</p>
<p>程序员有时控制准确的字节宽度，这样的话，代码可以有更好的可移植性，头文件<code>stdint.h</code>创造了一些新的类型别名。</p>
<p>（1）精确宽度类型(exact-width integer type)，保证某个整数类型的宽度是确定的。</p>
<ul>
<li><code>int8_t</code>：8位有符号整数。</li>
<li><code>int16_t</code>：16位有符号整数。</li>
<li><code>int32_t</code>：32位有符号整数。</li>
<li><code>int64_t</code>：64位有符号整数。</li>
<li><code>uint8_t</code>：8位无符号整数。</li>
<li><code>uint16_t</code>：16位无符号整数。</li>
<li><code>uint32_t</code>：32位无符号整数。</li>
<li><code>uint64_t</code>：64位无符号整数。</li>
</ul>
<p>上面这些都是类型别名，编译器会指定它们指向的底层类型。比如，某个系统中，如果<code>int</code>类型为32位，<code>int32_t</code>就会指向<code>int</code>；如果<code>long</code>类型为32位，<code>int32_t</code>则会指向<code>long</code>。</p>
<p>下面是一个使用示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int32_t</span> x32 = <span class="number">45933945</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x32 = %d\n&quot;</span>, x32);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>x32</code>声明为<code>int32_t</code>类型，可以保证是32位的宽度。</p>
<p>（2）最小宽度类型（minimum width type），保证某个整数类型的最小长度。</p>
<ul>
<li>int_least8_t</li>
<li>int_least16_t</li>
<li>int_least32_t</li>
<li>int_least64_t</li>
<li>uint_least8_t</li>
<li>uint_least16_t</li>
<li>uint_least32_t</li>
<li>uint_least64_t</li>
</ul>
<p>上面这些类型，可以保证占据的字节不少于指定宽度。比如，<code>int_least8_t</code>表示可以容纳8位有符号整数的最小宽度的类型。</p>
<p>（3）最快的最小宽度类型（fast minimum width type），可以使整数计算达到最快的类型。</p>
<ul>
<li>int_fast8_t</li>
<li>int_fast16_t</li>
<li>int_fast32_t</li>
<li>int_fast64_t</li>
<li>uint_fast8_t</li>
<li>uint_fast16_t</li>
<li>uint_fast32_t</li>
<li>uint_fast64_t</li>
</ul>
<p>上面这些类型是保证字节宽度的同时，追求最快的运算速度，比如<code>int_fast8_t</code>表示对于8位有符号整数，运算速度最快的类型。这是因为某些机器对于特定宽度的数据，运算速度最快，举例来说，32位计算机对于32位数据的运算速度，会快于16位数据。</p>
<p>（4）可以保存指针的整数类型。</p>
<ul>
<li><code>intptr_t</code>：可以存储指针（内存地址）的有符号整数类型。</li>
<li><code>uintptr_t</code>：可以存储指针的无符号整数类型。</li>
</ul>
<p>（5）最大宽度整数类型，用于存放最大的整数。</p>
<ul>
<li><code>intmax_t</code>：可以存储任何有效的有符号整数的类型。</li>
<li><code>uintmax_t</code>：可以存放任何有效的无符号整数的类型。</li>
</ul>
<p>上面的这两个类型的宽度比<code>long long</code>和<code>unsigned long</code>更大。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是 C 语言最重要的概念之一，也是最难理解的概念之一。</p>
<h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>指针是什么？首先，它是一个值，这个值代表一个内存地址，因此指针相当于指向某个内存地址的路标。</p>
<p>字符<code>*</code>表示指针，通常跟在类型关键字的后面，表示指针指向的是什么类型的值。比如，<code>char*</code>表示一个指向字符的指针，<code>float*</code>表示一个指向<code>float</code>类型的值的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* intPtr;</span><br></pre></td></tr></table></figure>

<p>上面示例声明了一个变量<code>intPtr</code>，它是一个指针，指向的内存地址存放的是一个整数。</p>
<p>星号<code>*</code>可以放在变量名与类型关键字之间的任何地方，下面的写法都是有效的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>   *intPtr;</span><br><span class="line"><span class="type">int</span> * intPtr;</span><br><span class="line"><span class="type">int</span>*  intPtr;</span><br></pre></td></tr></table></figure>

<p>本书使用星号紧跟在类型关键字后面的写法（即<code>int* intPtr;</code>），因为这样可以体现，指针变量就是一个普通变量，只不过它的值是内存地址而已。</p>
<p>这种写法有一个地方需要注意，如果同一行声明两个指针变量，那么需要写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="type">int</span> * foo, * bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="type">int</span>* foo, bar;</span><br></pre></td></tr></table></figure>

<p>上面示例中，第二行的执行结果是，<code>foo</code>是整数指针变量，而<code>bar</code>是整数变量，即<code>*</code>只对第一个变量生效。</p>
<p>一个指针指向的可能还是指针，这时就要用两个星号<code>**</code>表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>** foo;</span><br></pre></td></tr></table></figure>

<p>上面示例表示变量<code>foo</code>是一个指针，指向的还是一个指针，第二个指针指向的则是一个整数。</p>
<h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="* 运算符"></a>* 运算符</h3><p><code>*</code>这个符号除了表示指针以外，还可以作为运算符，用来取出指针变量所指向的内存地址里面的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span>* p)</span> &#123;</span><br><span class="line">  *p = *p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>increment()</code>的参数是一个整数指针<code>p</code>。函数体里面，<code>*p</code>就表示指针<code>p</code>所指向的那个值。对<code>*p</code>赋值，就表示改变指针所指向的那个地址里面的值。</p>
<p>上面函数的作用是将参数值加<code>1</code>。该函数没有返回值，因为传入的是地址，函数体内部对该地址包含的值的操作，会影响到函数外部，所以不需要返回值。事实上，函数内部通过指针，将值传到外部，是 C 语言的常用方法。</p>
<p>变量地址而不是变量值传入函数，还有一个好处。对于需要大量存储空间的大型变量，复制变量值传入函数，非常浪费时间和空间，不如传入指针来得高效。</p>
<h3 id="amp-运算符"><a href="#amp-运算符" class="headerlink" title="&amp; 运算符"></a>&amp; 运算符</h3><p><code>&amp;</code>运算符用来取出一个变量所在的内存地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x&#x27;s address is %p\n&quot;</span>, &amp;x);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>x</code>是一个整数变量，<code>&amp;x</code>就是<code>x</code>的值所在的内存地址。<code>printf()</code>的<code>%p</code>是内存地址的占位符，可以打印出内存地址。</p>
<p>上一小节中，参数变量加<code>1</code>的函数，可以像下面这样使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span>* p)</span> &#123;</span><br><span class="line">  *p = *p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">increment(&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，调用<code>increment()</code>函数以后，变量<code>x</code>的值就增加了1，原因就在于传入函数的是变量<code>x</code>的地址<code>&amp;x</code>。</p>
<p><code>&amp;</code>运算符与<code>*</code>运算符互为逆运算，下面的表达式总是成立。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == *(&amp;i)) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<h3 id="指针变量的初始化"><a href="#指针变量的初始化" class="headerlink" title="指针变量的初始化"></a>指针变量的初始化</h3><p>声明指针变量之后，编译器会为指针变量本身分配一个内存空间，但是这个内存空间里面的值是随机的，也就是说，指针变量指向的值是随机的。这时一定不能去读写指针变量指向的地址，因为那个地址是随机地址，很可能会导致严重后果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">*p = <span class="number">1</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>上面的代码是错的，因为<code>p</code>指向的那个地址是随机的，向这个随机地址里面写入<code>1</code>，会导致意想不到的结果。</p>
<p>正确做法是指针变量声明后，必须先让它指向一个分配好的地址，然后再进行读写，这叫做指针变量的初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">p = &amp;i;</span><br><span class="line">*p = <span class="number">13</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>p</code>是指针变量，声明这个变量后，<code>p</code>会指向一个随机的内存地址。这时要将它指向一个已经分配好的内存地址，上例就是再声明一个整数变量<code>i</code>，编译器会为<code>i</code>分配内存地址，然后让<code>p</code>指向<code>i</code>的内存地址（<code>p = &amp;i;</code>）。完成初始化之后，就可以对<code>p</code>指向的内存地址进行赋值了（<code>*p = 13;</code>）。</p>
<p>为了防止读写未初始化的指针变量，可以养成习惯，将未初始化的指针变量设为<code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><code>NULL</code>在 C 语言中是一个常量，表示地址为<code>0</code>的内存空间，这个地址是无法使用的，读写该地址会报错。</p>
<h3 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h3><p>指针本质上就是一个无符号整数，代表了内存地址。它可以进行运算，但是规则并不是整数运算的运算。</p>
<p>（1）指针与整数值的加减运算</p>
<p>指针与整数值的运算，表示指针的移动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span>* j;</span><br><span class="line">j = (<span class="type">short</span>*)<span class="number">0x1234</span>;</span><br><span class="line">j = j + <span class="number">1</span>; <span class="comment">// 0x1236</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>j</code>是一个指针，指向内存地址<code>0x1234</code>。你可能以为<code>j + 1</code>等于<code>0x1235</code>，但正确答案是<code>0x1236</code>。原因是<code>j + 1</code>表示指针向高位移动一个单位，而一个单位的<code>short</code>类型占据两个字节的宽度，所以相当于向高位移动两个字节。同样的，<code>j - 1</code>得到的结果是<code>0x1232</code>。</p>
<p>指针移动的单位，与指针指向的数据类型有关。数据类型占据多少个字节，每单位就移动多少个字节。</p>
<p>（2）指针与指针的加法运算</p>
<p>指针只能与整数值进行加减运算，两个指针进行加法是非法的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span>* j;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>* k;</span><br><span class="line">x = j + k; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>

<p>上面示例是两个指针相加，这是非法的。</p>
<p>（3）指针与指针的减法</p>
<p>相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位。</p>
<p>高位地址减去低位地址，返回的是正值；低位地址减去高位地址，返回的是负值。</p>
<p>这时，减法返回的值属于<code>ptrdiff_t</code>类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同。这个类型的原型定义在头文件<code>stddef.h</code>里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span>* j1;</span><br><span class="line"><span class="type">short</span>* j2;</span><br><span class="line"></span><br><span class="line">j1 = (<span class="type">short</span>*)<span class="number">0x1234</span>;</span><br><span class="line">j2 = (<span class="type">short</span>*)<span class="number">0x1236</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ptrdiff_t</span> dist = j2 - j1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>j1</code>和<code>j2</code>是两个指向 short 类型的指针，变量<code>dist</code>是它们之间的距离，类型为<code>ptrdiff_t</code>，值为<code>1</code>，因为相差2个字节正好存放一个 short 类型的值。</p>
<p>（4）指针与指针的比较运算</p>
<p>指针之间的比较运算，比较的是各自的内存地址哪一个更大，返回值是整数<code>1</code>（true）或<code>0</code>（false）。</p>
<h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>函数是一段可以重复执行的代码。它可以接受不同的参数，完成对应的操作。下面的例子就是一个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">plus_one</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码声明了一个函数<code>plus_one()</code>。</p>
<p>函数声明的语法有以下几点，需要注意。</p>
<p>（1）返回值类型。函数声明时，首先需要给出返回值的类型，上例是<code>int</code>，表示函数<code>plus_one()</code>返回一个整数。</p>
<p>（2）参数。函数名后面的圆括号里面，需要声明参数的类型和参数名，<code>plus_one(int n)</code>表示这个函数有一个整数参数<code>n</code>。</p>
<p>（3）函数体。函数体要写在大括号里面，后面（即大括号外面）不需要加分号。大括号的起始位置，可以跟函数名在同一行，也可以另起一行，本书采用同一行的写法。</p>
<p>（4）<code>return</code>语句。<code>return</code>语句给出函数的返回值，程序运行到这一行，就会跳出函数体，结束函数的调用。如果函数没有返回值，可以省略<code>return</code>语句，或者写成<code>return;</code>。</p>
<p>调用函数时，只要在函数名后面加上圆括号就可以了，实际的参数放在圆括号里面，就像下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = plus_one(<span class="number">13</span>);</span><br><span class="line"><span class="comment">// a 等于 14</span></span><br></pre></td></tr></table></figure>

<p>函数调用时，参数个数必须与定义里面的参数个数一致，参数过多或过少都会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">plus_one</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plus_one(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 报错</span></span><br><span class="line">plus_one();  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>plus_one()</code>只能接受一个参数，传入两个参数或不传参数，都会报错。</p>
<p>函数必须声明后使用，否则会报错。也就是说，一定要在使用<code>plus_one()</code>之前，声明这个函数。如果像下面这样写，编译时会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = plus_one(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">plus_one</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，在调用<code>plus_one()</code>之后，才声明这个函数，编译就会报错。</p>
<p>C 语言标准规定，函数只能声明在源码文件的顶层，不能声明在其他函数内部。</p>
<p>不返回值的函数，使用<code>void</code>关键字表示返回值的类型。没有参数的函数，声明时要用<code>void</code>关键字表示参数类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myFunc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>myFunc()</code>函数，既没有返回值，调用时也不需要参数。</p>
<p>函数可以调用自身，这就叫做递归（recursion）。下面是斐波那契数列的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Fibonacci</span><span class="params">(<span class="type">unsigned</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>Fibonacci()</code>调用了自身，大大简化了算法。</p>
<h3 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h3><p>C 语言规定，<code>main()</code>是程序的入口函数，即所有的程序一定要包含一个<code>main()</code>函数。程序总是从这个函数开始执行，如果没有该函数，程序就无法启动。其他函数都是通过它引入程序的。</p>
<p><code>main()</code>的写法与其他函数一样，要给出返回值的类型和参数的类型，就像下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，最后的<code>return 0;</code>表示函数结束运行，返回<code>0</code>。</p>
<p>C 语言约定，返回值<code>0</code>表示函数运行成功，如果返回其他非零整数，就表示运行失败，代码出了问题。系统根据<code>main()</code>的返回值，作为整个程序的返回值，确定程序是否运行成功。</p>
<p>正常情况下，如果<code>main()</code>里面省略<code>return 0</code>这一行，编译器会自动加上，即<code>main()</code>的默认返回值为0。所以，写成下面这样，效果完全一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 C 语言只会对<code>main()</code>函数默认添加返回值，对其他函数不会这样做，所以建议总是保留<code>return</code>语句，以便形成统一的代码风格。</p>
<h3 id="参数的传值引用"><a href="#参数的传值引用" class="headerlink" title="参数的传值引用"></a>参数的传值引用</h3><p>如果函数的参数是一个变量，那么调用时，传入的是这个变量的值的拷贝，而不是变量本身。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">  a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">increment(i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，调用<code>increment(i)</code>以后，变量<code>i</code>本身不会发生变化，还是等于<code>10</code>。因为传入函数的是<code>i</code>的拷贝，而不是<code>i</code>本身，拷贝的变化，影响不到原始变量。这就叫做“传值引用”。</p>
<p>所以，如果参数变量发生变化，最好把它作为返回值传出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">i = increment(i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>再看下面的例子，<code>Swap()</code>函数用来交换两个变量的值，由于传值引用，下面的写法不会生效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">Swap(a, b); <span class="comment">// 无效</span></span><br></pre></td></tr></table></figure>

<p>上面的写法不会产生交换变量值的效果，因为传入的变量是原始变量<code>a</code>和<code>b</code>的拷贝，不管函数内部怎么操作，都影响不了原始变量。</p>
<p>如果想要传入变量本身，只有一个办法，就是传入变量的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span>* x, <span class="type">int</span>* y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  temp = *x;</span><br><span class="line">  *x = *y;</span><br><span class="line">  *y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">Swap(&amp;a, &amp;b);</span><br></pre></td></tr></table></figure>

<p>上面示例中，通过传入变量<code>x</code>和<code>y</code>的地址，函数内部就可以直接操作该地址，从而实现交换两个变量的值。</p>
<p>虽然跟传参无关，这里特别提一下，函数不要返回内部变量的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> &amp;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数返回内部变量<code>i</code>的指针，这种写法是错的。因为当函数结束运行时，内部变量就消失了，这时指向内部变量<code>i</code>的内存地址就是无效的，再去使用这个地址是非常危险的。</p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数本身就是一段内存里面的代码，C 语言允许通过指针获取函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*print_ptr)(<span class="type">int</span>) = &amp;print;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>print_ptr</code>是一个函数指针，它指向函数<code>print()</code>的地址。函数<code>print()</code>的地址可以用<code>&amp;print</code>获得。注意，<code>(*print_ptr)</code>一定要写在圆括号里面，否则函数参数<code>(int)</code>的优先级高于<code>*</code>，整个式子就会变成<code>void* print_ptr(int)</code>。</p>
<p>有了函数指针，通过它也可以调用函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(*print_ptr)(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">print(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>比较特殊的是，C 语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说，<code>print</code>和<code>&amp;print</code>是一回事。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (print == &amp;print) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因此，上面代码的<code>print_ptr</code>等同于<code>print</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*print_ptr)(<span class="type">int</span>) = &amp;print;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="type">void</span> (*print_ptr)(<span class="type">int</span>) = print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (print_ptr == print) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>所以，对于任意函数，都有五种调用函数的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line">print(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">(*print)(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line">(&amp;print)(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法四</span></span><br><span class="line">(*print_ptr)(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法五</span></span><br><span class="line">print_ptr(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>为了简洁易读，一般情况下，函数名前面都不加<code>*</code>和<code>&amp;</code>。</p>
<p>这种特性的一个应用是，如果一个函数的参数或返回值，也是一个函数，那么函数原型可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compute</span><span class="params">(<span class="type">int</span> (*myfunc)(<span class="type">int</span>), <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例可以清晰地表明，函数<code>compute()</code>的第一个参数也是一个函数。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p>前面说过，函数必须先声明，后使用。由于程序总是先运行<code>main()</code>函数，导致所有其他函数都必须在<code>main()</code>函数之前声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  func1();</span><br><span class="line">  func2();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>main()</code>函数必须在最后声明，否则编译时会产生警告，找不到<code>func1()</code>或<code>func2()</code>的声明。</p>
<p>但是，<code>main()</code>是整个程序的入口，也是主要逻辑，放在最前面比较好。另一方面，对于函数较多的程序，保证每个函数的顺序正确，会变得很麻烦。</p>
<p>C 语言提供的解决方法是，只要在程序开头处给出函数原型，函数就可以先使用、后声明。所谓函数原型，就是提前告诉编译器，每个函数的返回类型和参数类型。其他信息都不需要，也不用包括函数体，具体的函数实现可以后面再补上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">twice</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> twice(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">twice</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>twice()</code>的实现是放在<code>main()</code>后面，但是代码头部先给出了函数原型，所以可以正确编译。只要提前给出函数原型，函数具体的实现放在哪里，就不重要了。</p>
<p>函数原型包括参数名也可以，虽然这样对于编译器是多余的，但是阅读代码的时候，可能有助于理解函数的意图。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">twice</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">twice</span><span class="params">(<span class="type">int</span> num)</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>twice</code>函数的参数名<code>num</code>，无论是否出现在原型里面，都是可以的。</p>
<p>注意，函数原型必须以分号结尾。</p>
<p>一般来说，每个源码文件的头部，都会给出当前脚本使用的所有函数的原型。</p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h3><p><code>exit()</code>函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件<code>stdlib.h</code>里面。</p>
<p><code>exit()</code>可以向程序外部返回一个值，它的参数就是程序的返回值。一般来说，使用两个常量作为它的参数：<code>EXIT_SUCCESS</code>（相当于 0）表示程序运行成功，<code>EXIT_FAILURE</code>（相当于 1）表示程序异常中止。这两个常数也是定义在<code>stdlib.h</code>里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序运行成功</span></span><br><span class="line"><span class="comment">// 等同于 exit(0);</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序异常中止</span></span><br><span class="line"><span class="comment">// 等同于 exit(1);</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br></pre></td></tr></table></figure>

<p>在<code>main()</code>函数里面，<code>exit()</code>等价于使用<code>return</code>语句。其他函数使用<code>exit()</code>，就是终止整个程序的运行，没有其他作用。</p>
<p>C 语言还提供了一个<code>atexit()</code>函数，用来登记<code>exit()</code>执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>

<p><code>atexit()</code>的参数是一个函数指针。注意，它的参数函数（上例的<code>print</code>）不能接受参数，也不能有返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;something wrong!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">atexit(print);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>exit()</code>执行时会先自动调用<code>atexit()</code>注册的<code>print()</code>函数，然后再终止程序。</p>
<h3 id="函数说明符"><a href="#函数说明符" class="headerlink" title="函数说明符"></a>函数说明符</h3><p>C 语言提供了一些函数说明符，让函数用法更加明确。</p>
<h4 id="extern-说明符"><a href="#extern-说明符" class="headerlink" title="extern 说明符"></a>extern 说明符</h4><p>对于多文件的项目，源码文件会用到其他文件声明的函数。这时，当前文件里面，需要给出外部函数的原型，并用<code>extern</code>说明该函数的定义来自其他文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> arg1, <span class="type">char</span> arg2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = foo(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>foo()</code>定义在其他文件，<code>extern</code>告诉编译器当前文件不包含该函数的定义。</p>
<p>不过，由于函数原型默认就是<code>extern</code>，所以这里不加<code>extern</code>，效果是一样的。</p>
<h4 id="static-说明符"><a href="#static-说明符" class="headerlink" title="static 说明符"></a>static 说明符</h4><p>默认情况下，每次调用函数时，函数的内部变量都会重新初始化，不会保留上一次运行的值。<code>static</code>说明符可以改变这种行为。</p>
<p><code>static</code>用于函数内部声明变量时，表示该变量只需要初始化一次，不需要在每次调用时都进行初始化。也就是说，它的值在两次调用之间保持不变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">counter</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">1</span>;  <span class="comment">// 只初始化一次</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  counter();  <span class="comment">// 1</span></span><br><span class="line">  counter();  <span class="comment">// 2</span></span><br><span class="line">  counter();  <span class="comment">// 3</span></span><br><span class="line">  counter();  <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>counter()</code>的内部变量<code>count</code>，使用<code>static</code>说明符修饰，表明这个变量只初始化一次，以后每次调用时都会使用上一次的值，造成递增的效果。</p>
<p>注意，<code>static</code>修饰的变量初始化时，只能赋值为常量，不能赋值为变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> j = i; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>j</code>属于静态变量，初始化时不能赋值为另一个变量<code>i</code>。</p>
<p>另外，在块作用域中，<code>static</code>声明的变量有默认值<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> foo;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> foo = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><code>static</code>可以用来修饰函数本身。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">Twice</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">  <span class="type">int</span> result = num * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>static</code>关键字表示该函数只能在当前文件里使用，如果没有这个关键字，其他文件也可以使用这个函数（通过声明函数原型）。</p>
<p><code>static</code>也可以用在参数里面，修饰参数数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span> a[<span class="type">static</span> <span class="number">3</span>], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>static</code>对程序行为不会有任何影响，只是用来告诉编译器，该数组长度至少为3，某些情况下可以加快程序运行速度。另外，需要注意的是，对于多维数组的参数，<code>static</code>仅可用于第一维的说明。</p>
<h4 id="const-说明符"><a href="#const-说明符" class="headerlink" title="const 说明符"></a>const 说明符</h4><p>函数参数里面的<code>const</code>说明符，表示函数内部不得修改该参数变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>* p)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f()</code>的参数是一个指针<code>p</code>，函数内部可能会改掉它所指向的值<code>*p</code>，从而影响到函数外部。</p>
<p>为了避免这种情况，可以在声明函数时，在指针参数前面加上<code>const</code>说明符，告诉编译器，函数内部不能修改该参数所指向的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* p)</span> &#123;</span><br><span class="line">  *p = <span class="number">0</span>; <span class="comment">// 该行报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，声明函数时，<code>const</code>指定不能修改指针<code>p</code>指向的值，所以<code>*p = 0</code>就会报错。</p>
<p>但是上面这种写法，只限制修改<code>p</code>所指向的值，而<code>p</code>本身的地址是可以修改的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* p)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">13</span>;</span><br><span class="line">  p = &amp;x; <span class="comment">// 允许修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>p</code>本身是可以修改，<code>const</code>只限定<code>*p</code>不能修改。</p>
<p>如果想限制修改<code>p</code>，可以把<code>const</code>放在<code>p</code>前面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> p)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">13</span>;</span><br><span class="line">  p = &amp;x; <span class="comment">// 该行报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想同时限制修改<code>p</code>和<code>*p</code>，需要使用两个<code>const</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>有些函数的参数数量是不确定的，声明函数的时候，可以使用省略号<code>...</code>表示可变数量的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例是<code>printf()</code>函数的原型，除了第一个参数，其他参数的数量是可变的，与格式字符串里面的占位符数量有关。这时，就可以用<code>...</code>表示可变数量的参数。</p>
<p>注意，<code>...</code>符号必须放在参数序列的结尾，否则会报错。</p>
<p>头文件<code>stdarg.h</code>定义了一些宏，可以操作可变参数。</p>
<p>（1）<code>va_list</code>：一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用。</p>
<p>（2）<code>va_start</code>：一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。</p>
<p>（3）<code>va_arg</code>：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。</p>
<p>（4）<code>va_end</code>：一个函数，用来清理可变参数对象。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> i, ...)</span> &#123;</span><br><span class="line">  <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">    total += va_arg(ap, <span class="type">double</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(ap);</span><br><span class="line">  <span class="keyword">return</span> total / i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>va_list ap</code>定义<code>ap</code>为可变参数对象，<code>va_start(ap, i)</code>将参数<code>i</code>后面的参数统一放入<code>ap</code>，<code>va_arg(ap, double)</code>用来从<code>ap</code>依次取出一个参数，并且指定该参数为 double 类型，<code>va_end(ap)</code>用来清理可变参数对象。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>数组是一组相同类型的值，按照顺序储存在一起。数组通过变量名后加方括号表示，方括号里面是数组的成员数量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例声明了一个数组<code>scores</code>，里面包含100个成员，每个成员都是<code>int</code>类型。</p>
<p>注意，声明数组时，必须给出数组的大小。</p>
<p>数组的成员从<code>0</code>开始编号，所以数组<code>scores[100]</code>就是从第0号成员一直到第99号成员，最后一个成员的编号会比数组长度小<code>1</code>。</p>
<p>数组名后面使用方括号指定编号，就可以引用该成员。也可以通过该方式，对该位置进行赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores[<span class="number">0</span>] = <span class="number">13</span>;</span><br><span class="line">scores[<span class="number">99</span>] = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例对数组<code>scores</code>的第一个位置和最后一个位置，进行了赋值。</p>
<p>注意，如果引用不存在的数组成员（即越界访问数组），并不会报错，所以必须非常小心。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">scores[<span class="number">100</span>] = <span class="number">51</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>scores</code>只有100个成员，因此<code>scores[100]</code>这个位置是不存在的。但是，引用这个位置并不会报错，会正常运行，使得紧跟在<code>scores</code>后面的那块内存区域被赋值，而那实际上是其他变量的区域，因此不知不觉就更改了其他变量的值。这很容易引发错误，而且难以发现。</p>
<p>数组也可以在声明时，使用大括号，同时对每一个成员赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>, <span class="number">18</span>, <span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line">a = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>, <span class="number">18</span>, <span class="number">95</span>&#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组<code>a</code>声明之后再进行大括号赋值，导致报错。</p>
<p>报错的原因是，C 语言规定，数组变量一旦声明，就不得修改变量指向的地址，具体会在后文解释。由于同样的原因，数组赋值之后，再用大括号修改值，也是不允许的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">a = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>, <span class="number">18</span>, <span class="number">95</span>&#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组<code>a</code>赋值后，再用大括号重新赋值也是不允许的。</p>
<p>使用大括号赋值时，大括号里面的值不能多于数组的长度，否则编译时会报错。</p>
<p>如果大括号里面的值，少于数组的成员数量，那么未赋值的成员自动初始化为<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>如果要将整个数组的每一个成员都设置为零，最简单的写法就是下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>数组初始化时，可以指定为哪些位置的成员赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">15</span>] = &#123;[<span class="number">2</span>] = <span class="number">29</span>, [<span class="number">9</span>] = <span class="number">7</span>, [<span class="number">14</span>] = <span class="number">48</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组的2号、9号、14号位置被赋值，其他位置的值都自动设为0。</p>
<p>指定位置的赋值可以不按照顺序，下面的写法与上面的例子是等价的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">15</span>] = &#123;[<span class="number">9</span>] = <span class="number">7</span>, [<span class="number">14</span>] = <span class="number">48</span>, [<span class="number">2</span>] = <span class="number">29</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>指定位置的赋值与顺序赋值，可以结合使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">15</span>] = &#123;<span class="number">1</span>, [<span class="number">5</span>] = <span class="number">10</span>, <span class="number">11</span>, [<span class="number">10</span>] = <span class="number">20</span>, <span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，0号、5号、6号、10号、11号被赋值。</p>
<p>C 语言允许省略方括号里面的数组成员数量，这时将根据大括号里面的值的数量，自动确定数组的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>a</code>的长度，将根据大括号里面的值的数量，确定为<code>3</code>。</p>
<p>省略成员数量时，如果同时采用指定位置的赋值，那么数组长度将是最大的指定位置再加1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;[<span class="number">2</span>] = <span class="number">6</span>, [<span class="number">9</span>] = <span class="number">12</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>a</code>的最大指定位置是<code>9</code>，所以数组的长度是10。</p>
<h3 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h3><p><code>sizeof</code>运算符会返回整个数组的字节长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>&#125;;</span><br><span class="line"><span class="type">int</span> arrLen = <span class="keyword">sizeof</span>(a); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>sizeof</code>返回数组<code>a</code>的字节长度是<code>12</code>。</p>
<p>由于数组成员都是同一个类型，每个成员的字节长度都是一样的，所以数组整体的字节长度除以某个数组成员的字节长度，就可以得到数组的成员数量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>sizeof(a)</code>是整个数组的字节长度，<code>sizeof(a[0])</code>是数组成员的字节长度，相除就是数组的成员数量。</p>
<p>注意，<code>sizeof</code>返回值的数据类型是<code>size_t</code>，所以<code>sizeof(a) / sizeof(a[0])</code>的数据类型也是<code>size_t</code>。在<code>printf()</code>里面的占位符，要用<code>%zd</code>或<code>%zu</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(x));     <span class="comment">// 48</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(x) / <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>sizeof(x) / sizeof(int)</code>就可以得到数组成员数量<code>12</code>。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>C 语言允许声明多个维度的数组，有多少个维度，就用多少个方括号，比如二维数组就使用两个方括号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> board[<span class="number">10</span>][<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例声明了一个二维数组，第一个维度有10个成员，第二个维度也有10个成员。</p>
<p>多维数组可以理解成，上层维度的每个成员本身就是一个数组。比如上例中，第一个维度的每个成员本身就是一个有10个成员的数组，因此整个二维数组共有100个成员（10 x 10 &#x3D; 100）。</p>
<p>三维数组就使用三个方括号声明，以此类推。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c[<span class="number">4</span>][<span class="number">5</span>][<span class="number">6</span>];</span><br></pre></td></tr></table></figure>

<p>引用二维数组的每个成员时，需要使用两个方括号，同时指定两个维度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">13</span>;</span><br><span class="line">board[<span class="number">9</span>][<span class="number">9</span>] = <span class="number">13</span>;</span><br></pre></td></tr></table></figure>

<p>注意，<code>board[0][0]</code>不能写成<code>board[0, 0]</code>，因为<code>0, 0</code>是一个逗号表达式，返回第二个值，所以<code>board[0, 0]</code>等同于<code>board[0]</code>。</p>
<p>跟一维数组一样，多维数组每个维度的第一个成员也是从<code>0</code>开始编号。</p>
<p>多维数组也可以使用大括号，一次性对所有成员赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">  &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">  &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>a</code>是一个二维数组，这种赋值写法相当于将第一维的每个成员写成一个数组。这种写法不用为每个成员都赋值，缺少的成员会自动设置为<code>0</code>。</p>
<p>多维数组也可以指定位置，进行初始化赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, [<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，指定了<code>[0][0]</code>和<code>[1][1]</code>位置的值，其他位置就自动设为<code>0</code>。</p>
<p>不管数组有多少维度，在内存里面都是线性存储，<code>a[0][0]</code>的后面是<code>a[0][1]</code>，<code>a[0][1]</code>的后面是<code>a[1][0]</code>，以此类推。因此，多维数组也可以使用单层大括号赋值，下面的语句是上面的赋值语句是完全等同的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h3><p>数组声明的时候，数组长度除了使用常量，也可以使用变量。这叫做变长数组（variable-length array，简称 VLA）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = x + y;</span><br><span class="line"><span class="type">int</span> arr[n];</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>arr</code>就是变长数组，因为它的长度取决于变量<code>n</code>的值，编译器没法事先确定，只有运行时才能知道<code>n</code>是多少。</p>
<p>变长数组的根本特征，就是数组长度只有运行时才能确定。它的好处是程序员不必在开发时，随意为数组指定一个估计的长度，程序可以在运行时为数组分配精确的长度。</p>
<p>任何长度需要运行时才能确定的数组，都是变长数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a1[i];</span><br><span class="line"><span class="type">int</span> a2[i + <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> a3[i + k];</span><br></pre></td></tr></table></figure>

<p>上面示例中，三个数组的长度都需要运行代码才能知道，编译器并不知道它们的长度，所以它们都是变长数组。</p>
<p>变长数组也可以用于多维数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> c[m][n];</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>c[m][n]</code>就是二维变长数组。</p>
<h3 id="数组的地址"><a href="#数组的地址" class="headerlink" title="数组的地址"></a>数组的地址</h3><p>数组是一连串连续储存的同类型值，只要获得起始地址（首个成员的内存地址），就能推算出其他成员的地址。请看下面的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line"></span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);  <span class="comment">// Prints &quot;11&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>&amp;a[0]</code>就是数组<code>a</code>的首个成员<code>11</code>的内存地址，也是整个数组的起始地址。反过来，从这个地址（<code>*p</code>），可以获得首个成员的值<code>11</code>。</p>
<p>由于数组的起始地址是常用操作，<code>&amp;array[0]</code>的写法有点麻烦，C 语言提供了便利写法，数组名等同于起始地址，也就是说，数组名就是指向第一个成员（<code>array[0]</code>）的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span>* p = a;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>&amp;a[0]</code>和数组名<code>a</code>是等价的。</p>
<p>这样的话，如果把数组名传入一个函数，就等同于传入一个指针变量。在函数内部，就可以通过这个指针变量获得整个数组。</p>
<p>函数接受数组作为参数，函数原型可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，传入一个整数数组，与传入一个整数指针是同一回事，数组符号<code>[]</code>与指针符号<code>*</code>是可以互换的。下一个例子是通过数组指针对成员求和。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假定数组有 10 个成员</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    total += arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，传入函数的是一个指针<code>arr</code>（也是数组名）和数组长度，通过指针获取数组的每个成员，从而求和。</p>
<p><code>*</code>和<code>&amp;</code>运算符也可以用于多维数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出 a[0][0] 的值</span></span><br><span class="line">*(a[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">**a</span><br></pre></td></tr></table></figure>

<p>上面示例中，由于<code>a[0]</code>本身是一个指针，指向第二维数组的第一个成员<code>a[0][0]</code>。所以，<code>*(a[0])</code>取出的是<code>a[0][0]</code>的值。至于<code>**a</code>，就是对<code>a</code>进行两次<code>*</code>运算，第一次取出的是<code>a[0]</code>，第二次取出的是<code>a[0][0]</code>。同理，二维数组的<code>&amp;a[0][0]</code>等同于<code>*a</code>。</p>
<p>注意，数组名指向的地址是不能更改的。声明数组时，编译器自动为数组分配了内存地址，这个地址与数组名是绑定的，不可更改，下面的代码会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ints[<span class="number">100</span>];</span><br><span class="line">ints = <span class="literal">NULL</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，重新为数组名赋值，改变原来的内存地址，就会报错。</p>
<p>这也导致不能将一个数组名赋值给另外一个数组名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">5</span>] = a; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">5</span>];</span><br><span class="line">b = a; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面两种写法都会更改数组<code>b</code>的地址，导致报错。</p>
<h3 id="数组指针的加减法"><a href="#数组指针的加减法" class="headerlink" title="数组指针的加减法"></a>数组指针的加减法</h3><p>C 语言里面，数组名可以进行加法和减法运算，等同于在数组成员之间前后移动，即从一个成员的内存地址移动到另一个成员的内存地址。比如，<code>a + 1</code>返回下一个成员的地址，<code>a - 1</code>返回上一个成员的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(a + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，通过指针的移动遍历数组，<code>a + i</code>的每轮循环每次都会指向下一个成员的地址，<code>*(a + i)</code>取出该地址的值，等同于<code>a[i]</code>。对于数组的第一个成员，<code>*(a + 0)</code>（即<code>*a</code>）等同于<code>a[0]</code>。</p>
<p>由于数组名与指针是等价的，所以下面的等式总是成立。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[b] == *(a + b)</span><br></pre></td></tr></table></figure>

<p>上面代码给出了数组成员的两种访问方式，一种是使用方括号<code>a[b]</code>，另一种是使用指针<code>*(a + b)</code>。</p>
<p>如果指针变量<code>p</code>指向数组的一个成员，那么<code>p++</code>就相当于指向下一个成员，这种方法常用来遍历数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">999</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*p != <span class="number">999</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">  p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，通过<code>p++</code>让变量<code>p</code>指向下一个成员。</p>
<p>注意，数组名指向的地址是不能变的，所以上例中，不能直接对<code>a</code>进行自增，即<code>a++</code>的写法是错的，必须将<code>a</code>的地址赋值给指针变量<code>p</code>，然后对<code>p</code>进行自增。</p>
<p>遍历数组一般都是通过数组长度的比较来实现，但也可以通过数组起始地址和结束地址的比较来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>* start, <span class="type">int</span>* end)</span> &#123;</span><br><span class="line">  <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    total += *start;</span><br><span class="line">    start++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">39</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, sum(arr, arr + <span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>arr</code>是数组的起始地址，<code>arr + 5</code>是结束地址。只要起始地址小于结束地址，就表示还没有到达数组尾部。</p>
<p>反过来，通过数组的减法，可以知道两个地址之间有多少个数组成员，请看下面的例子，自己实现一个计算数组长度的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">39</span>, <span class="number">88</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*p != <span class="number">88</span>)</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, p - arr); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，将某个数组成员的地址，减去数组起始地址，就可以知道，当前成员与起始地址之间有多少个成员。</p>
<p>对于多维数组，数组指针的加减法对于不同维度，含义是不一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针指向 arr[1]</span></span><br><span class="line">arr + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针指向 arr[0][1]</span></span><br><span class="line">arr[<span class="number">0</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>arr</code>是一个二维数组，<code>arr + 1</code>是将指针移动到第一维数组的下一个成员，即<code>arr[1]</code>。由于每个第一维的成员，本身都包含另一个数组，即<code>arr[0]</code>是一个指向第二维数组的指针，所以<code>arr[0] + 1</code>的含义是将指针移动到第二维数组的下一个成员，即<code>arr[0][1]</code>。</p>
<p>同一个数组的两个成员的指针相减时，返回它们之间的距离。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = &amp;a[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* q = &amp;a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p - q); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q - p); <span class="comment">// -4</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>p</code>和<code>q</code>分别是数组5号位置和1号位置的指针，它们相减等于4或-4。</p>
<h3 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h3><p>由于数组名是指针，所以复制数组不能简单地复制数组名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a;</span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure>

<p>上面的写法，结果不是将数组<code>b</code>复制给数组<code>a</code>，而是让<code>a</code>和<code>b</code>指向同一个数组。</p>
<p>复制数组最简单的方法，还是使用循环，将数组元素逐个进行复制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  a[i] = b[i];</span><br></pre></td></tr></table></figure>

<p>上面示例中，通过将数组<code>b</code>的成员逐个复制给数组<code>a</code>，从而实现数组的赋值。</p>
<p>另一种方法是使用<code>memcpy()</code>函数（定义在头文件<code>string.h</code>），直接把数组所在的那一段内存，再复制一份。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(a, b, <span class="keyword">sizeof</span>(b));</span><br></pre></td></tr></table></figure>

<p>上面示例中，将数组<code>b</code>所在的那段内存，复制给数组<code>a</code>。这种方法要比循环复制数组成员要快。</p>
<h3 id="作为函数的参数"><a href="#作为函数的参数" class="headerlink" title="作为函数的参数"></a>作为函数的参数</h3><h4 id="声明参数数组"><a href="#声明参数数组" class="headerlink" title="声明参数数组"></a>声明参数数组</h4><p>数组作为函数的参数，一般会同时传入数组名和数组长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> sum = sum_array(a, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>sum_array()</code>的第一个参数是数组本身，也就是数组名，第二个参数是数组长度。</p>
<p>由于数组名就是一个指针，如果只传数组名，那么函数只知道数组开始的地址，不知道结束的地址，所以才需要把数组长度也一起传入。</p>
<p>如果函数的参数是多维数组，那么除了第一维的长度可以当作参数传入函数，其他维的长度需要写入函数的定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span> a[][<span class="number">4</span>], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">  &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> sum = sum_array(a, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>sum_array()</code>的参数是一个二维数组。第一个参数是数组本身（<code>a[][4]</code>），这时可以不写第一维的长度，因为它作为第二个参数，会传入函数，但是一定要写第二维的长度<code>4</code>。</p>
<p>这是因为函数内部拿到的，只是数组的起始地址<code>a</code>，以及第一维的成员数量<code>2</code>。如果要正确计算数组的结束地址，还必须知道第一维每个成员的字节长度。写成<code>int a[][4]</code>，编译器就知道了，第一维每个成员本身也是一个数组，里面包含了4个整数，所以每个成员的字节长度就是<code>4 * sizeof(int)</code>。</p>
<h4 id="变长数组作为参数"><a href="#变长数组作为参数" class="headerlink" title="变长数组作为参数"></a>变长数组作为参数</h4><p>变长数组作为函数参数时，写法略有不同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a[n])</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> sum = sum_array(<span class="number">4</span>, a);</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>a[n]</code>是一个变长数组，它的长度取决于变量<code>n</code>的值，只有运行时才能知道。所以，变量<code>n</code>作为参数时，顺序一定要在变长数组前面，这样运行时才能确定数组<code>a[n]</code>的长度，否则就会报错。</p>
<p>因为函数原型可以省略参数名，所以变长数组的原型中，可以使用<code>*</code>代替变量名，也可以省略变量名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span>, <span class="type">int</span> [*])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span>, <span class="type">int</span> [])</span>;</span><br></pre></td></tr></table></figure>

<p>上面两种变长函数的原型写法，都是合法的。</p>
<p>变长数组作为函数参数有一个好处，就是多维数组的参数声明，可以把后面的维度省掉了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span> a[][<span class="number">4</span>], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变长数组的写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> a[n][m])</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>sum_array()</code>的参数是一个多维数组，按照原来的写法，一定要声明第二维的长度。但是使用变长数组的写法，就不用声明第二维长度了，因为它可以作为参数传入函数。</p>
<h4 id="数组字面量作为参数"><a href="#数组字面量作为参数" class="headerlink" title="数组字面量作为参数"></a>数组字面量作为参数</h4><p>C 语言允许将数组字面量作为参数，传入函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组变量作为参数</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> sum = sum_array(a, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组字面量作为参数</span></span><br><span class="line"><span class="type">int</span> sum = sum_array((<span class="type">int</span> [])&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，两种写法是等价的。第二种写法省掉了数组变量的声明，直接将数组字面量传入函数。<code>&#123;2, 3, 4, 5&#125;</code>是数组值的字面量，<code>(int [])</code>类似于强制的类型转换，告诉编译器怎么理解这组值。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>C 语言没有单独的字符串类型，字符串被当作字符数组，即<code>char</code>类型的数组。比如，字符串“Hello”是当作数组<code>&#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;&#125;</code>处理的。</p>
<p>编译器会给数组分配一段连续内存，所有字符储存在相邻的内存单元之中。在字符串结尾，C 语言会自动添加一个全是二进制<code>0</code>的字节，写作<code>\0</code>字符，表示字符串结束。字符<code>\0</code>不同于字符<code>0</code>，前者的 ASCII 码是0（二进制形式<code>00000000</code>），后者的 ASCII 码是48（二进制形式<code>00110000</code>）。所以，字符串“Hello”实际储存的数组是<code>&#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;&#125;</code>。</p>
<p>所有字符串的最后一个字符，都是<code>\0</code>。这样做的好处是，C 语言不需要知道字符串的长度，就可以读取内存里面的字符串，只要发现有一个字符是<code>\0</code>，那么就知道字符串结束了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> localString[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例声明了一个10个成员的字符数组，可以当作字符串。由于必须留一个位置给<code>\0</code>，所以最多只能容纳9个字符的字符串。</p>
<p>字符串写成数组的形式，是非常麻烦的。C 语言提供了一种简写法，双引号之中的字符，会被自动视为字符数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面两种字符串的写法是等价的，内部存储方式都是一样的。双引号里面的字符串，不用自己添加结尾字符<code>\0</code>，C 语言会自动添加。</p>
<p>注意，双引号里面是字符串，单引号里面是字符，两者不能互换。如果把<code>Hello</code>放在单引号里面，编译器会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span></span><br></pre></td></tr></table></figure>

<p>另一方面，即使双引号里面只有一个字符（比如<code>&quot;a&quot;</code>），也依然被处理成字符串（存储为2个字节），而不是字符<code>&#39;a&#39;</code>（存储为1个字节）。</p>
<p>如果字符串内部包含双引号，则该双引号需要使用反斜杠转义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;She replied, \&quot;It does.\&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>反斜杠还可以表示其他特殊字符，比如换行符（<code>\n</code>）、制表符（<code>\t</code>）等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello, world!\n&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果字符串过长，可以在需要折行的地方，使用反斜杠（<code>\</code>）结尾，将一行拆成多行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello \</span></span><br><span class="line"><span class="string">world&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，第一行尾部的反斜杠，将字符串拆成两行。</p>
<p>上面这种写法有一个缺点，就是第二行必须顶格书写，如果想包含缩进，那么缩进也会被计入字符串。为了解决这个问题，C 语言允许合并多个字符串字面量，只要这些字符串之间没有间隔，或者只有空格，C 语言会将它们自动合并。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[<span class="number">50</span>] = <span class="string">&quot;Hello, &quot;</span><span class="string">&quot;how are you &quot;</span><span class="string">&quot;today!&quot;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">char</span> greeting[<span class="number">50</span>] = <span class="string">&quot;Hello, how are you today!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这种新写法支持多行字符串的合并。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[<span class="number">50</span>] = <span class="string">&quot;Hello, &quot;</span></span><br><span class="line">  <span class="string">&quot;how are you &quot;</span></span><br><span class="line">  <span class="string">&quot;today!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>printf()</code>使用占位符<code>%s</code>输出字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="字符串变量的声明"><a href="#字符串变量的声明" class="headerlink" title="字符串变量的声明"></a>字符串变量的声明</h3><p>字符串变量可以声明成一个字符数组，也可以声明成一个指针，指向字符数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">14</span>] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="type">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面两种写法都声明了一个字符串变量<code>s</code>。如果采用第一种写法，由于字符数组的长度可以让编译器自动计算，所以声明时可以省略字符数组的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，编译器会将数组<code>s</code>的长度指定为14，正好容纳后面的字符串。</p>
<p>字符数组的长度，可以大于字符串的实际长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">50</span>] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，字符数组<code>s</code>的长度是<code>50</code>，但是字符串“hello”的实际长度只有6（包含结尾符号<code>\0</code>），所以后面空出来的44个位置，都会被初始化为<code>\0</code>。</p>
<p>字符数组的长度，不能小于字符串的实际长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">5</span>] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，字符串数组<code>s</code>的长度是<code>5</code>，小于字符串“hello”的实际长度6，这时编译器会报错。因为如果只将前5个字符写入，而省略最后的结尾符号<code>\0</code>，这很可能导致后面的字符串相关代码出错。</p>
<p>字符指针和字符数组，这两种声明字符串变量的写法基本是等价的，但是有两个差异。</p>
<p>第一个差异是，指针指向的字符串，在 C 语言内部被当作常量，不能修改字符串本身。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>上面代码使用指针，声明了一个字符串变量，然后修改了字符串的第一个字符。这种写法是错的，会导致难以预测的后果，执行时很可能会报错。</p>
<p>如果使用数组声明字符串变量，就没有这个问题，可以修改数组的任意成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>为什么字符串声明为指针时不能修改，声明为数组时就可以修改？原因是系统会将字符串的字面量保存在内存的常量区，这个区是不允许用户修改的。声明为指针时，指针变量存储的只是一个指向常量区的内存地址，因此用户不能通过这个地址去修改常量区。但是，声明为数组时，编译器会给数组单独分配一段内存，字符串字面量会被编译器解释成字符数组，逐个字符写入这段新分配的内存之中，而这段新内存是允许修改的。</p>
<p>为了提醒用户，字符串声明为指针后不得修改，可以在声明时使用<code>const</code>说明符，保证该字符串是只读的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面字符串声明为指针时，使用了<code>const</code>说明符，就保证了该字符串无法修改。一旦修改，编译器肯定会报错。</p>
<p>第二个差异是，指针变量可以指向其它字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，字符指针可以指向另一个字符串。</p>
<p>但是，字符数组变量不能指向另一个字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;world&quot;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，字符数组的数组名，总是指向初始化时的字符串地址，不能修改。</p>
<p>同样的原因，声明字符数组后，不能直接用字符串赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">s = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，不能直接把字符串赋值给字符数组变量，会报错。原因是字符数组的变量名，跟所指向的数组是绑定的，不能指向另一个地址。</p>
<p>为什么数组变量不能赋值为另一个数组？原因是数组变量所在的地址无法改变，或者说，编译器一旦为数组变量分配地址后，这个地址就绑定这个数组变量了，这种绑定关系是不变的。C 语言也因此规定，数组变量是一个不可修改的左值，即不能用赋值运算符为它重新赋值。</p>
<p>想要重新赋值，必须使用 C 语言原生提供的<code>strcpy()</code>函数，通过字符串拷贝完成赋值。这样做以后，数组变量的地址还是不变的，即<code>strcpy()</code>只是在原地址写入新的字符串，而不是让数组变量指向新的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s, <span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>strcpy()</code>函数把字符串<code>abc</code>拷贝给变量<code>s</code>，这个函数的详细用法会在后面介绍。</p>
<h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h3><p><code>strlen()</code>函数返回字符串的字节长度，不包括末尾的空字符<code>\0</code>。该函数的原型如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string.h</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span>;</span><br></pre></td></tr></table></figure>

<p>它的参数是字符串变量，返回的是<code>size_t</code>类型的无符号整数，除非是极长的字符串，一般情况下当作<code>int</code>类型处理即可。下面是一个用法实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(str); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p><code>strlen()</code>的原型在标准库的<code>string.h</code>文件中定义，使用时需要加载头文件<code>string.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The string is %zd characters long.\n&quot;</span>, <span class="built_in">strlen</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，字符串长度（<code>strlen()</code>）与字符串变量长度（<code>sizeof()</code>），是两个不同的概念。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">50</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(s));  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(s));  <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，字符串长度是5，字符串变量长度是50。</p>
<p>如果不使用这个函数，可以通过判断字符串末尾的<code>\0</code>，自己计算字符串长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (s[count] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    count++;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy()"></a>strcpy()</h3><p>字符串的复制，不能使用赋值运算符，直接将一个字符串赋值给字符数组变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> str2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 报错</span></span><br><span class="line">str2 = str1;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面两种字符串的复制写法，都是错的。因为数组的变量名是一个固定的地址，不能修改，使其指向另一个地址。</p>
<p>如果是字符指针，赋值运算符（<code>=</code>）只是将一个指针的地址复制给另一个指针，而不是复制字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s1;</span><br><span class="line"><span class="type">char</span>* s2;</span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s2 = s1;</span><br></pre></td></tr></table></figure>

<p>上面代码可以运行，结果是两个指针变量<code>s1</code>和<code>s2</code>指向同一字符串，而不是将字符串<code>s2</code>的内容复制给<code>s1</code>。</p>
<p>C 语言提供了<code>strcpy()</code>函数，用于将一个字符串的内容复制到另一个字符串，相当于字符串赋值。该函数的原型定义在<code>string.h</code>头文件里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(<span class="type">char</span> dest[], <span class="type">const</span> <span class="type">char</span> source[])</span><br></pre></td></tr></table></figure>

<p><code>strcpy()</code>接受两个参数，第一个参数是目的字符串数组，第二个参数是源字符串数组。复制字符串之前，必须要保证第一个参数的长度不小于第二个参数，否则虽然不会报错，但会溢出第一个字符串变量的边界，发生难以预料的结果。第二个参数的<code>const</code>说明符，表示这个函数不会修改第二个字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> s[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">  <span class="type">char</span> t[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(t, s);</span><br><span class="line"></span><br><span class="line">  t[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);  <span class="comment">// &quot;Hello, world!&quot;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, t);  <span class="comment">// &quot;zello, world!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例将变量<code>s</code>的值，拷贝一份放到变量<code>t</code>，变成两个不同的字符串，修改一个不会影响到另一个。另外，变量<code>t</code>的长度大于<code>s</code>，复制后多余的位置（结束标志<code>\0</code>后面的位置）都为随机值。</p>
<p><code>strcpy()</code>也可以用于字符数组的赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例将字符数组变量，赋值为字符串“abcd”。</p>
<p><code>strcpy()</code>的返回值是一个字符串指针（即<code>char*</code>），指向第一个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s1 = <span class="string">&quot;beast&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[<span class="number">40</span>] = <span class="string">&quot;Be the best that you can be.&quot;</span>;</span><br><span class="line"><span class="type">char</span>* ps;</span><br><span class="line"></span><br><span class="line">ps = <span class="built_in">strcpy</span>(s2 + <span class="number">7</span>, s1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(s2); <span class="comment">// Be the beast</span></span><br><span class="line"><span class="built_in">puts</span>(ps); <span class="comment">// beast</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，从<code>s2</code>的第7个位置开始拷贝字符串<code>beast</code>，前面的位置不变。这导致<code>s2</code>后面的内容都被截去了，因为会连<code>beast</code>结尾的空字符一起拷贝。<code>strcpy()</code>返回的是一个指针，指向拷贝开始的位置。</p>
<p><code>strcpy()</code>返回值的另一个用途，是连续为多个字符数组赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(str1, <span class="built_in">strcpy</span>(str2, <span class="string">&quot;abcd&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>上面示例调用两次<code>strcpy()</code>，完成两个字符串变量的赋值。</p>
<p>另外，<code>strcpy()</code>的第一个参数最好是一个已经声明的数组，而不是声明后没有进行初始化的字符指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* str;</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>上面的代码是有问题的。<code>strcpy()</code>将字符串分配给指针变量<code>str</code>，但是<code>str</code>并没有进行初始化，指向的是一个随机的位置，因此字符串可能被复制到任意地方。</p>
<p>如果不用<code>strcpy()</code>，自己实现字符串的拷贝，可以用下面的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* source)</span> &#123;</span><br><span class="line">  <span class="type">char</span>* ptr = dest;</span><br><span class="line">  <span class="keyword">while</span> (*dest++ = *source++);</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">25</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，关键的一行是<code>while (*dest++ = *source++)</code>，这是一个循环，依次将<code>source</code>的每个字符赋值给<code>dest</code>，然后移向下一个位置，直到遇到<code>\0</code>，循环判断条件不再为真，从而跳出循环。其中，<code>*dest++</code>这个表达式等同于<code>*(dest++)</code>，即先返回<code>dest</code>这个地址，再进行自增运算移向下一个位置，而<code>*dest</code>可以对当前位置赋值。</p>
<p><code>strcpy()</code>函数有安全风险，因为它并不检查目标字符串的长度，是否足够容纳源字符串的副本，可能导致写入溢出。如果不能保证不会发生溢出，建议使用<code>strncpy()</code>函数代替。</p>
<h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy()"></a>strncpy()</h3><p><code>strncpy()</code>跟<code>strcpy()</code>的用法完全一样，只是多了第3个参数，用来指定复制的最大字符数，防止溢出目标字符串变量的边界。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">char</span> *dest, </span></span><br><span class="line"><span class="params">  <span class="type">char</span> *src, </span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> n</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>上面原型中，第三个参数<code>n</code>定义了复制的最大字符数。如果达到最大字符数以后，源字符串仍然没有复制完，就会停止复制，这时目的字符串结尾将没有终止符<code>\0</code>，这一点务必注意。如果源字符串的字符数小于<code>n</code>，则<code>strncpy()</code>的行为与<code>strcpy()</code>完全一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncpy</span>(str1, str2, <span class="keyword">sizeof</span>(str1) - <span class="number">1</span>);</span><br><span class="line">str1[<span class="keyword">sizeof</span>(str1) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，字符串<code>str2</code>复制给<code>str1</code>，但是复制长度最多为<code>str1</code>的长度减去1，<code>str1</code>剩下的最后一位用于写入字符串的结尾标志<code>\0</code>。这是因为<code>strncpy()</code>不会自己添加<code>\0</code>，如果复制的字符串片段不包含结尾标志，就需要手动添加。</p>
<p><code>strncpy()</code>也可以用来拷贝部分字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">40</span>];</span><br><span class="line"><span class="type">char</span> s2[<span class="number">12</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(s1, s2, <span class="number">5</span>);</span><br><span class="line">s1[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，指定只拷贝前5个字符。</p>
<h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat()"></a>strcat()</h3><p><code>strcat()</code>函数用于连接字符串。它接受两个字符串作为参数，把第二个字符串的副本添加到第一个字符串的末尾。这个函数会改变第一个字符串，但是第二个字符串不变。</p>
<p>该函数的原型定义在<code>string.h</code>头文件里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcat</span><span class="params">(<span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span>;</span><br></pre></td></tr></table></figure>

<p><code>strcat()</code>的返回值是一个字符串指针，指向第一个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">12</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[<span class="number">6</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(s1, s2);</span><br><span class="line"><span class="built_in">puts</span>(s1); <span class="comment">// &quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，调用<code>strcat()</code>以后，可以看到字符串<code>s1</code>的值变了。</p>
<p>注意，<code>strcat()</code>的第一个参数的长度，必须足以容纳添加第二个参数字符串。否则，拼接后的字符串会溢出第一个字符串的边界，写入相邻的内存单元，这是很危险的，建议使用下面的<code>strncat()</code>代替。</p>
<h3 id="strncat"><a href="#strncat" class="headerlink" title="strncat()"></a>strncat()</h3><p><code>strncat()</code>用于连接两个字符串，用法与<code>strncat()</code>完全一致，只是增加了第三个参数，指定最大添加的字符数。在添加过程中，一旦达到指定的字符数，或者在源字符串中遇到空字符<code>\0</code>，就不再添加了。它的原型定义在<code>string.h</code>头文件里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncat</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* dest,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* src,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> n</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><code>strncat()</code>返回第一个参数，即目标字符串指针。</p>
<p>为了保证连接后的字符串，不超过目标字符串的长度，<code>strncat()</code>通常会写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncat</span>(</span><br><span class="line">  str1, </span><br><span class="line">  str2, </span><br><span class="line">  <span class="keyword">sizeof</span>(str1) - <span class="built_in">strlen</span>(str1) - <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>strncat()</code>总是会在拼接结果的结尾，自动添加空字符<code>\0</code>，所以第三个参数的最大值，应该是<code>str1</code>的变量长度减去<code>str1</code>的字符串长度，再减去<code>1</code>。下面是一个用法实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">10</span>] = <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[<span class="number">8</span>] = <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncat</span>(s1, s2, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">puts</span>(s1); <span class="comment">// &quot;MondayTue&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>s1</code>的变量长度是10，字符长度是6，两者相减后再减去1，得到<code>3</code>，表明<code>s1</code>最多可以再添加三个字符，所以得到的结果是<code>MondayTue</code>。</p>
<h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h3><p>如果要比较两个字符串，无法直接比较，只能一个个字符进行比较，C 语言提供了<code>strcmp()</code>函数。</p>
<p><code>strcmp()</code>函数用于比较两个字符串的内容。该函数的原型如下，定义在<code>string.h</code>头文件里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span>;</span><br></pre></td></tr></table></figure>

<p>按照字典顺序，如果两个字符串相同，返回值为<code>0</code>；如果<code>s1</code>小于<code>s2</code>，<code>strcmp()</code>返回值小于0；如果<code>s1</code>大于<code>s2</code>，返回值大于0。</p>
<p>下面是一个用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1 = Happy New Year</span></span><br><span class="line"><span class="comment">// s2 = Happy New Year</span></span><br><span class="line"><span class="comment">// s3 = Happy Holidays</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s2) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s3) <span class="comment">// 大于 0</span></span><br><span class="line"><span class="built_in">strcmp</span>(s3, s1) <span class="comment">// 小于 0</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>strcmp()</code>只用来比较字符串，不用来比较字符。因为字符就是小整数，直接用相等运算符（<code>==</code>）就能比较。所以，不要把字符类型（<code>char</code>）的值，放入<code>strcmp()</code>当作参数。</p>
<h3 id="strncmp"><a href="#strncmp" class="headerlink" title="strncmp()"></a>strncmp()</h3><p>由于<code>strcmp()</code>比较的是整个字符串，C 语言又提供了<code>strncmp()</code>函数，只比较到指定的位置。</p>
<p>该函数增加了第三个参数，指定了比较的字符数。它的原型定义在<code>string.h</code>头文件里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* s1,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* s2, </span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> n</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它的返回值与<code>strcmp()</code>一样。如果两个字符串相同，返回值为<code>0</code>；如果<code>s1</code>小于<code>s2</code>，<code>strcmp()</code>返回值小于0；如果<code>s1</code>大于<code>s2</code>，返回值大于0。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">12</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[<span class="number">12</span>] = <span class="string">&quot;hello C&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;They all have hello.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例只比较两个字符串的前5个字符。</p>
<h3 id="sprintf-，snprintf"><a href="#sprintf-，snprintf" class="headerlink" title="sprintf()，snprintf()"></a>sprintf()，snprintf()</h3><p><code>sprintf()</code>函数跟<code>printf()</code>类似，但是用于将数据写入字符串，而不是输出到显示器。该函数的原型定义在<code>stdio.h</code>头文件里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span>* s, <span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p><code>sprintf()</code>的第一个参数是字符串指针变量，其余参数和<code>printf()</code>相同，即第二个参数是格式字符串，后面的参数是待写入的变量列表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> first[<span class="number">6</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> last[<span class="number">6</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">char</span> s[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%s %s&quot;</span>, first, last);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>sprintf()</code>将输出内容组合成“hello world”，然后放入了变量<code>s</code>。</p>
<p><code>sprintf()</code>的返回值是写入变量的字符数量（不计入尾部的空字符<code>\0</code>）。如果遇到错误，返回负值。</p>
<p><code>sprintf()</code>有严重的安全风险，如果写入的字符串过长，超过了目标字符串的长度，<code>sprintf()</code>依然会将其写入，导致发生溢出。为了控制写入的字符串的长度，C 语言又提供了另一个函数<code>snprintf()</code>。</p>
<p><code>snprintf()</code>只比<code>sprintf()</code>多了一个参数<code>n</code>，用来控制写入变量的字符串不超过<code>n - 1</code>个字符，剩下一个位置写入空字符<code>\0</code>。下面是它的原型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span>*s, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p><code>snprintf()</code>总是会自动写入字符串结尾的空字符。如果你尝试写入的字符数超过指定的最大字符数，<code>snprintf()</code>会写入 n - 1 个字符，留出最后一个位置写入空字符。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(s, <span class="number">12</span>, <span class="string">&quot;%s %s&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>snprintf()</code>的第二个参数是12，表示写入字符串的最大长度不超过12（包括尾部的空字符）。</p>
<p><code>snprintf()</code>的返回值是写入变量的字符数量（不计入尾部的空字符<code>\0</code>），应该小于<code>n</code>。如果遇到错误，返回负值。</p>
<h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><p>如果一个数组的每个成员都是一个字符串，需要通过二维的字符数组实现。每个字符串本身是一个字符数组，多个字符串再组成一个数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> weekdays[<span class="number">7</span>][<span class="number">10</span>] = &#123;</span><br><span class="line">  <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例就是一个字符串数组，一共包含7个字符串，所以第一维的长度是7。其中，最长的字符串的长度是10（含结尾的终止符<code>\0</code>），所以第二维的长度统一设为10。</p>
<p>因为第一维的长度，编译器可以自动计算，所以可以省略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> weekdays[][<span class="number">10</span>] = &#123;</span><br><span class="line">  <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，二维数组第一维的长度，可以由编译器根据后面的赋值，自动计算，所以可以不写。</p>
<p>数组的第二维，长度统一定为10，有点浪费空间，因为大多数成员的长度都小于10。解决方法就是把数组的第二维，从字符数组改成字符指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* weekdays[] = &#123;</span><br><span class="line">  <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的字符串数组，其实是一个一维数组，成员就是7个字符指针，每个指针指向一个字符串（字符数组）。</p>
<p>遍历字符串数组的写法如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, weekdays[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-语言的内存管理"><a href="#C-语言的内存管理" class="headerlink" title="C 语言的内存管理"></a>C 语言的内存管理</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>C 语言的内存管理，分成两部分。一部分是系统管理的，另一部分是用户手动管理的。</p>
<p>系统管理的内存，主要是函数内部的变量（局部变量）。这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为”栈“（stack），”栈“所在的内存是系统自动管理的。</p>
<p>用户手动管理的内存，主要是程序运行的整个过程中都存在的变量（全局变量），这些变量需要用户手动从内存释放。如果使用后忘记释放，它就一直占用内存，直到程序退出，这种情况称为”内存泄漏“（memory leak）。这些变量所在的内存称为”堆“（heap），”堆“所在的内存是用户手动管理的。</p>
<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void 指针"></a>void 指针</h3><p>前面章节已经说过了，每一块内存都有地址，通过指针变量可以获取指定地址的内存块。指针变量必须有类型，否则编译器无法知道，如何解读内存块保存的二进制数据。但是，向系统请求内存的时候，有时不确定会有什么样的数据写入内存，需要先获得内存块，稍后再确定写入的数据类型。</p>
<p>为了满足这种需求，C 语言提供了一种不定类型的指针，叫做 void 指针。它只有内存块的地址信息，没有类型信息，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么。</p>
<p>另一方面，void 指针等同于无类型指针，可以指向任意类型的数据，但是不能解读数据。void 指针与其他所有类型指针之间是互相转换关系，任一类型的指针都可以转为 void 指针，而 void 指针也可以转为任一类型的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* p = &amp;x; <span class="comment">// 整数指针转为 void 指针</span></span><br><span class="line"><span class="type">int</span>* q = p; <span class="comment">// void 指针转为整数指针</span></span><br></pre></td></tr></table></figure>

<p>上面示例演示了，整数指针和 void 指针如何互相转换。<code>&amp;x</code>是一个整数指针，<code>p</code>是 void 指针，赋值时<code>&amp;x</code>的地址会自动解释为 void 类型。同样的，<code>p</code>再赋值给整数指针<code>q</code>时，<code>p</code>的地址会自动解释为整数指针。</p>
<p>注意，由于不知道 void 指针指向什么类型的值，所以不能用<code>*</code>运算符取出它指向的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"><span class="type">void</span>* p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *p); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>p</code>是一个 void 指针，所以这时无法用<code>*p</code>取出指针指向的值。</p>
<p>void 指针的重要之处在于，很多内存相关函数的返回值就是 void 指针，只给出内存块的地址信息，所以放在最前面进行介绍。</p>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p><code>malloc()</code>函数用于分配内存，该函数向系统要求一段内存，系统就在“堆”里面分配一段连续的内存块给它。它的原型定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure>

<p>它接受一个非负整数作为参数，表示所要分配的内存字节数，返回一个 void 指针，指向分配好的内存块。这是非常合理的，因为<code>malloc()</code>函数不知道，将要存储在该块内存的数据是什么类型，所以只能返回一个无类型的 void 指针。</p>
<p>可以使用<code>malloc()</code>为任意类型的数据分配内存，常见的做法是先使用<code>sizeof()</code>函数，算出某种数据类型所需的字节长度，然后再将这个长度传给<code>malloc()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">*p = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，先为整数类型分配一段内存，然后将整数<code>12</code>放入这段内存里面。这个例子其实不需要使用<code>malloc()</code>，因为 C 语言会自动为整数（本例是<code>12</code>）提供内存。</p>
<p>有时候为了增加代码的可读性，可以对<code>malloc()</code>返回的指针进行一次强制类型转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>上面代码将<code>malloc()</code>返回的 void 指针，强制转换成了整数指针。</p>
<p>由于<code>sizeof()</code>的参数可以是变量，所以上面的例子也可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p));</span><br></pre></td></tr></table></figure>

<p><code>malloc()</code>分配内存有可能分配失败，这时返回常量 NULL。Null 的值为0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针。它在包括<code>stdlib.h</code>等多个头文件里面都有定义，所以只要可以使用<code>malloc()</code>，就可以使用<code>NULL</code>。由于存在分配失败的可能，所以最好在使用<code>malloc()</code>之后检查一下，是否分配成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="comment">// 内存分配失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，通过判断返回的指针<code>p</code>是否为<code>NULL</code>，确定<code>malloc()</code>是否分配成功。</p>
<p><code>malloc()</code>最常用的场合，就是为数组和自定义数据结构分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  p[i] = i * <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>p</code>是一个整数指针，指向一段可以放置10个整数的内存，所以可以用作数组。</p>
<p><code>malloc()</code>用来创建数组，有一个好处，就是它可以创建动态数组，即根据成员数量的不同，而创建长度不同的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>malloc()</code>可以根据变量<code>n</code>的不同，动态为数组分配不同的大小。</p>
<p>注意，<code>malloc()</code>不会对所分配的内存进行初始化，里面还保存着原来的值。如果没有初始化，就使用这段内存，可能从里面读到以前的值。程序员要自己负责初始化，比如，字符串初始化可以使用<code>strcpy()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p = <span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">p = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，字符指针<code>p</code>指向一段4个字节的内存，<code>strcpy()</code>将字符串“abc”拷贝放入这段内存，完成了这段内存的初始化。</p>
<h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p><code>free()</code>用于释放<code>malloc()</code>函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束。该函数的原型定义在头文件<code>stdlib.h</code>里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* block)</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>free()</code>的参数是<code>malloc()</code>返回的内存地址。下面就是用法实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">*p = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure>

<p>注意，分配的内存块一旦释放，就不应该再次操作已经释放的地址，也不应该再次使用<code>free()</code>对该地址释放第二次。</p>
<p>一个很常见的错误是，在函数内部分配了内存，但是函数调用结束时，没有使用<code>free()</code>释放内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gobble</span><span class="params">(<span class="type">double</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">double</span>* temp = (<span class="type">double</span>*) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>gobble()</code>内部分配了内存，但是没有写<code>free(temp)</code>。这会造成函数运行结束后，占用的内存块依然保留，如果多次调用<code>gobble()</code>，就会留下多个内存块。并且，由于指针<code>temp</code>已经消失了，也无法访问这些内存块，再次使用。</p>
<h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h3><p><code>calloc()</code>函数的作用与<code>malloc()</code>相似，也是分配内存块。该函数的原型定义在头文件<code>stdlib.h</code>。</p>
<p>两者的区别主要有两点：</p>
<p>（1）<code>calloc()</code>接受两个参数，第一个参数是某种数据类型的值的数量，第二个是该数据类型的单位字节长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> n, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p><code>calloc()</code>的返回值也是一个 void 指针。分配失败时，返回 NULL。</p>
<p>（2）<code>calloc()</code>会将所分配的内存全部初始化为<code>0</code>。<code>malloc()</code>不会对内存进行初始化，如果想要初始化为<code>0</code>，还要额外调用<code>memset()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>calloc()</code>相当于<code>malloc() + memset()</code>。</p>
<p><code>calloc()</code>分配的内存块，也要使用<code>free()</code>释放。</p>
<h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc()"></a>realloc()</h3><p><code>realloc()</code>函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针。如果分配不成功，返回 NULL。该函数的原型定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">realloc</span><span class="params">(<span class="type">void</span>* block, <span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure>

<p>它接受两个参数。</p>
<ul>
<li><code>block</code>：已经分配好的内存块指针（由<code>malloc()</code>或<code>calloc()</code>或<code>realloc()</code>产生）。</li>
<li><code>size</code>：该内存块的新大小，单位为字节。</li>
</ul>
<p><code>realloc()</code>可能返回一个全新的地址（数据也会自动复制过去），也可能返回跟原来一样的地址。<code>realloc()</code>优先在原有内存块上进行缩减，尽量不移动数据，所以通常是返回原先的地址。如果新内存块小于原来的大小，则丢弃超出的部分；如果大于原来的大小，则不对新增的部分进行初始化（程序员可以自动调用<code>memset()</code>）。</p>
<p>下面是一个例子，<code>b</code>是数组指针，<code>realloc()</code>动态调整它的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* b;</span><br><span class="line"></span><br><span class="line">b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line">b = <span class="built_in">realloc</span>(b, <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，指针<code>b</code>原来指向10个成员的整数数组，使用<code>realloc()</code>调整为2000个成员的数组。这就是手动分配数组内存的好处，可以在运行时随时调整数组的长度。</p>
<p><code>realloc()</code>的第一个参数可以是 NULL，这时就相当于新建一个指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p = <span class="built_in">realloc</span>(<span class="literal">NULL</span>, <span class="number">3490</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">char</span>* p = <span class="built_in">malloc</span>(<span class="number">3490</span>);</span><br></pre></td></tr></table></figure>

<p>如果<code>realloc()</code>的第二个参数是<code>0</code>，就会释放掉内存块。</p>
<p>由于有分配失败的可能，所以调用<code>realloc()</code>以后，最好检查一下它的返回值是否为 NULL。分配失败时，原有内存块中的数据不会发生改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span>* new_p = <span class="built_in">realloc</span>(p, <span class="keyword">sizeof</span>(*p * <span class="number">40</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (new_p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Error reallocing\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>realloc()</code>不会对内存块进行初始化。</p>
<h3 id="restrict-说明符"><a href="#restrict-说明符" class="headerlink" title="restrict 说明符"></a>restrict 说明符</h3><p>声明指针变量时，可以使用<code>restrict</code>说明符，告诉编译器，该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存。这种指针称为“受限指针”（restrict pointer）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="keyword">restrict</span> p;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>上面示例中，声明指针变量<code>p</code>时，加入了<code>restrict</code>说明符，使得<code>p</code>变成了受限指针。后面，当<code>p</code>指向<code>malloc()</code>函数返回的一块内存区域，就味着，该区域只有通过<code>p</code>来访问，不存在其他访问方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="keyword">restrict</span> p;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* q = p;</span><br><span class="line">*q = <span class="number">0</span>; <span class="comment">// 未定义行为</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，另一个指针<code>q</code>与受限指针<code>p</code>指向同一块内存，现在该内存有<code>p</code>和<code>q</code>两种访问方式。这就违反了对编译器的承诺，后面通过<code>*q</code>对该内存区域赋值，会导致未定义行为。</p>
<h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy()"></a>memcpy()</h3><p><code>memcpy()</code>用于将一块内存拷贝到另一块内存。该函数的原型定义在头文件<code>string.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">memcpy</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">void</span>* <span class="keyword">restrict</span> dest, </span></span><br><span class="line"><span class="params">  <span class="type">void</span>* <span class="keyword">restrict</span> source, </span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> n</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>dest</code>是目标地址，<code>source</code>是源地址，第三个参数<code>n</code>是要拷贝的字节数<code>n</code>。如果要拷贝10个 double 类型的数组成员，<code>n</code>就等于<code>10 * sizeof(double)</code>，而不是<code>10</code>。该函数会将从<code>source</code>开始的<code>n</code>个字节，拷贝到<code>dest</code>。</p>
<p><code>dest</code>和<code>source</code>都是 void 指针，表示这里不限制指针类型，各种类型的内存数据都可以拷贝。两者都有 restrict 关键字，表示这两个内存块不应该有互相重叠的区域。</p>
<p><code>memcpy()</code>的返回值是第一个参数，即目标地址的指针。</p>
<p>因为<code>memcpy()</code>只是将一段内存的值，复制到另一段内存，所以不需要知道内存里面的数据是什么类型。下面是复制字符串的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> s[] = <span class="string">&quot;Goats!&quot;</span>;</span><br><span class="line">  <span class="type">char</span> t[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(t, s, <span class="keyword">sizeof</span>(s));  <span class="comment">// 拷贝7个字节，包括终止符</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, t);  <span class="comment">// &quot;Goats!&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，字符串<code>s</code>所在的内存，被拷贝到字符数组<code>t</code>所在的内存。</p>
<p><code>memcpy()</code>可以取代<code>strcpy()</code>进行字符串拷贝，而且是更好的方法，不仅更安全，速度也更快，它不检查字符串尾部的<code>\0</code>字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(s) + <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> *c = <span class="built_in">malloc</span>(len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c) &#123;</span><br><span class="line">  <span class="comment">// strcpy() 的写法</span></span><br><span class="line">  <span class="built_in">strcpy</span>(c, s);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// memcpy() 的写法</span></span><br><span class="line">  <span class="built_in">memcpy</span>(c, s, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两种写法的效果完全一样，但是<code>memcpy()</code>的写法要好于<code>strcpy()</code>。</p>
<p>使用 void 指针，也可以自定义一个复制内存的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">my_memcpy</span><span class="params">(<span class="type">void</span>* dest, <span class="type">void</span>* src, <span class="type">int</span> byte_count)</span> &#123;</span><br><span class="line">  <span class="type">char</span>* s = src;</span><br><span class="line">  <span class="type">char</span>* d = dest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (byte_count--) &#123;</span><br><span class="line">    *d++ = *s++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，不管传入的<code>dest</code>和<code>src</code>是什么类型的指针，将它们重新定义成一字节的 Char 指针，这样就可以逐字节进行复制。<code>*d++ = *s++</code>语句相当于先执行<code>*d = *s</code>（源字节的值复制给目标字节），然后各自移动到下一个字节。最后，返回复制后的<code>dest</code>指针，便于后续使用。</p>
<h3 id="memmove"><a href="#memmove" class="headerlink" title="memmove()"></a>memmove()</h3><p><code>memmove()</code>函数用于将一段内存数据复制到另一段内存。它跟<code>memcpy()</code>的主要区别是，它允许目标区域与源区域有重叠。如果发生重叠，源区域的内容会被更改；如果没有重叠，它与<code>memcpy()</code>行为相同。</p>
<p>该函数的原型定义在头文件<code>string.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">memmove</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">void</span>* dest, </span></span><br><span class="line"><span class="params">  <span class="type">void</span>* source, </span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> n</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>dest</code>是目标地址，<code>source</code>是源地址，<code>n</code>是要移动的字节数。<code>dest</code>和<code>source</code>都是 void 指针，表示可以移动任何类型的内存数据，两个内存区域可以有重叠。</p>
<p><code>memmove()</code>返回值是第一个参数，即目标地址的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">memmove(&amp;a[<span class="number">0</span>], &amp;a[<span class="number">1</span>], <span class="number">99</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>上面示例中，从数组成员<code>a[1]</code>开始的99个成员，都向前移动一个位置。</p>
<p>下面是另一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> x[] = <span class="string">&quot;Home Sweet Home&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 Sweet Home Home</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *) memmove(x, &amp;x[<span class="number">5</span>], <span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>上面示例中，从字符串<code>x</code>的5号位置开始的10个字节，就是“Sweet Home”，<code>memmove()</code>将其前移到0号位置，所以<code>x</code>就变成了“Sweet Home Home”。</p>
<h3 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp()"></a>memcmp()</h3><p><code>memcmp()</code>函数用来比较两个内存区域。它的原型定义在<code>string.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">void</span>* s1,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">void</span>* s2,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> n</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受三个参数，前两个参数是用来比较的指针，第三个参数指定比较的字节数。</p>
<p>它的返回值是一个整数。两块内存区域的每个字节以字符形式解读，按照字典顺序进行比较，如果两者相同，返回<code>0</code>；如果<code>s1</code>大于<code>s2</code>，返回大于0的整数；如果<code>s1</code>小于<code>s2</code>，返回小于0的整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span>* s2 = <span class="string">&quot;acd&quot;</span>;</span><br><span class="line"><span class="type">int</span> r = <span class="built_in">memcmp</span>(s1, s2, <span class="number">3</span>); <span class="comment">// 小于 0</span></span><br></pre></td></tr></table></figure>

<p>上面示例比较<code>s1</code>和<code>s2</code>的前三个字节，由于<code>s1</code>小于<code>s2</code>，所以<code>r</code>是一个小于0的整数，一般为-1。</p>
<p>下面是另一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[] = &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> s2[] = &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">3</span>) == <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">4</span>) == <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">7</span>) == <span class="number">0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面示例展示了，<code>memcmp()</code>可以比较内部带有字符串终止符<code>\0</code>的内存区域。</p>
<h2 id="struct-结构"><a href="#struct-结构" class="headerlink" title="struct 结构"></a>struct 结构</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>C 语言内置的数据类型，除了最基本的几种原始类型，只有数组属于复合类型，可以同时包含多个值，但是只能包含相同类型的数据，实际使用中并不够用。</p>
<p>实际使用中，主要有下面两种情况，需要更灵活强大的复合类型。</p>
<ul>
<li>复杂的物体需要使用多个变量描述，这些变量都是相关的，最好有某种机制将它们联系起来。</li>
<li>某些函数需要传入多个参数，如果一个个按照顺序传入，非常麻烦，最好能组合成一个复合结构传入。</li>
</ul>
<p>为了解决这些问题，C 语言提供了<code>struct</code>关键字，允许自定义复合数据类型，将不同类型的值组合在一起。这样不仅为编程提供方便，也有利于增强代码的可读性。C 语言没有其他语言的对象（object）和类（class）的概念，struct 结构很大程度上提供了对象和类的功能。</p>
<p>下面是<code>struct</code>自定义数据类型的一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fraction</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> numerator;</span><br><span class="line">  <span class="type">int</span> denominator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例定义了一个分数的数据类型<code>struct fraction</code>，包含两个属性<code>numerator</code>和<code>denominator</code>。</p>
<p>注意，作为一个自定义的数据类型，它的类型名要包括<code>struct</code>关键字，比如上例是<code>struct fraction</code>，单独的<code>fraction</code>没有任何意义，甚至脚本还可以另外定义名为<code>fraction</code>的变量，虽然这样很容易造成混淆。另外，<code>struct</code>语句结尾的分号不能省略，否则很容易产生错误。</p>
<p>定义了新的数据类型以后，就可以声明该类型的变量，这与声明其他类型变量的写法是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fraction</span> <span class="title">f1</span>;</span></span><br><span class="line"></span><br><span class="line">f1.numerator = <span class="number">22</span>;</span><br><span class="line">f1.denominator = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，先声明了一个<code>struct fraction</code>类型的变量<code>f1</code>，这时编译器就会为<code>f1</code>分配内存，接着就可以为<code>f1</code>的不同属性赋值。可以看到，struct 结构的属性通过点（<code>.</code>）来表示，比如<code>numerator</code>属性要写成<code>f1.numerator</code>。</p>
<p>再提醒一下，声明自定义类型的变量时，类型名前面，不要忘记加上<code>struct</code>关键字。也就是说，必须使用<code>struct fraction f1</code>声明变量，不能写成<code>fraction f1</code>。</p>
<p>除了逐一对属性赋值，也可以使用大括号，一次性对 struct 结构的所有属性赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  <span class="type">float</span> price;</span><br><span class="line">  <span class="type">int</span> speed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> <span class="title">saturn</span> =</span> &#123;<span class="string">&quot;Saturn SL/2&quot;</span>, <span class="number">16000.99</span>, <span class="number">175</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>saturn</code>是<code>struct cat</code>类型，大括号里面同时对它的三个属性赋值。如果大括号里面的值的数量，少于属性的数量，那么缺失的属性自动初始化为<code>0</code>。</p>
<p>注意，大括号里面的值的顺序，必须与 struct 类型声明时属性的顺序一致。否则，必须为每个值指定属性名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> <span class="title">saturn</span> =</span> &#123;.speed=<span class="number">172</span>, .name=<span class="string">&quot;Saturn SL/2&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，初始化的属性少于声明时的属性，这时剩下的那些属性都会初始化为<code>0</code>。</p>
<p>声明变量以后，可以修改某个属性的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> <span class="title">saturn</span> =</span> &#123;.speed=<span class="number">172</span>, .name=<span class="string">&quot;Saturn SL/2&quot;</span>&#125;;</span><br><span class="line">saturn.speed = <span class="number">168</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例将<code>speed</code>属性的值改成<code>168</code>。</p>
<p>struct 的数据类型声明语句与变量的声明语句，可以合并为一个语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="type">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="type">float</span> value;</span><br><span class="line">&#125; b1;</span><br></pre></td></tr></table></figure>

<p>上面的语句同时声明了数据类型<code>book</code>和该类型的变量<code>b1</code>。如果类型标识符<code>book</code>只用在这一个地方，后面不再用到，这里可以将类型名省略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="type">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="type">float</span> value;</span><br><span class="line">&#125; b1;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>struct</code>声明了一个匿名数据类型，然后又声明了这个类型的变量<code>b1</code>。</p>
<p>与其他变量声明语句一样，可以在声明变量的同时，对变量赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="type">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="type">float</span> value;</span><br><span class="line">&#125; b1 = &#123;<span class="string">&quot;Harry Potter&quot;</span>, <span class="string">&quot;J. K. Rowling&quot;</span>, <span class="number">10.0</span>&#125;,</span><br><span class="line">  b2 = &#123;<span class="string">&quot;Cancer Ward&quot;</span>, <span class="string">&quot;Aleksandr Solzhenitsyn&quot;</span>, <span class="number">7.85</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，在声明变量<code>b1</code>和<code>b2</code>的同时，为它们赋值。</p>
<p>下一章介绍的<code>typedef</code>命令可以为 struct 结构指定一个别名，这样使用起来更简洁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cell_phone</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> cell_no;</span><br><span class="line">  <span class="type">float</span> minutes_of_charge;</span><br><span class="line">&#125; phone;</span><br><span class="line"></span><br><span class="line">phone p = &#123;<span class="number">5551234</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>phone</code>就是<code>struct cell_phone</code>的别名。</p>
<p>指针变量也可以指向<code>struct</code>结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="type">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="type">float</span> value;</span><br><span class="line">&#125;* b1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者写成两个语句</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="type">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="type">float</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>* <span class="title">b1</span>;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>b1</code>是一个指针，指向的数据是<code>struct book</code>类型的实例。</p>
<p>struct 结构也可以作为数组成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fraction</span> <span class="title">numbers</span>[1000];</span></span><br><span class="line"></span><br><span class="line">numbers[<span class="number">0</span>].numerator = <span class="number">22</span>;</span><br><span class="line">numbers[<span class="number">0</span>].denominator = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例声明了一个有1000个成员的数组<code>numbers</code>，每个成员都是自定义类型<code>fraction</code>的实例。</p>
<p>struct 结构占用的存储空间，不是各个属性存储空间的总和。因为为了计算效率，C 语言的内存占用空间一般来说，都必须是<code>int</code>类型存储空间的倍数。如果<code>int</code>类型的存储是4字节，那么 struct 类型的存储空间就总是4的倍数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">char</span> a; <span class="type">int</span> b; &#125; s;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(s)); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，如果按照属性占据的空间相加，变量<code>s</code>的存储空间应该是5个字节。但是，struct 结构的存储空间是<code>int</code>类型的倍数，所以最后的结果是占据8个字节，<code>a</code>属性与<code>b</code>属性之间有3个字节的“空洞”。</p>
<h3 id="struct-的复制"><a href="#struct-的复制" class="headerlink" title="struct 的复制"></a>struct 的复制</h3><p>struct 变量可以使用赋值运算符（<code>=</code>），复制给另一个变量，这时会生成一个全新的副本。系统会分配一块新的内存空间，大小与原来的变量相同，把每个属性都复制过去，即原样生成了一份数据。这一点跟数组的复制不一样，务必小心。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cat</span> &#123;</span> <span class="type">char</span> name[<span class="number">30</span>]; <span class="type">short</span> age; &#125; a, b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(a.name, <span class="string">&quot;Hula&quot;</span>);</span><br><span class="line">a.age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">b = a;</span><br><span class="line">b.name[<span class="number">0</span>] = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a.name); <span class="comment">// Hula</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, b.name); <span class="comment">// Mula</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>b</code>是变量<code>a</code>的副本，两个变量的值是各自独立的，修改掉<code>b.name</code>不影响<code>a.name</code>。</p>
<p>上面这个示例是有前提的，就是 struct 结构的属性必须定义成字符数组，才能复制数据。如果稍作修改，属性定义成字符指针，结果就不一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cat</span> &#123;</span> <span class="type">char</span>* name; <span class="type">short</span> age; &#125; a, b;</span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;Hula&quot;</span>;</span><br><span class="line">a.age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>name</code>属性变成了一个字符指针，这时<code>a</code>赋值给<code>b</code>，导致<code>b.name</code>也是同样的字符指针，指向同一个地址，也就是说两个属性共享同一个地址。因为这时，struct 结构内部保存的是一个指针，而不是上一个例子的数组，这时复制的就不是字符串本身，而是它的指针。并且，这个时候也没法修改字符串，因为字符指针指向的字符串是不能修改的。</p>
<p>总结一下，赋值运算符（<code>=</code>）可以将 struct 结构每个属性的值，一模一样复制一份，拷贝给另一个 struct 变量。这一点跟数组完全不同，使用赋值运算符复制数组，不会复制数据，只会共享地址。</p>
<p>注意，这种赋值要求两个变量是同一个类型，不同类型的 struct 变量无法互相赋值。</p>
<p>另外，C 语言没有提供比较两个自定义数据结构是否相等的方法，无法用比较运算符（比如<code>==</code>和<code>!=</code>）比较两个数据结构是否相等或不等。</p>
<h3 id="struct-指针"><a href="#struct-指针" class="headerlink" title="struct 指针"></a>struct 指针</h3><p>如果将 struct 变量传入函数，函数内部得到的是一个原始值的副本。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">turtle</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  <span class="type">char</span>* species;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">happy</span><span class="params">(<span class="keyword">struct</span> turtle t)</span> &#123;</span><br><span class="line">  t.age = t.age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">turtle</span> <span class="title">myTurtle</span> =</span> &#123;<span class="string">&quot;MyTurtle&quot;</span>, <span class="string">&quot;sea turtle&quot;</span>, <span class="number">99</span>&#125;;</span><br><span class="line">  happy(myTurtle);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Age is %i\n&quot;</span>, myTurtle.age); <span class="comment">// 输出 99</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>happy()</code>传入的是一个 struct 变量<code>myTurtle</code>，函数内部有一个自增操作。但是，执行完<code>happy()</code>以后，函数外部的<code>age</code>属性值根本没变。原因就是函数内部得到的是 struct 变量的副本，改变副本影响不到函数外部的原始数据。</p>
<p>通常情况下，开发者希望传入函数的是同一份数据，函数内部修改数据以后，会反映在函数外部。而且，传入的是同一份数据，也有利于提高程序性能。这时就需要将 struct 变量的指针传入函数，通过指针来修改 struct 属性，就可以影响到函数外部。</p>
<p>struct 指针传入函数的写法如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">happy</span><span class="params">(<span class="keyword">struct</span> turtle* t)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">happy(&amp;myTurtle);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>t</code>是 struct 结构的指针，调用函数时传入的是指针。struct 类型跟数组不一样，类型标识符本身并不是指针，所以传入时，指针必须写成<code>&amp;myTurtle</code>。</p>
<p>函数内部也必须使用<code>(*t).age</code>的写法，从指针拿到 struct 结构本身。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">happy</span><span class="params">(<span class="keyword">struct</span> turtle* t)</span> &#123;</span><br><span class="line">  (*t).age = (*t).age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>(*t).age</code>不能写成<code>*t.age</code>，因为点运算符<code>.</code>的优先级高于<code>*</code>。<code>*t.age</code>这种写法会将<code>t.age</code>看成一个指针，然后取它对应的值，会出现无法预料的结果。</p>
<p>现在，重新编译执行上面的整个示例，<code>happy()</code>内部对 struct 结构的操作，就会反映到函数外部。</p>
<p><code>(*t).age</code>这样的写法很麻烦。C 语言就引入了一个新的箭头运算符（<code>-&gt;</code>），可以从 struct 指针上直接获取属性，大大增强了代码的可读性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">happy</span><span class="params">(<span class="keyword">struct</span> turtle* t)</span> &#123;</span><br><span class="line">  t-&gt;age = t-&gt;age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，对于 struct 变量名，使用点运算符（<code>.</code>）获取属性；对于 struct 变量指针，使用箭头运算符（<code>-&gt;</code>）获取属性。以变量<code>myStruct</code>为例，假设<code>ptr</code>是它的指针，那么下面三种写法是同一回事。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ptr == &amp;myStruct</span></span><br><span class="line">myStruct.prop == (*ptr).prop == ptr-&gt;prop</span><br></pre></td></tr></table></figure>

<h3 id="struct-的嵌套"><a href="#struct-的嵌套" class="headerlink" title="struct 的嵌套"></a>struct 的嵌套</h3><p>struct 结构的成员可以是另一个 struct 结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">species</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  <span class="type">int</span> kinds;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">species</span> <span class="title">breed</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fish</code>的属性<code>breed</code>是另一个 struct 结构<code>species</code>。</p>
<p>赋值的时候有多种写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">shark</span> =</span> &#123;<span class="string">&quot;shark&quot;</span>, <span class="number">9</span>, &#123;<span class="string">&quot;Selachimorpha&quot;</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">species</span> <span class="title">myBreed</span> =</span> &#123;<span class="string">&quot;Selachimorpha&quot;</span>, <span class="number">500</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">shark</span> =</span> &#123;<span class="string">&quot;shark&quot;</span>, <span class="number">9</span>, myBreed&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">shark</span> =</span> &#123;</span><br><span class="line">  .name=<span class="string">&quot;shark&quot;</span>,</span><br><span class="line">  .age=<span class="number">9</span>,</span><br><span class="line">  .breed=&#123;<span class="string">&quot;Selachimorpha&quot;</span>, <span class="number">500</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法四</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">shark</span> =</span> &#123;</span><br><span class="line">  .name=<span class="string">&quot;shark&quot;</span>,</span><br><span class="line">  .age=<span class="number">9</span>,</span><br><span class="line">  .breed.name=<span class="string">&quot;Selachimorpha&quot;</span>,</span><br><span class="line">  .breed.kinds=<span class="number">500</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Shark&#x27;s species is %s&quot;</span>, shark.breed.name);</span><br></pre></td></tr></table></figure>

<p>上面示例展示了嵌套 Struct 结构的四种赋值写法。另外，引用<code>breed</code>属性的内部属性，要使用两次点运算符（<code>shark.breed.name</code>）。</p>
<p>下面是另一个嵌套 struct 的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> first[<span class="number">50</span>];</span><br><span class="line">  <span class="type">char</span> last[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">name</span>;</span></span><br><span class="line">  <span class="type">short</span> age;</span><br><span class="line">  <span class="type">char</span> sex;</span><br><span class="line">&#125; student1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(student1.name.first, <span class="string">&quot;Harry&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(student1.name.last, <span class="string">&quot;Potter&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">myname</span> =</span> &#123;<span class="string">&quot;Harry&quot;</span>, <span class="string">&quot;Potter&quot;</span>&#125;;</span><br><span class="line">student1.name = myname;</span><br></pre></td></tr></table></figure>

<p>上面示例中，自定义类型<code>student</code>的<code>name</code>属性是另一个自定义类型，如果要引用后者的属性，就必须使用两个<code>.</code>运算符，比如<code>student1.name.first</code>。另外，对字符数组属性赋值，要使用<code>strcpy()</code>函数，不能直接赋值，因为直接改掉字符数组名的地址会报错。</p>
<p>struct 结构内部不仅可以引用其他结构，还可以自我引用，即结构内部引用当前结构。比如，链表结构的节点就可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>node</code>结构的<code>next</code>属性，就是指向另一个<code>node</code>实例的指针。下面，使用这个结构自定义一个数据链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个三个节点的列表 (11)-&gt;(22)-&gt;(33)</span></span><br><span class="line">head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line"></span><br><span class="line">head-&gt;data = <span class="number">11</span>;</span><br><span class="line">head-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line"></span><br><span class="line">head-&gt;next-&gt;data = <span class="number">22</span>;</span><br><span class="line">head-&gt;next-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line"></span><br><span class="line">head-&gt;next-&gt;next-&gt;data = <span class="number">33</span>;</span><br><span class="line">head-&gt;next-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历这个列表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">struct</span> node *cur = head; cur != <span class="literal">NULL</span>; cur = cur-&gt;next) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cur-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例是链表结构的最简单实现，通过<code>for</code>循环可以对其进行遍历。</p>
<h3 id="位字段"><a href="#位字段" class="headerlink" title="位字段"></a>位字段</h3><p>struct 还可以用来定义二进制位组成的数据结构，称为“位字段”（bit field），这对于操作底层的二进制数据非常有用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ab:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cd:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ef:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> gh:<span class="number">1</span>;</span><br><span class="line">&#125; synth;</span><br><span class="line"></span><br><span class="line">synth.ab = <span class="number">0</span>;</span><br><span class="line">synth.cd = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，每个属性后面的<code>:1</code>，表示指定这些属性只占用一个二进制位，所以这个数据结构一共是4个二进制位。</p>
<p>注意，定义二进制位时，结构内部的各个属性只能是整数类型。</p>
<p>实际存储的时候，C 语言会按照<code>int</code>类型占用的字节数，存储一个位字段结构。如果有剩余的二进制位，可以使用未命名属性，填满那些位。也可以使用宽度为0的属性，表示占满当前字节剩余的二进制位，迫使下一个属性存储在下一个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> field1 : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>        : <span class="number">2</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> field2 : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>        : <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> field3 : <span class="number">1</span>;</span><br><span class="line">&#125; stuff;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>stuff.field1</code>与<code>stuff.field2</code>之间，有一个宽度为两个二进制位的未命名属性。<code>stuff.field3</code>将存储在下一个字节。</p>
<h3 id="弹性数组成员"><a href="#弹性数组成员" class="headerlink" title="弹性数组成员"></a>弹性数组成员</h3><p>很多时候，不能事先确定数组到底有多少个成员。如果声明数组的时候，事先给出一个很大的成员数，就会很浪费空间。C 语言提供了一个解决方法，叫做弹性数组成员（flexible array member）。</p>
<p>如果不能事先确定数组成员的数量时，可以定义一个 struct 结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vstring</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">char</span> chars[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>struct vstring</code>结构有两个属性。<code>len</code>属性用来记录数组<code>chars</code>的长度，<code>chars</code>属性是一个数组，但是没有给出成员数量。</p>
<p><code>chars</code>数组到底有多少个成员，可以在为<code>vstring</code>分配内存时确定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vstring</span>* <span class="title">str</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> vstring) + n * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">str-&gt;len = n;</span><br></pre></td></tr></table></figure>

<p>上面示例中，假定<code>chars</code>数组的成员数量是<code>n</code>，只有在运行时才能知道<code>n</code>到底是多少。然后，就为<code>struct vstring</code>分配它需要的内存：它本身占用的内存长度，再加上<code>n</code>个数组成员占用的内存长度。最后，<code>len</code>属性记录一下<code>n</code>是多少。</p>
<p>这样就可以让数组<code>chars</code>有<code>n</code>个成员，不用事先确定，可以跟运行时的需要保持一致。</p>
<p>弹性数组成员有一些专门的规则。首先，弹性成员的数组，必须是 struct 结构的最后一个属性。另外，除了弹性数组成员，struct 结构必须至少还有一个其他属性。</p>
<h2 id="typedef-命令"><a href="#typedef-命令" class="headerlink" title="typedef 命令"></a>typedef 命令</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><p><code>typedef</code>命令用来为某个类型起别名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> type name;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>type</code>代表类型名，<code>name</code>代表别名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> BYTE;</span><br><span class="line"></span><br><span class="line">BYTE c = <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>typedef</code>命令为类型<code>unsign char</code>起别名<code>BYTE</code>，然后就可以使用<code>BYTE</code>声明变量。</p>
<p>typedef 可以一次指定多个别名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> antelope, bagel, mushroom;</span><br></pre></td></tr></table></figure>

<p>上面示例中，一次性为<code>int</code>类型起了三个别名。</p>
<p>typedef 可以为指针起别名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* intptr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">intptr x = &amp;a;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>intptr</code>是<code>int*</code>的别名。不过，使用的时候要小心，这样不容易看出来，变量<code>x</code>是一个指针类型。</p>
<p>typedef 也可以用来为数组类型起别名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> five_ints[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">five_ints x = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>five_ints</code>是一个数组类型，包含5个整数的</p>
<p>typedef 为函数起别名的写法如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="title function_">char</span> <span class="params">(*fp)</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型别名<code>fp</code>是一个指针，代表函数<code>signed char (*)(void)</code>。</p>
<h3 id="主要好处"><a href="#主要好处" class="headerlink" title="主要好处"></a>主要好处</h3><p><code>typedef</code>为类型起别名的好处，主要有下面几点。</p>
<p>（1）更好的代码可读性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* STRING;</span><br><span class="line"></span><br><span class="line">STRING name;</span><br></pre></td></tr></table></figure>

<p>上面示例为字符指针起别名为<code>STRING</code>，以后使用<code>STRING</code>声明变量时，就可以轻易辨别该变量是字符串。</p>
<p>（2）为 struct、union、enum 等命令定义的复杂数据结构创建别名，从而便于引用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treenode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treenode</span>* <span class="title">Tree</span>;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Tree</code>为<code>struct treenode*</code>的别名。</p>
<p>typedef 也可以与 struct 定义数据类型的命令写在一起。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">animal</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  <span class="type">int</span> leg_count, speed;</span><br><span class="line">&#125; animal;</span><br></pre></td></tr></table></figure>

<p>上面示例中，自定义数据类型时，同时使用<code>typedef</code>命令，为<code>struct animal</code>起了一个别名<code>animal</code>。</p>
<p>这种情况下，C 语言允许省略 struct 命令后面的类型名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">int</span> leg_count, speed;</span><br><span class="line">&#125; animal;</span><br></pre></td></tr></table></figure>

<p>上面示例相当于为一个匿名的数据类型起了别名<code>animal</code>。</p>
<p>（3）typedef 方便以后为变量改类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> app_float;</span><br><span class="line"></span><br><span class="line">app_float f1, f2, f3;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>f1</code>、<code>f2</code>、<code>f3</code>的类型都是<code>float</code>。如果以后需要为它们改类型，只需要修改<code>typedef</code>语句即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> app_float;</span><br></pre></td></tr></table></figure>

<p>上面命令将变量<code>f1</code>、<code>f2</code>、<code>f3</code>的类型都改为<code>long double</code>。</p>
<p>（4）可移植性</p>
<p>某一个值在不同计算机上的类型，可能是不一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">100000</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码在32位整数的计算机没有问题，但是在16位整数的计算机就会出错。</p>
<p>C 语言的解决办法，就是提供了类型别名，在不同计算机上会解释成不同类型，比如<code>int32_t</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> i = <span class="number">100000</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例将变量<code>i</code>声明成<code>int32_t</code>类型，保证它在不同计算机上都是32位宽度，移植代码时就不会出错。</p>
<p>这一类的类型别名都是用 typedef 定义的。下面是类似的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">ptrdiff_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">wchar_t</span>;</span><br></pre></td></tr></table></figure>

<p>这些整数类型别名都放在头文件<code>stdint.h</code>，不同架构的计算机只需修改这个头文件即可，而无需修改代码。</p>
<p>因此，<code>typedef</code>有助于提高代码的可移植性，使其能适配不同架构的计算机。</p>
<p>（5）简化类型声明</p>
<p>C 语言有些类型声明相当复杂，比如下面这个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> (*(*x(<span class="type">void</span>))[<span class="number">5</span>])(<span class="type">void</span>);</span><br></pre></td></tr></table></figure>

<p>typedef 可以简化复杂的类型声明，使其更容易理解。首先，最外面一层起一个类型别名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">char</span> <span class="params">(*Func)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">Func (*x(<span class="type">void</span>))[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>这个看起来还是有点复杂，就为里面一层也定义一个别名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">char</span> <span class="params">(*Func)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">typedef</span> Func Arr[<span class="number">5</span>];</span><br><span class="line">Arr* <span class="title function_">x</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码就比较容易解读了。</p>
<ul>
<li><code>x</code>是一个函数，返回一个指向 Arr 类型的指针。</li>
<li><code>Arr</code>是一个数组，有5个成员，每个成员是<code>Func</code>类型。</li>
<li><code>Func</code>是一个函数指针，指向一个无参数、返回字符值的函数。</li>
</ul>
<h2 id="Union-结构"><a href="#Union-结构" class="headerlink" title="Union 结构"></a>Union 结构</h2><p>有时需要一种数据结构，不同的场合表示不同的数据类型。比如，如果只用一种数据结构表示水果的“量”，这种结构就需要有时是整数（6个苹果），有时是浮点数（1.5公斤草莓）。</p>
<p>C 语言提供了 Union 结构，用来自定义可以灵活变更的数据结构。它内部可以包含各种属性，但同一时间只能有一个属性，因为所有属性都保存在同一个内存地址，后面写入的属性会覆盖前面的属性。这样做的最大好处是节省空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> count;</span><br><span class="line">  <span class="type">float</span> weight;</span><br><span class="line">  <span class="type">float</span> volume;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>union</code>命令定义了一个包含三个属性的数据类型<code>quantity</code>。虽然包含三个属性，但是同一时间只能取到一个属性。最后赋值的属性，就是可以取到值的那个属性。</p>
<p>使用时，声明一个该类型的变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> <span class="title">q</span>;</span></span><br><span class="line">q.count = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> <span class="title">q</span> =</span> &#123;.count=<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> <span class="title">q</span> =</span> &#123;<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码展示了为 Union 结构赋值的三种写法。最后一种写法不指定属性名，就会赋值给第一个属性。</p>
<p>执行完上面的代码以后，<code>q.count</code>可以取到值，另外两个属性取不到值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;count is %i\n&quot;</span>, q.count); <span class="comment">// count is 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;weight is %f\n&quot;</span>, q.weight); <span class="comment">// 未定义行为</span></span><br></pre></td></tr></table></figure>

<p>如果要让<code>q.weight</code>属性可以取到值，就要先为它赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q.weight = <span class="number">0.5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;weight is %f\n&quot;</span>, q.weight); <span class="comment">// weight is 0.5</span></span><br></pre></td></tr></table></figure>

<p>一旦为其他属性赋值，原先可以取到值的<code>q.count</code>属性就不再有效了。除了这一点，Union 结构的其他用法与 Struct 结构，基本上是一致的。</p>
<p>Union 结构也支持指针运算符<code>-&gt;</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> count;</span><br><span class="line">  <span class="type">float</span> weight;</span><br><span class="line">  <span class="type">float</span> volume;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> <span class="title">q</span>;</span></span><br><span class="line">q.count = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span>* <span class="title">ptr</span>;</span></span><br><span class="line">ptr = &amp;q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ptr-&gt;count); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>ptr</code>是<code>q</code>的指针，那么<code>ptr-&gt;count</code>等同于<code>q.count</code>。</p>
<p>Union 结构指针与它的属性有关，当前哪个属性能够取到值，它的指针就是对应的数据类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">float</span> b;</span><br><span class="line">&#125; x;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* foo_int_p = (<span class="type">int</span> *)&amp;x;</span><br><span class="line"><span class="type">float</span>* foo_float_p = (<span class="type">float</span> *)&amp;x;</span><br><span class="line"></span><br><span class="line">x.a = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x.a);           <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *foo_int_p);    <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line">x.b = <span class="number">3.141592</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, x.b);           <span class="comment">// 3.141592</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, *foo_float_p);  <span class="comment">// 3.141592</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>&amp;x</code>是 foo 结构的指针，它的数据类型完全由当前赋值的属性决定。</p>
<p>typedef 命令可以为 Union 数据类型起别名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> count;</span><br><span class="line">  <span class="type">float</span> weight;</span><br><span class="line">  <span class="type">float</span> volume;</span><br><span class="line">&#125; quantity;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>union</code>命令定义了一个包含三个属性的数据类型，<code>typedef</code>命令为它起别名为<code>quantity</code>。</p>
<p>Union 结构的好处，主要是节省空间。它将一段内存空间，重用于不同类型的数据。定义了三个属性，但同一时间只用到一个，使用 Union 结构就可以节省另外两个属性的空间。Union 结构占用的内存长度，等于它内部最长属性的长度。</p>
<h2 id="Enum-类型"><a href="#Enum-类型" class="headerlink" title="Enum 类型"></a>Enum 类型</h2><p>如果一种数据类型的取值只有少数几种可能，并且每种取值都有自己的含义，为了提高代码的可读性，可以将它们定义为 Enum 类型，中文名为枚举。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">colors</span> &#123;</span>RED, GREEN, BLUE&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, RED); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, GREEN);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, BLUE);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，假定程序里面需要三种颜色，就可以使用<code>enum</code>命令，把这三种颜色定义成一种枚举类型<code>colors</code>，它只有三种取值可能<code>RED</code>、<code>GREEN</code>、<code>BLUE</code>。这时，这三个名字自动成为整数常量，编译器默认将它们的值设为数字<code>0</code>、<code>1</code>、<code>2</code>。相比之下，<code>RED</code>要比<code>0</code>的可读性好了许多。</p>
<p>注意，Enum 内部的常量名，遵守标识符的命名规范，但是通常都使用大写。</p>
<p>使用时，可以将变量声明为 Enum 类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">colors</span> <span class="title">color</span>;</span></span><br></pre></td></tr></table></figure>

<p>上面代码将变量<code>color</code>声明为<code>enum colors</code>类型。这个变量的值就是常量<code>RED</code>、<code>GREEN</code>、<code>BLUE</code>之中的一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color = BLUE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, color); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码将变量<code>color</code>的值设为<code>BLUE</code>，这里<code>BLUE</code>就是一个常量，值等于<code>2</code>。</p>
<p>typedef 命令可以为 Enum 类型起别名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  SHEEP,</span><br><span class="line">  WHEAT,</span><br><span class="line">  WOOD,</span><br><span class="line">  BRICK,</span><br><span class="line">  ORE</span><br><span class="line">&#125; RESOURCE;</span><br><span class="line"></span><br><span class="line">RESOURCE r;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>RESOURCE</code>是 Enum 类型的别名。声明变量时，使用这个别名即可。</p>
<p>还有一种不常见的写法，就是声明 Enum 类型时，在同一行里面为变量赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  SHEEP,</span><br><span class="line">  WHEAT,</span><br><span class="line">  WOOD,</span><br><span class="line">  BRICK,</span><br><span class="line">  ORE</span><br><span class="line">&#125; r = BRICK, s = WOOD;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>r</code>的值是<code>3</code>，<code>s</code>的值是<code>2</code>。</p>
<p>由于 Enum 的属性会自动声明为常量，所以有时候使用 Enum 的目的，不是为了自定义一种数据类型，而是为了声明一组常量。这时就可以使用下面这种写法，比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> ONE, TWO &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, ONE, TWO);  <span class="comment">// 0 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>enum</code>是一个关键字，后面跟着一个代码块，常量就在代码内声明。<code>ONE</code>和<code>TWO</code>就是两个 Enum 常量。</p>
<p>常量之间使用逗号分隔。最后一个常量后面的尾逗号，可以省略，也可以保留。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> ONE, TWO, &#125;;</span><br></pre></td></tr></table></figure>

<p>由于Enum 会自动编号，因此可以不必为常量赋值。C 语言会自动从0开始递增，为常量赋值。但是，C 语言也允许为 ENUM 常量指定值，不过只能指定为整数，不能是其他类型。因此，任何可以使用整数的场合，都可以使用 Enum 常量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> ONE = <span class="number">1</span>, TWO = <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, ONE, TWO);  <span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>

<p>Enum 常量可以是不连续的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> X = <span class="number">2</span>, Y = <span class="number">18</span>, Z = <span class="number">-2</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>Enum 常量也可以是同一个值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> X = <span class="number">2</span>, Y = <span class="number">2</span>, Z = <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>如果一组常量之中，有些指定了值，有些没有指定。那么，没有指定值的常量会从上一个指定了值的常量，开始自动递增赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  A,    <span class="comment">// 0</span></span><br><span class="line">  B,    <span class="comment">// 1</span></span><br><span class="line">  C = <span class="number">4</span>,  <span class="comment">// 4</span></span><br><span class="line">  D,    <span class="comment">// 5</span></span><br><span class="line">  E,    <span class="comment">// 6</span></span><br><span class="line">  F = <span class="number">3</span>   <span class="comment">// 3</span></span><br><span class="line">  G,    <span class="comment">// 4</span></span><br><span class="line">  H     <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Enum 的作用域与变量相同。如果是在顶层声明，那么在整个文件内都有效；如果是在代码块内部声明，则只对该代码块有效。如果与使用<code>int</code>声明的常量相比，Enum 的好处是更清晰地表示代码意图。</p>
<h2 id="预处理器（Preprocessor）"><a href="#预处理器（Preprocessor）" class="headerlink" title="预处理器（Preprocessor）"></a>预处理器（Preprocessor）</h2><h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><p>C 语言编译器在编译程序之前，会先使用预处理器（preprocessor）处理代码。</p>
<p>预处理器首先会清理代码，进行删除注释、多行的语句合成一个逻辑行等等。然后，执行<code>#</code>开头的预处理指令。本章介绍 C 语言的预处理指令。</p>
<p>预处理指令可以出现在程序的任何地方，但是习惯上，往往放在代码的开头部分。</p>
<p>每个预处理指令都以<code>#</code>开头，放在一行的行首，指令前面可以有空白字符（比如空格或制表符）。<code>#</code>和指令的其余部分之间也可以有空格，但是为了兼容老的编译器，一般不留空格。</p>
<p>所有预处理指令都是一行的，除非在行尾使用反斜杠，将其折行。指令结尾处不需要分号。</p>
<h3 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h3><p><code>#define</code>是最常见的预处理指令，用来将指定的词替换成另一个词。它的参数分成两个部分，第一个参数就是要被替换的部分，其余参数是替换后的内容。每条替换规则，称为一个宏（macro）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>#define</code>指定将源码里面的<code>MAX</code>，全部替换成<code>100</code>。<code>MAX</code>就称为一个宏。</p>
<p>宏的名称不允许有空格，而且必须遵守 C 语言的变量命名规则，只能使用字母、数字与下划线（<code>_</code>），且首字符不能是数字。</p>
<p>宏是原样替换，指定什么内容，就一模一样替换成什么内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HELLO <span class="string">&quot;Hello, world&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 printf(&quot;%s&quot;, &quot;Hello, world&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, HELLO);</span><br></pre></td></tr></table></figure>

<p>上面示例中，宏<code>HELLO</code>会被原样替换成<code>&quot;Hello, world&quot;</code>。</p>
<p><code>#define</code>指令可以出现在源码文件的任何地方，从指令出现的地方到该文件末尾都有效。习惯上，会将<code>#define</code>放在源码文件的头部。它的主要好处是，会使得程序的可读性更好，也更容易修改。</p>
<p><code>#define</code>指令从<code>#</code>开始，一直到换行符为止。如果整条指令过长，可以在折行处使用反斜杠，延续到下一行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OW <span class="string">&quot;C programming language is invented \</span></span></span><br><span class="line"><span class="string"><span class="meta">in 1970s.&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，第一行结尾的反斜杠将<code>#define</code>指令拆成两行。</p>
<p><code>#define</code>允许多重替换，即一个宏可以包含另一个宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TWO 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOUR TWO*TWO</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>FOUR</code>会被替换成<code>2*2</code>。</p>
<p>注意，如果宏出现在字符串里面（即出现在双引号中），或者是其他标识符的一部分，就会失效，并不会发生替换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TWO 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 TWO</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;TWO\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 22</span></span><br><span class="line"><span class="type">const</span> TWOs = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, TWOs);</span><br></pre></td></tr></table></figure>

<p>上面示例中，双引号里面的<code>TWO</code>，以及标识符<code>TWOs</code>，都不会被替换。</p>
<p>同名的宏可以重复定义，只要定义是相同的，就没有问题。如果定义不同，就会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOO hello</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOO hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAR hello</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAR world</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，宏<code>FOO</code>没有变化，所以可以重复定义，宏<code>BAR</code>发生了变化，就报错了。</p>
<h3 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a>带参数的宏</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>宏的强大之处在于，它的名称后面可以使用括号，指定接受一个或多个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) X*X</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，宏<code>SQUARE</code>可以接受一个参数<code>X</code>，替换成<code>X*X</code>。</p>
<p>注意，宏的名称与左边圆括号之间，不能有空格。</p>
<p>这个宏的用法如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换成 z = 2*2;</span></span><br><span class="line">z = SQUARE(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>这种写法很像函数，但又不是函数，而是完全原样的替换，会跟函数有不一样的行为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) X*X</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出19</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, SQUARE(<span class="number">3</span> + <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>SQUARE(3 + 4)</code>如果是函数，输出的应该是49（<code>7*7</code>）；宏是原样替换，所以替换成<code>3 + 4*3 + 4</code>，最后输出19。</p>
<p>可以看到，原样替换可能导致意料之外的行为。解决办法就是在定义宏的时候，尽量多使用圆括号，这样可以避免很多意外。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) ((X) * (X))</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>SQUARE(X)</code>替换后的形式，有两层圆括号，就可以避免很多错误的发生。</p>
<p>宏的参数也可以是空的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> getchar() getc(stdin)</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，宏<code>getchar()</code>的参数就是空的。这种情况其实可以省略圆括号，但是加上了，会让它看上去更像函数。</p>
<p>一般来说，带参数的宏都是一行的。下面是两个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x)&gt;(y)?(x):(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_EVEN(n) ((n)%2==0)</span></span><br></pre></td></tr></table></figure>

<p>如果宏的长度过长，可以使用反斜杠（<code>\</code>）折行，将宏写成多行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_NUMS_TO_PRODUCT(a, b) &#123; \</span></span><br><span class="line"><span class="meta">  int product = (a) * (b); \</span></span><br><span class="line"><span class="meta">  for (int i = 0; i &lt; product; i++) &#123; \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;%d\n&quot;</span>, i); \</span></span><br><span class="line"><span class="meta">  &#125; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，替换文本放在大括号里面，这是为了创造一个块作用域，避免宏内部的变量污染外部。</p>
<p>带参数的宏也可以嵌套，一个宏里面包含另一个宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> QUADP(a, b, c) ((-(b) + sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUADM(a, b, c) ((-(b) - sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUAD(a, b, c) QUADP(a, b, c), QUADM(a, b, c)</span></span><br></pre></td></tr></table></figure>

<p>上面示例是一元二次方程组求解的宏，由于存在正负两个解，所以宏<code>QUAD</code>先替换成另外两个宏<code>QUADP</code>和<code>QUADM</code>，后者再各自替换成一个解。</p>
<p>那么，什么时候使用带参数的宏，什么时候使用函数呢？</p>
<p>一般来说，应该首先使用函数，它的功能更强、更容易理解。宏有时候会产生意想不到的替换结果，而且往往只能写成一行，除非对换行符进行转义，但是可读性就变得很差。</p>
<p>宏的优点是相对简单，本质上是字符串替换，不涉及数据类型，不像函数必须定义数据类型。而且，宏将每一处都替换成实际的代码，省掉了函数调用的开销，所以性能会好一些。另外，以前的代码大量使用宏，尤其是简单的数学运算，为了读懂前人的代码，需要对它有所了解。</p>
<h4 id="运算符，-运算符"><a href="#运算符，-运算符" class="headerlink" title="#运算符，##运算符"></a><code>#</code>运算符，<code>##</code>运算符</h4><p>由于宏不涉及数据类型，所以替换以后可能为各种类型的值。如果希望替换后的值为字符串，可以在替换文本的参数前面加上<code>#</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR(x) #x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 printf(&quot;%s\n&quot;, &quot;3.14159&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, STR(<span class="number">3.14159</span>));</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>STR(3.14159)</code>会被替换成<code>3.14159</code>。如果<code>x</code>前面没有<code>#</code>，这会被解释成一个浮点数，有了<code>#</code>以后，就会被转换成字符串。</p>
<p>下面是另一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XNAME(n) <span class="string">&quot;x&quot;</span>#n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 x4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, XNAME(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>#n</code>指定参数输出为字符串，再跟前面的字符串结合，最终输出为<code>&quot;x4&quot;</code>。如果不加<code>#</code>，这里实现起来就很麻烦了。</p>
<p>如果替换后的文本里面，参数需要跟其他标识符连在一起，组成一个新的标识符，可以使用<code>##</code>运算符。它起到粘合作用，将参数“嵌入”一个标识符之中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MK_ID(n) i##n</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>n</code>是宏<code>MK_ID</code>的参数，这个参数需要跟标识符<code>i</code>粘合在一起，这时<code>i</code>和<code>n</code>之间就要使用<code>##</code>运算符。下面是这个宏的用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MK_ID</span><span class="params">(<span class="number">1</span>)</span>, <span class="title function_">MK_ID</span><span class="params">(<span class="number">2</span>)</span>, <span class="title function_">MK_ID</span><span class="params">(<span class="number">3</span>)</span>;</span><br><span class="line"><span class="comment">// 替换成</span></span><br><span class="line"><span class="type">int</span> i1, i2, i3;</span><br></pre></td></tr></table></figure>

<p>上面示例中，替换后的文本<code>i1</code>、<code>i2</code>、<code>i3</code>是三个标识符，参数<code>n</code>是标识符的一部分。从这个例子可以看到，<code>##</code>运算符的一个主要用途是批量生成变量名和标识符。</p>
<h4 id="不定参数的宏"><a href="#不定参数的宏" class="headerlink" title="不定参数的宏"></a>不定参数的宏</h4><p>宏的参数还可以是不定数量的（即不确定有多少个参数），<code>...</code>表示剩余的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> X(a, b, ...) (10*(a) + 20*(b)), __VA_ARGS__</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>X(a, b, ...)</code>表示<code>X()</code>至少有两个参数，多余的参数使用<code>...</code>表示。在替换文本中，<code>__VA_ARGS__</code>代表多余的参数（每个参数之间使用逗号分隔）。下面是用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3.14</span>, <span class="string">&quot;Hi!&quot;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="comment">// 替换成</span></span><br><span class="line">(<span class="number">10</span>*(<span class="number">5</span>) + <span class="number">20</span>*(<span class="number">4</span>)), <span class="number">3.14</span>, <span class="string">&quot;Hi!&quot;</span>, <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>...</code>只能替代宏的尾部参数，不能写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRONG(X, ..., Y) #X #__CA_ARGS__ #Y</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>...</code>替代中间部分的参数，这是不允许的，会报错。</p>
<p><code>__VA_ARGS__</code>前面加上一个<code>#</code>号，可以让输出变成一个字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> X(...) #__VA_ARGS__</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, X(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));  <span class="comment">// Prints &quot;1, 2, 3&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="undef"><a href="#undef" class="headerlink" title="#undef"></a>#undef</h3><p><code>#undef</code>指令用来取消已经使用<code>#define</code>定义的宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIMIT 400</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> LIMIT</span></span><br></pre></td></tr></table></figure>

<p>上面示例的<code>undef</code>指令取消已经定义的宏<code>LIMIT</code>，后面就可以重新用 LIMIT 定义一个宏。</p>
<p>有时候想重新定义一个宏，但不确定是否以前定义过，就可以先用<code>#undef</code>取消，然后再定义。因为同名的宏如果两次定义不一样，会报错，而<code>#undef</code>的参数如果是不存在的宏，并不会报错。</p>
<p>GCC 的<code>-U</code>选项可以在命令行取消宏的定义，相当于<code>#undef</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -ULIMIT foo.c</span><br></pre></td></tr></table></figure>

<p>上面示例中的<code>-U</code>参数，取消了宏<code>LIMIT</code>，相当于源文件里面的<code>#undef LIMIT</code>。</p>
<h3 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h3><p><code>#include</code>指令用于编译时将其他源码文件，加载进入当前文件。它有两种形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式一</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;foo.h&gt;</span> <span class="comment">// 加载系统提供的文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 形式二</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo.h&quot;</span> <span class="comment">// 加载用户提供的文件</span></span></span><br></pre></td></tr></table></figure>

<p>形式一，文件名写在尖括号里面，表示该文件是系统提供的，通常是标准库的库文件，不需要写路径。因为编译器会到系统指定的安装目录里面，去寻找这些文件。</p>
<p>形式二，文件名写在双引号里面，表示该文件由用户提供，具体的路径取决于编译器的设置，可能是当前目录，也可能是项目的工作目录。如果所要包含的文件在其他位置，就需要指定路径，下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/usr/local/lib/foo.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>GCC 编译器的<code>-I</code>参数，也可以用来指定<code>include</code>命令中用户文件的加载路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Iinclude/ -o code code.c</span><br></pre></td></tr></table></figure>

<p>上面命令中，<code>-Iinclude/</code>指定从当前目录的<code>include</code>子目录里面，加载用户自己的文件。</p>
<p><code>#include</code>最常见的用途，就是用来加载包含函数原型的头文件（后缀名为<code>.h</code>），参见《多文件编译》一章。多个<code>#include</code>指令的顺序无关紧要，多次包含同一个头文件也是合法的。</p>
<h3 id="if…-endif"><a href="#if…-endif" class="headerlink" title="#if…#endif"></a>#if…#endif</h3><p><code>#if...#endif</code>指令用于预处理器的条件判断，满足条件时，内部的行会被编译，否则就被编译器忽略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415</span>; <span class="comment">// 不会执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>#if</code>后面的<code>0</code>，表示判断条件不成立。所以，内部的变量定义语句会被编译器忽略。<code>#if 0</code>这种写法常用来当作注释使用，不需要的代码就放在<code>#if 0</code>里面。</p>
<p><code>#if</code>后面的判断条件，通常是一个表达式。如果表达式的值不等于<code>0</code>，就表示判断条件为真，编译内部的语句；如果表达式的值等于0，表示判断条件为伪，则忽略内部的语句。</p>
<p><code>#if...#endif</code>之间还可以加入<code>#else</code>指令，用于指定判断条件不成立时，需要编译的语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FOO 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FOO</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;defined\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;not defined\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，宏<code>FOO</code>如果定义过，会被替换成<code>1</code>，从而输出<code>defined</code>，否则输出<code>not defined</code>。</p>
<p>如果有多个判断条件，还可以加入<code>#elif</code>命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> HAPPY_FACTOR == 0</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m not happy!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> HAPPY_FACTOR == 1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m just regular\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m extra happy!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，通过<code>#elif</code>指定了第二重判断。注意，<code>#elif</code>的位置必须在<code>#else</code>之前。如果多个判断条件皆不满足，则执行<code>#else</code>的部分。</p>
<p>没有定义过的宏，等同于<code>0</code>。因此如果<code>UNDEFINED</code>是一个没有定义过的宏，那么<code>#if UNDEFINED</code>为伪，而<code>#if !UNDEFINED</code>为真。</p>
<p><code>#if</code>的常见应用就是打开（或关闭）调试模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;value of i : %d\n&quot;</span>, i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;value of j : %d\n&quot;</span>, j);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，通过将<code>DEBUG</code>设为<code>1</code>，就打开了调试模式，可以输出调试信息。</p>
<p>GCC 的<code>-D</code>参数可以在编译时指定宏的值，因此可以很方便地打开调试开关。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -DDEBUG=1 foo.c</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>-D</code>参数指定宏<code>DEBUG</code>为<code>1</code>，相当于在代码中指定<code>#define DEBUG 1</code>。</p>
<h3 id="ifdef…-endif"><a href="#ifdef…-endif" class="headerlink" title="#ifdef…#endif"></a>#ifdef…#endif</h3><p><code>#ifdef...#endif</code>指令用于判断某个宏是否定义过。</p>
<p>有时源码文件可能会重复加载某个库，为了避免这种情况，可以在库文件里使用<code>#define</code>定义一个空的宏。通过这个宏，判断库文件是否被加载了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXTRA_HAPPY</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>EXTRA_HAPPY</code>就是一个空的宏。</p>
<p>然后，源码文件使用<code>#ifdef...#endif</code>检查这个宏是否定义过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EXTRA_HAPPY</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m extra happy!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>#ifdef</code>检查宏<code>EXTRA_HAPPY</code>是否定义过。如果已经存在，表示加载过库文件，就会打印一行提示。</p>
<p><code>#ifdef</code>可以与<code>#else</code>指令配合使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EXTRA_HAPPY</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m extra happy!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m just regular\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，如果宏<code>EXTRA_HAPPY</code>没有定义过，就会执行<code>#else</code>的部分。</p>
<p><code>#ifdef...#else...#endif</code>可以用来实现条件加载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAVIS</span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo.h&quot;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> STABLES 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bar.h&quot;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> STABLES 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，通过判断宏<code>MAVIS</code>是否定义过，实现加载不同的头文件。</p>
<h3 id="defined-运算符"><a href="#defined-运算符" class="headerlink" title="defined 运算符"></a>defined 运算符</h3><p>上一节的<code>#ifdef</code>指令，等同于<code>#if defined</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FOO</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined FOO</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>defined</code>是一个预处理运算符，如果它的参数是一个定义过的宏，就会返回1，否则返回0。</p>
<p>使用这种语法，可以完成多重判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined FOO</span></span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined BAR</span></span><br><span class="line">  x = <span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这个运算符的一个应用，就是对于不同架构的系统，加载不同的头文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined IBMPC</span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ibmpc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined MAC</span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mac.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;general.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，不同架构的系统需要定义对应的宏。代码根据不同的宏，加载对应的头文件。</p>
<h3 id="ifndef…-endif"><a href="#ifndef…-endif" class="headerlink" title="#ifndef…#endif"></a>#ifndef…#endif</h3><p><code>#ifndef...#endif</code>指令跟<code>#ifdef...#endif</code>正好相反。它用来判断，如果某个宏没有被定义过，则执行指定的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EXTRA_HAPPY</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m extra happy!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXTRA_HAPPY</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m just regular\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，针对宏<code>EXTRA_HAPPY</code>是否被定义过，<code>#ifdef</code>和<code>#ifndef</code>分别指定了两种情况各自需要编译的代码。</p>
<p><code>#ifndef</code>常用于防止重复加载。举例来说，为了防止头文件<code>myheader.h</code>被重复加载，可以把它放在<code>#ifndef...#endif</code>里面加载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYHEADER_H</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> MYHEADER_H</span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，宏<code>MYHEADER_H</code>对应文件名<code>myheader.h</code>的大写。只要<code>#ifndef</code>发现这个宏没有被定义过，就说明该头文件没有加载过，从而加载内部的代码，并会定义宏<code>MYHEADER_H</code>，防止被再次加载。</p>
<p><code>#ifndef</code>等同于<code>#if !defined</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FOO</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined FOO</span></span><br></pre></td></tr></table></figure>

<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>C 语言提供一些预定义的宏，可以直接使用。</p>
<ul>
<li><code>__DATE__</code>：编译日期，格式为“Mmm dd yyyy”的字符串（比如 Nov 23 2021）。</li>
<li><code>__TIME__</code>：编译时间，格式为“hh:mm:ss”。</li>
<li><code>__FILE__</code>：当前文件名。</li>
<li><code>__LINE__</code>：当前行号。</li>
<li><code>__func__</code>：当前正在执行的函数名。该预定义宏必须在函数作用域使用。</li>
<li><code>__STDC__</code>：如果被设为1，表示当前编译器遵循 C 标准。</li>
<li><code>__STDC_HOSTED__</code>：如果被设为1，表示当前编译器可以提供完整的标准库；否则被设为0（嵌入式系统的标准库常常是不完整的）。</li>
<li><code>__STDC_VERSION__</code>：编译所使用的 C 语言版本，是一个格式为<code>yyyymmL</code>的长整数，C99 版本为“199901L”，C11 版本为“201112L”，C17 版本为“201710L”。</li>
</ul>
<p>下面示例打印这些预定义宏的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This function: %s\n&quot;</span>, __func__);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This file: %s\n&quot;</span>, __FILE__);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This line: %d\n&quot;</span>, __LINE__);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Compiled on: %s %s\n&quot;</span>, __DATE__, __TIME__);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;C Version: %ld\n&quot;</span>, __STDC_VERSION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出如下</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This function: main</span></span><br><span class="line"><span class="comment">This file: test.c</span></span><br><span class="line"><span class="comment">This line: 7</span></span><br><span class="line"><span class="comment">Compiled on: Mar 29 2021 19:19:37</span></span><br><span class="line"><span class="comment">C Version: 201710</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="line"><a href="#line" class="headerlink" title="#line"></a>#line</h3><p><code>#line</code>指令用于覆盖预定义宏<code>__LINE__</code>，将其改为自定义的行号。后面的行将从<code>__LINE__</code>的新值开始计数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将下一行的行号重置为 300</span></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 300</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，紧跟在<code>#line 300</code>后面一行的行号，将被改成300，其后的行会在300的基础上递增编号。</p>
<p><code>#line</code>还可以改掉预定义宏<code>__FILE__</code>，将其改为自定义的文件名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">line</span> 300 <span class="string">&quot;newfilename&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，下一行的行号重置为<code>300</code>，文件名重置为<code>newfilename</code>。</p>
<h3 id="error"><a href="#error" class="headerlink" title="#error"></a>#error</h3><p><code>#error</code>指令用于让预处理器抛出一个错误，终止编译。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STDC_VERSION__ != 201112L</span></span><br><span class="line">  <span class="meta">#<span class="keyword">error</span> Not C11</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例指定，如果编译器不使用 C11 标准，就中止编译。GCC 编译器会像下面这样报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -std=c99 newish.c</span><br><span class="line">newish.c:14:2: error: <span class="comment">#error Not C11</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，GCC 使用 C99 标准编译，就报错了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> INT_MAX &lt; 100000</span></span><br><span class="line">  <span class="meta">#<span class="keyword">error</span> int type is too small</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，编译器一旦发现<code>INT</code>类型的最大值小于<code>100,000</code>，就会停止编译。</p>
<p><code>#error</code>指令也可以用在<code>#if...#elif...#else</code>的部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined WIN32</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined MAC_OS</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined LINUX</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">error</span> NOT support the operating system</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h3><p><code>#pragma</code>指令用来修改编译器属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 C99 标准</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> c9x on</span></span><br></pre></td></tr></table></figure>

<p>上面示例让编译器以 C99 标准进行编译。</p>
<h2 id="I-x2F-O-函数"><a href="#I-x2F-O-函数" class="headerlink" title="I&#x2F;O 函数"></a>I&#x2F;O 函数</h2><p>C 语言提供了一些函数，用于与外部设备通信，称为输入输出函数，简称 I&#x2F;O 函数。输入（import）指的是获取外部数据，输出（export）指的是向外部传递数据。</p>
<h3 id="缓存和字节流"><a href="#缓存和字节流" class="headerlink" title="缓存和字节流"></a>缓存和字节流</h3><p>严格地说，输入输出函数并不是直接与外部设备通信，而是通过缓存（buffer）进行间接通信。这个小节介绍缓存是什么。</p>
<p>普通文件一般都保存在磁盘上面，跟 CPU 相比，磁盘读取或写入数据是一个很慢的操作。所以，程序直接读写磁盘是不可行的，可能每执行一行命令，都必须等半天。C 语言的解决方案，就是只要打开一个文件，就在内存里面为这个文件设置一个缓存区。</p>
<p>程序向文件写入数据时，程序先把数据放入缓存，等到缓存满了，再把里面的数据会一次性写入磁盘文件。这时，缓存区就空了，程序再把新的数据放入缓存，重复整个过程。</p>
<p>程序从文件读取数据时，文件先把一部分数据放到缓存里面，然后程序从缓存获取数据，等到缓存空了，磁盘文件再把新的数据放入缓存，重复整个过程。</p>
<p>内存的读写速度比磁盘快得多，缓存的设计减少了读写磁盘的次数，大大提高了程序的执行效率。另外，一次性移动大块数据，要比多次移动小块数据快得多。</p>
<p>这种读写模式，对于程序来说，就有点像水流（stream），不是一次性读取或写入所有数据，而是一个持续不断的过程。先操作一部分数据，等到缓存吞吐完这部分数据，再操作下一部分数据。这个过程就叫做字节流操作。</p>
<p>由于缓存读完就空了，所以字节流读取都是只能读一次，第二次就读不到了。这跟读取文件很不一样。</p>
<p>C 语言的输入输出函数，凡是涉及读写文件，都是属于字节流操作。输入函数从文件获取数据，操作的是输入流；输出函数向文件写入数据，操作的是输出流。</p>
<h3 id="printf-1"><a href="#printf-1" class="headerlink" title="printf()"></a>printf()</h3><p><code>printf()</code>是最常用的输出函数，用于屏幕输出，原型定义在头文件<code>stdio.h</code>，详见《基本语法》一章。</p>
<h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf()"></a>scanf()</h3><h4 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>scanf()</code>函数用于读取用户的键盘输入。程序运行到这个语句时，会停下来，等待用户从键盘输入。用户输入数据、按下回车键后，<code>scanf()</code>就会处理用户的输入，将其存入变量。它的原型定义在头文件<code>stdio.h</code>。</p>
<p><code>scanf()</code>的语法跟<code>printf()</code>类似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<p>它的第一个参数是一个格式字符串，里面会放置占位符（与<code>printf()</code>的占位符基本一致），告诉编译器如何解读用户的输入，需要提取的数据是什么类型。这是因为 C 语言的数据都是有类型的，<code>scanf()</code>必须提前知道用户输入的数据类型，才能处理数据。它的其余参数就是存放用户输入的变量，格式字符串里面有多少个占位符，就有多少个变量。</p>
<p>上面示例中，<code>scanf()</code>的第一个参数<code>%d</code>，表示用户输入的应该是一个整数。<code>%d</code>就是一个占位符，<code>%</code>是占位符的标志，<code>d</code>表示整数。第二个参数<code>&amp;i</code>表示，将用户从键盘输入的整数存入变量<code>i</code>。</p>
<p>注意，变量前面必须加上<code>&amp;</code>运算符（指针变量除外），因为<code>scanf()</code>传递的不是值，而是地址，即将变量<code>i</code>的地址指向用户输入的值。如果这里的变量是指针变量（比如字符串变量），那就不用加<code>&amp;</code>运算符。</p>
<p>下面是一次将键盘输入读入多个变量的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%f%f&quot;</span>, &amp;i, &amp;j, &amp;x, &amp;y);</span><br></pre></td></tr></table></figure>

<p>上面示例中，格式字符串<code>%d%d%f%f</code>，表示用户输入的前两个是整数，后两个是浮点数，比如<code>1 -20 3.4 -4.0e3</code>。这四个值依次放入<code>i</code>、<code>j</code>、<code>x</code>、<code>y</code>四个变量。</p>
<p><code>scanf()</code>处理数值占位符时，会自动过滤空白字符，包括空格、制表符、换行符等。所以，用户输入的数据之间，有一个或多个空格不影响<code>scanf()</code>解读数据。另外，用户使用回车键，将输入分成几行，也不影响解读。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">-20</span></span><br><span class="line"><span class="number">3.4</span></span><br><span class="line"><span class="number">-4.0e3</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，用户分成四行输入，得到的结果与一行输入是完全一样的。每次按下回车键以后，<code>scanf()</code>就会开始解读，如果第一行匹配第一个占位符，那么下次按下回车键时，就会从第二个占位符开始解读。</p>
<p><code>scanf()</code>处理用户输入的原理是，用户的输入先放入缓存，等到按下回车键后，按照占位符对缓存进行解读。解读用户输入时，会从上一次解读遗留的第一个字符开始，直到读完缓存，或者遇到第一个不符合条件的字符为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">float</span> y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户输入 &quot;    -13.45e12## 0&quot;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;y);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>scanf()</code>读取用户输入时，<code>%d</code>占位符会忽略起首的空格，从<code>-</code>处开始获取数据，读取到<code>-13</code>停下来，因为后面的<code>.</code>不属于整数的有效字符。这就是说，占位符<code>%d</code>会读到<code>-13</code>。</p>
<p>第二次调用<code>scanf()</code>时，就会从上一次停止解读的地方，继续往下读取。这一次读取的首字符是<code>.</code>，由于对应的占位符是<code>%f</code>，会读取到<code>.45e12</code>，这是采用科学计数法的浮点数格式。后面的<code>#</code>不属于浮点数的有效字符，所以会停在这里。</p>
<p>由于<code>scanf()</code>可以连续处理多个占位符，所以上面的例子也可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%f&quot;</span>, &amp;x, &amp;y);</span><br></pre></td></tr></table></figure>

<p><code>scanf()</code>的返回值是一个整数，表示成功读取的变量个数。如果没有读取任何项，或者匹配失败，则返回<code>0</code>。如果读取到文件结尾，则返回常量 EOF。</p>
<h4 id="占位符-1"><a href="#占位符-1" class="headerlink" title="占位符"></a>占位符</h4><p><code>scanf()</code>常用的占位符如下，与<code>printf()</code>的占位符基本一致。</p>
<ul>
<li><code>%c</code>：字符。</li>
<li><code>%d</code>：整数。</li>
<li><code>%f</code>：<code>float</code>类型浮点数。</li>
<li><code>%lf</code>：<code>double</code>类型浮点数。</li>
<li><code>%Lf</code>：<code>long double</code>类型浮点数。</li>
<li><code>%s</code>：字符串。</li>
<li><code>%[]</code>：在方括号中指定一组匹配的字符（比如<code>%[0-9]</code>），遇到不在集合之中的字符，匹配将会停止。</li>
</ul>
<p>上面所有占位符之中，除了<code>%c</code>以外，都会自动忽略起首的空白字符。<code>%c</code>不忽略空白字符，总是返回当前第一个字符，无论该字符是否为空格。如果要强制跳过字符前的空白字符，可以写成<code>scanf(&quot; %c&quot;, &amp;ch)</code>，即<code>%c</code>前加上一个空格，表示跳过零个或多个空白字符。</p>
<p>下面要特别说一下占位符<code>%s</code>，它其实不能简单地等同于字符串。它的规则是，从当前第一个非空白字符开始读起，直到遇到空白字符（即空格、换行符、制表符等）为止。因为<code>%s</code>不会包含空白字符，所以无法用来读取多个单词，除非多个<code>%s</code>一起使用。这也意味着，<code>scanf()</code>不适合读取可能包含空格的字符串，比如书名或歌曲名。另外，<code>scanf()</code>遇到<code>%s</code>占位符，会在字符串变量末尾存储一个空字符<code>\0</code>。</p>
<p><code>scanf()</code>将字符串读入字符数组时，不会检测字符串是否超过了数组长度。所以，储存字符串时，很可能会超过数组的边界，导致预想不到的结果。为了防止这种情况，使用<code>%s</code>占位符时，应该指定读入字符串的最长长度，即写成<code>%[m]s</code>，其中的<code>[m]</code>是一个整数，表示读取字符串的最大长度，后面的字符将被丢弃。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">11</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%10s&quot;</span>, name);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>name</code>是一个长度为11的字符数组，<code>scanf()</code>的占位符<code>%10s</code>表示最多读取用户输入的10个字符，后面的字符将被丢弃，这样就不会有数组溢出的风险了。</p>
<h4 id="赋值忽略符"><a href="#赋值忽略符" class="headerlink" title="赋值忽略符"></a>赋值忽略符</h4><p>有时，用户的输入可能不符合预定的格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d-%d-%d&quot;</span>, &amp;year, &amp;month, &amp;day);</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果用户输入<code>2020-01-01</code>，就会正确解读出年、月、日。问题是用户可能输入其他格式，比如<code>2020/01/01</code>，这种情况下，<code>scanf()</code>解析数据就会失败。</p>
<p>为了避免这种情况，<code>scanf()</code>提供了一个赋值忽略符（assignment suppression character）<code>*</code>。只要把<code>*</code>加在任何占位符的百分号后面，该占位符就不会返回值，解析后将被丢弃。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%*c%d%*c%d&quot;</span>, &amp;year, &amp;month, &amp;day);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>%*c</code>就是在占位符的百分号后面，加入了赋值忽略符<code>*</code>，表示这个占位符没有对应的变量，解读后不必返回。</p>
<h3 id="sscanf"><a href="#sscanf" class="headerlink" title="sscanf()"></a>sscanf()</h3><p><code>sscanf()</code>函数与<code>scanf()</code>很类似，不同之处是<code>sscanf()</code>从字符串里面，而不是从用户输入获取数据。它的原型定义在头文件<code>stdio.h</code>里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p><code>sscanf()</code>的第一个参数是一个字符串指针，用来从其中获取数据。其他参数都与<code>scanf()</code>相同。</p>
<p><code>sscanf()</code>主要用来处理其他输入函数读入的字符串，从其中提取数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;j);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fgets()</code>先从标准输入获取了一行数据（<code>fgets()</code>的介绍详见下一章），存入字符数组<code>str</code>。然后，<code>sscanf()</code>再从字符串<code>str</code>里面提取两个整数，放入变量<code>i</code>和<code>j</code>。</p>
<p><code>sscanf()</code>的一个好处是，它的数据来源不是流数据，所以可以反复使用，不像<code>scanf()</code>的数据来源是流数据，只能读取一次。</p>
<p><code>sscanf()</code>的返回值是成功赋值的变量的数量，如果提取失败，返回常量 EOF。</p>
<h3 id="getchar-，putchar"><a href="#getchar-，putchar" class="headerlink" title="getchar()，putchar()"></a>getchar()，putchar()</h3><p><strong>（1）getchar()</strong></p>
<p><code>getchar()</code>函数返回用户从键盘输入的一个字符，使用时不带有任何参数。程序运行到这个命令就会暂停，等待用户从键盘输入，等同于使用<code>scanf()</code>方法读取一个字符。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line">ch = getchar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br></pre></td></tr></table></figure>

<p><code>getchar()</code>不会忽略起首的空白字符，总是返回当前读取的第一个字符，无论是否为空格。如果读取失败，返回常量 EOF，由于 EOF 通常是<code>-1</code>，所以返回值的类型要设为 int，而不是 char。</p>
<p>由于<code>getchar()</code>返回读取的字符，所以可以用在循环条件之中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>

<p>上面示例中，只有读到的字符等于换行符（<code>\n</code>），才会退出循环，常用来跳过某行。<code>while</code>循环的循环体没有任何语句，表示对该行不执行任何操作。</p>
<p>下面的例子是计算某一行的字符长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  len++;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>getchar()</code>每读取一个字符，长度变量<code>len</code>就会加1，直到读取到换行符为止，这时<code>len</code>就是该行的字符长度。</p>
<p>下面的例子是跳过空格字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>

<p>上面示例中，结束循环后，变量<code>ch</code>等于第一个非空格字符。</p>
<p><strong>（2）putchar()</strong></p>
<p><code>putchar()</code>函数将它的参数字符输出到屏幕，等同于使用<code>printf()</code>输出一个字符。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br></pre></td></tr></table></figure>

<p>操作成功时，<code>putchar()</code>返回输出的字符，否则返回常量 EOF。</p>
<p><strong>（3）小结</strong></p>
<p>由于<code>getchar()</code>和<code>putchar()</code>这两个函数的用法，要比<code>scanf()</code>和<code>printf()</code>更简单，而且通常是用宏来实现，所以要比<code>scanf()</code>和<code>printf()</code>更快。如果操作单个字符，建议优先使用这两个函数。</p>
<h3 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h3><p><code>puts()</code>函数用于将参数字符串显示在屏幕（stdout）上，并且自动在字符串末尾添加换行符。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Here are some messages:&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>puts()</code>在屏幕上输出两行内容。</p>
<p>写入成功时，<code>puts()</code>返回一个非负整数，否则返回常量 EOF。</p>
<h3 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h3><p><code>gets()</code>函数以前用于从<code>stdin</code>读取整行输入，现在已经被废除了，仍然放在这里介绍一下。</p>
<p>该函数读取用户的一行输入，不会跳过起始处的空白字符，直到遇到换行符为止。这个函数会丢弃换行符，将其余字符放入参数变量，并在这些字符的末尾添加一个空字符<code>\0</code>，使其成为一个字符串。</p>
<p>它经常与<code>puts()</code>配合使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> words[<span class="number">81</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter a string, please&quot;</span>);</span><br><span class="line">gets(words);</span><br></pre></td></tr></table></figure>

<p>上面示例使用<code>puts()</code>在屏幕上输出提示，然后使用<code>gets()</code>获取用户的输入。</p>
<p>由于<code>gets()</code>获取的字符串，可能超过字符数组变量的最大长度，有安全风险，建议不要使用，改为使用<code>fgets()</code>。</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>本章介绍 C 语言如何操作文件。</p>
<h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h3><p>C 语言提供了一个 FILE 数据结构，记录了操作一个文件所需要的信息。该结构定义在头文件<code>stdio.h</code>，所有文件操作函数都要通过这个数据结构，获取文件信息。</p>
<p>开始操作一个文件之前，就要定义一个指向该文件的 FILE 指针，相当于获取一块内存区域，用来保存文件信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp;</span><br></pre></td></tr></table></figure>

<p>上面示例定义了一个 FILE 指针<code>fp</code>。</p>
<p>下面是一个读取文件的完整示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  FILE* fp;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c = fgetc(fp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，新建文件指针<code>fp</code>以后，依次使用了下面三个文件操作函数，分成三个步骤。其他的文件操作，大致上也是这样的步骤。</p>
<p>第一步，使用<code>fopen()</code>打开指定文件，返回一个 File 指针。如果出错，返回 NULL。</p>
<p>它相当于将指定文件的信息与新建的文件指针<code>fp</code>相关联，在 FILE 结构内部记录了这样一些信息：文件内部的当前读写位置、读写报错的记录、文件结尾指示器、缓冲区开始位置的指针、文件标识符、一个计数器（统计拷贝进缓冲区的字节数）等等。后继的操作就可以使用这个指针（而不是文件名）来处理指定文件。</p>
<p>同时，它还为文件建立一个缓存区。由于存在缓存区，也可以说<code>fopen()</code>函数“打开一个了流”，后继的读写文件都是流模式。</p>
<p>第二步，使用读写函数，从文件读取数据，或者向文件写入数据。上例使用了<code>fgetc()</code>函数，从已经打开的文件里面，读取一个字符。</p>
<p><code>fgetc()</code>一调用，文件的数据块先拷贝到缓冲区。不同的计算机有不同的缓冲区大小，一般是512字节或是它的倍数，如4096或16384。随着计算机硬盘容量越来越大，缓冲区也越来越大。</p>
<p><code>fgetc()</code>从缓冲区读取数据，同时将文件指针内部的读写位置指示器，指向所读取字符的下一个字符。所有的文件读取函数都使用相同的缓冲区，后面再调用任何一个读取函数，都将从指示器指向的位置，即上一次读取函数停止的位置开始读取。</p>
<p>当读取函数发现已读完缓冲区里面的所有字符时，会请求把下一个缓冲区大小的数据块，从文件拷贝到缓冲区中。读取函数就以这种方式，读完文件的所有内容，直到文件结尾。不过，上例是只从缓存区读取一个字符。当函数在缓冲区里面，读完文件的最后一个字符时，就把 FILE 结构里面的文件结尾指示器设置为真。于是，下一次再调用读取函数时，会返回常量 EOF。EOF 是一个整数值，代表文件结尾，一般是<code>-1</code>。</p>
<p>第三步，<code>fclose()</code>关闭文件，同时清空缓存区。</p>
<p>上面是文件读取的过程，文件写入也是类似的方式，先把数据写入缓冲区，当缓冲区填满后，缓存区的数据将被转移到文件中。</p>
<h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h3><p><code>fopen()</code>函数用来打开文件。所有文件操作的第一步，都是使用<code>fopen()</code>打开指定文件。这个函数的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* <span class="title function_">fopen</span><span class="params">(<span class="type">char</span>* filename, <span class="type">char</span>* mode)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数。第一个参数是文件名(可以包含路径)，第二个参数是模式字符串，指定对文件执行的操作，比如下面的例子中，<code>r</code>表示以读取模式打开文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp = fopen(<span class="string">&quot;in.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>成功打开文件以后，<code>fopen()</code>返回一个 FILE 指针，其他函数可以用这个指针操作文件。如果无法打开文件（比如文件不存在或没有权限），会返回空指针 NULL。所以，执行<code>fopen()</code>以后，最好判断一下，有没有打开成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open file!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果<code>fopen()</code>返回一个空指针，程序就会报错。</p>
<p><code>fopen()</code>的模式字符串有以下几种。</p>
<ul>
<li><code>r</code>：读模式，只用来读取数据。如果文件不存在，返回 NULL 指针。</li>
<li><code>w</code>：写模式，只用来写入数据。如果文件存在，文件长度会被截为0，然后再写入；如果文件不存在，则创建该文件。</li>
<li><code>a</code>：写模式，只用来在文件尾部追加数据。如果文件不存在，则创建该文件。</li>
<li><code>r+</code>：读写模式。如果文件存在，指针指向文件开始处，可以在文件头部添加数据。如果文件不存在，返回 NULL 指针。</li>
<li><code>w+</code>：读写模式。如果文件存在，文件长度会被截为0，然后再写入数据。这种模式实际上读不到数据，反而会擦掉数据。如果文件不存在，则创建该文件。</li>
<li><code>a+</code>：读写模式。如果文件存在，指针指向文件结尾，可以在现有文件末尾添加内容。如果文件不存在，则创建该文件。</li>
</ul>
<p>上一小节说过，<code>fopen()</code>函数会为打开的文件创建一个缓冲区。读模式下，创建的是读缓存区；写模式下，创建的是写缓存区；读写模式下，会同时创建两个缓冲区。C 语言通过缓存区，以流的形式，向文件读写数据。</p>
<p>数据在文件里面，都是以二进制形式存储。但是，读取的时候，有不同的解读方法：以原本的二进制形式解读，叫做“二进制流”；将二进制数据转成文本，以文本形式解读，叫做“文本流”。写入操作也是如此，分成以二进制写入和以文本写入，后者会多一个文本转二进制的步骤。</p>
<p><code>fopen()</code>的模式字符串，默认是以文本流读写。如果添加<code>b</code>后缀（表示 binary），就会以“二进制流”进行读写。比如，<code>rb</code>是读取二进制数据模式，<code>wb</code>是写入二进制数据模式。</p>
<p>模式字符串还有一个<code>x</code>后缀，表示独占模式（exclusive）。如果文件已经存在，则打开文件失败；如果文件不存在，则新建文件，打开后不再允许其他程序或线程访问当前文件。比如，<code>wx</code>表示以独占模式写入文件，如果文件已经存在，就会打开失败。</p>
<h3 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h3><p>Linux 系统默认提供三个已经打开的文件，它们的文件指针如下。</p>
<ul>
<li><code>stdin</code>（标准输入）：默认来源为键盘，文件指针编号为<code>0</code>。</li>
<li><code>stdout</code>（标准输出）：默认目的地为显示器，文件指针编号为<code>1</code>。</li>
<li><code>stderr</code>（标准错误）：默认目的地为显示器，文件指针编号为<code>2</code>。</li>
</ul>
<p>Linux 系统的文件，不一定是数据文件，也可以是设备文件，即文件代表一个可以读或写的设备。文件指针<code>stdin</code>默认是把键盘看作一个文件，读取这个文件，就能获取用户的键盘输入。同理，<code>stdout</code>和<code>stderr</code>默认是把显示器看作一个文件，将程序的运行结果写入这个文件，用户就能看到运行结果了。它们的区别是，<code>stdout</code>写入的是程序的正常运行结果，<code>stderr</code>写入的是程序的报错信息。</p>
<p>这三个输入和输出渠道，是 Linux 默认提供的，所以分别称为标准输入（stdin）、标准输出（stdout）和标准错误（stderr）。因为它们的实现是一样的，都是文件流，所以合称为“标准流”。</p>
<p>Linux 允许改变这三个文件指针（文件流）指向的文件，这称为重定向（redirection）。</p>
<p>如果标准输入不绑定键盘，而是绑定其他文件，可以在文件名前面加上小于号<code>&lt;</code>，跟在程序名后面。这叫做“输入重定向”（input redirection）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo &lt; in.dat</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>demo</code>程序代码里面的<code>stdin</code>，将指向文件<code>in.dat</code>，即从<code>in.dat</code>获取数据。</p>
<p>如果标准输出绑定其他文件，而不是显示器，可以在文件名前加上大于号<code>&gt;</code>，跟在程序名后面。这叫做“输出重定向”（output redirection）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo &gt; out.dat</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>demo</code>程序代码里面的<code>stdout</code>，将指向文件<code>out.dat</code>，即向<code>out.dat</code>写入数据。</p>
<p>输出重定向<code>&gt;</code>会先擦去<code>out.dat</code>的所有原有的内容，然后再写入。如果希望写入的信息追加在<code>out.dat</code>的结尾，可以使用<code>&gt;&gt;</code>符号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo &gt;&gt; out.dat</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>demo</code>程序代码里面的<code>stdout</code>，将向文件<code>out.dat</code>写入数据。与<code>&gt;</code>不同的是，写入的开始位置是<code>out.dat</code>的文件结尾。</p>
<p>标准错误的重定向符号是<code>2&gt;</code>。其中的<code>2</code>代表文件指针的编号，即<code>2&gt;</code>表示将2号文件指针的写入，重定向到<code>err.txt</code>。2号文件指针就是标准错误<code>stderr</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo &gt; out.dat 2&gt; err.txt</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>demo</code>程序代码里面的<code>stderr</code>，会向文件<code>err.txt</code>写入报错信息。而<code>stdout</code>向文件<code>out.dat</code>写入。</p>
<p>输入重定向和输出重定向，也可以结合在一条命令里面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ demo &lt; in.dat &gt; out.dat</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line">$ demo &gt; out.dat &lt; in.dat</span><br></pre></td></tr></table></figure>

<p>重定向还有另一种情况，就是将一个程序的标准输出<code>stdout</code>，指向另一个程序的标准输入<code>stdin</code>，这时要使用<code>|</code>符号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random | <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>random</code>程序代码里面的<code>stdout</code>的写入，会从<code>sum</code>程序代码里面的<code>stdin</code>被读取。</p>
<h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose()"></a>fclose()</h3><p><code>fclose()</code>用来关闭已经使用<code>fopen()</code>打开的文件。它的原型定义在<code>stdin.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE* stream)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受一个文件指针<code>fp</code>作为参数。如果成功关闭文件，<code>fclose()</code>函数返回整数<code>0</code>；如果操作失败（比如磁盘已满，或者出现 I&#x2F;O 错误），则返回一个特殊值 EOF（详见下一小节）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fclose(fp) != <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Something wrong.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不再使用的文件，都应该使用<code>fclose()</code>关闭，否则无法释放资源。一般来说，系统对同时打开的文件数量有限制，及时关闭文件可以避免超过这个限制。</p>
<h3 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h3><p>C 语言的文件操作函数的设计是，如果遇到文件结尾，就返回一个特殊值。程序接收到这个特殊值，就知道已经到达文件结尾了。</p>
<p>头文件<code>stdio.h</code>为这个特殊值定义了一个宏<code>EOF</code>（end of file 的缩写），它的值一般是<code>-1</code>。这是因为从文件读取的二进制值，不管作为无符号数字解释，还是作为 ASCII 码解释，都不可能是负值，所以可以很安全地返回<code>-1</code>，不会跟文件本身的数据相冲突。</p>
<p>需要注意的是，不像字符串结尾真的存储了<code>\0</code>这个值，<code>EOF</code>并不存储在文件结尾，文件中并不存在这个值，完全是文件操作函数发现到达了文件结尾，而返回这个值。</p>
<h3 id="freopen"><a href="#freopen" class="headerlink" title="freopen()"></a>freopen()</h3><p><code>freopen()</code>用于新打开一个文件，直接关联到某个已经打开的文件指针。这样可以复用文件指针。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* <span class="title function_">freopen</span><span class="params">(<span class="type">char</span>* filename, <span class="type">char</span>* mode, FILE stream)</span>;</span><br></pre></td></tr></table></figure>

<p>它跟<code>fopen()</code>相比，就是多出了第三个参数，表示要复用的文件指针。其他两个参数都一样，分别是文件名和打开模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例将文件<code>output.txt</code>关联到<code>stdout</code>，此后向<code>stdout</code>写入的内容，都会写入<code>output.txt</code>。由于<code>printf()</code>默认就是输出到<code>stdout</code>，所以运行上面的代码以后，文件<code>output.txt</code>会被写入<code>hello</code>。</p>
<p><code>freopen()</code>的返回值是它的第三个参数（文件指针）。如果打开失败（比如文件不存在），会返回空指针 NULL。</p>
<p><code>freopen()</code>会自动关闭原先已经打开的文件，如果文件指针并没有指向已经打开的文件，则<code>freopen()</code>等同于<code>fopen()</code>。</p>
<p>下面是<code>freopen()</code>关联<code>scanf()</code>的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, i2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i); </span><br><span class="line"></span><br><span class="line">freopen(<span class="string">&quot;someints.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i2);</span><br></pre></td></tr></table></figure>

<p>上面例子中，一共调用了两次<code>scanf()</code>，第一次调用是从键盘读取，然后使用<code>freopen()</code>将<code>stdin</code>指针关联到某个文件，第二次调用就会从该文件读取。</p>
<p>某些系统允许使用<code>freopen()</code>，改变文件的打开模式。这时，<code>freopen()</code>的第一个参数应该是 NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="literal">NULL</span>, <span class="string">&quot;wb&quot;</span>, <span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例将<code>stdout</code>的打开模式从<code>w</code>改成了<code>wb</code>。</p>
<h3 id="fgetc-，getc"><a href="#fgetc-，getc" class="headerlink" title="fgetc()，getc()"></a>fgetc()，getc()</h3><p><code>fgetc()</code>和<code>getc()</code>用于从文件读取一个字符。它们的用法跟<code>getchar()</code>类似，区别是<code>getchar()</code>只用来从<code>stdin</code>读取，而这两个函数是从任意指定的文件读取。它们的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p><code>fgetc()</code>与<code>getc()</code>的用法是一样的，都只有文件指针一个参数。两者的区别是，<code>getc()</code>一般用宏来实现，而<code>fgetc()</code>是函数实现，所以前者的性能可能更好一些。注意，虽然这两个函数返回的是一个字符，但是它们的返回值类型却不是<code>char</code>，而是<code>int</code>，这是因为读取失败的情况下，它们会返回 EOF，这个值一般是<code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="keyword">while</span> ((c = getc(fp)) != EOF)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>getc()</code>依次读取文件的每个字符，将其放入变量<code>c</code>，直到读到文件结尾，返回 EOF，循环终止。变量<code>c</code>的类型是<code>int</code>，而不是<code>char</code>，因为有可能等于负值，所以设为<code>int</code>更好一些。</p>
<h3 id="fputc-，putc"><a href="#fputc-，putc" class="headerlink" title="fputc()，putc()"></a>fputc()，putc()</h3><p><code>fputc()</code>和<code>putc()</code>用于向文件写入一个字符。它们的用法跟<code>putchar()</code>类似，区别是<code>putchar()</code>是向<code>stdout</code>写入，而这两个函数是向文件写入。它们的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> <span class="type">char</span>, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> <span class="type">char</span>, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p><code>fputc()</code>与<code>putc()</code>的用法是一样，都接受两个参数，第一个参数是待写入的字符，第二个参数是文件指针。它们的区别是，<code>putc()</code>通常是使用宏来实现，而<code>fputc()</code>只作为函数来实现，所以理论上，<code>putc()</code>的性能会好一点。</p>
<p>写入成功时，它们返回写入的字符；写入失败时，返回 EOF。</p>
<h3 id="fprintf"><a href="#fprintf" class="headerlink" title="fprintf()"></a>fprintf()</h3><p><code>fprintf()</code>用于向文件写入格式化字符串，用法与<code>printf()</code>类似。区别是<code>printf()</code>总是写入<code>stdout</code>，而<code>fprintf()</code>则是写入指定的文件，它的第一个参数必须是一个文件指针。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE* stream, <span class="type">const</span> <span class="type">char</span>* format, ...)</span></span><br></pre></td></tr></table></figure>

<p><code>fprintf()</code>可以替代<code>printf()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Hello, world!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面例子中，指定<code>fprintf()</code>写入<code>stdout</code>，结果就等同于调用<code>printf()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">&quot;Sum: %d\n&quot;</span>, sum);</span><br></pre></td></tr></table></figure>

<p>上面示例是向文件指针<code>fp</code>写入指定格式的字符串。</p>
<p>下面是向<code>stderr</code>输出错误信息的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Something number.\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="fscanf"><a href="#fscanf" class="headerlink" title="fscanf()"></a>fscanf()</h3><p><code>fscanf()</code>用于按照给定的模式，从文件中读取内容，用法跟<code>scanf()</code>类似。区别是<code>scanf()</code>总是从<code>stdin</code>读取数据，而<code>fscanf()</code>是从文件读入数据，它的原型定义在头文件<code>stdio.h</code>，第一个参数必须是文件指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE* stream, <span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;j);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fscanf()</code>从文件<code>fp</code>里面，读取两个整数，放入变量<code>i</code>和<code>j</code>。</p>
<p>使用<code>fscanf()</code>的前提是知道文件的结构，它的占位符解析规则与<code>scanf()</code>完全一致。由于<code>fscanf()</code>可以连续读取，直到读到文件尾，或者发生错误（读取失败、匹配失败），才会停止读取，所以<code>fscanf()</code>通常放在循环里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s&quot;</span>, words) == <span class="number">1</span>)</span><br><span class="line">  <span class="built_in">puts</span>(words);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fscanf()</code>依次读取文件的每个词，将它们一行打印一个，直到文件结束。</p>
<p><code>fscanf()</code>的返回值是赋值成功的变量数量，如果赋值失败会返回 EOF。</p>
<h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h3><p><code>fgets()</code>用于从文件读取指定长度的字符串，它名字的第一个字符是<code>f</code>，就代表<code>file</code>。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">fgets</span><span class="params">(<span class="type">char</span>* str, <span class="type">int</span> STRLEN, File* fp)</span>;</span><br></pre></td></tr></table></figure>

<p>它的第一个参数<code>str</code>是一个字符串指针，用于存放读取的内容。第二个参数<code>STRLEN</code>指定读取的长度，第三个参数是一个 FILE 指针，指向要读取的文件。</p>
<p><code>fgets()</code>读取 STRLEN - 1 个字符之后，或者遇到换行符与文件结尾，就会停止读取，然后在已经读取的内容末尾添加一个空字符<code>\0</code>，使之成为一个字符串。注意，<code>fgets()</code>会将换行符（<code>\n</code>）存储进字符串。</p>
<p>如果<code>fgets</code>的第三个参数是<code>stdin</code>，就可以读取标准输入，等同于<code>scanf()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure>

<p>读取成功时，<code>fgets()</code>的返回值是它的第一个参数，即指向字符串的指针，否则返回空指针 NULL。</p>
<p><code>fgets()</code>可以用来读取文件的每一行，下面是读取文件所有行的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  FILE* fp;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">1024</span>];  <span class="comment">// 数组必须足够大，足以放下一行</span></span><br><span class="line">  <span class="type">int</span> linecount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (fgets(s, <span class="keyword">sizeof</span> s, fp) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: %s&quot;</span>, ++linecount, s);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，每读取一行，都会输出行号和该行的内容。</p>
<p>下面的例子是循环读取用户的输入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> words[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter strings (q to quit):&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fgets(words, <span class="number">10</span>, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (words[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span> &amp;&amp; words[<span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(words);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Done.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的示例中，如果用户输入的字符串大于9个字符，<code>fgets()</code>会多次读取。直到遇到<code>q</code> + 回车键，才会退出循环。</p>
<h3 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h3><p><code>fputs()</code>函数用于向文件写入字符串，和<code>puts()</code>函数只有一点不同，那就是它不会在字符串末尾添加换行符。这是因为<code>fgets()</code>保留了换行符，所以<code>fputs()</code>就不添加了。<code>fputs()</code>函数通常与<code>fgets()</code>配对使用。</p>
<p>它的原型定义在<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, FILE* stream)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，第一个参数是字符串指针，第二个参数是要写入的文件指针。如果第二个参数为<code>stdout</code>（标准输出），就是将内容输出到计算机屏幕，等同于<code>printf()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> words[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter a string, please.&quot;</span>);</span><br><span class="line">fgets(words, <span class="number">14</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;This is your string:&quot;</span>);</span><br><span class="line"><span class="built_in">fputs</span>(words, <span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，先用<code>fgets()</code>从<code>stdin</code>读取用户输入，然后用<code>fputs()</code>输出到<code>stdout</code>。</p>
<p>写入成功时，<code>fputs()</code>返回一个非负整数，否则返回 EOF。</p>
<h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite()"></a>fwrite()</h3><p><code>fwrite()</code>用来一次性写入较大的数据块，主要用途是将数组数据一次性写入文件，适合写入二进制数据。它的原型定义在<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">void</span>* ptr,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> nmemb,</span></span><br><span class="line"><span class="params">  FILE* fp</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受四个参数。</p>
<ul>
<li><code>ptr</code>：数组指针。</li>
<li><code>size</code>：每个数组成员的大小，单位字节。</li>
<li><code>nmemb</code>：数组成员的数量。</li>
<li><code>fp</code>：要写入的文件指针。</li>
</ul>
<p>注意，<code>fwrite()</code>原型的第一个参数类型是<code>void*</code>，这是一个无类型指针，编译器会自动将参数指针转成<code>void*</code>类型。正是由于<code>fwrite()</code>不知道数组成员的类型，所以才需要知道每个成员的大小（第二个参数）和成员数量（第三个参数）。</p>
<p><code>fwrite()</code>函数的返回值是成功写入的数组成员的数量（注意不是字节数）。正常情况下，该返回值就是第三个参数<code>nmemb</code>，但如果出现写入错误，只写入了一部分成员，返回值会比<code>nmemb</code>小。</p>
<p>要将整个数组<code>arr</code>写入文件，可以采用下面的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fwrite(</span><br><span class="line">  arr,</span><br><span class="line">  <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),</span><br><span class="line">  <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),</span><br><span class="line">  fp</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>sizeof(a[0])</code>是每个数组成员占用的字节，<code>sizeof(a) / sizeof(a[0])</code>是整个数组的成员数量。</p>
<p>下面的例子是将一个大小为256字节的字符串写入文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">fwrite(buffer, <span class="number">1</span>, <span class="number">256</span>, fp);</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>buffer</code>每个成员是1个字节，一共有256个成员。由于<code>fwrite()</code>是连续内存复制，所以写成<code>fwrite(buffer, 256, 1, fp)</code>也能达到目的。</p>
<p><code>fwrite()</code>没有规定一定要写入整个数组，只写入数组的一部分也是可以的。</p>
<p>任何类型的数据都可以看成是1字节数据组成的数组，或者是一个成员的数组，所以<code>fwrite()</code>实际上可以写入任何类型的数据，而不仅仅是数组。比如，<code>fwrite()</code>可以将一个 Struct 结构写入文件保存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fwrite(&amp;s, <span class="keyword">sizeof</span>(s), <span class="number">1</span>, fp);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>s</code>是一个 Struct 结构指针，可以看成是一个成员的数组。注意，如果<code>s</code>的属性包含指针，存储时需要小心，因为保存指针可能没意义，还原出来的时候，并不能保证指针指向的数据还存在。</p>
<p><code>fwrite()</code>以及后面要介绍的<code>fread()</code>，比较适合读写二进制数据，因为它们不会对写入的数据进行解读。二进制数据可能包含空字符<code>\0</code>，这是 C 语言的字符串结尾标记，所以读写二进制文件，不适合使用文本读写函数（比如<code>fprintf()</code>等）。</p>
<p>下面是一个写入二进制文件的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  FILE* fp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> bytes[] = &#123;<span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">88</span>, <span class="number">255</span>, <span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;output.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">  fwrite(bytes, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="keyword">sizeof</span>(bytes), fp);</span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，写入二进制文件时，<code>fopen()</code>要使用<code>wb</code>模式打开，表示二进制写入。<code>fwrite()</code>可以把数据解释成单字节数组，因此它的第二个参数是<code>sizeof(char)</code>，第三个参数是数组的总字节数<code>sizeof(bytes)</code>。</p>
<p>上面例子写入的文件<code>output.bin</code>，使用十六进制编辑器打开，会是下面的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">05</span> <span class="number">25</span> <span class="number">00</span> <span class="number">58</span> ff <span class="number">0</span>c</span><br></pre></td></tr></table></figure>

<p><code>fwrite()</code>还可以连续向一个文件写入数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clientData</span> <span class="title">myClient</span> =</span> &#123;<span class="number">1</span>, <span class="string">&#x27;foo bar&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">  fwrite(&amp;myClient, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> clientData), <span class="number">1</span>, cfPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fwrite()</code>连续将100条数据写入文件。</p>
<h3 id="fread"><a href="#fread" class="headerlink" title="fread()"></a>fread()</h3><p><code>fread()</code>函数用于一次性从文件读取较大的数据块，主要用途是将文件内容读入一个数组，适合读取二进制数据。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">void</span>* ptr,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> nmemb,</span></span><br><span class="line"><span class="params">  FILE* fp</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受四个参数，与<code>fwrite()</code>完全相同。</p>
<ul>
<li><code>ptr</code>：数组地址。</li>
<li><code>size</code>：数组的成员数量。</li>
<li><code>nmemb</code>：每个数组成员的大小。</li>
<li><code>fp</code>：文件指针。</li>
</ul>
<p>要将文件内容读入数组<code>arr</code>，可以采用下面的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fread(</span><br><span class="line">  arr,</span><br><span class="line">  <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),</span><br><span class="line">  <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),</span><br><span class="line">  fp</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组长度（第二个参数）和每个成员的大小（第三个参数）的乘积，就是数组占用的内存空间的大小。<code>fread()</code>会从文件（第四个参数）里面读取相同大小的内容，然后将<code>ptr</code>（第一个参数）指向这些内容的内存地址。</p>
<p>下面的例子是将文件内容读入一个10个成员的双精度浮点数数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> earnings[<span class="number">10</span>];</span><br><span class="line">fread(earnings, <span class="keyword">sizeof</span>(<span class="type">double</span>), <span class="number">10</span>, fp);</span><br></pre></td></tr></table></figure>

<p>上面示例中，每个数组成员的大小是<code>sizeof(double)</code>，一个有10个成员，就会从文件<code>fp</code>读取<code>sizeof(double) * 10</code>大小的内容。</p>
<p><code>fread()</code>函数的返回值是成功读取的数组成员的数量。正常情况下，该返回值就是第三个参数<code>nmemb</code>，但如果出现读取错误或读到文件结尾，该返回值就会比<code>nmemb</code>小。所以，检查<code>fread()</code>的返回值是非常重要的。</p>
<p><code>fread()</code>和<code>fwrite()</code>可以配合使用。在程序终止之前，使用<code>fwrite()</code>将数据保存进文件，下次运行时再用<code>fread()</code>将数据还原进入内存。</p>
<p>下面是读取上一节生成的二进制文件<code>output.bin</code>的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  FILE* fp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;output.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (fread(&amp;c, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">1</span>, fp) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后，得到如下结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">37</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">88</span></span><br><span class="line"><span class="number">255</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="feof"><a href="#feof" class="headerlink" title="feof()"></a>feof()</h3><p><code>feof()</code>函数判断文件的内部指针是否指向文件结尾。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>

<p><code>feof()</code>接受一个文件指针作为参数。如果已经到达文件结尾，会返回一个非零值（表示 true），否则返回<code>0</code>（表示 false）。</p>
<p>诸如<code>fgetc()</code>这样的文件读取函数，如果返回 EOF，有两种可能，一种可能是已读取到文件结尾，另一种可能是出现读取错误。<code>feof()</code>可以用来判断到底是那一种情况。</p>
<p>下面是通过<code>feof()</code>判断是否到达文件结尾，从而循环读取整个文件的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">FILE* cfPtr = fopen(<span class="string">&quot;clients.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!feof(cfPtr)) &#123;</span><br><span class="line">  <span class="built_in">fscanf</span>(cfPtr, <span class="string">&quot;%d%s\n&quot;</span>, &amp;num, name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, num, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(cfPtr);</span><br></pre></td></tr></table></figure>

<p>上面示例通过循环判断<code>feof()</code>是否读到文件结尾，从而实现读出整个文件内容。</p>
<p><code>feof()</code>为真时，可以通过<code>fseek()</code>、<code>rewind()</code>、<code>fsetpos()</code>函数改变文件内部读写位置的指示器，从而清除这个函数的状态。</p>
<h3 id="fseek"><a href="#fseek" class="headerlink" title="fseek()"></a>fseek()</h3><p>每个文件指针都有一个内部指示器（内部指针），记录当前打开的文件的读写位置（file position），即下一次读写从哪里开始。文件操作函数（比如<code>getc()</code>、<code>fgets()</code>、<code>fscanf()</code>和<code>fread()</code>等）都从这个指示器指定的位置开始按顺序读写文件。</p>
<p>如果希望改变这个指示器，将它移到文件的指定位置，可以使用<code>fseek()</code>函数。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE* stream, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<p><code>fseek()</code>接受3个参数。</p>
<ul>
<li><code>stream</code>：文件指针。</li>
<li><code>offset</code>：距离基准（第三个参数）的字节数。类型为 long int，可以为正值（向文件末尾移动）、负值（向文件开始处移动）或 0（保持不动）。</li>
<li><code>whence</code>：位置基准，用来确定计算起点。它的值是以下三个宏（定义在<code>stdio.h</code>）：<code>SEEK_SET</code>（文件开始处）、<code>SEEK_CUR</code>（内部指针的当前位置）、<code>SEEK_END</code>（文件末尾）</li>
</ul>
<p>请看下面的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位到文件开始处</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位到文件末尾</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从当前位置前移2个字节</span></span><br><span class="line">fseek(fp, <span class="number">2L</span>, SEEK_CUR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位到文件第10个字节</span></span><br><span class="line">fseek(fp, <span class="number">10L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位到文件倒数第10个字节</span></span><br><span class="line">fseek(fp, <span class="number">-10L</span>, SEEK_END);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fseek()</code>的第二个参数为 long 类型，所以移动距离必须加上后缀<code>L</code>，将其转为 long 类型。</p>
<p>下面的示例逆向输出文件的所有字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (count = <span class="number">1L</span>; count &lt;= size; count++) &#123;</span><br><span class="line">  fseek(fp, -count, SEEK_END);</span><br><span class="line">  ch = getc(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>fseek()</code>最好只用来操作二进制文件，不要用来读取文本文件。因为文本文件的字符有不同的编码，某个位置的准确字节位置不容易确定。</p>
<p>正常情况下，<code>fseek()</code>的返回值为0。如果发生错误（如移动的距离超出文件的范围），返回值为非零值（比如<code>-1</code>)。</p>
<h3 id="ftell"><a href="#ftell" class="headerlink" title="ftell()"></a>ftell()</h3><p><code>ftell()</code>函数返回文件内部指示器的当前位置。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">ftell</span><span class="params">(FILE* stream)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受一个文件指针作为参数。返回值是一个 long 类型的整数，表示内部指示器的当前位置，即文件开始处到当前位置的字节数，<code>0</code>表示文件开始处。如果发生错误，<code>ftell()</code>返回<code>-1L</code>。</p>
<p><code>ftell()</code>可以跟<code>fseek()</code>配合使用，先记录内部指针的位置，一系列操作过后，再用<code>fseek()</code>返回原来的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> file_pos = ftell(fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一系列文件操作之后</span></span><br><span class="line">fseek(fp, file_pos, SEEK_SET);</span><br></pre></td></tr></table></figure>

<p>下面的例子先将指示器定位到文件结尾，然后得到文件开始处到结尾的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line">size = ftell(fp);</span><br></pre></td></tr></table></figure>

<h3 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a>rewind()</h3><p><code>rewind()</code>函数可以让文件的内部指示器回到文件开始处。它的原型定义在<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(file* stream)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受一个文件指针作为参数。</p>
<p><code>rewind(fp)</code>基本等价于<code>fseek(fp, 0l, seek_set)</code>，唯一的区别是<code>rewind()</code>没有返回值，而且会清除当前文件的错误指示器。</p>
<h3 id="fgetpos-，fsetpos"><a href="#fgetpos-，fsetpos" class="headerlink" title="fgetpos()，fsetpos()"></a>fgetpos()，fsetpos()</h3><p><code>fseek()</code>和<code>ftell()</code>有一个潜在的问题，那就是它们都把文件大小限制在 long int 类型能表示的范围内。这看起来相当大，但是在32位计算机上，long int 的长度为4个字节，能够表示的范围最大为 4GB。随着存储设备的容量迅猛增长，文件也越来越大，往往会超出这个范围。鉴于此，C 语言新增了两个处理大文件的新定位函数：<code>fgetpos()</code>和<code>fsetpos()</code>。</p>
<p>它们的原型都定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetpos</span><span class="params">(FILE* stream, <span class="type">fpos_t</span>* pos)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsetpos</span><span class="params">(FILE* stream, <span class="type">const</span> <span class="type">fpos_t</span>* pos)</span>;</span><br></pre></td></tr></table></figure>

<p><code>fgetpos()</code>函数会将文件内部指示器的当前位置，存储在指针变量<code>pos</code>。该函数接受两个参数，第一个是文件指针，第二个存储指示器位置的变量。</p>
<p><code>fsetpos()</code>函数会将文件内部指示器的位置，移动到指针变量<code>pos</code>指定的地址。注意，变量<code>pos</code>必须是通过调用<code>fgetpos()</code>方法获得的。<code>fsetpos()</code>的两个参数与<code>fgetpos()</code>必须是一样的。</p>
<p>记录文件内部指示器位置的指针变量<code>pos</code>，类型为<code>fpos_t*</code>（file position type 的缩写，意为文件定位类型）。它不一定是整数，也可能是一个 Struct 结构。</p>
<p>下面是用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">fpos_t</span> file_pos;</span><br><span class="line">fgetpos(fp, &amp;file_pos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一系列文件操作之后</span></span><br><span class="line">fsetpos(fp, &amp;file_pos);</span><br></pre></td></tr></table></figure>

<p>上面示例中，先用<code>fgetpos()</code>获取内部指针的位置，后面再用<code>fsetpos()</code>恢复指针的位置。</p>
<p>执行成功时，<code>fgetpos()</code>和<code>fsetpos()</code>都会返回<code>0</code>，否则返回非零值。</p>
<h3 id="ferror-，clearerr"><a href="#ferror-，clearerr" class="headerlink" title="ferror()，clearerr()"></a>ferror()，clearerr()</h3><p>所有的文件操作函数如果执行失败，都会在文件指针里面记录错误状态。后面的操作只要读取错误指示器，就知道前面的操作出错了。</p>
<p><code>ferror()</code>函数用来返回错误指示器的状态。可以通过这个函数，判断前面的文件操作是否成功。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受一个文件指针作为参数。如果前面的操作出现错误，<code>ferror()</code>就会返回一个非零整数（表示 true），否则返回<code>0</code>。</p>
<p><code>clearerr()</code>函数用来重置出错指示器。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE* fp)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受一个文件指针作为参数，没有返回值。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="type">char</span> c = fgetc(fp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ferror(fp)) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;读取文件：file.txt 时发生错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clearerr(fp);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fgetc()</code>尝试读取一个以”写模式“打开的文件，读取失败就会返回 EOF。这时调用<code>ferror()</code>就可以知道上一步操作出错了。处理完以后，再用<code>clearerr()</code>清除出错状态。</p>
<p>文件操作函数如果正常执行，<code>ferror()</code>和<code>feof()</code>都会返回零。如果执行不正常，就要判断到底是哪里出了问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d&quot;</span>, &amp;n) != <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ferror(fp)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;io error\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (feof(fp)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end of file\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clearerr(fp);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，当<code>fscanf()</code>函数报错时，通过检查<code>ferror()</code>和<code>feof()</code>，确定到底发生什么问题。这两个指示器改变状态后，会保持不变，所以要用<code>clearerr()</code>清除它们，<code>clearerr()</code>可以同时清除两个指示器。</p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p><code>remove()</code>函数用于删除指定文件。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受文件名作为参数。如果删除成功，<code>remove()</code>返回<code>0</code>，否则返回非零值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove(<span class="string">&quot;foo.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例删除了<code>foo.txt</code>文件。</p>
<p>注意，删除文件必须是在文件关闭的状态下。如果是用<code>fopen()</code>打开的文件，必须先用<code>fclose()</code>关闭后再删除。</p>
<h3 id="rename"><a href="#rename" class="headerlink" title="rename()"></a>rename()</h3><p><code>rename()</code>函数用于文件改名，也用于移动文件。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* old_filename, <span class="type">const</span> <span class="type">char</span>* new_filename)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，第一个参数是现在的文件名，第二个参数是新的文件名。如果改名成功，<code>rename()</code>返回<code>0</code>，否则返回非零值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;bar.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例将<code>foo.txt</code>改名为<code>bar.txt</code>。</p>
<p>注意，改名后的文件不能与现有文件同名。另外，如果要改名的文件已经打开了，必须先关闭，然后再改名，对打开的文件进行改名会失败。</p>
<p>下面是移动文件的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename(<span class="string">&quot;/tmp/evidence.txt&quot;</span>, <span class="string">&quot;/home/beej/nothing.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="变量说明符"><a href="#变量说明符" class="headerlink" title="变量说明符"></a>变量说明符</h2><p>C 语言允许声明变量的时候，加上一些特定的说明符（specifier），为编译器提供变量行为的额外信息。它的主要作用是帮助编译器优化代码，有时会对程序行为产生影响。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><code>const</code>说明符表示变量是只读的，不得被修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line">PI = <span class="number">3</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例里面的<code>const</code>，表示变量<code>PI</code>的值不应改变。如果改变的话，编译器会报错。</p>
<p>对于数组，<code>const</code>表示数组成员不能修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">5</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>const</code>使得数组<code>arr</code>的成员无法修改。</p>
<p>对于指针变量，<code>const</code>有两种写法，含义是不一样的。如果<code>const</code>在<code>*</code>前面，表示指针指向的值不可修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 表示指向的值 *x 不能修改</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * x</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * x</span><br></pre></td></tr></table></figure>

<p>下面示例中，对<code>x</code>指向的值进行修改导致报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p = <span class="number">1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* x = &amp;p;</span><br><span class="line"></span><br><span class="line">(*x)++; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>如果<code>const</code>在<code>*</code>后面，表示指针包含的地址不可修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 表示地址 x 不能修改</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> x</span><br></pre></td></tr></table></figure>

<p>下面示例中，对<code>x</code>进行修改导致报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p = <span class="number">1</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> x = &amp;p;</span><br><span class="line"></span><br><span class="line">x++; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>这两者可以结合起来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> x;</span><br></pre></td></tr></table></figure>

<p>上面示例中，指针变量<code>x</code>指向一个字符串。两个<code>const</code>意味着，<code>x</code>包含的内存地址以及<code>x</code>指向的字符串，都不能修改。</p>
<p><code>const</code>的一个用途，就是防止函数体内修改函数参数。如果某个参数在函数体内不会被修改，可以在函数声明时，对该参数添加<code>const</code>说明符。这样的话，使用这个函数的人看到原型里面的<code>const</code>，就知道调用函数前后，参数数组保持不变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* arr, <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>find</code>的参数数组<code>arr</code>有<code>const</code>说明符，就说明该数组在函数内部将保持不变。</p>
<p>有一种情况需要注意，如果一个指针变量指向<code>const</code>变量，那么该指针变量也不应该被修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* j = &amp;i;</span><br><span class="line">*j = <span class="number">2</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>j</code>是一个指针变量，指向变量<code>i</code>，即<code>j</code>和<code>i</code>指向同一个地址。<code>j</code>本身没有<code>const</code>说明符，但是<code>i</code>有。这种情况下，<code>j</code>指向的值也不能被修改。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><code>static</code>说明符对于全局变量和局部变量有不同的含义。</p>
<p>（1）用于局部变量（位于块作用域内部）。</p>
<p><code>static</code>用于函数内部声明的局部变量时，表示该变量的值会在函数每次执行后得到保留，下次执行时不会进行初始化，就类似于一个只用于函数内部的全局变量。由于不必每次执行函数时，都对该变量进行初始化，这样可以提高函数的执行速度，详见《函数》一章。</p>
<p>（2）用于全局变量（位于块作用域外部）。</p>
<p><code>static</code>用于函数外部声明的全局变量时，表示该变量只用于当前文件，其他源码文件不可以引用该变量，即该变量不会被链接（link）。</p>
<p><code>static</code>修饰的变量，初始化时，值不能等于变量，必须是常量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> m = n; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>m</code>有<code>static</code>修饰，它的值如果等于变量<code>n</code>，就会报错，必须等于常量。</p>
<p>只在当前文件里面使用的函数，也可以声明为<code>static</code>，表明该函数只在当前文件使用，其他文件可以定义同名函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> i)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p><code>auto</code>说明符表示该变量的存储，由编译器自主分配内存空间，且只存在于定义时所在的作用域，退出作用域时会自动释放。</p>
<p>由于只要不是<code>extern</code>的变量（外部变量），都是由编译器自主分配内存空间的，这属于默认行为，所以该说明符没有实际作用，一般都省略不写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="type">int</span> a;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure>

<h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p><code>extern</code>说明符表示，该变量在其他文件里面声明，没有必要在当前文件里面为它分配空间。通常用来表示，该变量是多个文件共享的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>是<code>extern</code>变量，表示该变量在其他文件里面定义和初始化，当前文件不必为它分配存储空间。</p>
<p>但是，变量声明时，同时进行初始化，<code>extern</code>就会无效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extern 无效</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>extern</code>对变量初始化的声明是无效的。这是为了防止多个<code>extern</code>对同一个变量进行多次初始化。</p>
<p>函数内部使用<code>extern</code>声明变量，就相当于该变量是静态存储，每次执行时都要从外部获取它的值。</p>
<p>函数本身默认是<code>extern</code>，即该函数可以被外部文件共享，通常省略<code>extern</code>不写。如果只希望函数在当前文件可用，那就需要在函数前面加上<code>static</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><p><code>register</code>说明符向编译器表示，该变量是经常使用的，应该提供最快的读取速度，所以应该放进寄存器。但是，编译器可以忽略这个说明符，不一定按照这个指示行事。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>register</code>提示编译器，变量<code>a</code>会经常用到，要为它提供最快的读取速度。</p>
<p><code>register</code>只对声明在代码块内部的变量有效。</p>
<p>设为<code>register</code>的变量，不能获取它的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">// 编译器报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>&amp;a</code>会报错，因为变量<code>a</code>可能放在寄存器里面，无法获取内存地址。</p>
<p>如果数组设为<code>register</code>，也不能获取整个数组或任一个数组成员的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> a[] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p = a;  <span class="comment">// 报错</span></span><br><span class="line"><span class="type">int</span> a = *(a + <span class="number">2</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>历史上，CPU 内部的缓存，称为寄存器（register）。与内存相比，寄存器的访问速度快得多，所以使用它们可以提高速度。但是它们不在内存之中，所以没有内存地址，这就是为什么不能获取指向它们的指针地址。现代编译器已经有巨大的进步，不管是否使用<code>register</code>关键字，都会尽可能使用寄存器，所以不保证一定会把这些变量放到寄存器。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><code>volatile</code>说明符表示所声明的变量，可能会预想不到地发生变化（即其他程序可能会更改它的值），不受当前程序控制，因此编译器不要对这类变量进行优化，每次使用时都应该查询一下它的值。硬件设备的编程中，这个说明符很常用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> foo;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span>* bar;</span><br></pre></td></tr></table></figure>

<p><code>volatile</code>的目的是阻止编译器对变量行为进行优化，请看下面的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> foo = x;</span><br><span class="line"><span class="comment">// 其他语句，假设没有改变 x 的值</span></span><br><span class="line"><span class="type">int</span> bar = x;</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于变量<code>foo</code>和<code>bar</code>都等于<code>x</code>，而且<code>x</code>的值也没有发生变化，所以编译器可能会把<code>x</code>放入缓存，直接从缓存读取值（而不是从 x 的原始内存位置读取），然后对<code>foo</code>和<code>bar</code>进行赋值。如果<code>x</code>被设定为<code>volatile</code>，编译器就不会把它放入缓存，每次都从原始位置去取<code>x</code>的值，因为在两次读取之间，其他程序可能会改变<code>x</code>。</p>
<h3 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h3><p><code>restrict</code>说明符允许编译器优化某些代码。它只能用于指针，表明该指针是访问数据的唯一方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="keyword">restrict</span> pt = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>restrict</code>表示变量<code>pt</code>是访问 malloc 所分配内存的唯一方式。</p>
<p>下面例子的变量<code>foo</code>，就不能使用<code>restrict</code>修饰符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> foo[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>* bar = foo;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>指向的内存，可以用<code>foo</code>访问，也可以用<code>bar</code>访问，因此就不能将<code>foo</code>设为 restrict。</p>
<p>如果编译器知道某块内存只能用一个方式访问，可能可以更好地优化代码，因为不用担心其他地方会修改值。</p>
<p><code>restrict</code>用于函数参数时，表示参数的内存地址之间没有重叠。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* <span class="keyword">restrict</span> a, <span class="type">int</span>* <span class="keyword">restrict</span> b)</span> &#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  t = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数参数声明里的<code>restrict</code>表示，参数<code>a</code>和参数<code>b</code>的内存地址没有重叠。</p>
<h2 id="多文件项目"><a href="#多文件项目" class="headerlink" title="多文件项目"></a>多文件项目</h2><h3 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h3><p>一个软件项目往往包含多个源码文件，编译时需要将这些文件一起编译，生成一个可执行文件。</p>
<p>假定一个项目有两个源码文件<code>foo.c</code>和<code>bar.c</code>，其中<code>foo.c</code>是主文件，<code>bar.c</code>是库文件。所谓“主文件”，就是包含了<code>main()</code>函数的项目入口文件，里面会引用库文件定义的各种函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File foo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, add(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 5!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，主文件<code>foo.c</code>调用了函数<code>add()</code>，这个函数是在库文件<code>bar.c</code>里面定义的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File bar.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，将这两个文件一起编译。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o foo foo.c bar.c</span><br><span class="line"></span><br><span class="line"><span class="comment">## 更省事的写法</span></span><br><span class="line">$ gcc -o foo *.c</span><br></pre></td></tr></table></figure>

<p>上面命令中，gcc 的<code>-o</code>参数指定生成的二进制可执行文件的文件名，本例是<code>foo</code>。</p>
<p>这个命令运行后，编译器会发出警告，原因是在编译<code>foo.c</code>的过程中，编译器发现一个不认识的函数<code>add()</code>，<code>foo.c</code>里面没有这个函数的原型或者定义。因此，最好修改一下<code>foo.c</code>，在文件头部加入<code>add()</code>的原型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File foo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, add(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 5!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在再编译就没有警告了。</p>
<p>你可能马上就会想到，如果有多个文件都使用这个函数<code>add()</code>，那么每个文件都需要加入函数原型。一旦需要修改函数<code>add()</code>（比如改变参数的数量），就会非常麻烦，需要每个文件逐一改动。所以，通常的做法是新建一个专门的头文件<code>bar.h</code>，放置所有在<code>bar.c</code>里面定义的函数的原型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File bar.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>然后使用<code>include</code>命令，在用到这个函数的源码文件里面加载这个头文件<code>bar.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File foo.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, add(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 5!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>#include &quot;bar.h&quot;</code>表示加入头文件<code>bar.h</code>。这个文件没有放在尖括号里面，表示它是用户提供的；它没有写路径，就表示与当前源码文件在同一个目录。</p>
<p>然后，最好在<code>bar.c</code>里面也加载这个头文件，这样可以让编译器验证，函数原型与函数定义是否一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File bar.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在重新编译，就可以顺利得到二进制可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o foo foo.c bar.c</span><br></pre></td></tr></table></figure>

<h3 id="重复加载"><a href="#重复加载" class="headerlink" title="重复加载"></a>重复加载</h3><p>头文件里面还可以加载其他头文件，因此有可能产生重复加载。比如，<code>a.h</code>和<code>b.h</code>都加载了<code>c.h</code>，然后<code>foo.c</code>同时加载了<code>a.h</code>和<code>b.h</code>，这意味着<code>foo.c</code>会编译两次<code>c.h</code>。</p>
<p>最好避免这种重复加载，虽然多次定义同一个函数原型并不会报错，但是有些语句重复使用会报错，比如多次重复定义同一个 Struct 数据结构。解决重复加载的常见方法是，在头文件里面设置一个专门的宏，加载时一旦发现这个宏存在，就不再继续加载当前文件了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File bar.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BAR_H</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> BAR_H</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，头文件<code>bar.h</code>使用<code>#ifndef</code>和<code>#endif</code>设置了一个条件判断。每当加载这个头文件时，就会执行这个判断，查看有没有设置过宏<code>BAR_H</code>。如果设置过了，表明这个头文件已经加载过了，就不再重复加载了，反之就先设置一下这个宏，然后加载函数原型。</p>
<h3 id="extern-说明符-1"><a href="#extern-说明符-1" class="headerlink" title="extern 说明符"></a>extern 说明符</h3><p>当前文件还可以使用其他文件定义的变量，这时要使用<code>extern</code>说明符，在当前文件中声明，这个变量是其他文件定义的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> myVar;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>extern</code>说明符告诉编译器，变量<code>myvar</code>是其他脚本文件声明的，不需要在这里为它分配内存空间。</p>
<p>由于不需要分配内存空间，所以<code>extern</code>声明数组时，不需要给出数组长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a[];</span><br></pre></td></tr></table></figure>

<p>这种共享变量的声明，可以直接写在源码文件里面，也可以放在头文件中，通过<code>#include</code>指令加载。</p>
<h3 id="static-说明符-1"><a href="#static-说明符-1" class="headerlink" title="static 说明符"></a>static 说明符</h3><p>正常情况下，当前文件内部的全局变量，可以被其他文件使用。有时候，不希望发生这种情况，而是希望某个变量只局限在当前文件内部使用，不要被其他文件引用。</p>
<p>这时可以在声明变量的时候，使用<code>static</code>关键字，使得该变量变成当前文件的私有变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> foo = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>只能在当前文件里面使用，其他文件不能引用。</p>
<h3 id="编译策略"><a href="#编译策略" class="headerlink" title="编译策略"></a>编译策略</h3><p>多个源码文件的项目，编译时需要所有文件一起编译。哪怕只是修改了一行，也需要从头编译，非常耗费时间。</p>
<p>为了节省时间，通常的做法是将编译拆分成两个步骤。第一步，使用 GCC 的<code>-c</code>参数，将每个源码文件单独编译为对象文件（object file）。第二步，将所有对象文件链接在一起，合并生成一个二进制可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c foo.c <span class="comment">## 生成 foo.o</span></span><br><span class="line">$ gcc -c bar.c <span class="comment">## 生成 bar.o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 更省事的写法</span></span><br><span class="line">$ gcc -c *.c</span><br></pre></td></tr></table></figure>

<p>上面命令为源码文件<code>foo.c</code>和<code>bar.c</code>，分别生成对象文件<code>foo.o</code>和<code>bar.o</code>。</p>
<p>对象文件不是可执行文件，只是编译过程中的一个阶段性产物，文件名与源码文件相同，但是后缀名变成了<code>.o</code>。</p>
<p>得到所有的对象文件以后，再次使用<code>gcc</code>命令，将它们通过链接，合并生成一个可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o foo foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="comment">## 更省事的写法</span></span><br><span class="line">$ gcc -o foo *.o</span><br></pre></td></tr></table></figure>

<p>以后，修改了哪一个源文件，就将这个文件重新编译成对象文件，其他文件不用重新编译，可以继续使用原来的对象文件，最后再将所有对象文件重新链接一次就可以了。由于链接的耗时大大短于编译，这样做就节省了大量时间。</p>
<h3 id="make-命令"><a href="#make-命令" class="headerlink" title="make 命令"></a>make 命令</h3><p>大型项目的编译，如果全部手动完成，是非常麻烦的，容易出错。一般会使用专门的自动化编译工具，比如 make。</p>
<p>make 是一个命令行工具，使用时会自动在当前目录下搜索配置文件 makefile（也可以写成 Makefile）。该文件定义了所有的编译规则，每个编译规则对应一个编译产物。为了得到这个编译产物，它需要知道两件事。</p>
<ul>
<li>依赖项（生成该编译产物，需要用到哪些文件）</li>
<li>生成命令（生成该编译产物的命令）</li>
</ul>
<p>比如，对象文件<code>foo.o</code>是一个编译产物，它的依赖项是<code>foo.c</code>，生成命令是<code>gcc -c foo.c</code>。对应的编译规则如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.o: foo.c</span><br><span class="line">  gcc -c foo.c</span><br></pre></td></tr></table></figure>

<p>上面示例中，编译规则由两行组成。第一行首先是编译产物，冒号后面是它的依赖项，第二行则是生成命令。</p>
<p>注意，第二行的缩进必须使用 Tab 键，如果使用空格键会报错。</p>
<p>完整的配置文件 makefile 由多个编译规则组成，可能是下面的样子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo: foo.o bar.o</span><br><span class="line">  gcc -o foo foo.o bar.o</span><br><span class="line"></span><br><span class="line">foo.o: bar.h foo.c</span><br><span class="line">  gcc -c foo.c</span><br><span class="line"></span><br><span class="line">bar.o: bar.h bar.c</span><br><span class="line">  gcc -c bar.c</span><br></pre></td></tr></table></figure>

<p>上面是 makefile 的一个示例文件。它包含三个编译规则，对应三个编译产物（<code>foo.o</code>、<code>bar.o</code>和<code>foo</code>），每个编译规则之间使用空行分隔。</p>
<p>有了 makefile，编译时，只要在 make 命令后面指定编译目标（编译产物的名字），就会自动调用对应的编译规则。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make foo.o</span><br><span class="line"></span><br><span class="line"><span class="comment">## or</span></span><br><span class="line">$ make bar.o</span><br><span class="line"></span><br><span class="line"><span class="comment">## or</span></span><br><span class="line">$ make foo</span><br></pre></td></tr></table></figure>

<p>上面示例中，make 命令会根据不同的命令，生成不同的编译产物。</p>
<p>如果省略了编译目标，<code>make</code>命令会执行第一条编译规则，构建相应的产物。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>make</code>后面没有编译目标，所以会执行 makefile 的第一条编译规则，本例是<code>make foo</code>。由于用户期望执行<code>make</code>后得到最终的可执行文件，所以建议总是把最终可执行文件的编译规则，放在 makefile 文件的第一条。makefile 本身对编译规则没有顺序要求。</p>
<p>make 命令的强大之处在于，它不是每次执行命令，都会进行编译，而是会检查是否有必要重新编译。具体方法是，通过检查每个源码文件的时间戳，确定在上次编译之后，哪些文件发生过变动。然后，重新编译那些受到影响的编译产物（即编译产物直接或间接依赖于那些发生变动的源码文件），不受影响的编译产物，就不会重新编译。</p>
<p>举例来说，上次编译之后，修改了<code>foo.c</code>，没有修改<code>bar.c</code>和<code>bar.h</code>。于是，重新运行<code>make foo</code>命令时，Make 就会发现<code>bar.c</code>和<code>bar.h</code>没有变动过，因此不用重新编译<code>bar.o</code>，只需要重新编译<code>foo.o</code>。有了新的<code>foo.o</code>以后，再跟<code>bar.o</code>一起，重新编译成新的可执行文件<code>foo</code>。</p>
<p>Make 这样设计的最大好处，就是自动处理编译过程，只重新编译变动过的文件，因此大大节省了时间。</p>
<h2 id="命令行环境"><a href="#命令行环境" class="headerlink" title="命令行环境"></a>命令行环境</h2><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>C 语言程序可以从命令行接收参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./foo hello world</span><br></pre></td></tr></table></figure>

<p>上面示例中，程序<code>foo</code>接收了两个命令行参数<code>hello</code>和<code>world</code>。</p>
<p>程序内部怎么拿到命令行参数呢？C 语言会把命令行输入的内容，放在一个数组里面。<code>main()</code>函数的参数可以接收到这个数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg %d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>main()</code>函数有两个参数<code>argc</code>（argument count）和<code>argv</code>（argument variable）。这两个参数的名字可以任意取，但是一般来说，约定俗成就是使用这两个词。</p>
<p>第一个参数<code>argc</code>是命令行参数的数量，由于程序名也被计算在内，所以严格地说<code>argc</code>是参数数量 + 1。</p>
<p>第二个参数<code>argv</code>是一个数组，保存了所有的命令行输入，它的每个成员是一个字符串指针。</p>
<p>以<code>./foo hello world</code>为例，<code>argc</code>是3，表示命令行输入有三个组成部分：<code>./foo</code>、<code>hello</code>、<code>world</code>。数组<code>argv</code>用来获取这些输入，<code>argv[0]</code>是程序名<code>./foo</code>，<code>argv[1]</code>是<code>hello</code>，<code>argv[2]</code>是<code>world</code>。一般来说，<code>argv[1]</code>到<code>argv[argc - 1]</code>依次是命令行的所有参数。<code>argv[argc]</code>则是一个空指针 NULL。</p>
<p>由于字符串指针可以看成是字符数组，所以下面三种写法是等价的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> argv[][])</span></span><br></pre></td></tr></table></figure>

<p>另一方面，每个命令行参数既可以写成数组形式<code>argv[i]</code>，也可以写成指针形式<code>*(argv + i)</code>。</p>
<p>利用<code>argc</code>，可以限定函数只能有多少个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;usage: mult x y\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, atoi(argv[<span class="number">1</span>]) * atoi(argv[<span class="number">2</span>]));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>argc</code>不等于<code>3</code>就会报错，这样就限定了程序必须有两个参数，才能运行。</p>
<p>另外，<code>argv</code>数组的最后一个成员是 NULL 指针（<code>argv[argc] == NULL</code>）。所以，参数的遍历也可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">char</span>** p = argv; *p != <span class="literal">NULL</span>; p++) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;arg: %s\n&quot;</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，指针<code>p</code>依次移动，指向<code>argv</code>的每个成员，一旦移到空指针 NULL，就表示遍历结束。由于<code>argv</code>的地址是固定的，不能执行自增运算（<code>argv++</code>），所以必须通过一个中间变量<code>p</code>，完成遍历操作。</p>
<h3 id="退出状态"><a href="#退出状态" class="headerlink" title="退出状态"></a>退出状态</h3><p>C 语言规定，如果<code>main()</code>函数没有<code>return</code>语句，那么结束运行的时候，默认会添加一句<code>return 0</code>，即返回整数<code>0</code>。这就是为什么<code>main()</code>语句通常约定返回一个整数值，并且返回整数<code>0</code>表示程序运行成功。如果返回非零值，就表示程序运行出了问题。</p>
<p>Bash 的环境变量<code>$?</code>可以用来读取上一个命令的返回值，从而知道是否运行成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./foo hello world</span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>echo $?</code>用来打印环境变量<code>$?</code>的值，该值为<code>0</code>，就表示上一条命令运行成功，否则就是运行失败。</p>
<p>注意，只有<code>main()</code>会默认添加<code>return 0</code>，其他函数都没有这个机制。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>C 语言提供了<code>getenv()</code>函数（原型在<code>stdlib.h</code>）用来读取命令行环境变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span>* val = getenv(<span class="string">&quot;HOME&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cannot find the HOME environment variable\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Value: %s\n&quot;</span>, val);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>getenv(&quot;HOME&quot;)</code>用来获取命令行的环境变量<code>$HOME</code>，如果这个变量为空（<code>NULL</code>），则程序报错返回。</p>
<h2 id="多字节字符"><a href="#多字节字符" class="headerlink" title="多字节字符"></a>多字节字符</h2><p>本章介绍 C 语言如何处理非英语字符。</p>
<h3 id="Unicode-简介"><a href="#Unicode-简介" class="headerlink" title="Unicode 简介"></a>Unicode 简介</h3><p>C 语言诞生时，只考虑了英语字符，使用7位的 ASCII 码表示所有字符。ASCII 码的范围是0到127，也就是100多个字符，所以<code>char</code>类型只占用一个字节，</p>
<p>但是，如果处理非英语字符，一个字节就不够了，单单是中文，就至少有几万个字符，字符集就势必使用多个字节表示。</p>
<p>最初，不同国家有自己的字符编码方式，这样不便于多种字符的混用。因此，后来就逐渐统一到 Unicode 编码，将所有字符放入一个字符集。</p>
<p>Unicode 为每个字符提供一个号码，称为码点（code point），其中0到127的部分，跟 ASCII 码是重合的。通常使用“U+十六进制码点”表示一个字符，比如<code>U+0041</code>表示字母<code>A</code>。</p>
<p>Unicode 编码目前一共包含了100多万个字符，码点范围是 U+0000 到 U+10FFFF。完整表达整个 Unicode 字符集，至少需要三个字节。但是，并不是所有文档都需要那么多字符，比如对于 ASCII 码就够用的英语文档，如果每个字符使用三个字节表示，就会比单字节表示的文件体积大出三倍。</p>
<p>为了适应不同的使用需求，Unicode 标准委员会提供了三种不同的表示方法，表示 Unicode 码点。</p>
<ul>
<li>UTF-8：使用1个到4个字节，表示一个码点。不同的字符占用的字节数不一样。</li>
<li>UTF-16：对于U+0000 到 U+FFFF 的字符（称为基本平面），使用2个字节表示一个码点。其他字符使用4个字节。</li>
<li>UTF-32：统一使用4个字节，表示一个码点。</li>
</ul>
<p>其中，UTF-8 的使用最为广泛，因为对于 ASCII 字符（U+0000 到 U+007F），它只使用一个字节表示，这就跟 ASCII 的编码方式完全一样。</p>
<p>C 语言提供了两个宏，表示当前系统支持的编码字节长度。这两个宏都定义在头文件<code>limits.h</code>。</p>
<ul>
<li><code>MB_LEN_MAX</code>：任意支持地区的最大字节长度，定义在<code>limits.h</code>。</li>
<li><code>MB_CUR_MAX</code>：当前语言的最大字节长度，总是小于或等于<code>MB_LEN_MAX</code>，定义在<code>stdlib.h</code>。</li>
</ul>
<h3 id="字符的表示方法"><a href="#字符的表示方法" class="headerlink" title="字符的表示方法"></a>字符的表示方法</h3><p>字符表示法的本质，是将每个字符映射为一个整数，然后从编码表获得该整数对应的字符。</p>
<p>C 语言提供了不同的写法，用来表示字符的整数号码。</p>
<ul>
<li><code>\123</code>：以八进制值表示一个字符，斜杠后面需要三个数字。</li>
<li><code>\x4D</code>：以十六进制表示一个字符，<code>\x</code>后面是十六进制整数。</li>
<li><code>\u2620</code>：以 Unicode 码点表示一个字符（不适用于 ASCII 字符），码点以十六进制表示，<code>\u</code>后面需要4个字符。</li>
<li><code>\U0001243F</code>：以 Unicode 码点表示一个字符（不适用于 ASCII 字符），码点以十六进制表示，<code>\U</code>后面需要8个字符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ABC\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\101\102\103\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\x41\x42\x43\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面三行都会输出“ABC”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\u2022 Bullet 1\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\U00002022 Bullet 1\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面两行都会输出“• Bullet 1”。</p>
<h3 id="多字节字符的表示"><a href="#多字节字符的表示" class="headerlink" title="多字节字符的表示"></a>多字节字符的表示</h3><p>C 语言预设只有基本字符，才能使用字面量表示，其它字符都应该使用码点表示，并且当前系统还必须支持该码点的编码方法。</p>
<p>所谓基本字符，指的是所有可打印的 ASCII 字符，但是有三个字符除外：<code>@</code>、<code>$</code>、<code>`</code>。</p>
<p>因此，遇到非英语字符，应该将其写成 Unicode 码点形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;\u6625\u5929&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s); <span class="comment">// 春天</span></span><br></pre></td></tr></table></figure>

<p>上面代码会输出中文“春天”。</p>
<p>如果当前系统是 UTF-8 编码，可以直接用字面量表示多字节字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<p>注意，<code>\u + 码点</code>和<code>\U + 码点</code>的写法，不能用来表示 ASCII 码字符（码点小于<code>0xA0</code>的字符），只有三个字符除外：<code>0x24</code>（<code>$</code>），<code>0x40</code>（<code>@</code>）和<code>0x60</code>（<code>`</code>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;\u0024\u0040\u0060&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);  <span class="comment">// @$`</span></span><br></pre></td></tr></table></figure>

<p>上面代码会输出三个 Unicode 字符“@$&#96;”，但是其它 ASCII 字符都不能用这种表示法表示。</p>
<p>为了保证程序执行时，字符能够正确解读，最好将程序环境切换到本地化环境。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_locale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，使用<code>set_locale()</code>切换到执行环境切换到系统的本地化语言。<code>set_locale()</code>的原型定义在头文件<code>locale.h</code>，详见标准库部分的《locale.h》章节。</p>
<p>像下面这样，指定编码语言也可以。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;zh_CN.UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码将程序执行环境，切换到中文环境的 UTF-8 编码。</p>
<p>C 语言允许使用<code>u8</code>前缀，对多字节字符串指定编码方式为 UTF-8。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">u8&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<p>一旦字符串里面包含多字节字符，就意味着字符串的字节数与字符数不再一一对应了。比如，字符串的长度为10字节，就不再是包含10个字符，而可能只包含7个字符、5个字符等等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_locale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* s = <span class="string">&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(s)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，字符串<code>s</code>只包含两个字符，但是<code>strlen()</code>返回的结果却是6，表示这两个字符一共占据了6个字节。</p>
<p>C 语言的字符串函数只针对单字节字符有效，对于多字节字符都会失效，比如<code>strtok()</code>、<code>strchr()</code>、<code>strspn()</code>、<code>toupper()</code>、<code>tolower()</code>、<code>isalpha()</code>等不会得到正确结果。</p>
<h3 id="宽字符"><a href="#宽字符" class="headerlink" title="宽字符"></a>宽字符</h3><p>上一小节的多字节字符串，每个字符的字节宽度是可变的。这种编码方式虽然使用起来方便，但是很不利于字符串处理，因此必须逐一检查每个字符占用的字节数。所以除了这种方式，C 语言还提供了确定宽度的多字节字符存储方式，称为宽字符（wide character）。</p>
<p>所谓“宽字符”，就是每个字符占用的字节数是固定的，要么是2个字节，要么是4个字节。这样的话，就很容易快速处理。</p>
<p>宽字符有一个单独的数据类型 wchar_t，每个宽字符都是这个类型。它属于整数类型的别名，可能是有符号的，也可能是无符号的，由当前实现决定。该类型的长度为16位（2个字节）或32位（4个字节），足以容纳当前系统的所有字符。它定义在头文件<code>wchar.h</code>里面。</p>
<p>宽字符的字面量必须加上前缀“L”，否则 C 语言会把字面量当作窄字符类型处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set_locale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span> c = <span class="string">L&#x27;牛&#x27;</span>；</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lc\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span>* s = <span class="string">L&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ls\n&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<p>上面示例中，前缀“L”在单引号前面，表示宽字符，对应<code>printf()</code>的占位符为<code>%lc</code>；在双引号前面，表示宽字符串，对应<code>printf()</code>的占位符为<code>%ls</code>。</p>
<p>宽字符串的结尾也有一个空字符，不过是宽空字符，占用多个字节。</p>
<p>处理宽字符，需要使用宽字符专用的函数，绝大部分都定义在头文件<code>wchar.h</code>。</p>
<h3 id="多字节字符处理函数"><a href="#多字节字符处理函数" class="headerlink" title="多字节字符处理函数"></a>多字节字符处理函数</h3><h4 id="mblen"><a href="#mblen" class="headerlink" title="mblen()"></a>mblen()</h4><p><code>mblen()</code>函数返回一个多字节字符占用的字符数。它的原型定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mblen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* mbstr, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，第一个参数是多字节字符串指针，一般会检查该字符串的第一个字符；第二个参数是需要检查的字节数，这个数字不能大于当前系统单个字符占用的最大字节，一般使用<code>MB_CUR_MAX</code>。</p>
<p>它的返回值是该字符占用的字节数。如果当前字符是空的宽字符，则返回<code>0</code>；如果当前字符不是有效的多字节字符，则返回<code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* mbs1 = <span class="string">&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mblen(mbs1, MB_CUR_MAX)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* mbs2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mblen(mbs2, MB_CUR_MAX)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，字符串“春天”的第一个字符“春”，占用3个字节；字符串“abc”的第一个字符“a”，占用1个字节。</p>
<h4 id="wctomb"><a href="#wctomb" class="headerlink" title="wctomb()"></a>wctomb()</h4><p><code>wctomb()</code>函数（wide character to multibyte）用于将宽字符转为多字节字符。它的原型定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wctomb</span><span class="params">(<span class="type">char</span>* s, <span class="type">wchar_t</span> wc)</span>;</span><br></pre></td></tr></table></figure>

<p><code>wctomb()</code>接受两个参数，第一个参数是作为目标的多字节字符数组，第二个参数是需要转换的一个宽字符。它的返回值是多字节字符存储占用的字节数量，如果无法转换，则返回<code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span> wc = <span class="string">L&#x27;牛&#x27;</span>;</span><br><span class="line"><span class="type">char</span> mbStr[<span class="number">10</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nBytes = <span class="number">0</span>;</span><br><span class="line">nBytes = wctomb(mbStr, wc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mbStr);  <span class="comment">// 牛</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>wctomb()</code>将宽字符“牛”转为多字节字符，<code>wctomb()</code>的返回值表示转换后的多字节字符占用3个字节。</p>
<h4 id="mbtowc"><a href="#mbtowc" class="headerlink" title="mbtowc()"></a>mbtowc()</h4><p><code>mbtowc()</code>用于将多字节字符转为宽字符。它的原型定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mbtowc</span><span class="params">(</span></span><br><span class="line"><span class="params">   <span class="type">wchar_t</span>* wchar,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="type">char</span>* mbchar,</span></span><br><span class="line"><span class="params">   <span class="type">size_t</span> count</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受3个参数，第一个参数是作为目标的宽字符指针，第二个参数是待转换的多字节字符指针，第三个参数是多字节字符的字节数。</p>
<p>它的返回值是多字节字符的字节数，如果转换失败，则返回<code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* mbchar = <span class="string">&quot;牛&quot;</span>;</span><br><span class="line"><span class="type">wchar_t</span> wc;</span><br><span class="line"><span class="type">wchar_t</span>* pwc = &amp;wc;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nBytes = <span class="number">0</span>;</span><br><span class="line">nBytes = mbtowc(pwc, mbchar, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lc\n&quot;</span>, *pwc);  <span class="comment">// 牛</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>mbtowc()</code>将多字节字符“牛”转为宽字符<code>wc</code>，返回值是<code>mbchar</code>占用的字节数（占用3个字节）。</p>
<h4 id="wcstombs"><a href="#wcstombs" class="headerlink" title="wcstombs()"></a>wcstombs()</h4><p><code>wcstombs()</code>用来将宽字符串转换为多字节字符串。它的原型定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">wcstombs</span><span class="params">(</span></span><br><span class="line"><span class="params">   <span class="type">char</span>* mbstr,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="type">wchar_t</span>* wcstr,</span></span><br><span class="line"><span class="params">   <span class="type">size_t</span> count</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受三个参数，第一个参数<code>mbstr</code>是目标的多字节字符串指针，第二个参数<code>wcstr</code>是待转换的宽字符串指针，第三个参数<code>count</code>是用来存储多字节字符串的最大字节数。</p>
<p>如果转换成功，它的返回值是成功转换后的多字节字符串的字节数，不包括尾部的字符串终止符；如果转换失败，则返回<code>-1</code>。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> mbs[<span class="number">20</span>];</span><br><span class="line"><span class="type">wchar_t</span>* wcs = <span class="string">L&quot;春天&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nBytes = <span class="number">0</span>;</span><br><span class="line">nBytes = wcstombs(mbs, wcs, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mbs); <span class="comment">// 春天</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>wcstombs()</code>将宽字符串<code>wcs</code>转为多字节字符串<code>mbs</code>，返回值<code>6</code>表示写入<code>mbs</code>的字符串占用6个字节，不包括尾部的字符串终止符。</p>
<p>如果<code>wcstombs()</code>的第一个参数是 NULL，则返回转换成功所需要的目标字符串的字节数。</p>
<h4 id="mbstowcs"><a href="#mbstowcs" class="headerlink" title="mbstowcs()"></a>mbstowcs()</h4><p><code>mbstowcs()</code>用来将多字节字符串转换为宽字符串。它的原型定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">mbstowcs</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">wchar_t</span>* wcstr,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* mbstr,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> count</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受三个参数，第一个参数<code>wcstr</code>是目标宽字符串，第二个参数<code>mbstr</code>是待转换的多字节字符串，第三个参数是待转换的多字节字符串的最大字符数。</p>
<p>转换成功时，它的返回值是成功转换的多字节字符的数量；转换失败时，返回<code>-1</code>。如果返回值与第三个参数相同，那么转换后的宽字符串不是以 NULL 结尾的。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* mbs = <span class="string">&quot;天气不错&quot;</span>;</span><br><span class="line"><span class="type">wchar_t</span> wcs[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nBytes = <span class="number">0</span>;</span><br><span class="line">nBytes = mbstowcs(wcs, mbs, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ls\n&quot;</span>, wcs); <span class="comment">// 天气不错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，多字节字符串<code>mbs</code>被<code>mbstowcs()</code>转为宽字符串，成功转换了4个字符，所以该函数的返回值为4。</p>
<p>如果<code>mbstowcs()</code>的第一个参数为<code>NULL</code>，则返回目标宽字符串会包含的字符数量。</p>
<h2 id="assert-h"><a href="#assert-h" class="headerlink" title="assert.h"></a>assert.h</h2><h3 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h3><p><code>assert.h</code>头文件定义了宏<code>assert()</code>，用于在运行时确保程序符合指定条件，如果不符合，就报错终止运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(PI &gt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码在程序运行到这一行语句时，验证变量是否<code>PI</code>大于3。如果确实大于3，程序继续运行，否则就会终止运行，并且给出报错信息提示。</p>
<p><code>assert()</code>宏接受一个表达式作为参数，如果表达式的返回值非零，<code>assert()</code>就会报错，在标准错误流<code>stderr</code>中写入一条错误信息，显示没有通过的表达式，以及包含这个表达式的文件名和行号。最后，调用<code>abort()</code>函数终止程序（<code>abort()</code>函数的原型在<code>stdlib.h</code>头文件中）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z = x * x - y * y;</span><br><span class="line">assert(z &gt;= <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上面的<code>assert()</code>语句类似于下面的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (z &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;z less than 0&quot;</span>);</span><br><span class="line">  <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果断言失败，程序会中断执行，会显示下面的提示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assertion failed: (z &gt;= <span class="number">0</span>), function main, file /Users/assert.c, line <span class="number">14.</span></span><br></pre></td></tr></table></figure>

<p>上面报错的格式如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assertion failed: [expression], function [abc], file [xyz], line [nnn].</span><br></pre></td></tr></table></figure>

<p>上面代码中，方括号的部分使用实际数据替换掉。</p>
<p>使用 assert() 有几个好处：它不仅能自动标识文件和出问题的行号，还有一种无需更改代码就能开启或关闭 assert() 的机制。如果已经确认程序没有问题，不需要再做断言，就在<code>#include &lt;assert.h&gt;</code>语句的前面，定义一个宏<code>NDEBUG</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>然后，重新编译程序，编译器就会禁用文件中所有的 assert() 语句。如果程序又出现问题，可以移除这条<code>#define NDBUG</code>指令（或者把它注释掉），再次编译，这样就重新启用了 assert() 语句。</p>
<p>assert() 的缺点是，因为引入了额外的检查，增加了程序的运行时间。</p>
<h3 id="static-assert"><a href="#static-assert" class="headerlink" title="static_assert()"></a>static_assert()</h3><p>C11 引入了静态断言<code>static_assert()</code>，用于在编译阶段进行断言判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(constant-expression, <span class="built_in">string</span>-literal);</span><br></pre></td></tr></table></figure>

<p><code>static_assert()</code>接受两个参数，第一个参数<code>constant-expression</code>是一个常量表达式，第二个参数<code>string-literal</code>是一个提示字符串。如果第一个参数的值为false，会产生一条编译错误，第二个参数就是错误提示信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span>, <span class="string">&quot;64-bit code generation is not supported.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码的意思是，如果当前计算机的<code>int</code>类型不等于4个字节，就会编译报错。</p>
<p>注意，<code>static_assert()</code>只在编译阶段运行，无法获得变量的值。如果对变量进行静态断言，就会导致编译错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">positive</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">static_assert</span>(n &gt; <span class="number">0</span>, <span class="string">&quot;value must &gt; 0&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码会导致编译报错，因为编译时无法知道变量<code>n</code>的值。</p>
<p><code>static_assert()</code>的好处是，尽量在编译阶段发现错误，避免运行时再报错，节省开发时间。另外，有些<code>assert()</code>断言位于函数之中，如果不执行该函数，就不会报错，而<code>static_assert()</code>不管函数是否执行，都会进行断言判断。最后，<code>static_assert()</code>不会生成可执行代码，所以不会造成任何运行时的性能损失。</p>
<h2 id="ctype-h"><a href="#ctype-h" class="headerlink" title="ctype.h"></a>ctype.h</h2><p><code>ctype.h</code>头文件定义了一系列字符处理函数的原型。</p>
<h3 id="字符测试函数"><a href="#字符测试函数" class="headerlink" title="字符测试函数"></a>字符测试函数</h3><p>这些函数用来判断字符是否属于某种类型。</p>
<ul>
<li><code>isalnum()</code>：是否为字母数字</li>
<li><code>isalpha()</code>：是否为字母</li>
<li><code>isdigit()</code>：是否为数字</li>
<li><code>isxdigit()</code>：是否为十六进制数字符</li>
<li><code>islower()</code>：是否为小写字母</li>
<li><code>isupper()</code>：是否为大写字母</li>
<li><code>isblank()</code>：是否为标准的空白字符（包含空格、水平制表符或换行符）</li>
<li><code>isspace()</code>：是否为空白字符（空格、换行符、换页符、回车符、垂直制表符、水平制表符等）</li>
<li><code>iscntrl()</code>：是否为控制字符，比如 Ctrl + B</li>
<li><code>isprint()</code>：是否为可打印字符</li>
<li><code>isgraph()</code>：是否为空格以外的任意可打印字符</li>
<li><code>ispunct()</code>：是否为标点符号（除了空格、字母、数字以外的可打印字符）</li>
</ul>
<p>它们接受一个待测试的字符作为参数。注意，参数类型为<code>int</code>，而不是<code>char</code>，因为它们允许 EOF 作为参数。</p>
<p>如果参数字符属于指定类型，就返回一个非零整数（通常是<code>1</code>，表示为真），否则返回<code>0</code>（表示为伪）。</p>
<p>下面是一个例子，用户输入一个字符，程序判断是否为英文字母。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> ch = getchar();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch))</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;it is an alpha character.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;it is not an alpha character.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符映射函数"><a href="#字符映射函数" class="headerlink" title="字符映射函数"></a>字符映射函数</h3><p>这一类函数返回字符的某种对应形式，主要有两个函数。</p>
<ul>
<li><code>tolower()</code>：如果参数是大写字符，返回小写字符，否则返回原始参数。</li>
<li><code>toupper()</code>：如果参数是小写字符，返回大写字符，否则返回原始参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符转为大写</span></span><br><span class="line">ch = <span class="built_in">toupper</span>(ch);</span><br></pre></td></tr></table></figure>

<p>注意，这两个函数不会改变原始字符。</p>
<h2 id="errno-h"><a href="#errno-h" class="headerlink" title="errno.h"></a>errno.h</h2><h3 id="errno-变量"><a href="#errno-变量" class="headerlink" title="errno 变量"></a>errno 变量</h3><p><code>errno.h</code>声明了一个 int 类型的 errno 变量，用来存储错误码（正整数）。</p>
<p>如果这个变量有非零值，表示已经执行的程序发生了错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> y = <span class="built_in">sqrt</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;sqrt error; program terminated.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，计算一个负值的平方根是不允许的，会导致<code>errno</code>不等于<code>0</code>。</p>
<p>如果要检查某个函数是否发生错误，必须在即将调用该函数之前，将<code>errno</code>的值置为0，防止其他函数改变<code>errno</code>的值。</p>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>变量<code>errno</code>的值通常是两个宏<code>EDOM</code>或<code>ERANGE</code>。这两个宏都定义在<code>errno.h</code>。它们表示调用数学函数时，可能发生的两种错误。</p>
<ul>
<li>定义域错误（EDOM）：传递给函数的一个参数超出了函数的定义域。例如，负数传入<code>sqrt()</code>作为参数。</li>
<li>取值范围错误（ERANGE）：函数的返回值太大，无法用返回类型表示。例如，1000 传入<code>exp()</code>作为参数，因为 e^1000 太大，无法使用 double 类型表示。</li>
</ul>
<p>使用数学函数时，可以将<code>errno</code>的值与 EDOM 和 ERANGE 比较，用来确定到底发生了哪一类错误。</p>
<h2 id="float-h"><a href="#float-h" class="headerlink" title="float.h"></a>float.h</h2><p><code>float.h</code>定义了浮点数类型 float、double、long double 的一些宏，规定了这些类型的范围和精度。</p>
<p>(1) <code>FLT_ROUNDS</code></p>
<p>宏<code>FLT_ROUNDS</code>表示当前浮点数加法的四舍五入方向。</p>
<p>它有以下可能的值。</p>
<ul>
<li>-1：不确定。</li>
<li>0：向零舍入。</li>
<li>1：向最近的整数舍入。</li>
<li>2：向正无穷方向舍入。</li>
<li>3：向负无穷方向舍入。</li>
</ul>
<p>（2）<code>FLT_RADIX</code></p>
<p>宏<code>FLT_RADIX</code>表示科学计数法的指数部分的底（base），一般总是2。</p>
<p>（3）浮点数类型的最大值</p>
<ul>
<li><code>FLT_MAX</code></li>
<li><code>DBL_MAX</code></li>
<li><code>LDBL_MAX</code></li>
</ul>
<p>（4）浮点数类型的最小正值</p>
<ul>
<li><code>FLT_MIN</code></li>
<li><code>DBL_MIN</code></li>
<li><code>LDBL_MIN</code></li>
</ul>
<p>（5）两个同类型浮点数之间可表示的最小差值（最小精度）</p>
<ul>
<li><code>FLT_EPSILON</code></li>
<li><code>DBL_EPSILON</code></li>
<li><code>LDBL_EPSILON</code></li>
</ul>
<p>（6）<code>DECIMAL_DIG</code></p>
<p>宏<code>DECIMAL_DIG</code>表示十进制有效位数。</p>
<p>（7）<code>FLT_EVAL_METHOD</code></p>
<p>宏<code>FLT_EVAL_METHOD</code>表示浮点数运算时的类型转换。</p>
<p>它可能有以下值。</p>
<ul>
<li>-1：不确定。</li>
<li>0：在当前类型中运算。</li>
<li>1：float 和 double 类型的运算使用 double 类型的范围和精度求值。</li>
<li>2：所有浮点数类型的运算使用 long double 类型的范围和精度求值。</li>
</ul>
<p>（8）浮点数尾数部分的个数</p>
<ul>
<li><code>FLT_MANT_DIG</code></li>
<li><code>DBL_MANT_DIG</code></li>
<li><code>LDBL_MANT_DIG</code></li>
</ul>
<p>（9）浮点数指数部分有效数字的个数（十进制）</p>
<ul>
<li><code>FLT_DIG</code></li>
<li><code>DBL_DIG</code></li>
<li><code>LDBL_DIG</code></li>
</ul>
<p>（10）科学计数法的指数部分的最小次幂（负数）</p>
<ul>
<li><code>FLT_MIN_EXP</code></li>
<li><code>DBL_MIN_EXP</code></li>
<li><code>LDBL_MIN_EXP</code></li>
</ul>
<p>（11）科学计数法的指数部分的十进制最小次幂（负数）</p>
<ul>
<li><code>FLT_MIN_10_EXP</code></li>
<li><code>DBL_MIN_10_EXP</code></li>
<li><code>LDBL_MIN_10_EXP</code></li>
</ul>
<p>（12）科学计数法的指数部分的最大次幂</p>
<ul>
<li><code>FLT_MAX_EXP</code></li>
<li><code>DBL_MAX_EXP</code></li>
<li><code>LDBL_MAX_EXP</code></li>
</ul>
<p>科学计数法的指数部分的十进制最大次幂</p>
<ul>
<li><code>FLT_MAX_10_EXP</code></li>
<li><code>DBL_MAX_10_EXP</code></li>
<li><code>LDBL_MAX_10_EXP</code></li>
</ul>
<h2 id="inttypes-h"><a href="#inttypes-h" class="headerlink" title="inttypes.h"></a>inttypes.h</h2><p>C 语言还在头文件 inttypes.h 里面，为 stdint.h 定义的四类整数类型，提供了<code>printf()</code>和<code>scanf()</code>的占位符。</p>
<ul>
<li>固定宽度整数类型，比如 int8_t。</li>
<li>最小宽度整数类型，比如 int_least8_t。</li>
<li>最快最小宽度整数类型，比如 int_fast8_t。</li>
<li>最大宽度整数类型，比如 intmax_t。</li>
</ul>
<p><code>printf()</code>的占位符采用<code>PRI + 原始占位符 + 类型关键字/宽度</code>的形式构成。举例来说，原始占位符为<code>%d</code>，则对应的占位符如下。</p>
<ul>
<li>PRIdn （固定宽度类型）</li>
<li>PRIdLEASTn （最小宽度类型）</li>
<li>PRIdFASTn （最快最小宽度类型）</li>
<li>PRIdMAX （最大宽度类型）</li>
</ul>
<p>上面占位符中的<code>n</code>，可以用8、16、32、64代入。</p>
<p>下面是用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int_least16_t</span> x = <span class="number">3490</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The value is %&quot;</span> PRIdLEAST16 <span class="string">&quot;!\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>PRIdLEAST16</code>对应的整数类型为 int_least16_t，原始占位符为<code>%d</code>。另外，<code>printf()</code>的第一个参数用到了多个字符串自动合并的写法。</p>
<p>下面是其它的原始占位符对应的占位符。</p>
<ul>
<li>%i：PRIin    PRIiLEASTn    PRIiFASTn    PRIiMAX</li>
<li>%o：PRIon    PRIoLEASTn    PRIoFASTn    PRIoMAX</li>
<li>%u：PRIun    PRIuLEASTn    PRIuFASTn    PRIuMAX</li>
<li>%x：PRIxn    PRIxLEASTn    PRIxFASTn    PRIxMAX</li>
<li>%X：PRIXn    PRIXLEASTn    PRIXFASTn    PRIXMAX</li>
</ul>
<p><code>scanf()</code>的占位符规则也与之类似。</p>
<ul>
<li>%d：SCNdn    SCNdLEASTn    SCNdFASTn    SCNdMAX</li>
<li>%i：SCNin    SCNiLEASTn    SCNiFASTn    SCNiMAX</li>
<li>%o：SCNon    SCNoLEASTn    SCNoFASTn    SCNoMAX</li>
<li>%u：SCNun    SCNuLEASTn    SCNuFASTn    SCNuMAX</li>
<li>%x：SCNxn    SCNxLEASTn    SCNxFASTn    SCNxMAX</li>
</ul>
<h2 id="iso646-h"><a href="#iso646-h" class="headerlink" title="iso646.h"></a>iso646.h</h2><p><code>iso646.h</code>头文件指定了一些常见运算符的替代拼写。比如，它用关键字<code>and</code>代替逻辑运算符<code>&amp;&amp;</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">6</span> and x &lt; <span class="number">12</span>)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">6</span> &amp;&amp; x &lt; <span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>它定义的替代拼写如下。</p>
<ul>
<li>and 替代 &amp;&amp;</li>
<li>and_eq 替代 &amp;&#x3D;</li>
<li>bitand 替代 &amp;</li>
<li>bitor 替代 |</li>
<li>compl 替代 ~</li>
<li>not 替代 !</li>
<li>not_eq 替代 !&#x3D;</li>
<li>or 替代 ||</li>
<li>or_eq 替代 |&#x3D;</li>
<li>xor 替代 ^</li>
<li>xor_eq 替代 ^&#x3D;</li>
</ul>
<h2 id="limits-h"><a href="#limits-h" class="headerlink" title="limits.h"></a>limits.h</h2><p><code>limits.h</code>提供了用来定义各种整数类型（包括字符类型）取值范围的宏。</p>
<ul>
<li><code>CHAR_BIT</code>：每个字符包含的二进制位数。</li>
<li><code>SCHAR_MIN</code>：signed char 类型的最小值。</li>
<li><code>SCHAR_MAX</code>：signed char 类型的最大值。</li>
<li><code>UCHAR_MAX</code>：unsiged char 类型的最大值。</li>
<li><code>CHAR_MIN</code>：char 类型的最小值。</li>
<li><code>CHAR_MAX</code>：char 类型的最大值。</li>
<li><code>MB_LEN_MAX</code>：多字节字符最多包含的字节数。</li>
<li><code>SHRT_MIN</code>：short int 类型的最小值。</li>
<li><code>SHRT_MAX</code>：short int 类型的最大值。</li>
<li><code>USHRT_MAX</code>：unsigned short int 类型的最大值。</li>
<li><code>INT_MIN</code>：int 类型的最小值。</li>
<li><code>INT_MAX</code>：int 类型的最大值。</li>
<li><code>UINT_MAX</code>：unsigned int 类型的最大值。</li>
<li><code>LONG_MIN</code>：long int 类型的最小值。</li>
<li><code>LONG_MAX</code>：long int 类型的最大值。</li>
<li><code>ULONG_MAX</code>：unsigned long int 类型的最大值。</li>
<li><code>LLONG_MIN</code>：long long int 类型的最小值。</li>
<li><code>LLONG_MAX</code>：long long int 类型的最大值。</li>
<li><code>ULLONG_MAX</code>：unsigned long long int 类型的最大值。</li>
</ul>
<p>下面的示例是使用预处理指令判断，int 类型是否可以用来存储大于 100000 的数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> INT_MAX &lt; 100000</span></span><br><span class="line">  <span class="meta">#<span class="keyword">error</span> int type is too small</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，如果 int 类型太小，预处理器会显示一条出错消息。</p>
<p>可以使用<code>limit.h</code>里面的宏，为类型别名选择正确的底层类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> INT_MAX &gt;= 100000</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">int</span> Quantity;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> Quantity;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，如果整数类型的最大值（<code>INT_MAX</code>）不小于100000，那么类型别名<code>Quantity</code>指向<code>int</code>，否则就指向<code>long int</code>。</p>
<h2 id="locale-h"><a href="#locale-h" class="headerlink" title="locale.h"></a>locale.h</h2><h3 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h3><p><code>locale.h</code>是程序的本地化设置，主要影响以下的行为。</p>
<ul>
<li>数字格式</li>
<li>货币格式</li>
<li>字符集</li>
<li>日期和时间格式</li>
</ul>
<p>它设置了以下几个宏。</p>
<ul>
<li>LC_COLLATE：影响字符串比较函数<code>strcoll()</code>和<code>strxfrm()</code>。</li>
<li>LC_CTYPE：影响字符处理函数的行为。</li>
<li>LC_MONETARY：影响货币格式。</li>
<li>LC_NUMERIC：影响<code>printf()</code>的数字格式。</li>
<li>LC_TIME：影响时间格式<code>strftime()</code>和<code>wcsftime()</code>。</li>
<li>LC_ALL：将以上所有类别设置为给定的语言环境。</li>
</ul>
<h3 id="setlocale"><a href="#setlocale" class="headerlink" title="setlocale()"></a>setlocale()</h3><p><code>setlocale()</code>用来设置当前的地区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">setlocal</span><span class="params">(<span class="type">int</span> category, <span class="type">const</span> <span class="type">char</span>* locale)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数。第一个参数表示影响范围，如果值为前面五个表示类别的宏之一，则只影响该宏对应的类别，如果值为<code>LC_ALL</code>，则影响所有类别。第二个参数通常只为<code>&quot;C&quot;</code>（正常模式）或<code>&quot;&quot;</code>（本地模式）。</p>
<p>任意程序开始时，都隐含下面的调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;C&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>下面的语句将格式本地化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_locale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，第二个参数为空字符，表示使用当前环境提供的本地化设置。</p>
<p>理论上，第二个参数也可以设为当前系统支持的某种格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;en_US.UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但是这样的话，程序的可移植性就变差了，因为无法保证其他系统也会支持那种格式。所以，通常都将第二个参数设为空字符串，使用操作系统的当前设置。</p>
<p><code>setlocale()</code>的返回值是一个字符串指针，表示已经设置好的格式。如果调用失败，则返回空指针 NULL。</p>
<p><code>setlocale()</code>可以用来查询当前地区，这时第二个参数设为 NULL 就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *loc;</span><br><span class="line"></span><br><span class="line">loc = setlocale(LC_ALL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 Starting locale: C</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Starting locale: %s\n&quot;</span>, loc);</span><br><span class="line"></span><br><span class="line">loc = setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 Native locale: en_US.UTF-8    </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Native locale: %s\n&quot;</span>, loc);</span><br></pre></td></tr></table></figure>

<h3 id="localeconv"><a href="#localeconv" class="headerlink" title="localeconv()"></a>localeconv()</h3><p><code>localeconv()</code>用来获取当前格式的详细信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> lconv* <span class="title function_">localeconv</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数返回一个 Struct 结构指针，该结构里面包含了格式信息，它的主要属性如下。</p>
<ul>
<li>char* mon_decimal_point：货币的十进制小数点字符，比如<code>.</code>。</li>
<li>char* mon_thousands_sep：货币的千位分隔符，比如<code>,</code>。</li>
<li>char* mon_grouping：货币的分组描述符。</li>
<li>char* positive_sign：货币的正值符号，比如<code>+</code>或为空字符串。</li>
<li>char* negative_sign：货币的负值符号，比如<code>-</code>。</li>
<li>char* currency_symbol：货币符号，比如<code>$</code>。</li>
<li>char frac_digits：打印货币金额时，十进制小数点后面输出几位小数，比如设为<code>2</code>。</li>
<li>char p_cs_precedes：设为<code>1</code>时，货币符号<code>currency_symbol</code>出现在非负金额前面。设为<code>0</code>时，出现在后面。</li>
<li>char n_cs_precedes：设为<code>1</code>时，货币符号<code>currency_symbol</code>出现在负的货币金额前面。设为<code>0</code>时，出现在后面。</li>
<li>char p_sep_by_space：决定了非负的货币金额与货币符号之间的分隔字符。</li>
<li>char n_sep_by_space：决定了负的货币金额与货币符号之间的分隔字符。</li>
<li>char p_sign_posn：决定了非负值的正值符号的位置。</li>
<li>char n_sign_posn：决定了负值的负值符号的位置。</li>
<li>char* int_curr_symbol：货币的国际符号，比如<code>USD</code>。</li>
<li>char int_frac_digits：使用国际符号时，<code>frac_digits</code>的值。</li>
<li>char int_p_cs_precedes：使用国际符号时，<code>p_cs_precedes</code>的值。</li>
<li>char int_n_cs_precedes：使用国际符号时，<code>n_cs_precedes</code>的值。</li>
<li>char int_p_sep_by_space：使用国际符号时，<code>p_sep_by_space</code>的值。</li>
<li>char int_n_sep_by_space：使用国际符号时，<code>n_sep_by_space</code>的值。</li>
<li>char int_p_sign_posn：使用国际符号时，<code>p_sign_posn</code>的值。</li>
<li>char int_n_sign_posn：使用国际符号时，<code>n_sign_posn</code>的值。</li>
</ul>
<p>下面程序打印当前系统的属性值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setlocale (LC_ALL,<span class="string">&quot;zh_CN&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lconv</span> * <span class="title">lc</span>;</span></span><br><span class="line">    lc=localeconv();</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;decimal_point: %s\n&quot;</span>,lc-&gt;decimal_point);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;thousands_sep: %s\n&quot;</span>,lc-&gt;thousands_sep);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;grouping: %s\n&quot;</span>,lc-&gt;grouping);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;int_curr_symbol: %s\n&quot;</span>,lc-&gt;int_curr_symbol);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;currency_symbol: %s\n&quot;</span>,lc-&gt;currency_symbol);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;mon_decimal_point: %s\n&quot;</span>,lc-&gt;mon_decimal_point);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;mon_thousands_sep: %s\n&quot;</span>,lc-&gt;mon_thousands_sep);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;mon_grouping: %s\n&quot;</span>,lc-&gt;mon_grouping);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;positive_sign: %s\n&quot;</span>,lc-&gt;positive_sign);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;negative_sign: %s\n&quot;</span>,lc-&gt;negative_sign);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;frac_digits: %d\n&quot;</span>,lc-&gt;frac_digits);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;p_cs_precedes: %d\n&quot;</span>,lc-&gt;p_cs_precedes);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;n_cs_precedes: %d\n&quot;</span>,lc-&gt;n_cs_precedes);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;p_sep_by_space: %d\n&quot;</span>,lc-&gt;p_sep_by_space);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;n_sep_by_space: %d\n&quot;</span>,lc-&gt;n_sep_by_space);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;p_sign_posn: %d\n&quot;</span>,lc-&gt;p_sign_posn);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;n_sign_posn: %d\n&quot;</span>,lc-&gt;n_sign_posn);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;int_frac_digits: %d\n&quot;</span>,lc-&gt;int_frac_digits);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;int_p_cs_precedes: %d\n&quot;</span>,lc-&gt;int_p_cs_precedes);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;int_n_cs_precedes: %d\n&quot;</span>,lc-&gt;int_n_cs_precedes);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;int_p_sep_by_space: %d\n&quot;</span>,lc-&gt;int_p_sep_by_space);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;int_n_sep_by_space: %d\n&quot;</span>,lc-&gt;int_n_sep_by_space);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;int_p_sign_posn: %d\n&quot;</span>,lc-&gt;int_p_sign_posn);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;int_n_sign_posn: %d\n&quot;</span>,lc-&gt;int_n_sign_posn);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="math-h"><a href="#math-h" class="headerlink" title="math.h"></a>math.h</h2><p><code>math.h</code>头文件提供了很多数学函数。</p>
<p>很多数学函数的返回值是 double 类型，但是同时提供 float 类型与 long double 类型的版本，比如<code>pow()</code>函数就还有<code>powf()</code>和<code>powl()</code>版本。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>      <span class="title function_">pow</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>; </span><br><span class="line"><span class="type">float</span>       <span class="title function_">powf</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="title function_">powl</span><span class="params">(<span class="type">long</span> <span class="type">double</span> x, <span class="type">long</span> <span class="type">double</span> y)</span>;</span><br></pre></td></tr></table></figure>

<p>为了简洁，下面就略去了函数的<code>f</code>后缀（float 类型）和<code>l</code>后缀（long double）版本。</p>
<h3 id="类型和宏"><a href="#类型和宏" class="headerlink" title="类型和宏"></a>类型和宏</h3><p>math.h 新定义了两个类型别名。</p>
<ul>
<li>float_t：（当前系统）最有效执行 float 运算的类型，宽度至少与 float 一样。</li>
<li>double_t&#96;：（当前系统）最有效执行 double 运算的类型，宽度至少与 double 一样。</li>
</ul>
<p>它们的具体类型可以通过宏<code>FLT_EVAL_METHOD</code>来了解。</p>
<table>
<thead>
<tr>
<th>FLT_EVAL_METHOD 的值</th>
<th>float_t 对应的类型</th>
<th>double_t 对应的类型</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>float</td>
<td>double</td>
</tr>
<tr>
<td>1</td>
<td>double</td>
<td>double</td>
</tr>
<tr>
<td>2</td>
<td>long double</td>
<td>long double</td>
</tr>
<tr>
<td>其他</td>
<td>由实现决定</td>
<td>由实现决定</td>
</tr>
</tbody></table>
<p>math.h 还定义了一些宏。</p>
<ul>
<li><code>INFINITY</code>：表示正无穷，返回一个 float 类型的值。</li>
<li><code>NAN</code>：表示非数字（Not-A-Number），返回一个 float 类型的值。</li>
</ul>
<h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><p>数学函数的报错有以下类型。</p>
<ul>
<li>Range errors：运算结果不能用函数返回类型表示。</li>
<li>Domain errors：函数参数不适用当前函数。</li>
<li>Pole errors：参数导致函数的极限值变成无限。</li>
<li>Overflow errors：运算结果太大，导致溢出。</li>
<li>Underflow errors：运算结果太小，导致溢出。</li>
</ul>
<p>变量<code>math_errhandling</code>提示了当前系统如何处理数学运算错误。</p>
<table>
<thead>
<tr>
<th>math_errhandling 的值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MATH_ERRNO</td>
<td>系统使用 errno 表示数学错误</td>
</tr>
<tr>
<td>MATH_ERREXCEPT</td>
<td>系统使用异常表示数学错误</td>
</tr>
<tr>
<td>MATH_ERRNO</td>
<td>MATH_ERREXCEPT</td>
</tr>
</tbody></table>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>数学函数的参数可以分成以下几类：正常值，无限值，有限值和非数字。</p>
<p>下面的函数用来判断一个值的类型。</p>
<ul>
<li>fpclassify()：返回给定浮点数的分类。</li>
<li>isfinite()：如果参数不是无限或 NaN，则为真。</li>
<li>isinf()：如果参数是无限的，则为真。</li>
<li>isnan()：如果参数不是数字，则为真。</li>
<li>isnormal()：如果参数是正常数字，则为真。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isfinite(<span class="number">1.23</span>)    <span class="comment">// 1</span></span><br><span class="line">isinf(<span class="number">1</span>/<span class="built_in">tan</span>(<span class="number">0</span>))   <span class="comment">// 1</span></span><br><span class="line">isnan(<span class="built_in">sqrt</span>(<span class="number">-1</span>))   <span class="comment">// 1</span></span><br><span class="line">isnormal(<span class="number">1e-310</span>)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="signbit"><a href="#signbit" class="headerlink" title="signbit()"></a>signbit()</h3><p><code>signbit()</code>判断参数是否带有符号。如果参数为负值，则返回1，否则返回0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signbit(<span class="number">3490.0</span>) <span class="comment">// 0</span></span><br><span class="line">signbit(<span class="number">-37.0</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>以下是三角函数，参数为弧度值。</p>
<ul>
<li>acos()：反余弦。</li>
<li>asin()：反正弦。</li>
<li>atan()：反正切</li>
<li>atan2()：反正切。</li>
<li>cos()：余弦。</li>
<li>sin()：正弦。</li>
<li>tan()：正切。</li>
</ul>
<p>不要忘了，上面所有函数都有 float 版本（函数名加上 f 后缀）和 long double 版本（函数名加上 l 后缀）。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cos</span>(PI/<span class="number">4</span>) <span class="comment">// 0.707107</span></span><br></pre></td></tr></table></figure>

<h3 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h3><p>以下是双曲函数，参数都为浮点数。</p>
<ul>
<li>acosh()：反双曲余弦。</li>
<li>asinh()：反双曲正弦。</li>
<li>atanh()：反双曲正切。</li>
<li>cosh()：双曲余弦。</li>
<li>tanh()：双曲正切。</li>
<li>sinh()：双曲正弦。</li>
</ul>
<h3 id="指数函数和对数函数"><a href="#指数函数和对数函数" class="headerlink" title="指数函数和对数函数"></a>指数函数和对数函数</h3><p>以下是指数函数和对数函数，它们的返回值都是 double 类型。</p>
<ul>
<li>exp()：计算欧拉数 e 的乘方，即 e<sup>x</sup>。</li>
<li>exp2()：计算 2 的乘方，即 2<sup>x</sup>。</li>
<li>expm1()：计算 e<sup>x</sup> - 1。</li>
<li>log()：计算自然对数，<code>exp()</code>的逆运算。</li>
<li>log2()：计算以2为底的对数。</li>
<li>log10()：计算以10为底的对数。</li>
<li>logp1()：计算一个数加 1 的自然对数，即<code>ln(x + 1)</code>。</li>
<li>logb()：计算以宏<code>FLT_RADIX</code>（一般为2）为底的对数，但只返回整数部分。</li>
</ul>
<p>下面是一些例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exp</span>(<span class="number">3.0</span>) <span class="comment">// 20.085500</span></span><br><span class="line"><span class="built_in">log</span>(<span class="number">20.0855</span>) <span class="comment">// 3.000000</span></span><br><span class="line"><span class="built_in">log10</span>(<span class="number">10000</span>) <span class="comment">// 3.000000</span></span><br></pre></td></tr></table></figure>

<p>如果结果值超出了 C 语言可以表示的最大值，函数将返回<code>HUGE_VAL</code>，它是一个在<code>math.h</code>中定义的 double 类型的值。</p>
<p>如果结果值太小，无法用 double 值表示，函数将返回0。以上这两种情况都属于出错。</p>
<h3 id="frexp"><a href="#frexp" class="headerlink" title="frexp()"></a>frexp()</h3><p><code>frexp()</code>将参数分解成浮点数和指数部分（2为底数），比如 1234.56 可以写成 0.6028125 * 2<sup>11</sup>，这个函数就能分解出 0.6028125 和 11。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">frexp</span><span class="params">(<span class="type">double</span> value, <span class="type">int</span>* <span class="built_in">exp</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，第一个参数是用来分解的浮点数，第二个参数是一个整数变量指针。</p>
<p>它返回小数部分，并将指数部分放入变量<code>exp</code>。如果参数为<code>0</code>，则返回的小数部分和指数部分都为<code>0</code>。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> frac;</span><br><span class="line"><span class="type">int</span> expt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// expt 的值是 11</span></span><br><span class="line">frac = <span class="built_in">frexp</span>(<span class="number">1234.56</span>, &amp;expt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1234.56 = 0.6028125 x 2^11</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1234.56 = %.7f x 2^%d\n&quot;</span>, frac, expt);</span><br></pre></td></tr></table></figure>

<h3 id="ilogb"><a href="#ilogb" class="headerlink" title="ilogb()"></a>ilogb()</h3><p><code>ilogb()</code>返回一个浮点数的指数部分，指数的基数是宏<code>FLT_RADIX</code>（一般是<code>2</code>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ilogb</span><span class="params">(<span class="type">double</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>它的参数为<code>x</code>，返回值是 log<sub>r</sub>|x|，其中<code>r</code>为宏<code>FLT_RADIX</code>。</p>
<p>下面是用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ilogb(<span class="number">257</span>) <span class="comment">// 8</span></span><br><span class="line">ilogb(<span class="number">256</span>) <span class="comment">// 8</span></span><br><span class="line">ilogb(<span class="number">255</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<h3 id="ldexp"><a href="#ldexp" class="headerlink" title="ldexp()"></a>ldexp()</h3><p><code>ldexp()</code>将一个数乘以2的乘方。它可以看成是<code>frexp()</code>的逆运算，将小数部分和指数部分合成一个<code>f * 2^n</code>形式的浮点数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">ldexp</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> <span class="built_in">exp</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，第一个参数是乘数<code>x</code>，第二个参数是2的指数部分<code>exp</code>，返回“x * 2<sup>exp</sup>”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ldexp</span>(<span class="number">1</span>, <span class="number">10</span>) <span class="comment">// 1024.000000</span></span><br><span class="line"><span class="built_in">ldexp</span>(<span class="number">3</span>, <span class="number">2</span>) <span class="comment">// 12.000000</span></span><br><span class="line"><span class="built_in">ldexp</span>(<span class="number">0.75</span>, <span class="number">4</span>) <span class="comment">// 12.000000</span></span><br><span class="line"><span class="built_in">ldexp</span>(<span class="number">0.5</span>, <span class="number">-1</span>) <span class="comment">// 0.250000</span></span><br></pre></td></tr></table></figure>

<h3 id="modf"><a href="#modf" class="headerlink" title="modf()"></a>modf()</h3><p><code>modf()</code>函数提取一个数的整数部分和小数部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">modf</span><span class="params">(<span class="type">double</span> value, <span class="type">double</span>* iptr)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，第一个参数<code>value</code>表示待分解的数值，第二个参数是浮点数变量<code>iptr</code>。返回值是<code>value</code>的小数部分，整数部分放入变量<code>double</code>。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int_part 的值是 3.0</span></span><br><span class="line"><span class="built_in">modf</span>(<span class="number">3.14159</span>, &amp;int_part); <span class="comment">// 返回 0.14159</span></span><br></pre></td></tr></table></figure>

<h3 id="scalbn"><a href="#scalbn" class="headerlink" title="scalbn()"></a>scalbn()</h3><p><code>scalbn()</code>用来计算“x * r<sup>n</sup>”，其中<code>r</code>是宏<code>FLT_RADIX</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">scalbn</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，第一个参数<code>x</code>是乘数部分，第二个参数<code>n</code>是指数部分，返回值是“x * r<sup>n</sup>”。</p>
<p>下面是一些例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scalbn(<span class="number">2</span>, <span class="number">8</span>) <span class="comment">// 512.000000</span></span><br></pre></td></tr></table></figure>

<p>这个函数有多个版本。</p>
<ul>
<li>scalbn()：指数 n 是 int 类型。</li>
<li>scalbnf()：float 版本的 scalbn()。</li>
<li>scalbnl()：long double 版本的 scalbn()。</li>
<li>scalbln()：指数 n 是 long int 类型。</li>
<li>scalblnf()：float 版本的 scalbln()。</li>
<li>scalblnl()：long double 版本的 scalbln()。</li>
</ul>
<h3 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h3><p><code>round()</code>函数以传统方式进行四舍五入，比如<code>1.5</code>舍入到<code>2</code>，<code>-1.5</code>舍入到<code>-2</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>它返回一个浮点数。</p>
<p>下面是一些例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">round(<span class="number">3.14</span>)  <span class="comment">// 3.000000</span></span><br><span class="line">round(<span class="number">3.5</span>)   <span class="comment">// 4.000000</span></span><br><span class="line">round(<span class="number">-1.5</span>)  <span class="comment">// -2.000000</span></span><br><span class="line">round(<span class="number">-1.14</span>) <span class="comment">// -1.000000</span></span><br></pre></td></tr></table></figure>

<p>它还有一些其他版本。</p>
<ul>
<li>lround()：返回值是 long int 类型。</li>
<li>llround()：返回值是 long long int 类型。</li>
</ul>
<h3 id="trunc"><a href="#trunc" class="headerlink" title="trunc()"></a>trunc()</h3><p><code>trunc()</code>用来截去一个浮点数的小数部分，将剩下的整数部分以浮点数的形式返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">trunc</span><span class="params">(<span class="type">double</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>下面是一些例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trunc(<span class="number">3.14</span>)  <span class="comment">// 3.000000</span></span><br><span class="line">trunc(<span class="number">3.8</span>)   <span class="comment">// 3.000000</span></span><br><span class="line">trunc(<span class="number">-1.5</span>)  <span class="comment">// -1.000000</span></span><br><span class="line">trunc(<span class="number">-1.14</span>) <span class="comment">// -1.000000</span></span><br></pre></td></tr></table></figure>

<h3 id="ceil"><a href="#ceil" class="headerlink" title="ceil()"></a>ceil()</h3><p><code>ceil()</code>返回不小于其参数的最小整数（double 类型），属于“向上舍入”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">ceil</span><span class="params">(<span class="type">double</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>下面是一些例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ceil</span>(<span class="number">7.1</span>) <span class="comment">// 8.0</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">7.9</span>) <span class="comment">// 8.0</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">-7.1</span>) <span class="comment">// -7.0</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">-7.9</span>) <span class="comment">// -7.0</span></span><br></pre></td></tr></table></figure>

<h3 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h3><p><code>floor()</code>返回不大于其参数的最大整数，属于“向下舍入”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">floor</span><span class="params">(<span class="type">double</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>下面是一些例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">floor</span>(<span class="number">7.1</span>) <span class="comment">// 7.0</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">7.9</span>) <span class="comment">// 7.0</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">-7.1</span>) <span class="comment">// -8.0</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="number">-7.9</span>) <span class="comment">// -8.0</span></span><br></pre></td></tr></table></figure>

<p>下面的函数可以实现“四舍五入”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">round_nearest</span><span class="params">(<span class="type">double</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0.0</span> ? <span class="built_in">ceil</span>(x - <span class="number">0.5</span>) : <span class="built_in">floor</span>(x + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fmod"><a href="#fmod" class="headerlink" title="fmod()"></a>fmod()</h3><p><code>fmod()</code>返回第一个参数除以第二个参数的余数，就是余值运算符<code>%</code>的浮点数版本，因为<code>%</code>只能用于整数运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">fmod</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>;</span><br></pre></td></tr></table></figure>

<p>它在幕后执行的计算是<code>x - trunc(x / y) * y</code>，返回值的符号与<code>x</code>的符号相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fmod</span>(<span class="number">5.5</span>, <span class="number">2.2</span>)  <span class="comment">//  1.100000</span></span><br><span class="line"><span class="built_in">fmod</span>(<span class="number">-9.2</span>, <span class="number">5.1</span>) <span class="comment">// -4.100000</span></span><br><span class="line"><span class="built_in">fmod</span>(<span class="number">9.2</span>, <span class="number">5.1</span>)  <span class="comment">//  4.100000</span></span><br></pre></td></tr></table></figure>

<h3 id="浮点数比较函数"><a href="#浮点数比较函数" class="headerlink" title="浮点数比较函数"></a>浮点数比较函数</h3><p>以下函数用于两个浮点数的比较，返回值的类型是整数。</p>
<ul>
<li>isgreater()：返回<code>x &gt; y</code>的结果。</li>
<li>isgreaterequal()：返回<code>x &gt;= y</code>的结果。</li>
<li>isless()：返回<code>x &lt; y</code>的结果。</li>
<li>islessequal()：返回<code>x &lt;= y</code>的结果。</li>
<li>islessgreater()：返回<code>(x &lt; y) || (x &gt; y)</code>的结果。</li>
</ul>
<p>下面是一些例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isgreater(<span class="number">10.0</span>, <span class="number">3.0</span>)   <span class="comment">// 1</span></span><br><span class="line">isgreaterequal(<span class="number">10.0</span>, <span class="number">10.0</span>)   <span class="comment">// 1</span></span><br><span class="line">isless(<span class="number">10.0</span>, <span class="number">3.0</span>)  <span class="comment">// 0</span></span><br><span class="line">islessequal(<span class="number">10.0</span>, <span class="number">3.0</span>)   <span class="comment">// 0</span></span><br><span class="line">islessgreater(<span class="number">10.0</span>, <span class="number">3.0</span>)   <span class="comment">// 1</span></span><br><span class="line">islessgreater(<span class="number">10.0</span>, <span class="number">30.0</span>)   <span class="comment">// 1</span></span><br><span class="line">islessgreater(<span class="number">10.0</span>, <span class="number">10.0</span>)   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="isunordered"><a href="#isunordered" class="headerlink" title="isunordered()"></a>isunordered()</h3><p><code>isunordered()</code>返回两个参数之中，是否存在 NAN。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isunordered</span><span class="params">(any_floating_type x, any_floating_type y)</span>;</span><br></pre></td></tr></table></figure>

<p>下面是一些例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isunordered(<span class="number">1.0</span>, <span class="number">2.0</span>)    <span class="comment">// 0</span></span><br><span class="line">isunordered(<span class="number">1.0</span>, <span class="built_in">sqrt</span>(<span class="number">-1</span>))  <span class="comment">// 1</span></span><br><span class="line">isunordered(NAN, <span class="number">30.0</span>)  <span class="comment">// 1</span></span><br><span class="line">isunordered(NAN, NAN)   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><p>下面是 math.h 包含的其它函数。</p>
<ul>
<li>pow()：计算参数<code>x</code>的<code>y</code>次方。</li>
<li>sqrt()：计算一个数的平方根。</li>
<li>cbrt()：计算立方根。</li>
<li>fabs()：计算绝对值。</li>
<li>hypot()：根据直角三角形的两条直角边，计算斜边。</li>
<li>fmax()：返回两个参数之中的最大值。</li>
<li>fmin()：返回两个参数之中的最小值。</li>
<li>remainder()：返回 IEC 60559 标准的余数，类似于<code>fmod()</code>，但是余数范围是从<code>-y/2</code>到<code>y/2</code>，而不是从<code>0</code>到<code>y</code>。</li>
<li>remquo()：同时返回余数和商，余数的计算方法与<code>remainder()</code>相同。</li>
<li>copysign()：返回一个大小等于第一个参数、符号等于第二个参数的值。</li>
<li>nan()：返回 NAN。  </li>
<li>nextafter()：获取下一个（或者上一个，具体方向取决于第二个参数<code>y</code>）当前系统可以表示的浮点值。</li>
<li>nextoward()：与<code>nextafter()</code>相同，除了第二个参数是 long double 类型。</li>
<li>fdim()：如果第一个参数减去第二个参数大于<code>0</code>，则返回差值，否则返回<code>0</code>。</li>
<li>fma()：以快速计算的方式，返回<code>x * y + z</code>的结果。</li>
<li>nearbyint()：在当前舍入方向上，舍入到最接近的整数。当前舍入方向可以使用<code>fesetround()</code>函数设定。</li>
<li>rint()：在当前舍入方向上，舍入到最接近的整数，与<code>nearbyint()</code>相同。不同之处是，它会触发浮点数的<code>INEXACT</code>异常。</li>
<li>lrint()：在当前舍入方向上，舍入到最接近的整数，与<code>rint()</code>相同。不同之处是，返回值是一个整数，而不是浮点数。</li>
<li>erf()：计算一个值的误差函数。</li>
<li>erfc()：计算一个值的互补误差函数。</li>
<li>tgamma()：计算 Gamma 函数。</li>
<li>lgamma()：计算 Gamma 函数绝对值的自然对数。</li>
</ul>
<p>下面是一些例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pow</span>(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 81.000000</span></span><br><span class="line"><span class="built_in">sqrt</span>(<span class="number">3.0</span>) <span class="comment">// 1.73205</span></span><br><span class="line">cbrt(<span class="number">1729.03</span>) <span class="comment">// 12.002384</span></span><br><span class="line"><span class="built_in">fabs</span>(<span class="number">-3490.0</span>) <span class="comment">// 3490.000000</span></span><br><span class="line">hypot(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 5.000000</span></span><br><span class="line">fmax(<span class="number">3.0</span>, <span class="number">10.0</span>) <span class="comment">// 10.000000</span></span><br><span class="line">fmin(<span class="number">10.0</span>, <span class="number">3.0</span>) <span class="comment">//  3.000000</span></span><br></pre></td></tr></table></figure>

<h2 id="signal-h"><a href="#signal-h" class="headerlink" title="signal.h"></a>signal.h</h2><h3 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h3><p><code>signal.h</code>提供了信号（即异常情况）的处理工具。所谓“信号”（signal），可以理解成系统与程序之间的短消息，主要用来表示运行时错误，或者发生了异常事件。</p>
<p>头文件<code>signal.h</code>定义了一系列宏，表示不同的信号。</p>
<ul>
<li>SIGABRT：异常中止（可能由于调用了 abort() 方法）。</li>
<li>SIGFPE：算术运算发生了错误（可能是除以 0 或者溢出）。</li>
<li>SIGILL：无效指令。</li>
<li>SIGINT：中断。</li>
<li>SIGSEGV：无效内存访问。</li>
<li>SIGTERM：终止请求。</li>
</ul>
<p>上面每个宏的值都是一个正整数常量。</p>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h3><p>头文件<code>signal.h</code>还定义了一个<code>signal()</code>函数，用来指定某种信号的处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGINT, handler);</span><br></pre></td></tr></table></figure>

<p><code>signal()</code>接受两个参数，第一个参数是某种信号的宏，第二个参数是处理这个信号的函数指针<code>handler</code>。</p>
<p>信号处理函数<code>handler</code>接受一个 int 类型的参数，表示信号类型。它的原型如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*func)(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p><code>handler</code>函数体内部可以根据这个整数，判断到底接受到了哪种信号，因为多个信号可以共用同一个处理函数。一旦处理函数执行完成，程序会从信号发生点恢复执行。但是，如果遇到 SIGABRT 信号，处理函数执行完成，系统会让程序中止。</p>
<p>当系统向程序发送信号时，程序可以忽略信号，即不指定处理函数。</p>
<p><code>signal()</code>的返回值是前一个处理函数的指针，常常把它保存在变量之中，当新的处理函数执行完，再恢复以前的处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*orig_handler)(<span class="type">int</span>);</span><br><span class="line">orig_handler = signal(SIGINT, handler);</span><br><span class="line"><span class="comment">// SIGINT 信号发生之后</span></span><br><span class="line">signal(SIGINT, orig_handler);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>signal()</code>为信号<code>SIGINT</code>指定了新的处理函数<code>handler</code>，把原来的处理函数保存在变量<code>orig_handler</code>里面。等到<code>handler</code>这个函数用过之后，再恢复原来的处理函数。</p>
<h3 id="信号相关的宏"><a href="#信号相关的宏" class="headerlink" title="信号相关的宏"></a>信号相关的宏</h3><p><code>signal.h</code>还提供了信号相关的宏。</p>
<p>（1）SIG_DFL</p>
<p>SIG_DFL 表示默认的处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGINT, SIG_DFL);</span><br></pre></td></tr></table></figure>

<p>上面示例中，SIGINT 的处理函数是默认处理函数，由当前实现决定。</p>
<p>（2）SIG_IGN</p>
<p>SIG_IGN 表示忽略该信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGINT, SIG_IGN);</span><br></pre></td></tr></table></figure>

<p>上面示例表示不对 SIGINT 信号进行处理。由于程序运行时按下 Ctrl + c 是发出 SIGINT 信号，所以使用该语句后，程序无法用 Ctrl + c 终止。</p>
<p>（3）SIG_ERR</p>
<p>SIG_ERR 是信号处理函数发生错误时，<code>signal()</code>的返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (signal(SIGINT, handler) == SIG_ERR) &#123;</span><br><span class="line">  perror(<span class="string">&quot;signal(SIGINT, handler) failed&quot;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例可以判断<code>handler</code>处理 SIGINT 时，是否发生错误。</p>
<h3 id="raise"><a href="#raise" class="headerlink" title="raise()"></a>raise()</h3><p><code>raise()</code>函数用来在程序中发出信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受一个信号值作为参数，表示发出该信号。它的返回值是一个整数，可以用来判断信号发出是否成功，0 表示成功，非 0 表示失败。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Handler called for signal %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(SIGINT, handler);</span><br><span class="line">raise(SIGINT);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>raise()</code>触发 SIGINT 信号，导致 handler 函数执行。</p>
<h2 id="stdarg-h"><a href="#stdarg-h" class="headerlink" title="stdarg.h"></a>stdarg.h</h2><p><code>stdarg.h</code>定义于函数的可变参数相关的一些方法。</p>
<ul>
<li>va_list 类型</li>
<li>va_start()</li>
<li>va_arg()：获取当前参数</li>
<li>va_end()。</li>
</ul>
<p>va_copy()：it makes a copy of your va_list variable in the exact same state.<br>va_copy() can be useful if you need to scan ahead through the arguments but need to also remember your current place.</p>
<p>接受可变函数作为参数的一些方法。</p>
<ul>
<li>vprintf()</li>
<li>vfprintf()</li>
<li>vsprintf()</li>
<li>vsnprintf()</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_printf</span><span class="params">(<span class="type">int</span> serial, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list va;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do my custom work</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The serial number is: %d\n&quot;</span>, serial);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then pass the rest off to vprintf()</span></span><br><span class="line">    va_start(va, format);</span><br><span class="line">    <span class="type">int</span> rv = <span class="built_in">vprintf</span>(format, va);</span><br><span class="line">    va_end(va);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">float</span> y = <span class="number">3.2</span>;</span><br><span class="line"></span><br><span class="line">    my_printf(<span class="number">3490</span>, <span class="string">&quot;x is %d, y is %f\n&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="stdbool-h"><a href="#stdbool-h" class="headerlink" title="stdbool.h"></a>stdbool.h</h2><p><code>stdbool.h</code>头文件定义了4个宏。</p>
<ul>
<li><code>bool</code>：定义为<code>_Bool</code>。</li>
<li><code>true</code>：定义为1。</li>
<li><code>false</code>：定义为0。</li>
<li><code>__bool_true_false_are_defined</code>：定义为1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isEven</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (number % <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> num;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> div;</span><br><span class="line">  <span class="type">bool</span> isPrime = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  num = <span class="number">64457</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (div = <span class="number">2</span>; (div * div) &lt;= num; div++) &#123;</span><br><span class="line">   <span class="keyword">if</span> (num % div == <span class="number">0</span>) isPrime = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isPrime) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu is prime.\n&quot;</span>, num);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu is not prime.\n&quot;</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="stddef-h"><a href="#stddef-h" class="headerlink" title="stddef.h"></a>stddef.h</h2><p><code>stddef.h</code>提供了常用类型和宏的定义，但没有声明任何函数。</p>
<p>这个头文件定义的类型如下。</p>
<ul>
<li>ptrdiff_t：指针相减运算时，返回结果的数据类型。</li>
<li>size_t：<code>sizeof</code>运算符返回的类型。</li>
<li>wchar_t：一种足够大、能容纳各种字符的类型。</li>
</ul>
<p>以上三个类型都是整数类型，其中<code>ptrdiff_t</code>是有符号整数，<code>size_t</code>是无符号整数。</p>
<p><code>stddef.h</code>定义了两个宏。</p>
<ul>
<li>NULL：空指针。</li>
<li>offsetof()</li>
</ul>
<h3 id="offsetof"><a href="#offsetof" class="headerlink" title="offsetof()"></a>offsetof()</h3><p><code>offsetof()</code>是<code>stddef.h</code>定义的一个宏，用来返回某个属性在 Struct 结构内部的起始位置。由于系统为了字节对齐，可能会在 Struct 结构的属性之间插入空字节，这个宏对于确定某个属性的内存位置很有用。</p>
<p>它是一个带参数的宏，接受两个参数。第一个参数是 Struct 结构，第二个参数是该结构的一个属性，返回 Struct 起始位置到该属性之间的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">int</span> b[<span class="number">2</span>];</span><br><span class="line">  <span class="type">float</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, offsetof(<span class="keyword">struct</span> s, a)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, offsetof(<span class="keyword">struct</span> s, b)); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, offsetof(<span class="keyword">struct</span> s, c)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>对于上面这个 Struct 结构，<code>offsetof(struct s, a)</code>一定等于<code>0</code>，因为<code>a</code>属性是第一个属性，与 Struct 结构自身的地址相同。</p>
<p>系统为了字节对齐，在<code>a</code>属性后面分配了3个空字节，导致<code>b</code>属性存储在第4个字节，所以<code>offsetof(struct s, b)</code>和<code>offsetof(struct s, c)</code>分别是4和12。</p>
<h2 id="stdint-h"><a href="#stdint-h" class="headerlink" title="stdint.h"></a>stdint.h</h2><h3 id="固定宽度的整数类型"><a href="#固定宽度的整数类型" class="headerlink" title="固定宽度的整数类型"></a>固定宽度的整数类型</h3><p>stdint.h 定义了一些固定宽度的整数类型别名，主要有下面三类。</p>
<ul>
<li>宽度完全确定的整数<code>intN_t</code>，比如<code>int32_t</code>。</li>
<li>宽度不小少于某个大小的整数<code>int_leastN_t</code>，比如<code>int_least8_t</code>。</li>
<li>宽度不小于某个大小、并且处理速度尽可能快的整数<code>int_fastN_t</code>，比如<code>int_fast64_t</code>。</li>
</ul>
<p>上面所有类型都是有符号的，类型名前面可以加一个前缀<code>u</code>，表示无符号类型，比如<code>uint16_t</code>。</p>
<p>C 语言标准要求至少定义以下类型。</p>
<ul>
<li>int8_t      uint8_t</li>
<li>int16_t     uint16_t</li>
<li>int32_t     uint32_t</li>
<li>int64_t     uint64_t</li>
<li>int_least8_t      uint_least8_t</li>
<li>int_least16_t     uint_least16_t</li>
<li>int_least32_t     uint_least32_t</li>
<li>int_least64_t     uint_least64_t</li>
<li>int_fast8_t       uint_fast8_t</li>
<li>int_fast16_t      uint_fast16_t</li>
<li>int_fast32_t      uint_fast32_t</li>
<li>int_fast64_t      uint_fast64_t</li>
</ul>
<h3 id="最大宽度的整数类型"><a href="#最大宽度的整数类型" class="headerlink" title="最大宽度的整数类型"></a>最大宽度的整数类型</h3><p>以下两个类型表示当前系统可用的最大宽度整数。</p>
<ul>
<li>intmax_t</li>
<li>uintmax_t</li>
</ul>
<p>如果想要尽可能大的整数时，可以使用上面类型。</p>
<h3 id="固定宽度的整数常量"><a href="#固定宽度的整数常量" class="headerlink" title="固定宽度的整数常量"></a>固定宽度的整数常量</h3><p>以下一些带参数的宏，可以生成固定宽度的整数常量。</p>
<ul>
<li>INT8_C(x)     UINT8_C(x)</li>
<li>INT16_C(x)    UINT16_C(x)</li>
<li>INT32_C(x)    UINT32_C(x)</li>
<li>INT64_C(x)    UINT64_C(x)</li>
<li>INTMAX_C(x)   UINTMAX_C(x)</li>
</ul>
<p>下面是用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> x = UINT16_C(<span class="number">12</span>);</span><br><span class="line"><span class="type">intmax_t</span> y = INTMAX_C(<span class="number">3490</span>);</span><br></pre></td></tr></table></figure>

<h3 id="固定宽度的整数极限值"><a href="#固定宽度的整数极限值" class="headerlink" title="固定宽度的整数极限值"></a>固定宽度的整数极限值</h3><p>下面一些宏代表了固定宽度的整数最大值和最小值。</p>
<ul>
<li>INT8_MAX           INT8_MIN           UINT8_MAX</li>
<li>INT16_MAX          INT16_MIN          UINT16_MAX</li>
<li>INT32_MAX          INT32_MIN          UINT32_MAX</li>
<li>INT64_MAX          INT64_MIN          UINT64_MAX</li>
<li>INT_LEAST8_MAX     INT_LEAST8_MIN     UINT_LEAST8_MAX</li>
<li>INT_LEAST16_MAX    INT_LEAST16_MIN    UINT_LEAST16_MAX</li>
<li>INT_LEAST32_MAX    INT_LEAST32_MIN    UINT_LEAST32_MAX</li>
<li>INT_LEAST64_MAX    INT_LEAST64_MIN    UINT_LEAST64_MAX</li>
<li>INT_FAST8_MAX      INT_FAST8_MIN      UINT_FAST8_MAX</li>
<li>INT_FAST16_MAX     INT_FAST16_MIN     UINT_FAST16_MAX</li>
<li>INT_FAST32_MAX     INT_FAST32_MIN     UINT_FAST32_MAX</li>
<li>INT_FAST64_MAX     INT_FAST64_MIN     UINT_FAST64_MAX</li>
<li>INTMAX_MAX         INTMAX_MIN         UINTMAX_MAX</li>
</ul>
<p>注意，所有无符号整数类型的最小值都为0，所以没有对应的宏。</p>
<h3 id="占位符-2"><a href="#占位符-2" class="headerlink" title="占位符"></a>占位符</h3><p>C 语言还在头文件 inttypes.h 里面，为上面类型定义了<code>printf()</code>和<code>scanf()</code>的占位符，参见《inttypes.h》一章。</p>
<h2 id="stdio-h"><a href="#stdio-h" class="headerlink" title="stdio.h"></a>stdio.h</h2><p><code>stdio.h</code>是 C 语言的标准 I&#x2F;O 库，用于读取和写入文件，也用于控制台的输入和输出。</p>
<h3 id="标准-I-x2F-O-函数"><a href="#标准-I-x2F-O-函数" class="headerlink" title="标准 I&#x2F;O 函数"></a>标准 I&#x2F;O 函数</h3><p>以下函数用于控制台的输入和输出。</p>
<ul>
<li>printf()：输出到控制台，详见《基本语法》一章。</li>
<li>scanf()：从控制台读取输入，详见《I&#x2F;O 函数》一章。</li>
<li>getchar()：从控制台读取一个字符，详见《I&#x2F;O 函数》一章。</li>
<li>putchar()：向控制台写入一个字符，详见《I&#x2F;O 函数》一章。</li>
<li>gets()：从控制台读取整行输入（已废除），详见《I&#x2F;O 函数》一章。</li>
<li>puts()：向控制台写入一个字符串，详见《I&#x2F;O 函数》一章。</li>
</ul>
<h3 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h3><p>以下函数用于文件操作，详见《文件操作》一章。</p>
<ul>
<li>fopen()：打开文件。</li>
<li>fclose()：关闭文件。</li>
<li>freopen()：打开一个新文件，关联一个已经打开的文件指针。</li>
<li>fprintf()：输出到文件。</li>
<li>fscanf()：从文件读取数据。</li>
<li>getc()：从文件读取一个字符。</li>
<li>fgetc()：从文件读取一个字符。</li>
<li>putc()：向文件写入一个字符。</li>
<li>fputc()：向文件写入一个字符。</li>
<li>fgets()：从文件读取整行。</li>
<li>fputs()：向文件写入字符串。</li>
<li>fread()：从文件读取二进制数据。</li>
<li>fwrite()：向文件写入二进制数据。</li>
<li>fseek()：将文件内部指针移到指定位置。</li>
<li>ftell()：获取文件内部指针的当前位置。</li>
<li>rewind()：将文件内部指针重置到文件开始处。</li>
<li>fgetpos()：获取文件内部指针的当前位置。</li>
<li>fsetpos()：设置文件内部指针的当前位置。</li>
<li>feof()：判断文件内部指针是否指向文件结尾。</li>
<li>ferror()：返回文件错误指示器的状态。</li>
<li>clearerr()：重置文件错误指示器。</li>
<li>remove()：删除文件。</li>
<li>rename()：文件改名，以及移动文件。</li>
</ul>
<h3 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h3><p>以下函数用于操作字符串，详见《字符串操作》一章。</p>
<ul>
<li>sscanf()：从字符串读取数据，详见《I&#x2F;O 函数》一章。</li>
<li>sprintf()：输出到字符串。</li>
<li>snprintf()：输出到字符串的更安全版本，指定了输出字符串的数量。</li>
</ul>
<h3 id="tmpfile"><a href="#tmpfile" class="headerlink" title="tmpfile()"></a>tmpfile()</h3><p><code>tmpfile()</code>函数创建一个临时文件，该文件只在程序运行期间存在，除非手动关闭它。它的原型如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* <span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>tmpfile()</code>返回一个文件指针，可以用于访问该函数创建的临时文件。如果创建失败，返回一个空指针 NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE* tempptr;</span><br><span class="line">tempptr = tmpfile();</span><br></pre></td></tr></table></figure>

<p>调用<code>close()</code>方法关闭临时文件后，该文件将被自动删除。</p>
<p><code>tmpfile()</code>有两个缺点。一是无法知道临时文件的文件名，二是无法让该文件成为永久文件。</p>
<h3 id="tmpnam"><a href="#tmpnam" class="headerlink" title="tmpnam()"></a>tmpnam()</h3><p><code>tmpname()</code>函数为临时文件生成一个名字，确保不会与其他文件重名。它的原型如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">tmpname</span><span class="params">(<span class="type">char</span>* s)</span>;</span><br></pre></td></tr></table></figure>

<p>它的参数是一个字符串变量，<code>tmpnam()</code>会把临时文件的文件名复制到这个变量里面，并返回指向该字符串变量的指针。如果生成文件名失败，<code>tmpnam()</code>返回空指针 NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> filename[L_tmpname];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmpnam(filename) != <span class="literal">NULL</span>)</span><br><span class="line">  <span class="comment">// 输出诸如 /tmp/filew9PMuZ 的文件名</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, filename);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Something wrong!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>L_tmpname</code>是<code>stdio.h</code>定义的一个宏，指定了临时文件的文件名长度。</p>
<p><code>tmpname()</code>的参数也可以是一个空指针 NULL，同样返回指向文件名字符串的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* filename;</span><br><span class="line">filename = tmpnam(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>filename</code>就是<code>tmpnam()</code>生成的文件名。</p>
<p>该函数只是生成一个文件名，稍后可以使用<code>fopen()</code>打开该文件并使用它。</p>
<h3 id="fflush"><a href="#fflush" class="headerlink" title="fflush()"></a>fflush()</h3><p><code>fflush()</code>用于清空缓存区。它接受一个文件指针作为参数，将缓存区内容写入该文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fflush(fp);</span><br></pre></td></tr></table></figure>

<p>如果不需要保存缓存区内容，则可以传入空指针 NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fflush(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>如果清空成功，<code>fflush()</code>返回0，否则返回 EOF。</p>
<p>注意，<code>fflush()</code>一般只用来清空输出缓存区（比如写文件）。如果使用它来清空输入缓存区（比如读文件），属于未定义行为。</p>
<p><code>fflush()</code>的一个用途是不等回车键，就强迫输出缓存区。大多数系统都是行缓存，这意味着只有遇到回车键（或者缓存区满了，或者文件读到结尾），缓存区的内容才会输出，<code>fflush()</code>可以不等回车键，立即输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\r%d&quot;</span>, i);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例是一个倒计时效果，<code>\r</code>是回车键，表示每轮循环都会回到当前行的行首，等于删除上一轮循环的输出。<code>fflush(stdout)</code>表示立即将缓存输出到显示器，这一行是必需的，否则由于上一行的输出没有回车键，不会触发缓存输出，屏幕上不会显示任何内容，只会等到程序运行结束再一次性输出。</p>
<h3 id="setvbuf"><a href="#setvbuf" class="headerlink" title="setvbuf()"></a>setvbuf()</h3><p><code>setvbuf()</code>函数用于定义某个字节流应该如何缓存。它可以接受四个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE* stream, <span class="type">char</span>* buffer, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure>

<p>第一个参数<code>stream</code>是文件流。</p>
<p>第二个参数<code>buffer</code>是缓存区的地址。</p>
<p>第三个参数<code>mode</code>指定缓存的行为模式，它是下面三个宏之一，这些宏都定义在<code>stdio.h</code>。</p>
<ul>
<li><code>_IOFBF</code>：满缓存。当缓存为空时，才从流读入数据；当缓存满了，才向流写入数据。一般情况下，这是默认设置。</li>
<li><code>_IOLBF</code>：行缓存。每次从流读入一行数据，或向流写入一行数据，即以行为单位读写缓存。</li>
<li><code>_IONBF</code>：无缓存。不使用缓存区，直接读写设备。</li>
</ul>
<p>第四个参数<code>size</code>指定缓存区的大小。较大的缓存区提供更好的性能，而较小的缓存区可以节省空间。<code>stdio.h</code>提供了一个宏<code>BUFSIZ</code>，表示系统默认的缓存区大小。</p>
<p>它的意义在于，使得用户可以在打开一个文件之前，定义自己的文件缓冲区，而不必使用<code>fopen()</code>函数打开文件时设定的默认缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[N];</span><br><span class="line"></span><br><span class="line">setvbuf(stream, buffer, _IOFBF, N);</span><br></pre></td></tr></table></figure>

<p>上面示例设置文件流<code>stream</code>的缓存区从地址<code>buffer</code>开始，大小为<code>N</code>，模式为<code>_IOFBF</code>。</p>
<p><code>setvbuf()</code>的第二个参数可以为空指针 NULL。这样的话，<code>setvbuf()</code>会自己创建一个缓存区。</p>
<p>注意，<code>setvbuf()</code>的调用必须在对文件流执行任何操作之前。</p>
<p>如果调用成功，<code>setvbuf()</code>的返回值为<code>0</code>，否则返回非零值。</p>
<p>下面的例子是将缓存区调整为行缓存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line"><span class="type">char</span> lineBuf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">fp = fopen(<span class="string">&quot;somefile.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">setvbuf(fp, lineBuf, _IOLBF, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<h3 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf()"></a>setbuf()</h3><p><code>setbuf()</code>是<code>setvbuf()</code>的早期版本，可以视为后者的简化版本，也用来定义某个字节流的缓存区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE* stream, <span class="type">char</span>* buffer)</span>;</span><br></pre></td></tr></table></figure>

<p>它的第一个参数<code>stream</code>是文件流，第二个参数<code>buffer</code>是缓存区的地址。</p>
<p>它总是可以改写成<code>setvbuf()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[BUFSIZ];</span><br><span class="line"></span><br><span class="line">setbuf(stream, buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">setvbuf(stream, buffer, _IOFBF, BUFSIZ);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>BUFSIZ</code>是<code>stdio.h</code>定义的宏，表示系统默认的缓存区大小。</p>
<p><code>setbuf()</code>函数没有返回值。</p>
<p><code>setbuf()</code>的第二个参数如果设置为 NULL，表示不进行缓存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="ungetc"><a href="#ungetc" class="headerlink" title="ungetc()"></a>ungetc()</h3><p><code>ungetc()</code>将从缓存里面读取的上一个字符，重新放回缓存，下一个读取缓存的操作会从这个字符串开始。有些操作需要了解下一个字符是什么，再决定应该怎么处理，这时这个函数就很有用。</p>
<p>它的原型如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ungetc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>它的第一个参数是一个字符变量，第二个参数是一个打开的文件流。它的返回值是放回缓存的那个字符，操作失败时，返回 EOF。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ch = fgetc(fp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">  ch = fgetd(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ungetc(ch, fp);</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果读取的字符不是数字，就将其放回缓存。</p>
<h3 id="perror"><a href="#perror" class="headerlink" title="perror()"></a>perror()</h3><p><code>perror()</code>用于在 stderr 的错误信息之前，添加一个自定义字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数的参数就是在报错信息前添加的字符串。它没有返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  errno = <span class="number">0</span>;</span><br><span class="line">  <span class="type">float</span> y = <span class="built_in">sqrt</span>(x);</span><br><span class="line">  <span class="keyword">if</span> (errno != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;sqrt error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，求<code>-1</code>的平方根，导致报错。头文件<code>errno.h</code>提供宏<code>errno</code>，只要上一步操作出错，这个宏就会设置成非零值。<code>perror()</code>用来在报错信息前，加上<code>sqrt error</code>的自定义字符串。</p>
<p>执行上面的程序，就会得到下面的报错信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -lm</span><br><span class="line">$ ./a.out</span><br><span class="line">sqrt error: Numerical argument out of domain</span><br></pre></td></tr></table></figure>

<h3 id="可变参数操作函数"><a href="#可变参数操作函数" class="headerlink" title="可变参数操作函数"></a>可变参数操作函数</h3><p>（1）输出函数</p>
<p>下面是<code>printf()</code>的变体函数，用于按照给定格式，输出函数的可变参数列表（va_list）。</p>
<ul>
<li>vprintf()：按照给定格式，输出到控制台，默认是显示器。</li>
<li>vfprintf()：按照给定格式，输出到文件。</li>
<li>vsprintf()：按照给定格式，输出到字符串。</li>
<li>vsnprintf()：按照给定格式，输出到字符串的安全版本。</li>
</ul>
<p>它们的原型如下，基本与对应的<code>printf()</code>系列函数一致，除了最后一个参数是可变参数对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">vprintf</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> format,</span></span><br><span class="line"><span class="params">  va_list arg</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfprintf</span><span class="params">(</span></span><br><span class="line"><span class="params">  FILE * <span class="keyword">restrict</span> stream,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> format,</span></span><br><span class="line"><span class="params">  va_list arg</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">char</span> * <span class="keyword">restrict</span> s,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> format,</span></span><br><span class="line"><span class="params">  va_list arg</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">vsnprintf</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">char</span> * <span class="keyword">restrict</span> s,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> n,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> format,</span></span><br><span class="line"><span class="params">  va_list arg</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它们的返回值都为输出的字符数，如果出错，返回负值。</p>
<p><code>vsprintf()</code>和<code>vsnprintf()</code>的第一个参数可以为 NULL，用来查看多少个字符会被写入。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logger</span><span class="params">(<span class="type">char</span> *format, ...)</span> &#123;</span><br><span class="line">  va_list va;</span><br><span class="line">  va_start(va, format);</span><br><span class="line">  <span class="type">int</span> result = <span class="built_in">vprintf</span>(format, va);</span><br><span class="line">  va_end(va);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 x = 12 and y = 3.20</span></span><br><span class="line">logger(<span class="string">&quot;x = %d and y = %.2f&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>

<p>（2）输入函数</p>
<p>下面是<code>scanf()</code>的变体函数，用于按照给定格式，输入可变参数列表 (va_list)。</p>
<ul>
<li>vscanf()：按照给定格式，从控制台读取（默认为键盘）。</li>
<li>vfscanf()：按照给定格式，从文件读取。</li>
<li>vsscanf()：按照给定格式，从字符串读取。</li>
</ul>
<p>它们的原型如下，跟对应的<code>scanf()</code>函数基本一致，除了最后一个参数是可变参数对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">vscanf</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> format,</span></span><br><span class="line"><span class="params">  va_list arg</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">vfscanf</span><span class="params">(</span></span><br><span class="line"><span class="params">  FILE * <span class="keyword">restrict</span> stream,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> format,</span></span><br><span class="line"><span class="params">  va_list arg</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">vsscanf</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> s,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> format,</span></span><br><span class="line"><span class="params">  va_list arg</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它们返回成功读取的项数，遇到文件结尾或错误，则返回 EOF。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">error_check_scanf</span><span class="params">(<span class="type">int</span> expected_count, <span class="type">char</span> *format, ...)</span> &#123;</span><br><span class="line">  va_list va;</span><br><span class="line"></span><br><span class="line">  va_start(va, format);</span><br><span class="line">  <span class="type">int</span> count = vscanf(format, va);</span><br><span class="line">  va_end(va);</span><br><span class="line"></span><br><span class="line">  assert(count == expected_count);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_check_scanf(<span class="number">3</span>, <span class="string">&quot;%d, %d/%f&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br></pre></td></tr></table></figure>

<h2 id="stdlib-h"><a href="#stdlib-h" class="headerlink" title="stdlib.h"></a>stdlib.h</h2><h3 id="类型别名和宏"><a href="#类型别名和宏" class="headerlink" title="类型别名和宏"></a>类型别名和宏</h3><p>stdlib.h 定义了下面的类型别名。</p>
<ul>
<li>size_t：sizeof 的返回类型。</li>
<li>wchar_t：宽字符类型。</li>
</ul>
<p>stdlib.h 定义了下面的宏。</p>
<ul>
<li>NULL：空指针。</li>
<li>EXIT_SUCCESS：函数运行成功时的退出状态。</li>
<li>EXIT_FAILURE：函数运行错误时的退出状态。</li>
<li>RAND_MAX：rand() 函数可以返回的最大值。</li>
<li>MB_CUR_MAX：当前语言环境中，多字节字符占用的最大字节数。</li>
</ul>
<h3 id="abs-，labs-，llabs"><a href="#abs-，labs-，llabs" class="headerlink" title="abs()，labs()，llabs()"></a>abs()，labs()，llabs()</h3><p>这三个函数用于计算整数的绝对值。<code>abs()</code>用于 int 类型，<code>labs()</code>用于 long int 类型，<code>llabs()</code>用于 long long int 类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> j)</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">labs</span><span class="params">(<span class="type">long</span> <span class="type">int</span> j)</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">llabs</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> j)</span>;</span><br></pre></td></tr></table></figure>

<p>下面是用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 |-2| = 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|-2| = %d\n&quot;</span>, <span class="built_in">abs</span>(<span class="number">-2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 |4|  = 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|4|  = %d\n&quot;</span>, <span class="built_in">abs</span>(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<h3 id="div-，ldiv-，lldiv"><a href="#div-，ldiv-，lldiv" class="headerlink" title="div()，ldiv()，lldiv()"></a>div()，ldiv()，lldiv()</h3><p>这三个函数用来计算两个参数的商和余数。<code>div()</code>用于 int 类型的相除，<code>ldiv()</code>用于 long int 类型的相除，<code>lldiv()</code>用于 long long int 类型的相除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">div_t</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> numer, <span class="type">int</span> denom)</span>;</span><br><span class="line"><span class="type">ldiv_t</span> <span class="title function_">ldiv</span><span class="params">(<span class="type">long</span> <span class="type">int</span> numer, <span class="type">long</span> <span class="type">int</span> denom)</span>;</span><br><span class="line"><span class="type">lldiv_t</span> <span class="title function_">lldiv</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> numer, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> denom)</span>;</span><br></pre></td></tr></table></figure>

<p>这些函数把第2个参数（分母）除以第1个参数（分子），产生商和余数。这两个值通过一个数据结构返回，<code>div()</code>返回 div_t 结构，<code>ldiv()</code>返回 ldiv_t 结构，<code>lldiv()</code>返回 lldiv_t 结构。</p>
<p>这些结构都包含下面两个字段，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>　quot;　 <span class="comment">//　商</span></span><br><span class="line"><span class="type">int</span>　rem;　 <span class="comment">//　余数</span></span><br></pre></td></tr></table></figure>

<p>它们完整的定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> quot, rem;</span><br><span class="line">&#125; <span class="type">div_t</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> quot, rem;</span><br><span class="line">&#125; <span class="type">ldiv_t</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> quot, rem;</span><br><span class="line">&#125; <span class="type">lldiv_t</span>;</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">div_t</span> d = div(<span class="number">64</span>, <span class="number">-7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 64 / -7 = -9</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;64 / -7 = %d\n&quot;</span>, d.quot);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 64 % -7 = 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;64 %% -7 = %d\n&quot;</span>, d.rem);</span><br></pre></td></tr></table></figure>

<h3 id="字符串转成数值"><a href="#字符串转成数值" class="headerlink" title="字符串转成数值"></a>字符串转成数值</h3><h4 id="a-系列函数"><a href="#a-系列函数" class="headerlink" title="a 系列函数"></a>a 系列函数</h4><p><code>stdlib.h</code>定义了一系列函数，可以将字符串转为数组。</p>
<ul>
<li>atoi()：字符串转成 int 类型。</li>
<li>atof()：字符串转成 double 类型。</li>
<li>atol()：字符串转成 long int 类型。</li>
<li>atoll()：字符串转成 long long int 类型。</li>
</ul>
<p>它们的原型如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* nptr)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">atof</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* nptr)</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">atol</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* nptr)</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">atoll</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* nptr)</span>;</span><br></pre></td></tr></table></figure>

<p>上面函数的参数都是一个字符串指针，字符串开头的空格会被忽略，转换到第一个无效字符处停止。函数名称里面的<code>a</code>代表 ASCII，所以<code>atoi()</code>的意思是“ASCII to int”。</p>
<p>它们返回转换后的数值，如果字符串无法转换，则返回<code>0</code>。</p>
<p>下面是用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atoi(<span class="string">&quot;3490&quot;</span>)   <span class="comment">// 3490</span></span><br><span class="line">atof(<span class="string">&quot;3.141593&quot;</span>)   <span class="comment">// 3.141593</span></span><br></pre></td></tr></table></figure>

<p>如果参数是数字开头的字符串，<code>atoi()</code>会只转换数字部分，比如<code>atoi(&quot;42regular&quot;)</code>会返回整数<code>42</code>。如果首字符不是数字，比如“hello world”，则会返回<code>0</code>。</p>
<h4 id="str-系列函数（浮点数转换）"><a href="#str-系列函数（浮点数转换）" class="headerlink" title="str 系列函数（浮点数转换）"></a>str 系列函数（浮点数转换）</h4><p><code>stdlib.h</code>还定义了一些更强功能的浮点数转换函数。</p>
<ul>
<li>strtof()：字符串转成 float 类型。</li>
<li>strtod()：字符串转成 double 类型。</li>
<li>strtold()：字符串转成 long double 类型。</li>
</ul>
<p>它们的原型如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">strtof</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* <span class="keyword">restrict</span> nptr,</span></span><br><span class="line"><span class="params">  <span class="type">char</span>** <span class="keyword">restrict</span> endptr</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">strtod</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* <span class="keyword">restrict</span> nptr,</span></span><br><span class="line"><span class="params">  <span class="type">char</span>** <span class="keyword">restrict</span> endptr</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="title function_">strtold</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* <span class="keyword">restrict</span> nptr,</span></span><br><span class="line"><span class="params">  <span class="type">char</span>** <span class="keyword">restrict</span> endptr</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它们都接受两个参数，第一个参数是需要转换的字符串，第二个参数是一个指针，指向原始字符串里面无法转换的部分。</p>
<ul>
<li><code>nptr</code>：待转换的字符串（起首的空白字符会被忽略）。</li>
<li><code>endprt</code>：一个指针，指向不能转换部分的第一个字符。如果字符串可以完全转成数值，该指针指向字符串末尾的终止符<code>\0</code>。这个参数如果设为 NULL，就表示不需要处理字符串剩余部分。</li>
</ul>
<p>它们的返回值是已经转换后的数值。如果字符串无法转换，则返回<code>0</code>。如果转换结果发生溢出，errno 会被设置为 ERANGE。如果值太大（无论是正数还是负数），函数返回<code>HUGE_VAL</code>；如果值太小，函数返回零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *inp = <span class="string">&quot;   123.4567abdc&quot;</span>;</span><br><span class="line"><span class="type">char</span> *badchar;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> val = strtod(inp, &amp;badchar);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, val); <span class="comment">// 123.456700</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, badchar); <span class="comment">// abdc</span></span><br></pre></td></tr></table></figure>

<p>字符串可以完全转换的情况下，第二个参数指向<code>\0</code>，因此可以用下面的写法判断是否完全转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (*endptr == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// 完全转换</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 存在无法转换的字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不关心没有转换的部分，则可以将 endptr 设置为 NULL。</p>
<p>这些函数还可以将字符串转换为特殊值 Infinity 和 NaN。如果字符串包含 INF 或 INFINITY（大写或小写皆可），则将转换为 Infinity；如果字符串包含 NAN，则将返回 NaN。</p>
<h4 id="str-系列函数（整数转换）"><a href="#str-系列函数（整数转换）" class="headerlink" title="str 系列函数（整数转换）"></a>str 系列函数（整数转换）</h4><p>str 系列函数也有整数转换的对应函数。</p>
<ul>
<li>strtol()：字符串转成 long int 类型。</li>
<li>strtoll()：字符串转成 long long int 类型。</li>
<li>strtoul()：字符串转成 unsigned long int 类型。</li>
<li>strtoull()：字符串转成 unsigned long long int 类型。</li>
</ul>
<p>它们的原型如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">strtol</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* <span class="keyword">restrict</span> nptr,</span></span><br><span class="line"><span class="params">  <span class="type">char</span>** <span class="keyword">restrict</span> endptr,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> base</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">strtoll</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* <span class="keyword">restrict</span> nptr,</span></span><br><span class="line"><span class="params">  <span class="type">char</span>** <span class="keyword">restrict</span> endptr,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> base</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">strtoul</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* <span class="keyword">restrict</span> nptr,</span></span><br><span class="line"><span class="params">  <span class="type">char</span>** <span class="keyword">restrict</span> endptr,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> base</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">strtoull</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* <span class="keyword">restrict</span> nptr,</span></span><br><span class="line"><span class="params">  <span class="type">char</span>** <span class="keyword">restrict</span> endptr, <span class="type">int</span> base</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它们接受三个参数。</p>
<p>（1）<code>nPtr</code>：待转换的字符串（起首的空白字符会被忽略）。</p>
<p>（2）<code>endPrt</code>：一个指针，指向不能转换部分的第一个字符。如果字符串可以完全转成数值，该指针指向字符串末尾的终止符<code>\0</code>。这个参数如果设为 NULL，就表示不需要处理字符串剩余部分。</p>
<p>（3）<code>base</code>：待转换整数的进制。这个值应该是<code>2</code>到<code>36</code>之间的整数，代表相应的进制，如果是特殊值<code>0</code>，表示让函数根据数值的前缀，自己确定进制，即如果数字有前缀<code>0</code>，则为八进制，如果数字有前缀<code>0x</code>或<code>0X</code>，则为十六进制。</p>
<p>它们的返回值是转换后的数值，如果转换不成功，返回<code>0</code>。</p>
<p>下面是转换十进制整数的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;3490&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> x = strtoul(u, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, x); <span class="comment">// 3490</span></span><br></pre></td></tr></table></figure>

<p>下面是转换十六进制整数的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* end;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> value = strtol(<span class="string">&quot;0xff&quot;</span>, &amp;end, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, value); <span class="comment">// 255</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, end); <span class="comment">// 无内容</span></span><br><span class="line"></span><br><span class="line">value = strtol(<span class="string">&quot;0xffxx&quot;</span>, &amp;end, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, value); <span class="comment">// 255</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, end); <span class="comment">// xx</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>strtol()</code>可以指定字符串包含的是16进制整数。不能转换的部分，可以使用指针<code>end</code>进行访问。</p>
<p>下面是转换二进制整数的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;101010&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> x = strtoul(s, <span class="literal">NULL</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, x); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<p>下面是让函数自行判断整数进制的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* <span class="built_in">string</span> = <span class="string">&quot;-1234567abc&quot;</span>;</span><br><span class="line">  <span class="type">char</span>* remainderPtr;</span><br><span class="line">  <span class="type">long</span> x = strtol(<span class="built_in">string</span>, &amp;remainderPtr, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\&quot;%s\&quot;\n%s%ld\n%s\&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The original string is &quot;</span>,</span><br><span class="line">    <span class="built_in">string</span>,</span><br><span class="line">    <span class="string">&quot;The converted value is &quot;</span>,</span><br><span class="line">    x,</span><br><span class="line">    <span class="string">&quot;The remainder of the original string is &quot;</span>,</span><br><span class="line">    remainderPtr</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的输出结果如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The original <span class="built_in">string</span> is <span class="string">&quot;-1234567abc&quot;</span></span><br><span class="line">The converted value is <span class="number">-1234567</span></span><br><span class="line">The remainder of the original <span class="built_in">string</span> is <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果被转换的值太大，<code>strtol()</code>函数在<code>errno</code>中存储<code>ERANGE</code>这个值，并返回<code>LONG_MIN</code>（原值为负数）或<code>LONG_MAX</code>（原值为正数），<code>strtoul()</code>则返回<code>ULONG_MAX</code>。</p>
<h3 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h3><p><code>rand()</code>函数用来生成 0～RAND_MAX 之间的随机整数。<code>RAND_MAX</code>是一个定义在<code>stdlib.h</code>里面的宏，通常等于 INT_MAX。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="type">int</span> x = rand();</span><br></pre></td></tr></table></figure>

<p>如果希望获得整数 N 到 M 之间的随机数（包括 N 和 M 两个端点值），可以使用下面的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = rand() % （M - N + <span class="number">1</span>) + N;</span><br></pre></td></tr></table></figure>

<p>比如，1 到 6 之间的随机数，写法如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = rand() % <span class="number">6</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>获得浮点数的随机值，可以使用下面的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 到 0.999999 之间的随机数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0 to 0.99999: %f\n&quot;</span>, rand() / ((<span class="type">float</span>)RAND_MAX + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// n 到 m 之间的随机数：</span></span><br><span class="line"><span class="comment">// n + m * (rand() / (float)RAND_MAX)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;10.5 to 15.7: %f\n&quot;</span>, <span class="number">10.5</span> + <span class="number">5.2</span> * rand() / (<span class="type">float</span>)RAND_MAX);</span><br></pre></td></tr></table></figure>

<p>上面示例中，由于<code>rand()</code>和<code>RAND_MAX</code>都是 int 类型，要用显示的类型转换转为浮点数。</p>
<h3 id="srand"><a href="#srand" class="headerlink" title="srand()"></a>srand()</h3><p><code>rand()</code>是伪随机数函数，为了增加随机性，必须在调用它之前，使用<code>srand()</code>函数重置一下种子值。</p>
<p><code>srand()</code>函数接受一个无符号整数（unsigned int）作为种子值，没有返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span>;</span><br></pre></td></tr></table></figure>

<p>通常使用<code>time(NULL)</code>函数返回当前距离时间纪元的秒数，作为<code>srand()</code>的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line">srand((<span class="type">unsigned</span> <span class="type">int</span>) time(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>time()</code>的原型定义在头文件<code>time.h</code>里面，返回值的类型是类型别名<code>time_t</code>，具体的类型与系统有关，所以要强制转换一下类型。<code>time()</code>的参数是一个指针，指向一个具体的 time_t 类型的时间值，这里传入空指针<code>NULL</code>作为参数，由于 NULL 一般是<code>0</code>，所以也可以写成<code>time(0)</code>。</p>
<h3 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h3><p><code>abort()</code>用于不正常地终止一个正在执行的程序。使用这个函数的目的，主要是它会触发 SIGABRT 信号，开发者可以在程序中为这个信号设置一个处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数没有参数。</p>
<h3 id="exit-，quick-exit-，-Exit"><a href="#exit-，quick-exit-，-Exit" class="headerlink" title="exit()，quick_exit()，_Exit()"></a>exit()，quick_exit()，_Exit()</h3><p>这三个函数都用来退出当前正在执行的程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"><span class="type">void</span> _Exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure>

<p>它们都接受一个整数，表示程序的退出状态，<code>0</code>是正常退出，非零值表示发生错误，可以使用宏<code>EXIT_SUCCESS</code>和<code>EXIT_FAILURE</code>当作参数。它们本身没有返回值。</p>
<p>它们的区别是，退出时所做的清理工作不同。<code>exit()</code>是正常退出，系统会做完整的清理，比如更新所有文件流，并且删除临时文件。<code>quick_exit()</code>是快速退出，系统的清理工作稍微少一点。<code>_Exit()</code>是立即退出，不做任何清理工作。</p>
<p>下面是一些用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">quick_exit(EXIT_FAILURE);</span><br><span class="line">_Exit(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="atexit-，at-quick-exit"><a href="#atexit-，at-quick-exit" class="headerlink" title="atexit()，at_quick_exit()"></a>atexit()，at_quick_exit()</h3><p><code>atexit()</code>用来登记当前程序退出时（调用<code>exit()</code>或<code>main()</code>正常退出），所要执行的其他函数。</p>
<p><code>at_quick_exit()</code>则是登记使用<code>quick_exit()</code>方法退出当前程序时，所要执行的其他函数。</p>
<p><code>exit()</code>只能触发<code>atexit()</code>登记的函数，<code>quick_exit()</code>只能触发<code>at_quick_exit()</code>登记的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">at_quick_exit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>

<p>它们的参数是要执行的函数地址，即函数名。它们的返回值都是调用成功时返回<code>0</code>，调用失败时返回非零值。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sign_off</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">too_bad</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  atexit(sign_off);　　 <span class="comment">/* 注册 sign_off()函数 */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter an integer:&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;That&#x27;s no integer!&quot;</span>);</span><br><span class="line">    atexit(too_bad);　<span class="comment">/* 注册 too_bad()函数 */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d is %s.\n&quot;</span>, n, (n % <span class="number">2</span> == <span class="number">0</span>) ? <span class="string">&quot;even&quot;</span> : <span class="string">&quot;odd&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sign_off</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;sign_off&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">too_bad</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;too bad&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，用户输入失败时，会调用<code>sign_off()</code>和<code>too_bad()</code>函数；但是输入成功时只会调用<code>sign_off()</code>。因为只有输入失败时，才会进入<code>if</code>语句登记<code>too_bad()</code>。</p>
<p>另外，如果有多条<code>atexit()</code>语句，函数退出时最先调用的，是最后一个登记的函数。</p>
<p><code>atexit()</code>登记的函数（如上例的<code>sign_off</code>和<code>too_bad</code>）应该不带任何参数且返回类型为<code>void</code>。通常，这些函数会执行一些清理任务，例如删除临时文件或重置环境变量。</p>
<p><code>at_quick_exit()</code>也是同样的规则，下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit_handler_1</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit_handler_2</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  at_quick_exit(exit_handler_1);</span><br><span class="line">  at_quick_exit(exit_handler_2);</span><br><span class="line">  quick_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的示例，命令行会先输出2，再输出1。</p>
<h3 id="getenv"><a href="#getenv" class="headerlink" title="getenv()"></a>getenv()</h3><p><code>getenv()</code>用于获取环境变量的值。环境变量是操作系统提供的程序之外的一些环境参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>;</span><br></pre></td></tr></table></figure>

<p>它的参数是一个字符串，表示环境变量名。返回值也是一个字符串，表示环境变量的值。如果指定的环境变量不存在，则返回 NULL。</p>
<p>下面是输出环境变量<code>$PATH</code>的值的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;PATH is %s\n&quot;</span>, getenv(<span class="string">&quot;PATH&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h3><p><code>system()</code>函数用于执行外部程序。它会把它的参数字符串传递给操作系统，让操作系统的命令处理器来执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">system</span><span class="params">( <span class="type">char</span> <span class="type">const</span> * command )</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数的返回值因编译器而异。但是标准规定，如果 NULL 作为参数，表示询问操作系统，是否有可用的命令处理器，如果有的话，返回一个非零值，否则返回零。</p>
<p>下面是执行<code>ls</code>命令的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">&quot;ls -l&quot;</span>); </span><br></pre></td></tr></table></figure>

<h3 id="内存管理函数"><a href="#内存管理函数" class="headerlink" title="内存管理函数"></a>内存管理函数</h3><p>stdlib.h 提供了一些内存操作函数，下面几个函数详见《内存管理》一章，其余在本节介绍。</p>
<ul>
<li>malloc()：分配内存区域</li>
<li>calloc()：分配内存区域。</li>
<li>realloc()：调节内存区域大小。</li>
<li>free()：释放内存区域。</li>
</ul>
<h4 id="aligned-alloc"><a href="#aligned-alloc" class="headerlink" title="aligned_alloc()"></a>aligned_alloc()</h4><p>很多系统有内存对齐的要求，即内存块的大小必须是某个值（比如64字节）的倍数，这样有利于提高处理速度。<code>aligned_alloc()</code>就用于分配满足内存对齐要求的内存块，它的原型如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">aligned_alloc</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数。</p>
<ul>
<li>alignment：整数，表示内存对齐的单位大小，一般是2的整数次幂（2、4、8、16……）。</li>
<li>size：整数，表示内存块的大小。</li>
</ul>
<p>分配成功时，它返回一个无类型指针，指向新分配的内存块。分配失败时，返回 NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p = aligned_alloc(<span class="number">64</span>, <span class="number">256</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>aligned_alloc()</code>分配的内存块，单位大小是64字节，要分配的字节数是256字节。</p>
<h3 id="qsort"><a href="#qsort" class="headerlink" title="qsort()"></a>qsort()</h3><p><code>qsort()</code>用来快速排序一个数组。它对数组成员的类型没有要求，任何类型数组都可以用这个函数排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *base,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> nmemb, </span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数接受四个参数。</p>
<ul>
<li>base：指向要排序的数组开始位置的指针。</li>
<li>nmemb：数组成员的数量。</li>
<li>size：数组每个成员占用的字节长度。</li>
<li>compar：一个函数指针，指向一个比较两个成员的函数。</li>
</ul>
<p>比较函数<code>compar</code>将指向数组两个成员的指针作为参数，并比较两个成员。如果第一个参数小于第二个参数，该函数应该返回一个负值；如果两个函数相等，返回<code>0</code>；如果第一个参数大于第二个参数，应该返回一个正数。</p>
<p>下面是一个用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compar</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* elem0, <span class="type">const</span> <span class="type">void</span>* elem1)</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* x = elem0;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* y = elem1; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> *x - *y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a[<span class="number">9</span>] = &#123;<span class="number">14</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">13</span>&#125;;</span><br><span class="line"></span><br><span class="line">  qsort(a, <span class="number">9</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), compar);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面示例，会输出排序好的数组“1 2 3 6 8 10 13 14 17”。</p>
<h3 id="bsearch"><a href="#bsearch" class="headerlink" title="bsearch()"></a>bsearch()</h3><p><code>bsearch()</code>使用二分法搜索，在数组中搜索一个值。它对数组成员的类型没有要求，任何类型数组都可以用这个函数搜索值。</p>
<p>注意，该方法只对已经排序好的数组有效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">bsearch</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">void</span>* key,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">void</span>* base,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> nmemb,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数接受5个参数。</p>
<ul>
<li>key：指向要查找的值的指针。</li>
<li>base：指向数组开始位置的指针，数组必须已经排序。</li>
<li>nmemb：数组成员的数量。</li>
<li>size：数组每个成员占用的字节长度。</li>
<li>compar：指向一个将待查找值与其他值进行比较的函数的指针。</li>
</ul>
<p>比较函数<code>compar</code>将待查找的值作为第一个参数，将要比较的值作为第二个参数。如果第一个参数小于第二个参数，该函数应该返回一个负值；如果两个参数相等，返回<code>0</code>；如果第一个参数大于第二个参数，返回一个正值。</p>
<p>如果找到待查找的值，<code>bsearch()</code>返回指向该值的指针，如果找不到，返回 NULL。</p>
<p>下面是一个用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compar</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="type">void</span> *value)</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* k = key;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* v = value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *k - *v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a[<span class="number">9</span>] = &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">32</span>, <span class="number">47</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span>* r;</span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">  key = <span class="number">12</span>; <span class="comment">// 包括在数组中</span></span><br><span class="line">  r = bsearch(&amp;key, a, <span class="number">9</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), compar);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Found %d\n&quot;</span>, *r);</span><br><span class="line"></span><br><span class="line">  key = <span class="number">30</span>;  <span class="comment">// 不包括在数组中</span></span><br><span class="line">  r = bsearch(&amp;key, a, <span class="number">9</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), compar);</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Didn&#x27;t find 30\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的示例，会输出下面的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Found 12</span><br><span class="line">Didn<span class="string">&#x27;t find 30</span></span><br></pre></td></tr></table></figure>

<h3 id="多字节字符函数"><a href="#多字节字符函数" class="headerlink" title="多字节字符函数"></a>多字节字符函数</h3><p>stdlib.h 提供了下面的函数，用来操作多字节字符，详见《多字节字符》一章。</p>
<ul>
<li>mblen()：多字节字符的字节长度。</li>
<li>mbtowc()：将多字节字符转换为宽字符。</li>
<li>wctomb()：将宽字符转换为多字节字符。</li>
<li>mbstowcs()：将多字节字符串转换为宽字符串。</li>
<li>wcstombs()：将宽字符串转换为多字节字符串。</li>
</ul>
<h2 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h2><p><code>string.h</code>主要定义了字符串处理函数和内存操作函数。</p>
<h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><p>以下字符串处理函数，详见《字符串》一章。</p>
<ul>
<li>strcpy()：复制字符串。</li>
<li>strncpy()：复制字符串，有长度限制。</li>
<li>strcat()：连接两个字符串。</li>
<li>strncat()：连接两个字符串，有长度限制。</li>
<li>strcmp()：比较两个字符串。</li>
<li>strncmp()：比较两个字符串，有长度限制。</li>
<li>strlen()：返回字符串的字节数。</li>
</ul>
<h4 id="strchr-，strrchr"><a href="#strchr-，strrchr" class="headerlink" title="strchr()，strrchr()"></a>strchr()，strrchr()</h4><p><code>strchr()</code>和<code>strrchr()</code>都用于在字符串中查找指定字符。不同之处是，<code>strchr()</code>从字符串开头开始查找，<code>strrchr()</code>从字符串结尾开始查找，函数名里面多出来的那个<code>r</code>表示 reverse（反向）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strchr</span><span class="params">(<span class="type">char</span>* str, <span class="type">int</span> c)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">strrchr</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure>

<p>它们都接受两个参数，第一个参数是字符串指针，第二个参数是所要查找的字符。</p>
<p>一旦找到该字符，它们就会停止查找，并返回指向该字符的指针。如果没有找到，则返回 NULL。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">strchr</span>(str, <span class="string">&#x27;,&#x27;</span>);  <span class="comment">// p 指向逗号的位置</span></span><br><span class="line">p = <span class="built_in">strrchr</span>(str, <span class="string">&#x27;o&#x27;</span>); <span class="comment">// p 指向 world 里面 o 的位置</span></span><br></pre></td></tr></table></figure>

<h4 id="strspn-，strcspn"><a href="#strspn-，strcspn" class="headerlink" title="strspn()，strcspn()"></a>strspn()，strcspn()</h4><p><code>strspn()</code>用来查找属于指定字符集的字符串长度，<code>strcspn()</code>正好相反，用来查找不属于指定字符集的字符串长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strspn</span><span class="params">(<span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* accept)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strcspn</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *reject)</span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数接受两个参数，第一个参数是源字符串，第二个参数是由指定字符组成的字符串。</p>
<p><code>strspn()</code>从第一个参数的开头开始查找，一旦发现第一个不属于指定字符集范围的字符，就停止查找，返回到目前为止的字符串长度。如果始终没有不在指定字符集的字符，则返回第一个参数字符串的长度。</p>
<p><code>strcspn()</code>则是一旦发现第一个属于指定字符集范围的字符，就停止查找，返回到目前为止的字符串长度。如果始终没有发现指定字符集的字符，则返回第一个参数字符串的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">strspn</span>(str1, <span class="string">&quot;aeiou&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);  <span class="comment">// n == 0</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">strcspn</span>(str1, <span class="string">&quot;aeiou&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n); <span class="comment">// n == 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，第一个<code>n</code>等于0，因为0号位置的字符<code>h</code>就不属于指定字符集<code>aeiou</code>，可以理解为开头有0个字符属于指定字符集。第二个<code>n</code>等于1，因为1号位置的字符<code>e</code>属于指定字符集<code>aeiou</code>，可以理解为开头有1个字符不属于指定字符集。</p>
<h4 id="strpbrk"><a href="#strpbrk" class="headerlink" title="strpbrk()"></a>strpbrk()</h4><p><code>strpbrk()</code>在字符串中搜索指定字符集的任一个字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strpbrk</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，第一个参数是源字符串，第二个参数是由指定字符组成的字符串。</p>
<p>它返回一个指向第一个匹配字符的指针，如果未找到匹配字符，则返回 NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s1 = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">char</span>* s2 = <span class="string">&quot;dow!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* p = <span class="built_in">strpbrk</span>(s1, s2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);  <span class="comment">// &quot;o, world!&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，指定字符集是“dow!”，那么<code>s1</code>里面第一个匹配字符是“Hello”的“o”，所以指针<code>p</code>指向这个字符。输出的话，就会输出从这个字符直到字符串末尾的“o, world!”。</p>
<h4 id="strstr"><a href="#strstr" class="headerlink" title="strstr()"></a>strstr()</h4><p><code>strstr()</code>在一个字符串里面，查找另一个字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* str,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* substr</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，第一个参数是源字符串，第二个参数是所要查找的子字符串。</p>
<p>如果匹配成功，就返回一个指针，指向源字符串里面的子字符串。如果匹配失败，就返回 NULL，表示无法找到子字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* str = <span class="string">&quot;The quick brown fox jumped over the lazy dogs.&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p = <span class="built_in">strstr</span>(str, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p == <span class="literal">NULL</span> ? <span class="string">&quot;null&quot;</span>: p); <span class="comment">// &quot;lazy dogs.&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>strstr()</code>用来在源字符串<code>str</code>里面，查找子字符串<code>lazy</code>。从返回的指针到字符串结尾，就是“lazy dogs.”。</p>
<h4 id="strtok"><a href="#strtok" class="headerlink" title="strtok()"></a>strtok()</h4><p><code>strtok()</code>用来将一个字符串按照指定的分隔符（delimiter），分解成一系列词元（tokens）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strtok</span><span class="params">(<span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* delim)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，第一个参数是待拆分的字符串，第二个参数是指定的分隔符。</p>
<p>它返回一个指针，指向分解出来的第一个词元，并将词元结束之处的分隔符替换成字符串结尾标志<code>\0</code>。如果没有待分解的词元，它返回 NULL。</p>
<p>如果要遍历所有词元，就必须循环调用，参考下面的例子。</p>
<p><code>strtok()</code>的第一个参数如果是 NULL，则表示从上一次<code>strtok()</code>分解结束的位置，继续往下分解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> <span class="built_in">string</span>[] = <span class="string">&quot;This is a sentence with 7 tokens&quot;</span>;</span><br><span class="line">  <span class="type">char</span>* tokenPtr = strtok(<span class="built_in">string</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (tokenPtr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, tokenPtr);</span><br><span class="line">    tokenPtr = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例将源字符串按照空格，分解词元。它的输出结果如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">This</span><br><span class="line">is</span><br><span class="line">a</span><br><span class="line">sentence</span><br><span class="line">with</span><br><span class="line">7</span><br><span class="line">tokens</span><br></pre></td></tr></table></figure>

<p>注意，<code>strtok()</code>会修改原始字符串，将所有分隔符都替换成字符串结尾符号<code>\0</code>。因此，最好生成一个原始字符串的拷贝，然后再对这个拷贝执行<code>strtok()</code>。</p>
<h4 id="strcoll"><a href="#strcoll" class="headerlink" title="strcoll()"></a>strcoll()</h4><p><code>strcoll()</code>用于比较两个启用了本地化设置的字符串，用法基本与<code>strcmp()</code>相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcoll</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span>;</span><br></pre></td></tr></table></figure>

<p>请看下面的示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报告 é &gt; f</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(<span class="string">&quot;é&quot;</span>, <span class="string">&quot;f&quot;</span>));  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 报告 é &lt; f</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, strcoll(<span class="string">&quot;é&quot;</span>, <span class="string">&quot;f&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>上面示例比较带重音符号的<code>é</code>与<code>f</code>，<code>strcmp()</code>会返回<code>é</code>大于<code>f</code>，而<code>strcoll()</code>就会正确识别<code>é</code>排在<code>f</code>前面，所以小于<code>f</code>。注意，在比较之前，需要使用<code>setlocale(LC_ALL, &quot;&quot;)</code>，启用本地化设置。</p>
<h4 id="strxfrm"><a href="#strxfrm" class="headerlink" title="strxfrm()"></a>strxfrm()</h4><p><code>strxfrm()</code>将一个本地化字符串转成可以使用<code>strcmp()</code>进行比较的形式，相当于<code>strcoll()</code>内部的第一部分操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strxfrm</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">char</span> * <span class="keyword">restrict</span> s1, </span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> s2, </span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> n</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受三个参数，将第二个参数<code>s2</code>转为可以使用<code>strcmp()</code>比较的形式，并将结果存入第一个参数<code>s1</code>。第三个参数<code>n</code>用来限定写入的字符数，防止超出<code>s1</code>的边界。</p>
<p>它返回转换后的字符串长度，不包括结尾的终止符。</p>
<p>如果第一个参数是 NULL，第三个参数是0，则不进行实际的转换，只返回转换后所需的字符串长度。</p>
<p>下面的示例是用这个函数自己实现一个<code>strcoll()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcoll</span><span class="params">(<span class="type">char</span>* s1, <span class="type">char</span>* s2)</span> &#123;</span><br><span class="line">  <span class="type">int</span> len1 = strxfrm(<span class="literal">NULL</span>, s1, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> len2 = strxfrm(<span class="literal">NULL</span>, s2, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *d1 = <span class="built_in">malloc</span>(len1);</span><br><span class="line">  <span class="type">char</span> *d2 = <span class="built_in">malloc</span>(len2);</span><br><span class="line"></span><br><span class="line">  strxfrm(d1, s1, len1);</span><br><span class="line">  strxfrm(d2, s2, len2);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> result = <span class="built_in">strcmp</span>(d1, d2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(d2);</span><br><span class="line">  <span class="built_in">free</span>(d1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，先为两个进行比较的本地化字符串，分配转换后的存储空间，使用<code>strxfrm()</code>将它们转为可比较的形式，再用<code>strcmp()</code>进行比较。</p>
<h4 id="strerror"><a href="#strerror" class="headerlink" title="strerror()"></a>strerror()</h4><p><code>strerror()</code>函数返回特定错误的说明字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errornum)</span>;</span><br></pre></td></tr></table></figure>

<p>它的参数是错误的编号，由<code>errno.h</code>定义。返回值是一个指向说明字符串的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 No such file or directory</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>上面示例输出2号错误的说明字符“No such file or directory“。</p>
<p>下面的例子是自定义报错信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  FILE* fp = fopen(<span class="string">&quot;NONEXISTENT_FILE.TXT&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">char</span>* errmsg = strerror(errno);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error %d opening file: %s\n&quot;</span>, errno, errmsg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，通过<code>strerror(errno)</code>拿到当前的默认报错信息，其中<code>errno</code>是<code>errno.h</code>定义的宏，表示当前的报错编号。然后，再输出一条自定义的报错信息。</p>
<h3 id="内存操作函数"><a href="#内存操作函数" class="headerlink" title="内存操作函数"></a>内存操作函数</h3><p>以下内存操作函数，详见《内存管理》一章。</p>
<ul>
<li>memcpy()：内存复制函数。</li>
<li>memmove()：内存复制函数（允许重叠）。</li>
<li>memcmp()：比较两个内存区域。</li>
</ul>
<h4 id="memchr"><a href="#memchr" class="headerlink" title="memchr()"></a>memchr()</h4><p><code>memchr()</code>用于在内存区域中查找指定字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">memchr</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受三个参数，第一个参数是内存区域的指针，第二个参数是所要查找的字符，第三个参数是内存区域的字节长度。</p>
<p>一旦找到，它就会停止查找，并返回指向该位置的指针。如果直到检查完指定的字节数，依然没有发现指定字符，则返回 NULL。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">memchr</span>(str, <span class="string">&#x27;!&#x27;</span>, <span class="number">13</span>); <span class="comment">// p 指向感叹号的位置</span></span><br></pre></td></tr></table></figure>

<h4 id="memset"><a href="#memset" class="headerlink" title="memset()"></a>memset()</h4><p><code>memset()</code>将一段内存全部格式化为指定值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">memset</span><span class="params">(<span class="type">void</span>* s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>它的第一个参数是一个指针，指向内存区域的开始位置，第二个参数是待写入的字符值，第三个参数是一个整数，表示需要格式化的字节数。它返回第一个参数（指针）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(p, <span class="string">&#x27; &#x27;</span>, N);</span><br></pre></td></tr></table></figure>

<p>上面示例中，p 是一个指针，指向一个长度为 N 个字节的内存区域。<code>memset()</code>将该块内存区域的每个字节，都改写为空格字符。</p>
<p>下面是另一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> string1[<span class="number">15</span>] = <span class="string">&quot;BBBBBBBBBBBBBB&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 bbbbbbbBBBBBBB</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span>*) <span class="built_in">memset</span>(string1, <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>));</span><br></pre></td></tr></table></figure>

<p><code>memset()</code>的一个重要用途，就是将数组成员全部初始化为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br></pre></td></tr></table></figure>

<p>下面是将 Struct 结构都初始化为0的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">banana</span> &#123;</span></span><br><span class="line">  <span class="type">float</span> ripeness;</span><br><span class="line">  <span class="type">char</span> *peel_color;</span><br><span class="line">  <span class="type">int</span> grams;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">banana</span> <span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;b, <span class="number">0</span>, <span class="keyword">sizeof</span> b);</span><br><span class="line"></span><br><span class="line">b.ripeness == <span class="number">0.0</span>;     <span class="comment">// True</span></span><br><span class="line">b.peel_color == <span class="literal">NULL</span>;  <span class="comment">// True</span></span><br><span class="line">b.grams == <span class="number">0</span>;          <span class="comment">// True</span></span><br></pre></td></tr></table></figure>

<p>上面示例，将 Struct banana 的实例 b 的所有属性都初始化为0。</p>
<h3 id="其他函数-1"><a href="#其他函数-1" class="headerlink" title="其他函数"></a>其他函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">memset</span><span class="params">(<span class="type">void</span>* a, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="time-h"><a href="#time-h" class="headerlink" title="time.h"></a>time.h</h2><h3 id="time-t"><a href="#time-t" class="headerlink" title="time_t"></a>time_t</h3><p>time_t 是一个表示时间的类型别名，可以视为国际标准时 UTC。它可能是浮点数，也可能是整数，Unix 系统一般是整数。</p>
<p>许多系统上，time_t 表示自时间纪元（time epoch）以来的秒数。Unix 的时间纪元是国际标准时 UTC 的1970年1月1日的零分零秒。time_t 如果为负数，则表示时间纪元之前的时间。</p>
<p>time_t 一般是32位或64位整数类型的别名，具体类型取决于当前系统。如果是32位带符号整数，time_t 可以表示的时间到 2038年1月19日03:14:07 UTC 为止；如果是32位无符号整数，则表示到2106年。如果是64位带符号整数，可以表示<code>-2930</code>亿年到<code>+2930</code>亿年的时间范围。</p>
<h3 id="struct-tm"><a href="#struct-tm" class="headerlink" title="struct tm"></a>struct tm</h3><p>struct tm 是一个数据结构，用来保存时间的各个组成部分，比如小时、分钟、秒、日、月、年等。下面是它的结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> tm_sec;    <span class="comment">// 秒数 [0, 60]</span></span><br><span class="line">  <span class="type">int</span> tm_min;    <span class="comment">// 分钟 [0, 59]</span></span><br><span class="line">  <span class="type">int</span> tm_hour;   <span class="comment">// 小时 [0, 23]</span></span><br><span class="line">  <span class="type">int</span> tm_mday;   <span class="comment">// 月份的天数 [1, 31]</span></span><br><span class="line">  <span class="type">int</span> tm_mon;    <span class="comment">// 月份 [0, 11]，一月用 0 表示</span></span><br><span class="line">  <span class="type">int</span> tm_year;   <span class="comment">// 距离 1900 的年数</span></span><br><span class="line">  <span class="type">int</span> tm_wday;   <span class="comment">// 星期几 [0, 6]，星期天用 0 表示</span></span><br><span class="line">  <span class="type">int</span> tm_yday;   <span class="comment">// 距离1月1日的天数 [0, 365]</span></span><br><span class="line">  <span class="type">int</span> tm_isdst;  <span class="comment">// 是否采用夏令时，1 表示采用，0 表示未采用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="time"><a href="#time" class="headerlink" title="time()"></a>time()</h3><p><code>time()</code>函数返回从时间纪元到现在经过的秒数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span>* returned_value)</span>;</span><br></pre></td></tr></table></figure>

<p><code>time()</code>接受一个 time_t 指针作为参数，返回值会写入指针地址。参数可以是空指针 NULL。</p>
<p><code>time()</code>的返回值是 time_t 类型的当前时间。 如果计算机无法提供当前的秒数，或者返回值太大，无法用<code>time_t</code>类型表示，<code>time()</code>函数就返回<code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> now;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一    </span></span><br><span class="line">now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二    </span></span><br><span class="line">time(&amp;now);</span><br></pre></td></tr></table></figure>

<p>上面示例展示了将当前时间存入变量<code>now</code>的两种写法。</p>
<p>如果要知道某个操作耗费的精确时间，需要调用两次<code>time()</code>，再将两次的返回值相减。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> begin = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 执行某些操作</span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> end = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, end - begin);</span><br></pre></td></tr></table></figure>

<p>注意，上面的方法只能精确到秒。</p>
<h3 id="ctime"><a href="#ctime" class="headerlink" title="ctime()"></a>ctime()</h3><p><code>ctime()</code>用来将 time_t 类型的值直接输出为人类可读的格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">ctime</span><span class="params">( <span class="type">time_t</span> <span class="type">const</span> * time_value )</span>;</span><br></pre></td></tr></table></figure>

<p><code>ctime()</code>的参数是一个 time_t 指针，返回一个字符串指针。该字符串的格式类似“Sun Jul 4 04:02:48 1976\n\0”，尾部包含换行符和字符串终止标志。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> now; </span><br><span class="line"></span><br><span class="line">now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 Sun Feb 28 18:47:25 2021</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, ctime(&amp;now));</span><br></pre></td></tr></table></figure>

<p>注意，<code>ctime()</code>会在字符串尾部自动添加换行符。</p>
<h3 id="localtime-，gmtime"><a href="#localtime-，gmtime" class="headerlink" title="localtime()，gmtime()"></a>localtime()，gmtime()</h3><p><code>localtime()</code>函数用来将 time_t 类型的时间，转换为当前时区的 struct tm 结构。</p>
<p><code>gmtime()</code>函数用来将 time_t 类型的时间，转换为 UTC 时间的 struct tm 结构。</p>
<p>它们的区别就是返回值，前者是本地时间，后者是 UTC 时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tm* <span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span>* timer)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm* <span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span>* timer)</span>;</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 Local: Sun Feb 28 20:15:27 2021</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Local: %s&quot;</span>, asctime(localtime(&amp;now)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 UTC  : Mon Mar  1 04:15:27 2021</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;UTC  : %s&quot;</span>, asctime(gmtime(&amp;now)));</span><br></pre></td></tr></table></figure>

<h3 id="asctime"><a href="#asctime" class="headerlink" title="asctime()"></a>asctime()</h3><p><code>asctime()</code>函数用来将 struct tm 结构，直接输出为人类可读的格式。该函数会自动在输出的尾部添加换行符。</p>
<p>用法示例参考上一小节。</p>
<h3 id="mktime"><a href="#mktime" class="headerlink" title="mktime()"></a>mktime()</h3><p><code>mktime()</code>函数用于把一个 struct tm 结构转换为 time_t 值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span>　<span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm* tm_ptr)</span>;</span><br></pre></td></tr></table></figure>

<p><code>mktime()</code>的参数是一个 struct tm 指针。</p>
<p><code>mktime()</code>会自动设置 struct tm 结构里面的<code>tm_wday</code>属性和<code>tm_yday</code>属性，开发者自己不必填写这两个属性。所以，这个函数常用来获得指定时间是星期几（<code>tm_wday</code>）。</p>
<p>struct tm 结构的<code>tm_isdst</code>属性也可以设为<code>-1</code>，让<code>mktime()</code>决定是否应该采用夏令时。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">some_time</span> =</span> &#123;</span><br><span class="line">  .tm_year=<span class="number">82</span>,   <span class="comment">// 距离 1900 的年数</span></span><br><span class="line">  .tm_mon=<span class="number">3</span>,     <span class="comment">// 月份 [0, 11]</span></span><br><span class="line">  .tm_mday=<span class="number">12</span>,   <span class="comment">// 天数 [1, 31]</span></span><br><span class="line">  .tm_hour=<span class="number">12</span>,   <span class="comment">// 小时 [0, 23]</span></span><br><span class="line">  .tm_min=<span class="number">00</span>,    <span class="comment">// 分钟 [0, 59]</span></span><br><span class="line">  .tm_sec=<span class="number">04</span>,    <span class="comment">// 秒数 [0, 60]</span></span><br><span class="line">  .tm_isdst=<span class="number">-1</span>,  <span class="comment">// 夏令时</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="type">time_t</span> some_time_epoch;</span><br><span class="line">some_time_epoch = mktime(&amp;some_time);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 输出 Mon Apr 12 12:00:04 1982</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, ctime(&amp;some_time_epoch));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 Is DST: 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Is DST: %d\n&quot;</span>, some_time.tm_isdst);</span><br></pre></td></tr></table></figure>

<h3 id="difftime"><a href="#difftime" class="headerlink" title="difftime()"></a>difftime()</h3><p><code>difftime()</code>用来计算两个时间之间的差异。Unix 系统上，直接相减两个 time_t 值，就可以得到相差的秒数，但是为了程序的可移植性，最好还是使用这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">difftime</span><span class="params">( <span class="type">time_t</span> time1, <span class="type">time_t</span> time2 )</span>;</span><br></pre></td></tr></table></figure>

<p><code>difftime()</code>函数接受两个 time_t 类型的时间作为参数，计算 time1 - time2 的差，并把结果转换为秒。</p>
<p>注意它的返回值是 double 类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_a</span> =</span> &#123;</span><br><span class="line">    .tm_year=<span class="number">82</span>, </span><br><span class="line">    .tm_mon=<span class="number">3</span>,   </span><br><span class="line">    .tm_mday=<span class="number">12</span>, </span><br><span class="line">    .tm_hour=<span class="number">4</span>,  </span><br><span class="line">    .tm_min=<span class="number">00</span>,  </span><br><span class="line">    .tm_sec=<span class="number">04</span>,  </span><br><span class="line">    .tm_isdst=<span class="number">-1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_b</span> =</span> &#123;</span><br><span class="line">    .tm_year=<span class="number">120</span>,</span><br><span class="line">    .tm_mon=<span class="number">10</span>,  </span><br><span class="line">    .tm_mday=<span class="number">15</span>, </span><br><span class="line">    .tm_hour=<span class="number">16</span>, </span><br><span class="line">    .tm_min=<span class="number">27</span>,  </span><br><span class="line">    .tm_sec=<span class="number">00</span>,  </span><br><span class="line">    .tm_isdst=<span class="number">-1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">    </span><br><span class="line">  <span class="type">time_t</span> cal_a = mktime(&amp;time_a);</span><br><span class="line">  <span class="type">time_t</span> cal_b = mktime(&amp;time_b);</span><br><span class="line">    </span><br><span class="line">  <span class="type">double</span> diff = difftime(cal_b, cal_a);</span><br><span class="line">    </span><br><span class="line">  <span class="type">double</span> years = diff / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span> / <span class="number">365.2425</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 输出 1217996816.000000 seconds (38.596783 years) between events</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%f seconds (%f years) between events\n&quot;</span>, diff, years);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，折算年份时，为了尽量准确，使用了一年的准确长度 365.2425 天，这样可以抵消闰年的影响。</p>
<h3 id="strftime"><a href="#strftime" class="headerlink" title="strftime()"></a>strftime()</h3><p><code>strftime()</code>函数用来将 struct tm 结构转换为一个指定格式的字符串，并复制到指定地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">char</span>* str, </span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> maxsize, </span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span>* format, </span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> tm* timeptr</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><code>strftime()</code>接受四个参数。</p>
<ul>
<li>第一个参数：目标字符串的指针。</li>
<li>第二个参数：目标字符串可以接受的最大长度。</li>
<li>第三个参数：格式字符串。</li>
<li>第四个参数：struct tm 结构。</li>
</ul>
<p>如果执行成功（转换并复制），<code>strftime()</code>函数返回复制的字符串长度；如果执行失败，返回<code>-1</code>。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">128</span>];</span><br><span class="line">  <span class="type">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// %c: 本地时间</span></span><br><span class="line">  strftime(s, <span class="keyword">sizeof</span> s, <span class="string">&quot;%c&quot;</span>, localtime(&amp;now));</span><br><span class="line">  <span class="built_in">puts</span>(s);   <span class="comment">// Sun Feb 28 22:29:00 2021</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// %A: 完整的星期日期的名称</span></span><br><span class="line">  <span class="comment">// %B: 完整的月份名称</span></span><br><span class="line">  <span class="comment">// %d: 月份的天数</span></span><br><span class="line">  strftime(s, <span class="keyword">sizeof</span> s, <span class="string">&quot;%A, %B %d&quot;</span>, localtime(&amp;now));</span><br><span class="line">  <span class="built_in">puts</span>(s);   <span class="comment">// Sunday, February 28</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// %I: 小时（12小时制）</span></span><br><span class="line">  <span class="comment">// %M: 分钟</span></span><br><span class="line">  <span class="comment">// %S: 秒数</span></span><br><span class="line">  <span class="comment">// %p: AM 或 PM</span></span><br><span class="line">  strftime(s, <span class="keyword">sizeof</span> s, <span class="string">&quot;It&#x27;s %I:%M:%S %p&quot;</span>, localtime(&amp;now));</span><br><span class="line">  <span class="built_in">puts</span>(s);   <span class="comment">// It&#x27;s 10:29:00 PM</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// %F: ISO 8601 yyyy-mm-dd 格式</span></span><br><span class="line">  <span class="comment">// %T: ISO 8601 hh:mm:ss 格式</span></span><br><span class="line">  <span class="comment">// %z: ISO 8601 时区</span></span><br><span class="line">  strftime(s, <span class="keyword">sizeof</span> s, <span class="string">&quot;ISO 8601: %FT%T%z&quot;</span>, localtime(&amp;now));</span><br><span class="line">  <span class="built_in">puts</span>(s);   <span class="comment">// ISO 8601: 2021-02-28T22:29:00-0800</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是常用的格式占位符。</p>
<ul>
<li>%%：输出 % 字符。</li>
<li>%a：星期几的简写形式，以当地时间计算。</li>
<li>%A：星期几的完整形式，以当地时间计算。</li>
<li>%b：月份的简写形式，以当地时间计算。</li>
<li>%B：月份的完整形式，以当地时间计算。</li>
<li>%c：日期和时间，使用“%x %X”。</li>
<li>%d：月份的天数（01-31）。</li>
<li>%H：小时，采用24小时制（00-23）。</li>
<li>%I：小时，采用12小时制（00-12）。</li>
<li>%J：一年的第几天（001-366）。</li>
<li>%m：月数（01-12）。</li>
<li>%M：分钟（00～59）。</li>
<li>%P：AM 或 PM。</li>
<li>%R：相当于”%H:%M”。</li>
<li>%S：秒（00-61）。</li>
<li>%U：一年的第几星期（00-53），以星期日为第1天。</li>
<li>%w：一星期的第几天，星期日为第0天。</li>
<li>%W：一年的第几星期(00-53)，以星期一为第1天。</li>
<li>%x：完整的年月日的日期，以当地时间计算。</li>
<li>%X：完整的时分秒的时间，以当地时间计算。</li>
<li>%y：两位数年份（00-99）。</li>
<li>%Y：四位数年份（例如 1984）。</li>
<li>%Z：时区的简写。</li>
</ul>
<h3 id="timespec-get"><a href="#timespec-get" class="headerlink" title="timespec_get()"></a>timespec_get()</h3><p><code>timespec_get()</code>用来将当前时间转成距离时间纪元的纳秒数（十亿分之一秒）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">timespec_get</span> <span class="params">( <span class="keyword">struct</span> timespec* ts, <span class="type">int</span> base )</span> ;</span><br></pre></td></tr></table></figure>

<p><code>timespec_get()</code>接受两个参数。</p>
<p>第一个参数是 struct timespec 结构指针，用来保存转换后的时间信息。struct timespec 的结构如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">  <span class="type">time_t</span> tv_sec;   <span class="comment">// 秒数</span></span><br><span class="line">  <span class="type">long</span>   tv_nsec;  <span class="comment">// 纳秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二个参数是一个整数，表示时间计算的起点。标准只给出了宏 TIME_UTC 这一个可能的值，表示返回距离时间纪元的秒数。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    </span><br><span class="line">timespec_get(&amp;ts, TIME_UTC);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 1614581530 s, 806325800 ns</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld s, %ld ns\n&quot;</span>, ts.tv_sec, ts.tv_nsec);</span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> float_time = ts.tv_sec + ts.tv_nsec/<span class="number">1000000000.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1614581530.806326 seconds since epoch</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f seconds since epoch\n&quot;</span>, float_time);</span><br></pre></td></tr></table></figure>

<h3 id="clock"><a href="#clock" class="headerlink" title="clock()"></a>clock()</h3><p><code>clock()</code>函数返回从程序开始执行到当前的 CPU 时钟周期。一个时钟周期等于 CPU 频率的倒数，比如 CPU 的频率如果是 1G Hz，表示1秒内时钟信号可以变化 10^9 次，那么每个时钟周期就是 10^-9 秒。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">clock_t</span>　<span class="title function_">clock</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>clock()</code>函数返回一个数字，表示从程序开始到现在的 CPU 时钟周期的次数。这个值的类型是 clock_t，一般是 long int 类型。</p>
<p>为了把这个值转换为秒，应该把它除以常量<code>CLOCKS_PER_SEC</code>（每秒的时钟周期），这个常量也由<code>time.h</code>定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;CPU time: %f\n&quot;</span>, clock() / (<span class="type">double</span>)CLOCKS_PER_SEC);</span><br></pre></td></tr></table></figure>

<p>上面示例可以输出程序从开始到运行到这一行所花费的秒数。</p>
<p>如果计算机无法提供 CPU 时间，或者返回值太大，无法用<code>clock_t</code>类型表示，<code>clock()</code>函数就返回<code>-1</code>。</p>
<p>为了知道某个操作所耗费的精确时间，需要调用两次<code>clock()</code>，然后将两次的返回值相减。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">clock_t</span> start = clock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 执行某些操作</span></span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> end = clock();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> seconds = (<span class="type">float</span>)(end - start) / CLOCKS_PER_SEC;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://serhack.me/articles/measure-execution-time-program/">How to Measure Execution Time of a Program</a></li>
</ul>
<h2 id="wchar-h"><a href="#wchar-h" class="headerlink" title="wchar.h"></a>wchar.h</h2><p>宽字符使用两个或四个字节表示一个字符，导致 C 语言常规的字符处理函数都会失效。wchar.h 定义了许多宽字符专用的处理函数。</p>
<h3 id="类型别名和宏-1"><a href="#类型别名和宏-1" class="headerlink" title="类型别名和宏"></a>类型别名和宏</h3><p>wchar.h 定义了一个类型别名 wint_t，表示宽字符对应整数值。</p>
<p>wchar.h 还定义了一个宏 WEOF，表示文件结束字符 EOF 的宽字符版。</p>
<h3 id="btowc-，wctob"><a href="#btowc-，wctob" class="headerlink" title="btowc()，wctob()"></a>btowc()，wctob()</h3><p><code>btowc()</code>将单字节字符转换为宽字符，<code>wctob()</code>将宽字符转换为单字节字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span> <span class="title function_">btowc</span><span class="params">(<span class="type">int</span> c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wctob</span><span class="params">(<span class="type">wint_t</span> c)</span>;</span><br></pre></td></tr></table></figure>

<p><code>btowc()</code>返回一个宽字符。如果参数是 EOF，或转换失败，则返回 WEOF。</p>
<p><code>wctob()</code>返回一个单字节字符。如果参数是 WEOF，或者参数宽字符无法对应单个的单字节字符，则返回 EOF。</p>
<p>下面是用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span> wc = btowc(<span class="string">&#x27;B&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出宽字符 B</span></span><br><span class="line">wprintf(<span class="string">L&quot;Wide character: %lc\n&quot;</span>, wc);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = wctob(wc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出单字节字符 B</span></span><br><span class="line">wprintf(<span class="string">L&quot;Single-byte character: %c\n&quot;</span>, c);</span><br></pre></td></tr></table></figure>

<h3 id="fwide"><a href="#fwide" class="headerlink" title="fwide()"></a>fwide()</h3><p><code>fwide()</code>用来设置一个字节流是宽字符流，还是多字节字符流。</p>
<p>如果使用宽字符专用函数处理字节流，就会默认设置字节流为宽字符流，否则就需要使用<code>fwide()</code>显式设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fwide</span><span class="params">(FILE* stream, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，第一个参数是文件指针，第二个参数是字节流模式，有三种选择。</p>
<ul>
<li>0：字节流模式保持原样。</li>
<li>-1（或其他负值）：设为多字节字符流。</li>
<li>1（或其他正值）：设为宽字符流。</li>
</ul>
<p><code>fwide()</code>的返回值也分成三种情况：如果是宽字符流，返回一个正值；如果是多字节字符流，返回一个负值；如果是普通字符流，返回<code>0</code>。</p>
<p>一旦设置了字节流模式，就无法再更改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  wprintf(<span class="string">L&quot;Hello world!\n&quot;</span>);</span><br><span class="line">  <span class="type">int</span> mode = fwide(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  wprintf(<span class="string">L&quot;Stream is %ls-oriented\n&quot;</span>, mode &lt; <span class="number">0</span> ? <span class="string">L&quot;byte&quot;</span> : <span class="string">L&quot;wide&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>wprintf()</code>将字节流隐式设为宽字符模式，所以<code>fwide(stdout, 0)</code>的返回值大于零。</p>
<h3 id="宽字符专用函数"><a href="#宽字符专用函数" class="headerlink" title="宽字符专用函数"></a>宽字符专用函数</h3><p>下面这些函数基本都是 stdio.h 里面的字符处理函数的宽字符版本，必须使用这些函数来操作宽字符。</p>
<ul>
<li>fgetwc() 从宽字符流中获取宽字符，对应 fgetc()。</li>
<li>fgetws() 从宽字符流中读取宽字符串，对应 fgets()。</li>
<li>fputwc() 将宽字符写入宽字符流，对应 fputc()。</li>
<li>fputws() 将宽字符串写入宽字符流，对应 fputs()。</li>
<li>fwprintf() 格式化宽输出到宽字符流，对应 fprintf()。</li>
<li>fwscanf() 来自宽字符流的格式化宽字符输入，对应 fscanf()。</li>
<li>getwchar() 从 stdin 获取一个宽字符，对应 getchar()。</li>
<li>getwc() 从 stdin 获取一个宽字符，对应 getc()。</li>
<li>putwchar() 写一个宽字符到 stdout，对应 putchar()。</li>
<li>putwc() 写一个宽字符到 stdout，对应 putc()。</li>
<li>swprintf() 格式化宽输出到宽字符串，对应 sprintf()。</li>
<li>swscanf() 来自宽字符串的格式化宽输入，对应 sscanf()。</li>
<li>ungetwc() 将宽字符推回输入流，对应 ungetc()。</li>
<li>vfwprintf() 可变参数的格式化宽字符输出到宽字符流，对应 vfprintf()。</li>
<li>vfwscanf() 来自宽字符流的可变参数格式化宽字符输入，对应 vfscanf()。</li>
<li>vswprintf() 可变参数的格式化宽字符输出到宽字符串，对应 vswprintf()。</li>
<li>vswscanf() 来自宽字符串的可变参数格式化宽字符输入，对应 vsscanf()。</li>
<li>vwprintf() 可变参数格式化宽字符输出，对应 vprintf()。</li>
<li>vwscanf() 可变参数的格式化宽字符输入，对应 vscanf()。</li>
<li>wcscat() 危险地连接宽字符串，对应 strcat()。</li>
<li>wcschr() 在宽字符串中查找宽字符，对应 strchr()。</li>
<li>wcscmp() 比较宽字符串，对应 strcmp()。</li>
<li>wcscoll() 比较两个考虑语言环境的宽字符串，对应 strcoll()。</li>
<li>wcscpy() 危险地复制宽字符串，对应 strcpy()。</li>
<li>wcscspn() 不是从宽字符串前面开始计算字符，对应 strcspn()。</li>
<li>wcsftime() 格式化的日期和时间输出，对应 strftime()。</li>
<li>wcslen() 返回宽字符串的长度，对应 strlen()。</li>
<li>wcsncat() 更安全地连接宽字符串，对应 strncat()。</li>
<li>wcsncmp() 比较宽字符串，长度有限，对应 strncmp()。</li>
<li>wcsncpy() 更安全地复制宽字符串，对应 strncpy()。</li>
<li>wcspbrk() 在宽字符串中搜索一组宽字符中的一个，对应 strpbrk()。</li>
<li>wcsrchr() 从末尾开始在宽字符串中查找宽字符，对应 strrchr()。</li>
<li>wcsspn() 从宽字符串前面的集合中计算字符，对应 strspn()。</li>
<li>wcsstr() 在另一个宽字符串中找到一个宽字符串，对应 strstr()。</li>
<li>wcstod() 将宽字符串转换为 double，对应 strtod()。</li>
<li>wcstof() 将宽字符串转换为 float，对应 strtof()。</li>
<li>wcstok() 标记一个宽字符串，对应 strtok()。</li>
<li>wcstold() 将宽字符串转换为 long double，对应 strtold()。</li>
<li>wcstoll() 将宽字符串转换为 long long，对应 strtoll()。</li>
<li>wcstol() 将宽字符串转换为 long，对应 strtol()。</li>
<li>wcstoull() 将宽字符串转换为 unsigned long long，对应 strtoull()。</li>
<li>wcstoul() 将宽字符串转换为 unsigned long，对应 strtoul()。</li>
<li>wcsxfrm() 转换宽字符串以根据语言环境进行比较，对应 strxfrm()。</li>
<li>wmemcmp() 比较内存中的宽字符，对应 memcmp()。</li>
<li>wmemcpy() 复制宽字符内存，对应 memcpy()。</li>
<li>wmemmove() 复制宽字符内存，可能重叠，对应 memmove()。</li>
<li>wprintf() 格式化宽输出，对应 printf()。</li>
<li>wscanf() 格式化宽输入，对应 scanf()。</li>
</ul>
<h3 id="多字节字符专用函数"><a href="#多字节字符专用函数" class="headerlink" title="多字节字符专用函数"></a>多字节字符专用函数</h3><p>wchar.h 也定义了一些多字节字符的专用函数。</p>
<ul>
<li>mbsinit() 判断 mbstate_t 是否处于初始转换状态。</li>
<li>mbrlen() 给定转换状态时，计算多字节字符串的字节数，对应 mblen()。</li>
<li>mbrtowc() 给定转换状态时，将多字节字符转换为宽字符，对应 mbtowc()。</li>
<li>wctombr() 给定转换状态时，将宽字符转换为多字节字符，对应 wctomb()。</li>
<li>mbsrtowcs() 给定转换状态时，将多字节字符串转换为宽字符串，对应 mbstowcs()。</li>
<li>wcsrtombs() 给定转换状态时，将宽字符串转换为多字节字符串，对应 wcstombs()。</li>
</ul>
<h2 id="wctype-h"><a href="#wctype-h" class="headerlink" title="wctype.h"></a>wctype.h</h2><p>wctype.h 提供 ctype.h 里面函数的宽字符版本。</p>
<h3 id="宽字符类型判断函数"><a href="#宽字符类型判断函数" class="headerlink" title="宽字符类型判断函数"></a>宽字符类型判断函数</h3><p>下面函数判断宽字符的类型。</p>
<ul>
<li>iswalnum() 测试宽字符是否为字母数字</li>
<li>iswalpha() 测试宽字符是否为字母</li>
<li>iswblank() 测试这是否是一个宽空白字符</li>
<li>iswcntrl() 测试这是否是一个宽控制字符。</li>
<li>iswdigit() 测试这个宽字符是否是数字</li>
<li>iswgraph() 测试宽字符是否是可打印的非空格字符</li>
<li>iswlower() 测试宽字符是否为小写</li>
<li>iswprint() 测试宽字符是否可打印</li>
<li>iswpunct() 测试宽字符是否为标点符号</li>
<li>iswspace() 测试宽字符是否为空格</li>
<li>iswupper() 测试宽字符是否为大写</li>
<li>iswxdigit() 测试宽字符是否为十六进制数字</li>
</ul>
<h3 id="wctype-，iswctype"><a href="#wctype-，iswctype" class="headerlink" title="wctype()，iswctype()"></a>wctype()，iswctype()</h3><p><code>iswctype()</code>是上一节各种宽字符类型判断函数的通用版本，必须与<code>wctype()</code>配合使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">iswctype</span><span class="params">(<span class="type">wint_t</span> wc, <span class="type">wctype_t</span> desc)</span>;</span><br></pre></td></tr></table></figure>

<p><code>iswctype()</code>接受两个参数，第一个参数是一个需要判断类型的宽字符，第二个参数是宽字符类型描述，来自<code>wctype()</code>的返回值。</p>
<p>如果宽字符属于指定类型，<code>iswctype()</code>返回一个非零值，否则返回零。</p>
<p><code>wctype()</code>用来获取某个种类宽字符的类型描述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wctype_t</span> <span class="title function_">wctype</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* property)</span>;</span><br></pre></td></tr></table></figure>

<p><code>wctype()</code>的参数是一个给定的字符串，可用的值如下：alnum、alpha、blank、cntrl、digit、graph、lower、print、punct、space、upper、xdigit。</p>
<p><code>wctype()</code>的返回值的类型为 wctype_t，通常是一个整数。如果参数是一个无效值，则返回<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (iswctype(c, wctype(<span class="string">&quot;digit&quot;</span>)))</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">if</span> (iswdigit(c))</span><br></pre></td></tr></table></figure>

<p>上面示例用来判断宽字符<code>c</code>是否为数值，相当于<code>iswdigit()</code>。</p>
<p><code>iswctype()</code>的完整类型判断如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">iswctype(c, wctype(<span class="string">&quot;alnum&quot;</span>)) <span class="comment">// 相当于 iswalnum(c)</span></span><br><span class="line">iswctype(c, wctype(<span class="string">&quot;alpha&quot;</span>)) <span class="comment">// 相当于 iswalpha(c)</span></span><br><span class="line">iswctype(c, wctype(<span class="string">&quot;blank&quot;</span>)) <span class="comment">// 相当于 iswblank(c)</span></span><br><span class="line">iswctype(c, wctype(<span class="string">&quot;cntrl&quot;</span>)) <span class="comment">// 相当于 iswcntrl(c)</span></span><br><span class="line">iswctype(c, wctype(<span class="string">&quot;digit&quot;</span>)) <span class="comment">// 相当于 iswdigit(c)</span></span><br><span class="line">iswctype(c, wctype(<span class="string">&quot;graph&quot;</span>)) <span class="comment">// 相当于 iswgraph(c)</span></span><br><span class="line">iswctype(c, wctype(<span class="string">&quot;lower&quot;</span>)) <span class="comment">// 相当于 iswlower(c)</span></span><br><span class="line">iswctype(c, wctype(<span class="string">&quot;print&quot;</span>)) <span class="comment">// 相当于 iswprint(c)</span></span><br><span class="line">iswctype(c, wctype(<span class="string">&quot;punct&quot;</span>)) <span class="comment">// 相当于 iswpunct(c)</span></span><br><span class="line">iswctype(c, wctype(<span class="string">&quot;space&quot;</span>)) <span class="comment">// 相当于 iswspace(c)</span></span><br><span class="line">iswctype(c, wctype(<span class="string">&quot;upper&quot;</span>)) <span class="comment">// 相当于 iswupper(c)</span></span><br><span class="line">iswctype(c, wctype(<span class="string">&quot;xdigit&quot;</span>)) <span class="comment">// 相当于 iswxdigit(c)</span></span><br></pre></td></tr></table></figure>

<h3 id="大小写转换函数"><a href="#大小写转换函数" class="headerlink" title="大小写转换函数"></a>大小写转换函数</h3><p>wctype.h 提供以下宽字符大小写转换函数。</p>
<ul>
<li>towlower() 将大写宽字符转换为小写</li>
<li>towupper() 将小写宽字符转换为大写</li>
<li>towctrans() 宽字符大小写转换的通用函数</li>
<li>wctrans() 大小写转换的辅助函数，配合 towctrans() 使用</li>
</ul>
<p>先看<code>towlower()</code>和<code>towupper()</code>的用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">towlower(<span class="string">L&#x27;B&#x27;</span>) <span class="comment">// b</span></span><br><span class="line">towupper(<span class="string">L&#x27;e&#x27;</span>) <span class="comment">// E</span></span><br></pre></td></tr></table></figure>

<p><code>towctrans()</code>和<code>wctrans()</code>的原型如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span> <span class="title function_">towctrans</span><span class="params">(<span class="type">wint_t</span> wc, <span class="type">wctrans_t</span> desc)</span>;</span><br><span class="line"><span class="type">wctrans_t</span> <span class="title function_">wctrans</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* property)</span>;</span><br></pre></td></tr></table></figure>

<p>下面是它们的用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">towctrans(c, wctrans(<span class="string">&quot;toupper&quot;</span>)) <span class="comment">// 相当于 towupper(c)</span></span><br><span class="line">towctrans(c, wctrans(<span class="string">&quot;tolower&quot;</span>)) <span class="comment">// 相当于 towlower(c)</span></span><br></pre></td></tr></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>《C语言入门教程》阮一峰</p><p><a href="https://mxts.jiujiuer.xyz/2021/11/02/计算机科学/编程语言/C·C++/《C语言入门教程》阮一峰/">https://mxts.jiujiuer.xyz/2021/11/02/计算机科学/编程语言/C·C++/《C语言入门教程》阮一峰/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>阮一峰</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-11-02</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-07-01</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://mxts.jiujiuer.xyz/" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/11/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">C语言学习笔记：预处理器</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/28/%E6%B8%B8%E6%88%8F/Minecraft/%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E5%B2%A9%E7%89%88%E7%9A%84%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/"><span class="level-item">写一个基岩版的启动脚本</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "732155b56537b6b1dbe36104d16025a3",
            repo: "xeonds.github.io",
            owner: "xeonds",
            clientID: "2bfc40bc0b5fef7b0688",
            clientSecret: "475f278f70ff3f0888e047f10766ab6929168f78",
            admin: ["xeonds"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#C-语言简介"><span class="level-left"><span class="level-item">1</span><span class="level-item">C 语言简介</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#历史"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">历史</span></span></a></li><li><a class="level is-mobile" href="#C-语言的特点"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">C 语言的特点</span></span></a></li><li><a class="level is-mobile" href="#C-语言的版本"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">C 语言的版本</span></span></a></li><li><a class="level is-mobile" href="#C-语言的编译"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">C 语言的编译</span></span></a></li><li><a class="level is-mobile" href="#Hello-World-示例"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">Hello World 示例</span></span></a></li></ul></li><li><a class="level is-mobile" href="#C-语言基本语法"><span class="level-left"><span class="level-item">2</span><span class="level-item">C 语言基本语法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#语句"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">语句</span></span></a></li><li><a class="level is-mobile" href="#表达式"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">表达式</span></span></a></li><li><a class="level is-mobile" href="#语句块"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">语句块</span></span></a></li><li><a class="level is-mobile" href="#空格"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">空格</span></span></a></li><li><a class="level is-mobile" href="#注释"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">注释</span></span></a></li><li><a class="level is-mobile" href="#printf"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">printf()</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基本用法"><span class="level-left"><span class="level-item">2.6.1</span><span class="level-item">基本用法</span></span></a></li><li><a class="level is-mobile" href="#占位符"><span class="level-left"><span class="level-item">2.6.2</span><span class="level-item">占位符</span></span></a></li><li><a class="level is-mobile" href="#输出格式"><span class="level-left"><span class="level-item">2.6.3</span><span class="level-item">输出格式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#标准库，头文件"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">标准库，头文件</span></span></a></li></ul></li><li><a class="level is-mobile" href="#变量"><span class="level-left"><span class="level-item">3</span><span class="level-item">变量</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#变量名"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">变量名</span></span></a></li><li><a class="level is-mobile" href="#变量的声明"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">变量的声明</span></span></a></li><li><a class="level is-mobile" href="#变量的赋值"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">变量的赋值</span></span></a></li><li><a class="level is-mobile" href="#变量的作用域"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">变量的作用域</span></span></a></li></ul></li><li><a class="level is-mobile" href="#运算符"><span class="level-left"><span class="level-item">4</span><span class="level-item">运算符</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#算术运算符"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">算术运算符</span></span></a></li><li><a class="level is-mobile" href="#自增运算符，自减运算符"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">自增运算符，自减运算符</span></span></a></li><li><a class="level is-mobile" href="#关系运算符"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">关系运算符</span></span></a></li><li><a class="level is-mobile" href="#逻辑运算符"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">逻辑运算符</span></span></a></li><li><a class="level is-mobile" href="#位运算符"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">位运算符</span></span></a></li><li><a class="level is-mobile" href="#逗号运算符"><span class="level-left"><span class="level-item">4.6</span><span class="level-item">逗号运算符</span></span></a></li><li><a class="level is-mobile" href="#运算优先级"><span class="level-left"><span class="level-item">4.7</span><span class="level-item">运算优先级</span></span></a></li></ul></li><li><a class="level is-mobile" href="#流程控制"><span class="level-left"><span class="level-item">5</span><span class="level-item">流程控制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#if-语句"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">if 语句</span></span></a></li><li><a class="level is-mobile" href="#三元运算符"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">三元运算符 ?</span></span></a></li><li><a class="level is-mobile" href="#switch-语句"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">switch 语句</span></span></a></li><li><a class="level is-mobile" href="#while-语句"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">while 语句</span></span></a></li><li><a class="level is-mobile" href="#do…while-结构"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">do…while 结构</span></span></a></li><li><a class="level is-mobile" href="#for-语句"><span class="level-left"><span class="level-item">5.6</span><span class="level-item">for 语句</span></span></a></li><li><a class="level is-mobile" href="#break-语句"><span class="level-left"><span class="level-item">5.7</span><span class="level-item">break 语句</span></span></a></li><li><a class="level is-mobile" href="#continue-语句"><span class="level-left"><span class="level-item">5.8</span><span class="level-item">continue 语句</span></span></a></li><li><a class="level is-mobile" href="#goto-语句"><span class="level-left"><span class="level-item">5.9</span><span class="level-item">goto 语句</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据类型"><span class="level-left"><span class="level-item">6</span><span class="level-item">数据类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#字符类型"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">字符类型</span></span></a></li><li><a class="level is-mobile" href="#整数类型"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">整数类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介"><span class="level-left"><span class="level-item">6.2.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#signed，unsigned"><span class="level-left"><span class="level-item">6.2.2</span><span class="level-item">signed，unsigned</span></span></a></li><li><a class="level is-mobile" href="#整数的子类型"><span class="level-left"><span class="level-item">6.2.3</span><span class="level-item">整数的子类型</span></span></a></li><li><a class="level is-mobile" href="#整数类型的极限值"><span class="level-left"><span class="level-item">6.2.4</span><span class="level-item">整数类型的极限值</span></span></a></li><li><a class="level is-mobile" href="#整数的进制"><span class="level-left"><span class="level-item">6.2.5</span><span class="level-item">整数的进制</span></span></a></li></ul></li><li><a class="level is-mobile" href="#浮点数类型"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">浮点数类型</span></span></a></li><li><a class="level is-mobile" href="#布尔类型"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">布尔类型</span></span></a></li><li><a class="level is-mobile" href="#字面量的类型"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">字面量的类型</span></span></a></li><li><a class="level is-mobile" href="#字面量后缀"><span class="level-left"><span class="level-item">6.6</span><span class="level-item">字面量后缀</span></span></a></li><li><a class="level is-mobile" href="#溢出"><span class="level-left"><span class="level-item">6.7</span><span class="level-item">溢出</span></span></a></li><li><a class="level is-mobile" href="#sizeof-运算符"><span class="level-left"><span class="level-item">6.8</span><span class="level-item">sizeof 运算符</span></span></a></li><li><a class="level is-mobile" href="#类型的自动转换"><span class="level-left"><span class="level-item">6.9</span><span class="level-item">类型的自动转换</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#赋值运算"><span class="level-left"><span class="level-item">6.9.1</span><span class="level-item">赋值运算</span></span></a></li><li><a class="level is-mobile" href="#混合类型的运算"><span class="level-left"><span class="level-item">6.9.2</span><span class="level-item">混合类型的运算</span></span></a></li><li><a class="level is-mobile" href="#整数类型的运算"><span class="level-left"><span class="level-item">6.9.3</span><span class="level-item">整数类型的运算</span></span></a></li><li><a class="level is-mobile" href="#函数"><span class="level-left"><span class="level-item">6.9.4</span><span class="level-item">函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#类型的显式转换"><span class="level-left"><span class="level-item">6.10</span><span class="level-item">类型的显式转换</span></span></a></li><li><a class="level is-mobile" href="#可移植类型"><span class="level-left"><span class="level-item">6.11</span><span class="level-item">可移植类型</span></span></a></li></ul></li><li><a class="level is-mobile" href="#指针"><span class="level-left"><span class="level-item">7</span><span class="level-item">指针</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介-1"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#运算符-1"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">* 运算符</span></span></a></li><li><a class="level is-mobile" href="#amp-运算符"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">&amp; 运算符</span></span></a></li><li><a class="level is-mobile" href="#指针变量的初始化"><span class="level-left"><span class="level-item">7.4</span><span class="level-item">指针变量的初始化</span></span></a></li><li><a class="level is-mobile" href="#指针的运算"><span class="level-left"><span class="level-item">7.5</span><span class="level-item">指针的运算</span></span></a></li></ul></li><li><a class="level is-mobile" href="#函数-1"><span class="level-left"><span class="level-item">8</span><span class="level-item">函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介-2"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#main"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">main()</span></span></a></li><li><a class="level is-mobile" href="#参数的传值引用"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">参数的传值引用</span></span></a></li><li><a class="level is-mobile" href="#函数指针"><span class="level-left"><span class="level-item">8.4</span><span class="level-item">函数指针</span></span></a></li><li><a class="level is-mobile" href="#函数原型"><span class="level-left"><span class="level-item">8.5</span><span class="level-item">函数原型</span></span></a></li><li><a class="level is-mobile" href="#exit"><span class="level-left"><span class="level-item">8.6</span><span class="level-item">exit()</span></span></a></li><li><a class="level is-mobile" href="#函数说明符"><span class="level-left"><span class="level-item">8.7</span><span class="level-item">函数说明符</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#extern-说明符"><span class="level-left"><span class="level-item">8.7.1</span><span class="level-item">extern 说明符</span></span></a></li><li><a class="level is-mobile" href="#static-说明符"><span class="level-left"><span class="level-item">8.7.2</span><span class="level-item">static 说明符</span></span></a></li><li><a class="level is-mobile" href="#const-说明符"><span class="level-left"><span class="level-item">8.7.3</span><span class="level-item">const 说明符</span></span></a></li></ul></li><li><a class="level is-mobile" href="#可变参数"><span class="level-left"><span class="level-item">8.8</span><span class="level-item">可变参数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数组"><span class="level-left"><span class="level-item">9</span><span class="level-item">数组</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介-3"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#数组长度"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">数组长度</span></span></a></li><li><a class="level is-mobile" href="#多维数组"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">多维数组</span></span></a></li><li><a class="level is-mobile" href="#变长数组"><span class="level-left"><span class="level-item">9.4</span><span class="level-item">变长数组</span></span></a></li><li><a class="level is-mobile" href="#数组的地址"><span class="level-left"><span class="level-item">9.5</span><span class="level-item">数组的地址</span></span></a></li><li><a class="level is-mobile" href="#数组指针的加减法"><span class="level-left"><span class="level-item">9.6</span><span class="level-item">数组指针的加减法</span></span></a></li><li><a class="level is-mobile" href="#数组的复制"><span class="level-left"><span class="level-item">9.7</span><span class="level-item">数组的复制</span></span></a></li><li><a class="level is-mobile" href="#作为函数的参数"><span class="level-left"><span class="level-item">9.8</span><span class="level-item">作为函数的参数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#声明参数数组"><span class="level-left"><span class="level-item">9.8.1</span><span class="level-item">声明参数数组</span></span></a></li><li><a class="level is-mobile" href="#变长数组作为参数"><span class="level-left"><span class="level-item">9.8.2</span><span class="level-item">变长数组作为参数</span></span></a></li><li><a class="level is-mobile" href="#数组字面量作为参数"><span class="level-left"><span class="level-item">9.8.3</span><span class="level-item">数组字面量作为参数</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#字符串"><span class="level-left"><span class="level-item">10</span><span class="level-item">字符串</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介-4"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#字符串变量的声明"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">字符串变量的声明</span></span></a></li><li><a class="level is-mobile" href="#strlen"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">strlen()</span></span></a></li><li><a class="level is-mobile" href="#strcpy"><span class="level-left"><span class="level-item">10.4</span><span class="level-item">strcpy()</span></span></a></li><li><a class="level is-mobile" href="#strncpy"><span class="level-left"><span class="level-item">10.5</span><span class="level-item">strncpy()</span></span></a></li><li><a class="level is-mobile" href="#strcat"><span class="level-left"><span class="level-item">10.6</span><span class="level-item">strcat()</span></span></a></li><li><a class="level is-mobile" href="#strncat"><span class="level-left"><span class="level-item">10.7</span><span class="level-item">strncat()</span></span></a></li><li><a class="level is-mobile" href="#strcmp"><span class="level-left"><span class="level-item">10.8</span><span class="level-item">strcmp()</span></span></a></li><li><a class="level is-mobile" href="#strncmp"><span class="level-left"><span class="level-item">10.9</span><span class="level-item">strncmp()</span></span></a></li><li><a class="level is-mobile" href="#sprintf-，snprintf"><span class="level-left"><span class="level-item">10.10</span><span class="level-item">sprintf()，snprintf()</span></span></a></li><li><a class="level is-mobile" href="#字符串数组"><span class="level-left"><span class="level-item">10.11</span><span class="level-item">字符串数组</span></span></a></li></ul></li><li><a class="level is-mobile" href="#C-语言的内存管理"><span class="level-left"><span class="level-item">11</span><span class="level-item">C 语言的内存管理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介-5"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#void-指针"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">void 指针</span></span></a></li><li><a class="level is-mobile" href="#malloc"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">malloc()</span></span></a></li><li><a class="level is-mobile" href="#free"><span class="level-left"><span class="level-item">11.4</span><span class="level-item">free()</span></span></a></li><li><a class="level is-mobile" href="#calloc"><span class="level-left"><span class="level-item">11.5</span><span class="level-item">calloc()</span></span></a></li><li><a class="level is-mobile" href="#realloc"><span class="level-left"><span class="level-item">11.6</span><span class="level-item">realloc()</span></span></a></li><li><a class="level is-mobile" href="#restrict-说明符"><span class="level-left"><span class="level-item">11.7</span><span class="level-item">restrict 说明符</span></span></a></li><li><a class="level is-mobile" href="#memcpy"><span class="level-left"><span class="level-item">11.8</span><span class="level-item">memcpy()</span></span></a></li><li><a class="level is-mobile" href="#memmove"><span class="level-left"><span class="level-item">11.9</span><span class="level-item">memmove()</span></span></a></li><li><a class="level is-mobile" href="#memcmp"><span class="level-left"><span class="level-item">11.10</span><span class="level-item">memcmp()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#struct-结构"><span class="level-left"><span class="level-item">12</span><span class="level-item">struct 结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介-6"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#struct-的复制"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">struct 的复制</span></span></a></li><li><a class="level is-mobile" href="#struct-指针"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">struct 指针</span></span></a></li><li><a class="level is-mobile" href="#struct-的嵌套"><span class="level-left"><span class="level-item">12.4</span><span class="level-item">struct 的嵌套</span></span></a></li><li><a class="level is-mobile" href="#位字段"><span class="level-left"><span class="level-item">12.5</span><span class="level-item">位字段</span></span></a></li><li><a class="level is-mobile" href="#弹性数组成员"><span class="level-left"><span class="level-item">12.6</span><span class="level-item">弹性数组成员</span></span></a></li></ul></li><li><a class="level is-mobile" href="#typedef-命令"><span class="level-left"><span class="level-item">13</span><span class="level-item">typedef 命令</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介-7"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#主要好处"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">主要好处</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Union-结构"><span class="level-left"><span class="level-item">14</span><span class="level-item">Union 结构</span></span></a></li><li><a class="level is-mobile" href="#Enum-类型"><span class="level-left"><span class="level-item">15</span><span class="level-item">Enum 类型</span></span></a></li><li><a class="level is-mobile" href="#预处理器（Preprocessor）"><span class="level-left"><span class="level-item">16</span><span class="level-item">预处理器（Preprocessor）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介-8"><span class="level-left"><span class="level-item">16.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#define"><span class="level-left"><span class="level-item">16.2</span><span class="level-item">#define</span></span></a></li><li><a class="level is-mobile" href="#带参数的宏"><span class="level-left"><span class="level-item">16.3</span><span class="level-item">带参数的宏</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基本用法-1"><span class="level-left"><span class="level-item">16.3.1</span><span class="level-item">基本用法</span></span></a></li><li><a class="level is-mobile" href="#运算符，-运算符"><span class="level-left"><span class="level-item">16.3.2</span><span class="level-item">#运算符，##运算符</span></span></a></li><li><a class="level is-mobile" href="#不定参数的宏"><span class="level-left"><span class="level-item">16.3.3</span><span class="level-item">不定参数的宏</span></span></a></li></ul></li><li><a class="level is-mobile" href="#undef"><span class="level-left"><span class="level-item">16.4</span><span class="level-item">#undef</span></span></a></li><li><a class="level is-mobile" href="#include"><span class="level-left"><span class="level-item">16.5</span><span class="level-item">#include</span></span></a></li><li><a class="level is-mobile" href="#if…-endif"><span class="level-left"><span class="level-item">16.6</span><span class="level-item">#if…#endif</span></span></a></li><li><a class="level is-mobile" href="#ifdef…-endif"><span class="level-left"><span class="level-item">16.7</span><span class="level-item">#ifdef…#endif</span></span></a></li><li><a class="level is-mobile" href="#defined-运算符"><span class="level-left"><span class="level-item">16.8</span><span class="level-item">defined 运算符</span></span></a></li><li><a class="level is-mobile" href="#ifndef…-endif"><span class="level-left"><span class="level-item">16.9</span><span class="level-item">#ifndef…#endif</span></span></a></li><li><a class="level is-mobile" href="#预定义宏"><span class="level-left"><span class="level-item">16.10</span><span class="level-item">预定义宏</span></span></a></li><li><a class="level is-mobile" href="#line"><span class="level-left"><span class="level-item">16.11</span><span class="level-item">#line</span></span></a></li><li><a class="level is-mobile" href="#error"><span class="level-left"><span class="level-item">16.12</span><span class="level-item">#error</span></span></a></li><li><a class="level is-mobile" href="#pragma"><span class="level-left"><span class="level-item">16.13</span><span class="level-item">#pragma</span></span></a></li></ul></li><li><a class="level is-mobile" href="#I-x2F-O-函数"><span class="level-left"><span class="level-item">17</span><span class="level-item">I/O 函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#缓存和字节流"><span class="level-left"><span class="level-item">17.1</span><span class="level-item">缓存和字节流</span></span></a></li><li><a class="level is-mobile" href="#printf-1"><span class="level-left"><span class="level-item">17.2</span><span class="level-item">printf()</span></span></a></li><li><a class="level is-mobile" href="#scanf"><span class="level-left"><span class="level-item">17.3</span><span class="level-item">scanf()</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基本用法-2"><span class="level-left"><span class="level-item">17.3.1</span><span class="level-item">基本用法</span></span></a></li><li><a class="level is-mobile" href="#占位符-1"><span class="level-left"><span class="level-item">17.3.2</span><span class="level-item">占位符</span></span></a></li><li><a class="level is-mobile" href="#赋值忽略符"><span class="level-left"><span class="level-item">17.3.3</span><span class="level-item">赋值忽略符</span></span></a></li></ul></li><li><a class="level is-mobile" href="#sscanf"><span class="level-left"><span class="level-item">17.4</span><span class="level-item">sscanf()</span></span></a></li><li><a class="level is-mobile" href="#getchar-，putchar"><span class="level-left"><span class="level-item">17.5</span><span class="level-item">getchar()，putchar()</span></span></a></li><li><a class="level is-mobile" href="#puts"><span class="level-left"><span class="level-item">17.6</span><span class="level-item">puts()</span></span></a></li><li><a class="level is-mobile" href="#gets"><span class="level-left"><span class="level-item">17.7</span><span class="level-item">gets()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#文件操作"><span class="level-left"><span class="level-item">18</span><span class="level-item">文件操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#文件指针"><span class="level-left"><span class="level-item">18.1</span><span class="level-item">文件指针</span></span></a></li><li><a class="level is-mobile" href="#fopen"><span class="level-left"><span class="level-item">18.2</span><span class="level-item">fopen()</span></span></a></li><li><a class="level is-mobile" href="#标准流"><span class="level-left"><span class="level-item">18.3</span><span class="level-item">标准流</span></span></a></li><li><a class="level is-mobile" href="#fclose"><span class="level-left"><span class="level-item">18.4</span><span class="level-item">fclose()</span></span></a></li><li><a class="level is-mobile" href="#EOF"><span class="level-left"><span class="level-item">18.5</span><span class="level-item">EOF</span></span></a></li><li><a class="level is-mobile" href="#freopen"><span class="level-left"><span class="level-item">18.6</span><span class="level-item">freopen()</span></span></a></li><li><a class="level is-mobile" href="#fgetc-，getc"><span class="level-left"><span class="level-item">18.7</span><span class="level-item">fgetc()，getc()</span></span></a></li><li><a class="level is-mobile" href="#fputc-，putc"><span class="level-left"><span class="level-item">18.8</span><span class="level-item">fputc()，putc()</span></span></a></li><li><a class="level is-mobile" href="#fprintf"><span class="level-left"><span class="level-item">18.9</span><span class="level-item">fprintf()</span></span></a></li><li><a class="level is-mobile" href="#fscanf"><span class="level-left"><span class="level-item">18.10</span><span class="level-item">fscanf()</span></span></a></li><li><a class="level is-mobile" href="#fgets"><span class="level-left"><span class="level-item">18.11</span><span class="level-item">fgets()</span></span></a></li><li><a class="level is-mobile" href="#fputs"><span class="level-left"><span class="level-item">18.12</span><span class="level-item">fputs()</span></span></a></li><li><a class="level is-mobile" href="#fwrite"><span class="level-left"><span class="level-item">18.13</span><span class="level-item">fwrite()</span></span></a></li><li><a class="level is-mobile" href="#fread"><span class="level-left"><span class="level-item">18.14</span><span class="level-item">fread()</span></span></a></li><li><a class="level is-mobile" href="#feof"><span class="level-left"><span class="level-item">18.15</span><span class="level-item">feof()</span></span></a></li><li><a class="level is-mobile" href="#fseek"><span class="level-left"><span class="level-item">18.16</span><span class="level-item">fseek()</span></span></a></li><li><a class="level is-mobile" href="#ftell"><span class="level-left"><span class="level-item">18.17</span><span class="level-item">ftell()</span></span></a></li><li><a class="level is-mobile" href="#rewind"><span class="level-left"><span class="level-item">18.18</span><span class="level-item">rewind()</span></span></a></li><li><a class="level is-mobile" href="#fgetpos-，fsetpos"><span class="level-left"><span class="level-item">18.19</span><span class="level-item">fgetpos()，fsetpos()</span></span></a></li><li><a class="level is-mobile" href="#ferror-，clearerr"><span class="level-left"><span class="level-item">18.20</span><span class="level-item">ferror()，clearerr()</span></span></a></li><li><a class="level is-mobile" href="#remove"><span class="level-left"><span class="level-item">18.21</span><span class="level-item">remove()</span></span></a></li><li><a class="level is-mobile" href="#rename"><span class="level-left"><span class="level-item">18.22</span><span class="level-item">rename()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#变量说明符"><span class="level-left"><span class="level-item">19</span><span class="level-item">变量说明符</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#const"><span class="level-left"><span class="level-item">19.1</span><span class="level-item">const</span></span></a></li><li><a class="level is-mobile" href="#static"><span class="level-left"><span class="level-item">19.2</span><span class="level-item">static</span></span></a></li><li><a class="level is-mobile" href="#auto"><span class="level-left"><span class="level-item">19.3</span><span class="level-item">auto</span></span></a></li><li><a class="level is-mobile" href="#extern"><span class="level-left"><span class="level-item">19.4</span><span class="level-item">extern</span></span></a></li><li><a class="level is-mobile" href="#register"><span class="level-left"><span class="level-item">19.5</span><span class="level-item">register</span></span></a></li><li><a class="level is-mobile" href="#volatile"><span class="level-left"><span class="level-item">19.6</span><span class="level-item">volatile</span></span></a></li><li><a class="level is-mobile" href="#restrict"><span class="level-left"><span class="level-item">19.7</span><span class="level-item">restrict</span></span></a></li></ul></li><li><a class="level is-mobile" href="#多文件项目"><span class="level-left"><span class="level-item">20</span><span class="level-item">多文件项目</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介-9"><span class="level-left"><span class="level-item">20.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#重复加载"><span class="level-left"><span class="level-item">20.2</span><span class="level-item">重复加载</span></span></a></li><li><a class="level is-mobile" href="#extern-说明符-1"><span class="level-left"><span class="level-item">20.3</span><span class="level-item">extern 说明符</span></span></a></li><li><a class="level is-mobile" href="#static-说明符-1"><span class="level-left"><span class="level-item">20.4</span><span class="level-item">static 说明符</span></span></a></li><li><a class="level is-mobile" href="#编译策略"><span class="level-left"><span class="level-item">20.5</span><span class="level-item">编译策略</span></span></a></li><li><a class="level is-mobile" href="#make-命令"><span class="level-left"><span class="level-item">20.6</span><span class="level-item">make 命令</span></span></a></li></ul></li><li><a class="level is-mobile" href="#命令行环境"><span class="level-left"><span class="level-item">21</span><span class="level-item">命令行环境</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#命令行参数"><span class="level-left"><span class="level-item">21.1</span><span class="level-item">命令行参数</span></span></a></li><li><a class="level is-mobile" href="#退出状态"><span class="level-left"><span class="level-item">21.2</span><span class="level-item">退出状态</span></span></a></li><li><a class="level is-mobile" href="#环境变量"><span class="level-left"><span class="level-item">21.3</span><span class="level-item">环境变量</span></span></a></li></ul></li><li><a class="level is-mobile" href="#多字节字符"><span class="level-left"><span class="level-item">22</span><span class="level-item">多字节字符</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Unicode-简介"><span class="level-left"><span class="level-item">22.1</span><span class="level-item">Unicode 简介</span></span></a></li><li><a class="level is-mobile" href="#字符的表示方法"><span class="level-left"><span class="level-item">22.2</span><span class="level-item">字符的表示方法</span></span></a></li><li><a class="level is-mobile" href="#多字节字符的表示"><span class="level-left"><span class="level-item">22.3</span><span class="level-item">多字节字符的表示</span></span></a></li><li><a class="level is-mobile" href="#宽字符"><span class="level-left"><span class="level-item">22.4</span><span class="level-item">宽字符</span></span></a></li><li><a class="level is-mobile" href="#多字节字符处理函数"><span class="level-left"><span class="level-item">22.5</span><span class="level-item">多字节字符处理函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#mblen"><span class="level-left"><span class="level-item">22.5.1</span><span class="level-item">mblen()</span></span></a></li><li><a class="level is-mobile" href="#wctomb"><span class="level-left"><span class="level-item">22.5.2</span><span class="level-item">wctomb()</span></span></a></li><li><a class="level is-mobile" href="#mbtowc"><span class="level-left"><span class="level-item">22.5.3</span><span class="level-item">mbtowc()</span></span></a></li><li><a class="level is-mobile" href="#wcstombs"><span class="level-left"><span class="level-item">22.5.4</span><span class="level-item">wcstombs()</span></span></a></li><li><a class="level is-mobile" href="#mbstowcs"><span class="level-left"><span class="level-item">22.5.5</span><span class="level-item">mbstowcs()</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#assert-h"><span class="level-left"><span class="level-item">23</span><span class="level-item">assert.h</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#assert"><span class="level-left"><span class="level-item">23.1</span><span class="level-item">assert()</span></span></a></li><li><a class="level is-mobile" href="#static-assert"><span class="level-left"><span class="level-item">23.2</span><span class="level-item">static_assert()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#ctype-h"><span class="level-left"><span class="level-item">24</span><span class="level-item">ctype.h</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#字符测试函数"><span class="level-left"><span class="level-item">24.1</span><span class="level-item">字符测试函数</span></span></a></li><li><a class="level is-mobile" href="#字符映射函数"><span class="level-left"><span class="level-item">24.2</span><span class="level-item">字符映射函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#errno-h"><span class="level-left"><span class="level-item">25</span><span class="level-item">errno.h</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#errno-变量"><span class="level-left"><span class="level-item">25.1</span><span class="level-item">errno 变量</span></span></a></li><li><a class="level is-mobile" href="#宏"><span class="level-left"><span class="level-item">25.2</span><span class="level-item">宏</span></span></a></li></ul></li><li><a class="level is-mobile" href="#float-h"><span class="level-left"><span class="level-item">26</span><span class="level-item">float.h</span></span></a></li><li><a class="level is-mobile" href="#inttypes-h"><span class="level-left"><span class="level-item">27</span><span class="level-item">inttypes.h</span></span></a></li><li><a class="level is-mobile" href="#iso646-h"><span class="level-left"><span class="level-item">28</span><span class="level-item">iso646.h</span></span></a></li><li><a class="level is-mobile" href="#limits-h"><span class="level-left"><span class="level-item">29</span><span class="level-item">limits.h</span></span></a></li><li><a class="level is-mobile" href="#locale-h"><span class="level-left"><span class="level-item">30</span><span class="level-item">locale.h</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介-10"><span class="level-left"><span class="level-item">30.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#setlocale"><span class="level-left"><span class="level-item">30.2</span><span class="level-item">setlocale()</span></span></a></li><li><a class="level is-mobile" href="#localeconv"><span class="level-left"><span class="level-item">30.3</span><span class="level-item">localeconv()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#math-h"><span class="level-left"><span class="level-item">31</span><span class="level-item">math.h</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#类型和宏"><span class="level-left"><span class="level-item">31.1</span><span class="level-item">类型和宏</span></span></a></li><li><a class="level is-mobile" href="#错误类型"><span class="level-left"><span class="level-item">31.2</span><span class="level-item">错误类型</span></span></a></li><li><a class="level is-mobile" href="#数值类型"><span class="level-left"><span class="level-item">31.3</span><span class="level-item">数值类型</span></span></a></li><li><a class="level is-mobile" href="#signbit"><span class="level-left"><span class="level-item">31.4</span><span class="level-item">signbit()</span></span></a></li><li><a class="level is-mobile" href="#三角函数"><span class="level-left"><span class="level-item">31.5</span><span class="level-item">三角函数</span></span></a></li><li><a class="level is-mobile" href="#双曲函数"><span class="level-left"><span class="level-item">31.6</span><span class="level-item">双曲函数</span></span></a></li><li><a class="level is-mobile" href="#指数函数和对数函数"><span class="level-left"><span class="level-item">31.7</span><span class="level-item">指数函数和对数函数</span></span></a></li><li><a class="level is-mobile" href="#frexp"><span class="level-left"><span class="level-item">31.8</span><span class="level-item">frexp()</span></span></a></li><li><a class="level is-mobile" href="#ilogb"><span class="level-left"><span class="level-item">31.9</span><span class="level-item">ilogb()</span></span></a></li><li><a class="level is-mobile" href="#ldexp"><span class="level-left"><span class="level-item">31.10</span><span class="level-item">ldexp()</span></span></a></li><li><a class="level is-mobile" href="#modf"><span class="level-left"><span class="level-item">31.11</span><span class="level-item">modf()</span></span></a></li><li><a class="level is-mobile" href="#scalbn"><span class="level-left"><span class="level-item">31.12</span><span class="level-item">scalbn()</span></span></a></li><li><a class="level is-mobile" href="#round"><span class="level-left"><span class="level-item">31.13</span><span class="level-item">round()</span></span></a></li><li><a class="level is-mobile" href="#trunc"><span class="level-left"><span class="level-item">31.14</span><span class="level-item">trunc()</span></span></a></li><li><a class="level is-mobile" href="#ceil"><span class="level-left"><span class="level-item">31.15</span><span class="level-item">ceil()</span></span></a></li><li><a class="level is-mobile" href="#floor"><span class="level-left"><span class="level-item">31.16</span><span class="level-item">floor()</span></span></a></li><li><a class="level is-mobile" href="#fmod"><span class="level-left"><span class="level-item">31.17</span><span class="level-item">fmod()</span></span></a></li><li><a class="level is-mobile" href="#浮点数比较函数"><span class="level-left"><span class="level-item">31.18</span><span class="level-item">浮点数比较函数</span></span></a></li><li><a class="level is-mobile" href="#isunordered"><span class="level-left"><span class="level-item">31.19</span><span class="level-item">isunordered()</span></span></a></li><li><a class="level is-mobile" href="#其他函数"><span class="level-left"><span class="level-item">31.20</span><span class="level-item">其他函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#signal-h"><span class="level-left"><span class="level-item">32</span><span class="level-item">signal.h</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介-11"><span class="level-left"><span class="level-item">32.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#signal"><span class="level-left"><span class="level-item">32.2</span><span class="level-item">signal()</span></span></a></li><li><a class="level is-mobile" href="#信号相关的宏"><span class="level-left"><span class="level-item">32.3</span><span class="level-item">信号相关的宏</span></span></a></li><li><a class="level is-mobile" href="#raise"><span class="level-left"><span class="level-item">32.4</span><span class="level-item">raise()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#stdarg-h"><span class="level-left"><span class="level-item">33</span><span class="level-item">stdarg.h</span></span></a></li><li><a class="level is-mobile" href="#stdbool-h"><span class="level-left"><span class="level-item">34</span><span class="level-item">stdbool.h</span></span></a></li><li><a class="level is-mobile" href="#stddef-h"><span class="level-left"><span class="level-item">35</span><span class="level-item">stddef.h</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#offsetof"><span class="level-left"><span class="level-item">35.1</span><span class="level-item">offsetof()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#stdint-h"><span class="level-left"><span class="level-item">36</span><span class="level-item">stdint.h</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#固定宽度的整数类型"><span class="level-left"><span class="level-item">36.1</span><span class="level-item">固定宽度的整数类型</span></span></a></li><li><a class="level is-mobile" href="#最大宽度的整数类型"><span class="level-left"><span class="level-item">36.2</span><span class="level-item">最大宽度的整数类型</span></span></a></li><li><a class="level is-mobile" href="#固定宽度的整数常量"><span class="level-left"><span class="level-item">36.3</span><span class="level-item">固定宽度的整数常量</span></span></a></li><li><a class="level is-mobile" href="#固定宽度的整数极限值"><span class="level-left"><span class="level-item">36.4</span><span class="level-item">固定宽度的整数极限值</span></span></a></li><li><a class="level is-mobile" href="#占位符-2"><span class="level-left"><span class="level-item">36.5</span><span class="level-item">占位符</span></span></a></li></ul></li><li><a class="level is-mobile" href="#stdio-h"><span class="level-left"><span class="level-item">37</span><span class="level-item">stdio.h</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#标准-I-x2F-O-函数"><span class="level-left"><span class="level-item">37.1</span><span class="level-item">标准 I/O 函数</span></span></a></li><li><a class="level is-mobile" href="#文件操作函数"><span class="level-left"><span class="level-item">37.2</span><span class="level-item">文件操作函数</span></span></a></li><li><a class="level is-mobile" href="#字符串操作函数"><span class="level-left"><span class="level-item">37.3</span><span class="level-item">字符串操作函数</span></span></a></li><li><a class="level is-mobile" href="#tmpfile"><span class="level-left"><span class="level-item">37.4</span><span class="level-item">tmpfile()</span></span></a></li><li><a class="level is-mobile" href="#tmpnam"><span class="level-left"><span class="level-item">37.5</span><span class="level-item">tmpnam()</span></span></a></li><li><a class="level is-mobile" href="#fflush"><span class="level-left"><span class="level-item">37.6</span><span class="level-item">fflush()</span></span></a></li><li><a class="level is-mobile" href="#setvbuf"><span class="level-left"><span class="level-item">37.7</span><span class="level-item">setvbuf()</span></span></a></li><li><a class="level is-mobile" href="#setbuf"><span class="level-left"><span class="level-item">37.8</span><span class="level-item">setbuf()</span></span></a></li><li><a class="level is-mobile" href="#ungetc"><span class="level-left"><span class="level-item">37.9</span><span class="level-item">ungetc()</span></span></a></li><li><a class="level is-mobile" href="#perror"><span class="level-left"><span class="level-item">37.10</span><span class="level-item">perror()</span></span></a></li><li><a class="level is-mobile" href="#可变参数操作函数"><span class="level-left"><span class="level-item">37.11</span><span class="level-item">可变参数操作函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#stdlib-h"><span class="level-left"><span class="level-item">38</span><span class="level-item">stdlib.h</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#类型别名和宏"><span class="level-left"><span class="level-item">38.1</span><span class="level-item">类型别名和宏</span></span></a></li><li><a class="level is-mobile" href="#abs-，labs-，llabs"><span class="level-left"><span class="level-item">38.2</span><span class="level-item">abs()，labs()，llabs()</span></span></a></li><li><a class="level is-mobile" href="#div-，ldiv-，lldiv"><span class="level-left"><span class="level-item">38.3</span><span class="level-item">div()，ldiv()，lldiv()</span></span></a></li><li><a class="level is-mobile" href="#字符串转成数值"><span class="level-left"><span class="level-item">38.4</span><span class="level-item">字符串转成数值</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#a-系列函数"><span class="level-left"><span class="level-item">38.4.1</span><span class="level-item">a 系列函数</span></span></a></li><li><a class="level is-mobile" href="#str-系列函数（浮点数转换）"><span class="level-left"><span class="level-item">38.4.2</span><span class="level-item">str 系列函数（浮点数转换）</span></span></a></li><li><a class="level is-mobile" href="#str-系列函数（整数转换）"><span class="level-left"><span class="level-item">38.4.3</span><span class="level-item">str 系列函数（整数转换）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#rand"><span class="level-left"><span class="level-item">38.5</span><span class="level-item">rand()</span></span></a></li><li><a class="level is-mobile" href="#srand"><span class="level-left"><span class="level-item">38.6</span><span class="level-item">srand()</span></span></a></li><li><a class="level is-mobile" href="#abort"><span class="level-left"><span class="level-item">38.7</span><span class="level-item">abort()</span></span></a></li><li><a class="level is-mobile" href="#exit-，quick-exit-，-Exit"><span class="level-left"><span class="level-item">38.8</span><span class="level-item">exit()，quick_exit()，_Exit()</span></span></a></li><li><a class="level is-mobile" href="#atexit-，at-quick-exit"><span class="level-left"><span class="level-item">38.9</span><span class="level-item">atexit()，at_quick_exit()</span></span></a></li><li><a class="level is-mobile" href="#getenv"><span class="level-left"><span class="level-item">38.10</span><span class="level-item">getenv()</span></span></a></li><li><a class="level is-mobile" href="#system"><span class="level-left"><span class="level-item">38.11</span><span class="level-item">system()</span></span></a></li><li><a class="level is-mobile" href="#内存管理函数"><span class="level-left"><span class="level-item">38.12</span><span class="level-item">内存管理函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#aligned-alloc"><span class="level-left"><span class="level-item">38.12.1</span><span class="level-item">aligned_alloc()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#qsort"><span class="level-left"><span class="level-item">38.13</span><span class="level-item">qsort()</span></span></a></li><li><a class="level is-mobile" href="#bsearch"><span class="level-left"><span class="level-item">38.14</span><span class="level-item">bsearch()</span></span></a></li><li><a class="level is-mobile" href="#多字节字符函数"><span class="level-left"><span class="level-item">38.15</span><span class="level-item">多字节字符函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#string-h"><span class="level-left"><span class="level-item">39</span><span class="level-item">string.h</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#字符串处理函数"><span class="level-left"><span class="level-item">39.1</span><span class="level-item">字符串处理函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#strchr-，strrchr"><span class="level-left"><span class="level-item">39.1.1</span><span class="level-item">strchr()，strrchr()</span></span></a></li><li><a class="level is-mobile" href="#strspn-，strcspn"><span class="level-left"><span class="level-item">39.1.2</span><span class="level-item">strspn()，strcspn()</span></span></a></li><li><a class="level is-mobile" href="#strpbrk"><span class="level-left"><span class="level-item">39.1.3</span><span class="level-item">strpbrk()</span></span></a></li><li><a class="level is-mobile" href="#strstr"><span class="level-left"><span class="level-item">39.1.4</span><span class="level-item">strstr()</span></span></a></li><li><a class="level is-mobile" href="#strtok"><span class="level-left"><span class="level-item">39.1.5</span><span class="level-item">strtok()</span></span></a></li><li><a class="level is-mobile" href="#strcoll"><span class="level-left"><span class="level-item">39.1.6</span><span class="level-item">strcoll()</span></span></a></li><li><a class="level is-mobile" href="#strxfrm"><span class="level-left"><span class="level-item">39.1.7</span><span class="level-item">strxfrm()</span></span></a></li><li><a class="level is-mobile" href="#strerror"><span class="level-left"><span class="level-item">39.1.8</span><span class="level-item">strerror()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#内存操作函数"><span class="level-left"><span class="level-item">39.2</span><span class="level-item">内存操作函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#memchr"><span class="level-left"><span class="level-item">39.2.1</span><span class="level-item">memchr()</span></span></a></li><li><a class="level is-mobile" href="#memset"><span class="level-left"><span class="level-item">39.2.2</span><span class="level-item">memset()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#其他函数-1"><span class="level-left"><span class="level-item">39.3</span><span class="level-item">其他函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#time-h"><span class="level-left"><span class="level-item">40</span><span class="level-item">time.h</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#time-t"><span class="level-left"><span class="level-item">40.1</span><span class="level-item">time_t</span></span></a></li><li><a class="level is-mobile" href="#struct-tm"><span class="level-left"><span class="level-item">40.2</span><span class="level-item">struct tm</span></span></a></li><li><a class="level is-mobile" href="#time"><span class="level-left"><span class="level-item">40.3</span><span class="level-item">time()</span></span></a></li><li><a class="level is-mobile" href="#ctime"><span class="level-left"><span class="level-item">40.4</span><span class="level-item">ctime()</span></span></a></li><li><a class="level is-mobile" href="#localtime-，gmtime"><span class="level-left"><span class="level-item">40.5</span><span class="level-item">localtime()，gmtime()</span></span></a></li><li><a class="level is-mobile" href="#asctime"><span class="level-left"><span class="level-item">40.6</span><span class="level-item">asctime()</span></span></a></li><li><a class="level is-mobile" href="#mktime"><span class="level-left"><span class="level-item">40.7</span><span class="level-item">mktime()</span></span></a></li><li><a class="level is-mobile" href="#difftime"><span class="level-left"><span class="level-item">40.8</span><span class="level-item">difftime()</span></span></a></li><li><a class="level is-mobile" href="#strftime"><span class="level-left"><span class="level-item">40.9</span><span class="level-item">strftime()</span></span></a></li><li><a class="level is-mobile" href="#timespec-get"><span class="level-left"><span class="level-item">40.10</span><span class="level-item">timespec_get()</span></span></a></li><li><a class="level is-mobile" href="#clock"><span class="level-left"><span class="level-item">40.11</span><span class="level-item">clock()</span></span></a></li><li><a class="level is-mobile" href="#参考链接"><span class="level-left"><span class="level-item">40.12</span><span class="level-item">参考链接</span></span></a></li></ul></li><li><a class="level is-mobile" href="#wchar-h"><span class="level-left"><span class="level-item">41</span><span class="level-item">wchar.h</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#类型别名和宏-1"><span class="level-left"><span class="level-item">41.1</span><span class="level-item">类型别名和宏</span></span></a></li><li><a class="level is-mobile" href="#btowc-，wctob"><span class="level-left"><span class="level-item">41.2</span><span class="level-item">btowc()，wctob()</span></span></a></li><li><a class="level is-mobile" href="#fwide"><span class="level-left"><span class="level-item">41.3</span><span class="level-item">fwide()</span></span></a></li><li><a class="level is-mobile" href="#宽字符专用函数"><span class="level-left"><span class="level-item">41.4</span><span class="level-item">宽字符专用函数</span></span></a></li><li><a class="level is-mobile" href="#多字节字符专用函数"><span class="level-left"><span class="level-item">41.5</span><span class="level-item">多字节字符专用函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#wctype-h"><span class="level-left"><span class="level-item">42</span><span class="level-item">wctype.h</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#宽字符类型判断函数"><span class="level-left"><span class="level-item">42.1</span><span class="level-item">宽字符类型判断函数</span></span></a></li><li><a class="level is-mobile" href="#wctype-，iswctype"><span class="level-left"><span class="level-item">42.2</span><span class="level-item">wctype()，iswctype()</span></span></a></li><li><a class="level is-mobile" href="#大小写转换函数"><span class="level-left"><span class="level-item">42.3</span><span class="level-item">大小写转换函数</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="xeonds"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">xeonds</p><p class="is-size-6 is-block">ENJ0Y CREATiNG.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Solaris, Earth</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">165</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">31</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">89</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xeonds" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xeonds"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://holynia.github.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Holynia</span></span><span class="level-right"><span class="level-item tag">holynia.github.io</span></span></a></li><li><a class="level is-mobile" href="https://ray.al" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Ray</span></span><span class="level-right"><span class="level-item tag">ray.al</span></span></a></li><li><a class="level is-mobile" href="https://moefactory.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Robotxm</span></span><span class="level-right"><span class="level-item tag">moefactory.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.dml.ink" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Dimole</span></span><span class="level-right"><span class="level-item tag">blog.dml.ink</span></span></a></li><li><a class="level is-mobile" href="https://mxts.jiujiuer.xyz/links" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">All</span></span><span class="level-right"><span class="level-item tag">mxts.jiujiuer.xyz</span></span></a></li><li><a class="level is-mobile" href="https://blog.iris.al/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">极速版（？</span></span><span class="level-right"><span class="level-item tag">blog.iris.al</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-30T19:54:58.000Z">2024-07-01</time></p><p class="title"><a href="/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OpenWRT%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/">OpenWRT折腾笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-05-04T03:58:02.000Z">2024-05-04</time></p><p class="title"><a href="/2024/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%9C%A8Wayland%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%97%A0%E7%BA%BF%E5%89%AF%E5%B1%8F/">在Wayland中使用无线副屏</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-27T13:12:15.000Z">2024-04-27</time></p><p class="title"><a href="/2024/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">搜索引擎学习笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-19T03:42:50.000Z">2024-04-19</time></p><p class="title"><a href="/2024/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Emmet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Emmet学习笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-14T07:54:33.000Z">2024-04-14</time></p><p class="title"><a href="/2024/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0/">开发手记</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">49</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">56</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/"><span class="level-start"><span class="level-item">2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/favicon.ico" alt="神社的储物间" height="28"></a><p class="is-size-7"><span>&copy; 2024 阮一峰</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>