<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>C语言SQLite3使用总结 - 神社的储物间</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="神社的储物间"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="神社的储物间"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="大一大作业那会用了一次"><meta property="og:type" content="blog"><meta property="og:title" content="C语言SQLite3使用总结"><meta property="og:url" content="https://mxts.jiujiuer.xyz/2022/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80SQLite3%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="神社的储物间"><meta property="og:description" content="大一大作业那会用了一次"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mxts.jiujiuer.xyz/img/og_image.png"><meta property="article:published_time" content="2022-11-22T12:14:44.000Z"><meta property="article:modified_time" content="2025-03-02T11:53:17.732Z"><meta property="article:author" content="xeonds"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://mxts.jiujiuer.xyz/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mxts.jiujiuer.xyz/2022/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80SQLite3%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},"headline":"C语言SQLite3使用总结","image":["https://mxts.jiujiuer.xyz/img/og_image.png"],"datePublished":"2022-11-22T12:14:44.000Z","dateModified":"2025-03-02T11:53:17.732Z","author":{"@type":"Person","name":"xeonds"},"publisher":{"@type":"Organization","name":"神社的储物间","logo":{"@type":"ImageObject","url":"https://mxts.jiujiuer.xyz/img/favicon.ico"}},"description":"大一大作业那会用了一次"}</script><link rel="canonical" href="https://mxts.jiujiuer.xyz/2022/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80SQLite3%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"><link rel="alternate" href="/atom.xml" title="神社的储物间" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?59fd9f709f6626bf608f0b08415e0283";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/favicon.ico" alt="神社的储物间" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archive</a><a class="navbar-item" href="/categories">Category</a><a class="navbar-item" href="/tags">Tag</a><a class="navbar-item" href="/links">Link</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="My GitHub" href="https://github.com/xeonds"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-11-22T12:14:44.000Z" title="11/22/2022, 12:14:44 PM">2022-11-22</time>发表</span><span class="level-item"><time dateTime="2025-03-02T11:53:17.732Z" title="3/2/2025, 11:53:17 AM">2025-03-02</time>更新</span><span class="level-item"> xeonds </span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/">计算机科学</a><span> / </span><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span> / </span><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C/">C·C++</a></span><span class="level-item">2 小时读完 (大约15501个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">C语言SQLite3使用总结</h1><div class="content"><p>转载网址：<a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-8447633-id-3321394.html">查看</a></p>
<p>前序：</p>
<p>Sqlite3 的确很好用。小巧、速度快。但是因为非微软的产品，帮助文档总觉得不够。这些天再次研究它，又有一些收获，这里把我对 sqlite3 的研究列出来，以备忘记。</p>
<p>这里要注明，我是一个跨平台专注者，并不喜欢只用 windows 平台。我以前的工作就是为 unix 平台写代码。下面我所写的东西，虽然没有验证，但是我已尽量不使用任何 windows 的东西，只使用标准 C 或标准C++。但是，我没有尝试过在别的系统、别的编译器下编译，因此下面的叙述如果不正确，则留待以后修改。</p>
<p>下面我的代码仍然用 VC 编写，因为我觉得VC是一个很不错的IDE，可以加快代码编写速度（例如配合 Vassist ）。下面我所说的编译环境，是VC2003。如果读者觉得自己习惯于 unix 下用 vi 编写代码速度较快，可以不用管我的说明，只需要符合自己习惯即可，因为我用的是标准 C 或 C++ 。不会给任何人带来不便。</p>
<h2 id="一、版本"><a href="#一、版本" class="headerlink" title="一、版本"></a>一、版本</h2><p>从 <a target="_blank" rel="noopener" href="http://www.sqlite.org/">www.sqlite.org</a> 网站可下载到最新的 sqlite 代码和编译版本。我写此文章时，最新代码是 3.3.17 版本。</p>
<p>很久没有去下载 sqlite 新代码，因此也不知道 sqlite 变化这么大。以前很多文件，现在全部合并成一个 sqlite3.c 文件。如果单独用此文件，是挺好的，省去拷贝一堆文件还担心有没有遗漏。但是也带来一个问题：此文件太大，快接近7万行代码，VC开它整个机器都慢下来了。如果不需要改它代码，也就不需要打开 sqlite3.c 文件，机器不会慢。但是，下面我要写通过修改 sqlite 代码完成加密功能，那时候就比较痛苦了。如果个人水平较高，建议用些简单的编辑器来编辑，例如UltraEdit 或 Notepad 。速度会快很多。</p>
<h2 id="二、基本编译"><a href="#二、基本编译" class="headerlink" title="二、基本编译"></a>二、基本编译</h2><p>这个不想多说了，在 VC 里新建 dos 控制台空白工程，把 sqlite3.c 和 sqlite3.h 添加到工程，再新建一个 main.cpp文件。在里面写:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./sqlite3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> , <span class="type">char</span>** )</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要 extern “C” ？如果问这个问题，我不想说太多，这是C++的基础。要在 C++ 里使用一段 C 的代码，必须要用 extern “C” 括起来。C++跟 C虽然语法上有重叠，但是它们是两个不同的东西，内存里的布局是完全不同的，在C++编译器里不用extern “C”括起C代码，会导致编译器不知道该如何为 C 代码描述内存布局。</p>
<p>可能在 sqlite3.c 里人家已经把整段代码都 extern “C” 括起来了，但是你遇到一个 .c 文件就自觉的再括一次，也没什么不好。</p>
<p>基本工程就这样建立起来了。编译，可以通过。但是有一堆的 warning。可以不管它。</p>
<h2 id="三、SQLITE操作入门"><a href="#三、SQLITE操作入门" class="headerlink" title="三、SQLITE操作入门"></a>三、SQLITE操作入门</h2><p>sqlite提供的是一些C函数接口，你可以用这些函数操作数据库。通过使用这些接口，传递一些标准 sql 语句（以 char * 类型）给 sqlite 函数，sqlite 就会为你操作数据库。</p>
<p>sqlite 跟MS的access一样是文件型数据库，就是说，一个数据库就是一个文件，此数据库里可以建立很多的表，可以建立索引、触发器等等，但是，它实际上得到的就是一个文件。备份这个文件就备份了整个数据库。</p>
<p>sqlite 不需要任何数据库引擎，这意味着如果你需要 sqlite 来保存一些用户数据，甚至都不需要安装数据库(如果你做个小软件还要求人家必须装了sqlserver 才能运行，那也太黑心了)。</p>
<p>下面开始介绍数据库基本操作。</p>
<p>1 基本流程（1）关键数据结构</p>
<p>sqlite 里最常用到的是 sqlite3 * 类型。从数据库打开开始，sqlite就要为这个类型准备好内存，直到数据库关闭，整个过程都需要用到这个类型。当数据库打开时开始，这个类型的变量就代表了你要操作的数据库。下面再详细介绍。</p>
<p>（2）打开数据库</p>
<p>int sqlite3_open( 文件名, sqlite3 ** );</p>
<p>用这个函数开始数据库操作。</p>
<p>需要传入两个参数，一是数据库文件名，比如：c:&#x2F;&#x2F;DongChunGuang_Database.db。</p>
<p>文件名不需要一定存在，如果此文件不存在，sqlite 会自动建立它。如果它存在，就尝试把它当数据库文件来打开。</p>
<p>sqlite3 ** 参数即前面提到的关键数据结构。这个结构底层细节如何，你不要关它。</p>
<p>函数返回值表示操作是否正确，如果是 SQLITE_OK 则表示操作正常。相关的返回值sqlite定义了一些宏。具体这些宏的含义可以参考 sqlite3.h 文件。里面有详细定义（顺便说一下，sqlite3 的代码注释率自称是非常高的，实际上也的确很高。只要你会看英文，sqlite 可以让你学到不少东西）。</p>
<p>下面介绍关闭数据库后，再给一段参考代码。</p>
<p>（3）关闭数据库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_close</span><span class="params">(sqlite3 *)</span>;</span><br></pre></td></tr></table></figure>

<p>前面如果用 sqlite3_open 开启了一个数据库，结尾时不要忘了用这个函数关闭数据库。</p>
<p>下面给段简单的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./sqlite3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> , <span class="type">char</span>** )</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   sqlite3 * db = <span class="literal">NULL</span>; <span class="comment">//声明sqlite关键结构指针</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要传入 db 这个指针的指针，因为 sqlite3_open 函数要为这个指针分配内存，还要让db指针指向这个内存区</span></span><br><span class="line"></span><br><span class="line">   result = sqlite3_open( “c:<span class="comment">//Dcg_database.db”, &amp;db );</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>( result != SQLITE_OK )</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库打开失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据库操作代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//…</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据库打开成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭数据库</span></span><br><span class="line"></span><br><span class="line">sqlite3_close( db );</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一次数据库操作过程。</p>
<p>2 SQL语句操作</p>
<p>本节介绍如何用sqlite 执行标准 sql 语法。</p>
<p>（1）执行sql语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_exec</span><span class="params">(sqlite3*, <span class="type">const</span> <span class="type">char</span> *sql, sqlite3_callback, <span class="type">void</span> *,  <span class="type">char</span> **errmsg )</span>;</span><br></pre></td></tr></table></figure>

<p>这就是执行一条 sql 语句的函数。</p>
<p>第1个参数不再说了，是前面open函数得到的指针。说了是关键数据结构。</p>
<p>第2个参数const char *sql 是一条 sql 语句，以&#x2F;0结尾。</p>
<p>第3个参数sqlite3_callback 是回调，当这条语句执行之后，sqlite3会去调用你提供的这个函数。（什么是回调函数，自己找别的资料学习）</p>
<p>第4个参数void * 是你所提供的指针，你可以传递任何一个指针参数到这里，这个参数最终会传到回调函数里面，如果不需要传递指针给回调函数，可以填NULL。等下我们再看回调函数的写法，以及这个参数的使用。</p>
<p>第5个参数char ** errmsg 是错误信息。注意是指针的指针。sqlite3里面有很多固定的错误信息。执行 sqlite3_exec 之后，执行失败时可以查阅这个指针（直接 printf(“%s&#x2F;n”,errmsg)）得到一串字符串信息，这串信息告诉你错在什么地方。sqlite3_exec函数通过修改你传入的指针的指针，把你提供的指针指向错误提示信息，这样sqlite3_exec函数外面就可以通过这个 char*得到具体错误提示。</p>
<p>说明：通常，sqlite3_callback 和它后面的 void * 这两个位置都可以填 NULL。填NULL表示你不需要回调。比如你做insert 操作，做 delete 操作，就没有必要使用回调。而当你做 select 时，就要使用回调，因为 sqlite3 把数据查出来，得通过回调告诉你查出了什么数据。</p>
<p>（2）exec 的回调</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*sqlite3_callback)</span><span class="params">(<span class="type">void</span>*,<span class="type">int</span>,<span class="type">char</span>**, <span class="type">char</span>**)</span>;</span><br></pre></td></tr></table></figure>

<p>你的回调函数必须定义成上面这个函数的类型。下面给个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sqlite3的回调函数      </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sqlite 每查到一条记录，就调用一次这个回调</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LoadMyInfo</span><span class="params">( <span class="type">void</span> * para, <span class="type">int</span> n_column, <span class="type">char</span> ** column_value, <span class="type">char</span> ** column_name )</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//para是你在 sqlite3_exec 里传入的 void * 参数</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过para参数，你可以传入一些特殊的指针（比如类指针、结构指针），然后在这里面强制转换成对应的类型（这里面是void*类型，必须强制转换成你的类型才可用）。然后操作这些数据</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//n_column是这一条记录有多少个字段 (即这条记录有多少列)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// char ** column_value 是个关键值，查出来的数据都保存在这里，它实际上是个1维数组（不要以为是2维数组），每一个元素都是一个 char * 值，是一个字段内容（用字符串来表示，以/0结尾）</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//char ** column_name 跟 column_value是对应的，表示这个字段的字段名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里，我不使用 para 参数。忽略它的存在.</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>( “记录包含 %d 个字段/n”, n_column );</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; n_column; i ++ )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>( “字段名:%s  ß&gt; 字段值:%s/n”,  column_name[i], column_value[i] );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>( “------------------/n“ );        </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> , <span class="type">char</span> ** )</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    sqlite3 * db;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> * errmsg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    result = sqlite3_open( “c:<span class="comment">//Dcg_database.db”, &amp;db );</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( result != SQLITE_OK )</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据库打开失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据库操作代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个测试表，表名叫 MyTable_1，有2个字段： ID 和 name。其中ID是一个自动增加的类型，以后insert时可以不去指定这个字段，它会自己从0开始增加</span></span><br><span class="line"></span><br><span class="line">result = sqlite3_exec( db, “create table MyTable_1( ID integer primary key autoincrement, name nvarchar(<span class="number">32</span>) )”, <span class="literal">NULL</span>, <span class="literal">NULL</span>, errmsg );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result != SQLITE_OK )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>( “创建表失败，错误码:%d，错误原因:%s/n”, result, errmsg );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入一些记录</span></span><br><span class="line"></span><br><span class="line">result = sqlite3_exec( db, “insert into MyTable_1( name ) values ( ‘走路’ )”, <span class="number">0</span>, <span class="number">0</span>, errmsg );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result != SQLITE_OK )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>( “插入记录失败，错误码:%d，错误原因:%s/n”, result, errmsg );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = sqlite3_exec( db, “insert into MyTable_1( name ) values ( ‘骑单车’ )”, <span class="number">0</span>, <span class="number">0</span>, errmsg );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result != SQLITE_OK )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>( “插入记录失败，错误码:%d，错误原因:%s/n”, result, errmsg );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = sqlite3_exec( db, “insert into MyTable_1( name ) values ( ‘坐汽车’ )”, <span class="number">0</span>, <span class="number">0</span>, errmsg );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result != SQLITE_OK )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>( “插入记录失败，错误码:%d，错误原因:%s/n”, result, errmsg );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始查询数据库</span></span><br><span class="line"></span><br><span class="line">result = sqlite3_exec( db, “select * from MyTable_1”, LoadMyInfo, <span class="literal">NULL</span>, errmsg );</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭数据库</span></span><br><span class="line"></span><br><span class="line">sqlite3_close( db );</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的例子，应该可以知道如何打开一个数据库，如何做数据库基本操作。</p>
<p>有这些知识，基本上可以应付很多数据库操作了。</p>
<p>（3）不使用回调查询数据库</p>
<p>上面介绍的 sqlite3_exec 是使用回调来执行 select 操作。还有一个方法可以直接查询而不需要回调。但是，我个人感觉还是回调好，因为代码可以更加整齐，只不过用回调很麻烦，你得声明一个函数，如果这个函数是类成员函数，你还不得不把它声明成 static 的（要问为什么？这又是C++基础了。C++成员函数实际上隐藏了一个参数：this，C++调用类的成员函数的时候，隐含把类指针当成函数的第一个参数传递进去。结果，这造成跟前面说的 sqlite 回调函数的参数不相符。只有当把成员函数声明成 static 时，它才没有多余的隐含的this参数）。</p>
<p>虽然回调显得代码整齐，但有时候你还是想要非回调的 select 查询。这可以通过 sqlite3_get_table 函数做到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_get_table</span><span class="params">(sqlite3*, <span class="type">const</span> <span class="type">char</span> *sql, <span class="type">char</span> ***resultp, <span class="type">int</span> *nrow, <span class="type">int</span> *ncolumn, <span class="type">char</span> **errmsg )</span>;</span><br></pre></td></tr></table></figure>

<p>第1个参数不再多说，看前面的例子。</p>
<p>第2个参数是 sql 语句，跟 sqlite3_exec 里的 sql 是一样的。是一个很普通的以&#x2F;0结尾的char *字符串。</p>
<p>第3个参数是查询结果，它依然一维数组（不要以为是二维数组，更不要以为是三维数组）。它内存布局是：第一行是字段名称，后面是紧接着是每个字段的值。下面用例子来说事。</p>
<p>第4个参数是查询出多少条记录（即查出多少行）。</p>
<p>第5个参数是多少个字段（多少列）。</p>
<p>第6个参数是错误信息，跟前面一样，这里不多说了。</p>
<p>下面给个简单例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> , <span class="type">char</span> ** )</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   sqlite3 * db;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> * errmsg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> **dbResult; <span class="comment">//是 char ** 类型，两个*号</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> nRow, nColumn;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> i , j;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">   result = sqlite3_open( “c:<span class="comment">//Dcg_database.db”, &amp;db );</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>( result != SQLITE_OK )</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据库打开失败</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//数据库操作代码</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//假设前面已经创建了 MyTable_1 表</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//开始查询，传入的 dbResult 已经是 char **，这里又加了一个 &amp; 取地址符，传递进去的就成了 char ***</span></span><br><span class="line"></span><br><span class="line">   result = sqlite3_get_table( db, “select * from MyTable_1”, &amp;dbResult, &amp;nRow, &amp;nColumn, &amp;errmsg );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>( SQLITE_OK == result )</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询成功</span></span><br><span class="line"></span><br><span class="line">        index = nColumn; <span class="comment">//前面说过 dbResult 前面第一行数据是字段名称，从 nColumn 索引开始才是真正的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>( “查到%d条记录/n”, nRow );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(  i = <span class="number">0</span>; i &lt; nRow ; i++ )</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">             <span class="built_in">printf</span>( “第 %d 条记录/n”, i+<span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">             <span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; nColumn; j++ )</span><br><span class="line"></span><br><span class="line">             &#123;</span><br><span class="line"></span><br><span class="line">                  <span class="built_in">printf</span>( “字段名:%s  ß&gt; 字段值:%s/n”,  dbResult[j], dbResult [index] );</span><br><span class="line"></span><br><span class="line">                  ++index; <span class="comment">// dbResult 的字段值是连续的，从第0索引到第 nColumn - 1索引都是字段名称，从第 nColumn 索引开始，后面都是字段值，它把一个二维的表（传统的行列表示法）用一个扁平的形式来表示</span></span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="built_in">printf</span>( “-------/n” );</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//到这里，不论数据库查询是否成功，都释放 char** 查询结果，使用 sqlite 提供的功能来释放</span></span><br><span class="line"></span><br><span class="line">   sqlite3_free_table( dbResult );</span><br><span class="line"></span><br><span class="line">   <span class="comment">//关闭数据库</span></span><br><span class="line"></span><br><span class="line">   sqlite3_close( db );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这个例子为止，sqlite3 的常用用法都介绍完了。</p>
<p>用以上的方法，再配上 sql 语句，完全可以应付绝大多数数据库需求。</p>
<p>但有一种情况，用上面方法是无法实现的：需要insert、select 二进制。当需要处理二进制数据时，上面的方法就没办法做到。下面这一节说明如何插入二进制数据</p>
<p>3 操作二进制</p>
<p>sqlite 操作二进制数据需要用一个辅助的数据类型：sqlite3_stmt * 。</p>
<p>这个数据类型记录了一个“sql语句”。为什么我把 “sql语句” 用双引号引起来？因为你可以把 sqlite3_stmt * 所表示的内容看成是 sql语句，但是实际上它不是我们所熟知的sql语句。它是一个已经把sql语句解析了的、用sqlite自己标记记录的内部数据结构。</p>
<p>正因为这个结构已经被解析了，所以你可以往这个语句里插入二进制数据。当然，把二进制数据插到 sqlite3_stmt 结构里可不能直接 memcpy ，也不能像 std::string 那样用 + 号。必须用 sqlite 提供的函数来插入。</p>
<p>（1）写入二进制</p>
<p>下面说写二进制的步骤。</p>
<p>要插入二进制，前提是这个表的字段的类型是 blob 类型。我假设有这么一张表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table <span class="title function_">Tbl_2</span><span class="params">( ID integer, file_content  blob )</span></span><br></pre></td></tr></table></figure>

<p>首先声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3_stmt * stat;</span><br></pre></td></tr></table></figure>

<p>然后，把一个 sql 语句解析到 stat 结构里去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3_prepare( db, “insert into Tbl_2( ID, file_content) values( <span class="number">10</span>, ? )”, <span class="number">-1</span>, &amp;stat, <span class="number">0</span> );</span><br></pre></td></tr></table></figure>

<p>上面的函数完成 sql 语句的解析。第一个参数跟前面一样，是个 sqlite3 * 类型变量，第二个参数是一个 sql 语句。</p>
<p>这个 sql 语句特别之处在于 values 里面有个 ? 号。在sqlite3_prepare函数里，?号表示一个未定的值，它的值等下才插入。</p>
<p>第三个参数我写的是-1，这个参数含义是前面 sql 语句的长度。如果小于0，sqlite会自动计算它的长度（把sql语句当成以&#x2F;0结尾的字符串）。</p>
<p>第四个参数是 sqlite3_stmt 的指针的指针。解析以后的sql语句就放在这个结构里。</p>
<p>第五个参数我也不知道是干什么的。为0就可以了。</p>
<p>如果这个函数执行成功（返回值是 SQLITE_OK 且 stat 不为NULL ），那么下面就可以开始插入二进制数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3_bind_blob( stat, <span class="number">1</span>, pdata, (<span class="type">int</span>)(length_of_data_in_bytes), <span class="literal">NULL</span> ); <span class="comment">// pdata为数据缓冲区，length_of_data_in_bytes为数据大小，以字节为单位</span></span><br></pre></td></tr></table></figure>

<p>这个函数一共有5个参数。</p>
<p>第1个参数：是前面prepare得到的 sqlite3_stmt * 类型变量。</p>
<p>第2个参数：?号的索引。前面prepare的sql语句里有一个?号，假如有多个?号怎么插入？方法就是改变 bind_blob 函数第2个参数。这个参数我写1，表示这里插入的值要替换 stat 的第一个?号（这里的索引从1开始计数，而非从0开始）。如果你有多个?号，就写多个 bind_blob 语句，并改变它们的第2个参数就替换到不同的?号。如果有?号没有替换，sqlite为它取值null。</p>
<p>第3个参数：二进制数据起始指针。</p>
<p>第4个参数：二进制数据的长度，以字节为单位。</p>
<p>第5个参数：是个析够回调函数，告诉sqlite当把数据处理完后调用此函数来析够你的数据。这个参数我还没有使用过，因此理解也不深刻。但是一般都填NULL，需要释放的内存自己用代码来释放。</p>
<p>bind完了之后，二进制数据就进入了你的“sql语句”里了。你现在可以把它保存到数据库里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = sqlite3_step( stat );</span><br></pre></td></tr></table></figure>

<p>通过这个语句，stat 表示的sql语句就被写到了数据库里。</p>
<p>最后，要把 sqlite3_stmt 结构给释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3_finalize( stat ); <span class="comment">//把刚才分配的内容析构掉</span></span><br></pre></td></tr></table></figure>

<p>（2）读出二进制</p>
<p>下面说读二进制的步骤。</p>
<p>跟前面一样，先声明 sqlite3_stmt * 类型变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3_stmt * stat;</span><br></pre></td></tr></table></figure>

<p>然后，把一个 sql 语句解析到 stat 结构里去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3_prepare( db, “select * from Tbl_2”, <span class="number">-1</span>, &amp;stat, <span class="number">0</span> );</span><br></pre></td></tr></table></figure>

<p>当 prepare 成功之后（返回值是 SQLITE_OK ），开始查询数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = sqlite3_step( stat );</span><br></pre></td></tr></table></figure>

<p>这一句的返回值是SQLITE_ROW 时表示成功（不是 SQLITE_OK ）。</p>
<p>你可以循环执行sqlite3_step 函数，一次step查询出一条记录。直到返回值不为 SQLITE_ROW 时表示查询结束。</p>
<p>然后开始获取第一个字段：ID 的值。ID是个整数，用下面这个语句获取它的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> id = sqlite3_column_int( stat, <span class="number">0</span> ); <span class="comment">//第2个参数表示获取第几个字段内容，从0开始计算，因为我的表的ID字段是第一个字段，因此这里我填0</span></span><br></pre></td></tr></table></figure>

<p>下面开始获取 file_content 的值，因为 file_content 是二进制，因此我需要得到它的指针，还有它的长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">void</span> * pFileContent = sqlite3_column_blob( stat, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = sqlite3_column_bytes( stat, <span class="number">1</span> );</span><br></pre></td></tr></table></figure>

<p>这样就得到了二进制的值。</p>
<p>把 pFileContent 的内容保存出来之后，不要忘了释放 sqlite3_stmt 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3_finalize( stat ); <span class="comment">//把刚才分配的内容析构掉</span></span><br></pre></td></tr></table></figure>

<p>（3）重复使用 sqlite3_stmt 结构</p>
<p>如果你需要重复使用 sqlite3_prepare 解析好的 sqlite3_stmt 结构，需要用函数： sqlite3_reset。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = sqlite3_reset(stat);</span><br></pre></td></tr></table></figure>

<p>这样， stat 结构又成为 sqlite3_prepare 完成时的状态，你可以重新为它 bind 内容。</p>
<p>4 事务处理</p>
<p>sqlite 是支持事务处理的。如果你知道你要同步删除很多数据，不仿把它们做成一个统一的事务。</p>
<p>通常一次 sqlite3_exec 就是一次事务，如果你要删除1万条数据，sqlite就做了1万次：开始新事务-&gt;删除一条数据-&gt;提交事务-&gt;开始新事务-&gt;… 的过程。这个操作是很慢的。因为时间都花在了开始事务、提交事务上。</p>
<p>你可以把这些同类操作做成一个事务，这样如果操作错误，还能够回滚事务。</p>
<p>事务的操作没有特别的接口函数，它就是一个普通的 sql 语句而已：</p>
<p>分别如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result; </span><br><span class="line"></span><br><span class="line">result = sqlite3_exec( db, <span class="string">&quot;begin transaction&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;zErrorMsg ); <span class="comment">//开始一个事务</span></span><br><span class="line"></span><br><span class="line">result = sqlite3_exec( db, <span class="string">&quot;commit transaction&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;zErrorMsg ); <span class="comment">//提交事务</span></span><br><span class="line"></span><br><span class="line">result = sqlite3_exec( db, <span class="string">&quot;rollback transaction&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;zErrorMsg ); <span class="comment">//回滚事务</span></span><br></pre></td></tr></table></figure>

<h2 id="四、C-x2F-C-开发接口简介1-总览"><a href="#四、C-x2F-C-开发接口简介1-总览" class="headerlink" title="四、C&#x2F;C++开发接口简介1 总览"></a>四、C&#x2F;C++开发接口简介1 总览</h2><p>SQLite3是SQLite一个全新的版本,它虽然是在SQLite 2.8.13的代码基础之上开发的,但是使用了和之前的版本不兼容的数据库格式和API. SQLite3是为了满足以下的需求而开发的:</p>
<ul>
<li>支持UTF-16编码.</li>
<li>用户自定义的文本排序方法.</li>
<li>可以对BLOBs字段建立索引.</li>
</ul>
<p>因此为了支持这些特性我改变了数据库的格式,建立了一个与之前版本不兼容的3.0版. 至于其他的兼容性的改变,例如全新的API等等,都将在理论介绍之后向你说明,这样可以使你最快的一次性摆脱兼容性问题.</p>
<p>3.0版的和2.X版的API非常相似,但是有一些重要的改变需要注意. 所有API接口函数和数据结构的前缀都由”sqlite_”改为了”sqlite3_”. 这是为了避免同时使用SQLite 2.X和SQLite 3.0这两个版本的时候发生链接冲突.</p>
<p>由于对于C语言应该用什么数据类型来存放UTF-16编码的字符串并没有一致的规范. 因此SQLite使用了普通的void<em>类型来指向UTF-16编码的字符串. 客户端使用过程中可以把void</em>映射成适合他们的系统的任何数据类型.</p>
<p>2 C&#x2F;C++接口</p>
<p>SQLite 3.0一共有83个API函数,此外还有一些数据结构和预定义(#defines). (完整的API介绍请参看另一份文档.) 不过你们可以放心,这些接口使用起来不会像它的数量所暗示的那么复杂. 最简单的程序仍然使用三个函数就可以完成: sqlite3_open(), sqlite3_exec(), 和 sqlite3_close(). 要是想更好的控制数据库引擎的执行,可以使用提供的sqlite3_prepare()函数把SQL语句编译成字节码,然后在使用sqlite3_step()函数来执行编译后的字节码. 以sqlite3_column_开头的一组API函数用来获取查询结果集中的信息. 许多接口函数都是成对出现的,同时有UTF-8和UTF-16两个版本. 并且提供了一组函数用来执行用户自定义的SQL函数和文本排序函数.</p>
<p>（1）如何打开关闭数据库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sqlite3</span> <span class="title">sqlite3</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">sqlite3_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, sqlite3**)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">sqlite3_open16</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*, sqlite3**)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">sqlite3_close</span><span class="params">(sqlite3*)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> *<span class="title function_">sqlite3_errmsg</span><span class="params">(sqlite3*)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> <span class="type">void</span> *<span class="title function_">sqlite3_errmsg16</span><span class="params">(sqlite3*)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">sqlite3_errcode</span><span class="params">(sqlite3*)</span>;</span><br></pre></td></tr></table></figure>

<p>sqlite3_open() 函数返回一个整数错误代码,而不是像第二版中一样返回一个指向sqlite3结构体的指针. sqlite3_open() 和sqlite3_open16() 的不同之处在于sqlite3_open16() 使用UTF-16编码(使用本地主机字节顺序)传递数据库文件名. 如果要创建新数据库, sqlite3_open16() 将内部文本转换为UTF-16编码, 反之sqlite3_open() 将文本转换为UTF-8编码.</p>
<p>打开或者创建数据库的命令会被缓存,直到这个数据库真正被调用的时候才会被执行. 而且允许使用PRAGMA声明来设置如本地文本编码或默认内存页面大小等选项和参数.</p>
<p>sqlite3_errcode() 通常用来获取最近调用的API接口返回的错误代码. sqlite3_errmsg() 则用来得到这些错误代码所对应的文字说明. 这些错误信息将以 UTF-8 的编码返回,并且在下一次调用任何SQLite API函数的时候被清除. sqlite3_errmsg16() 和sqlite3_errmsg() 大体上相同,除了返回的错误信息将以 UTF-16 本机字节顺序编码.</p>
<p>SQLite3的错误代码相比SQLite2没有任何的改变,它们分别是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_OK           0   <span class="comment">/* Successful result */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_ERROR        1   <span class="comment">/* SQL error or missing database */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_INTERNAL     2   <span class="comment">/* An internal logic error in SQLite */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_PERM         3   <span class="comment">/* Access permission denied */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_ABORT        4   <span class="comment">/* Callback routine requested an abort */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_BUSY         5   <span class="comment">/* The database file is locked */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_LOCKED       6   <span class="comment">/* A table in the database is locked */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_NOMEM        7   <span class="comment">/* A malloc() failed */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_READONLY     8   <span class="comment">/* Attempt to write a readonly database */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_INTERRUPT    9   <span class="comment">/* Operation terminated by sqlite_interrupt() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_IOERR       10   <span class="comment">/* Some kind of disk I/O error occurred */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_CORRUPT     11   <span class="comment">/* The database disk image is malformed */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_NOTFOUND    12   <span class="comment">/* (Internal Only) Table or record not found */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_FULL        13   <span class="comment">/* Insertion failed because database is full */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_CANTOPEN    14   <span class="comment">/* Unable to open the database file */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_PROTOCOL    15   <span class="comment">/* Database lock protocol error */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_EMPTY       16   <span class="comment">/* (Internal Only) Database table is empty */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_SCHEMA      17   <span class="comment">/* The database schema changed */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_TOOBIG      18   <span class="comment">/* Too much data for one row of a table */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_CONSTRAINT  19   <span class="comment">/* Abort due to contraint violation */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_MISMATCH    20   <span class="comment">/* Data type mismatch */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_MISUSE      21   <span class="comment">/* Library used incorrectly */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_NOLFS       22   <span class="comment">/* Uses OS features not supported on host */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_AUTH        23   <span class="comment">/* Authorization denied */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_ROW         100  <span class="comment">/* sqlite_step() has another row ready */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_DONE        101  <span class="comment">/* sqlite_step() has finished executing */</span></span></span><br></pre></td></tr></table></figure>

<p>（2）执行 SQL 语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*sqlite_callback)</span><span class="params">(<span class="type">void</span>*,<span class="type">int</span>,<span class="type">char</span>**, <span class="type">char</span>**)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_exec</span><span class="params">(sqlite3*, <span class="type">const</span> <span class="type">char</span> *sql, sqlite_callback, <span class="type">void</span>*, <span class="type">char</span>**)</span>;</span><br></pre></td></tr></table></figure>

<p>sqlite3_exec 函数依然像它在SQLite2中一样承担着很多的工作. 该函数的第二个参数中可以编译和执行零个或多个SQL语句. 查询的结果返回给回调函数. 更多地信息可以查看API 参考.</p>
<p>在SQLite3里,sqlite3_exec一般是被准备SQL语句接口封装起来使用的.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sqlite3_stmt</span> <span class="title">sqlite3_stmt</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_prepare</span><span class="params">(sqlite3*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>, sqlite3_stmt**, <span class="type">const</span> <span class="type">char</span>**)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_prepare16</span><span class="params">(sqlite3*, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span>, sqlite3_stmt**, <span class="type">const</span> <span class="type">void</span>**)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_finalize</span><span class="params">(sqlite3_stmt*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_reset</span><span class="params">(sqlite3_stmt*)</span>;</span><br></pre></td></tr></table></figure>

<p>sqlite3_prepare 接口把一条SQL语句编译成字节码留给后面的执行函数. 使用该接口访问数据库是当前比较好的的一种方法.</p>
<p>sqlite3_prepare() 处理的SQL语句应该是UTF-8编码的. 而sqlite3_prepare16() 则要求是UTF-16编码的. 输入的参数中只有第一个SQL语句会被编译. 第四个参数则用来指向输入参数中下一个需要编译的SQL语句存放的SQLite statement对象的指针,任何时候如果调用 sqlite3_finalize() 将销毁一个准备好的SQL声明. 在数据库关闭之前，所有准备好的声明都必须被释放销毁. sqlite3_reset() 函数用来重置一个SQL声明的状态，使得它可以被再次执行.</p>
<p>SQL声明可以包含一些型如”?” 或 “?nnn” 或 “:aaa”的标记， 其中”nnn” 是一个整数，”aaa” 是一个字符串. 这些标记代表一些不确定的字符值（或者说是通配符），可以在后面用sqlite3_bind 接口来填充这些值. 每一个通配符都被分配了一个编号（由它在SQL声明中的位置决定，从1开始），此外也可以用 “nnn” 来表示 “?nnn” 这种情况. 允许相同的通配符在同一个SQL声明中出现多次, 在这种情况下所有相同的通配符都会被替换成相同的值. 没有被绑定的通配符将自动取NULL值.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_bind_blob</span><span class="params">(sqlite3_stmt*, <span class="type">int</span>, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span> n, <span class="type">void</span>(*)(<span class="type">void</span>*))</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_bind_double</span><span class="params">(sqlite3_stmt*, <span class="type">int</span>, <span class="type">double</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_bind_int</span><span class="params">(sqlite3_stmt*, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_bind_int64</span><span class="params">(sqlite3_stmt*, <span class="type">int</span>, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_bind_null</span><span class="params">(sqlite3_stmt*, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_bind_text</span><span class="params">(sqlite3_stmt*, <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span> n, <span class="type">void</span>(*)(<span class="type">void</span>*))</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_bind_text16</span><span class="params">(sqlite3_stmt*, <span class="type">int</span>, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span> n, <span class="type">void</span>(*)(<span class="type">void</span>*))</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_bind_value</span><span class="params">(sqlite3_stmt*, <span class="type">int</span>, <span class="type">const</span> sqlite3_value*)</span>;</span><br></pre></td></tr></table></figure>

<p>以上是 sqlite3_bind 所包含的全部接口，它们是用来给SQL声明中的通配符赋值的. 没有绑定的通配符则被认为是空值.绑定上的值不会被sqlite3_reset()函数重置. 但是在调用了sqlite3_reset()之后所有的通配符都可以被重新赋值.</p>
<p>在SQL声明准备好之后(其中绑定的步骤是可选的), 需要调用以下的方法来执行:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_step</span><span class="params">(sqlite3_stmt*)</span>;</span><br></pre></td></tr></table></figure>

<p>如果SQL返回了一个单行结果集，sqlite3_step() 函数将返回 SQLITE_ROW , 如果SQL语句执行成功或者正常将返回SQLITE_DONE , 否则将返回错误代码. 如果不能打开数据库文件则会返回 SQLITE_BUSY . 如果函数的返回值是SQLITE_ROW, 那么下边的这些方法可以用来获得记录集行中的数据:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">void</span> *<span class="title function_">sqlite3_column_blob</span><span class="params">(sqlite3_stmt*, <span class="type">int</span> iCol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_column_bytes</span><span class="params">(sqlite3_stmt*, <span class="type">int</span> iCol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_column_bytes16</span><span class="params">(sqlite3_stmt*, <span class="type">int</span> iCol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_column_count</span><span class="params">(sqlite3_stmt*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">sqlite3_column_decltype</span><span class="params">(sqlite3_stmt *, <span class="type">int</span> iCol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">void</span> *<span class="title function_">sqlite3_column_decltype16</span><span class="params">(sqlite3_stmt *, <span class="type">int</span> iCol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">sqlite3_column_double</span><span class="params">(sqlite3_stmt*, <span class="type">int</span> iCol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_column_int</span><span class="params">(sqlite3_stmt*, <span class="type">int</span> iCol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">sqlite3_column_int64</span><span class="params">(sqlite3_stmt*, <span class="type">int</span> iCol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">sqlite3_column_name</span><span class="params">(sqlite3_stmt*, <span class="type">int</span> iCol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">void</span> *<span class="title function_">sqlite3_column_name16</span><span class="params">(sqlite3_stmt*, <span class="type">int</span> iCol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">sqlite3_column_text</span><span class="params">(sqlite3_stmt*, <span class="type">int</span> iCol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">void</span> *<span class="title function_">sqlite3_column_text16</span><span class="params">(sqlite3_stmt*, <span class="type">int</span> iCol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_column_type</span><span class="params">(sqlite3_stmt*, <span class="type">int</span> iCol)</span>;</span><br></pre></td></tr></table></figure>

<p>sqlite3_column_count()函数返回结果集中包含的列数. sqlite3_column_count() 可以在执行了 sqlite3_prepare()之后的任何时刻调用. sqlite3_data_count()除了必需要在sqlite3_step()之后调用之外，其他跟sqlite3_column_count() 大同小异. 如果调用sqlite3_step() 返回值是 SQLITE_DONE 或者一个错误代码, 则此时调用sqlite3_data_count() 将返回 0 ，然而sqlite3_column_count() 仍然会返回结果集中包含的列数.</p>
<p>返回的记录集通过使用其它的几个 sqlite3_column_***() 函数来提取, 所有的这些函数都把列的编号作为第二个参数. 列编号从左到右以零起始. 请注意它和之前那些从1起始的参数的不同.</p>
<p>sqlite3_column_type()函数返回第N列的值的数据类型. 具体的返回值如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_INTEGER  1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_FLOAT    2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_TEXT     3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_BLOB     4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_NULL     5</span></span><br></pre></td></tr></table></figure>

<p>sqlite3_column_decltype() 则用来返回该列在 CREATE TABLE 语句中声明的类型. 它可以用在当返回类型是空字符串的时候. sqlite3_column_name() 返回第N列的字段名. sqlite3_column_bytes() 用来返回 UTF-8 编码的BLOBs列的字节数或者TEXT字符串的字节数. sqlite3_column_bytes16() 对于BLOBs列返回同样的结果，但是对于TEXT字符串则按 UTF-16 的编码来计算字节数. sqlite3_column_blob() 返回 BLOB 数据. sqlite3_column_text() 返回 UTF-8 编码的 TEXT 数据. sqlite3_column_text16() 返回 UTF-16 编码的 TEXT 数据. sqlite3_column_int() 以本地主机的整数格式返回一个整数值. sqlite3_column_int64() 返回一个64位的整数. 最后, sqlite3_column_double() 返回浮点数.</p>
<p>不一定非要按照sqlite3_column_type()接口返回的数据类型来获取数据. 数据类型不同时软件将自动转换.</p>
<p>（3）用户自定义函数</p>
<p>可以使用以下的方法来创建用户自定义的SQL函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sqlite3_value</span> <span class="title">sqlite3_value</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_create_function</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     sqlite3 *,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     <span class="type">const</span> <span class="type">char</span> *zFunctionName,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     <span class="type">int</span> nArg,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     <span class="type">int</span> eTextRep,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     <span class="type">void</span>*,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     <span class="type">void</span> (*xFunc)(sqlite3_context*,<span class="type">int</span>,sqlite3_value**),</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     <span class="type">void</span> (*xStep)(sqlite3_context*,<span class="type">int</span>,sqlite3_value**),</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     <span class="type">void</span> (*xFinal)(sqlite3_context*)</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">   )</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">sqlite3_create_function16</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     sqlite3*,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     <span class="type">const</span> <span class="type">void</span> *zFunctionName,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     <span class="type">int</span> nArg,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     <span class="type">int</span> eTextRep,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     <span class="type">void</span>*,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     <span class="type">void</span> (*xFunc)(sqlite3_context*,<span class="type">int</span>,sqlite3_value**),</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     <span class="type">void</span> (*xStep)(sqlite3_context*,<span class="type">int</span>,sqlite3_value**),</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">     <span class="type">void</span> (*xFinal)(sqlite3_context*)</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">   )</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> SQLITE_UTF8     1</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> SQLITE_UTF16    2</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> SQLITE_UTF16BE  3</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> SQLITE_UTF16LE  4</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> SQLITE_ANY      5</span></span><br></pre></td></tr></table></figure>

<p>nArg 参数用来表明自定义函数的参数个数. 如果参数值为0，则表示接受任意个数的参数. 用 eTextRep 参数来表明传入参数的编码形式. 参数值可以是上面的五种预定义值. SQLite3 允许同一个自定义函数有多种不同的编码参数的版本. 数据库引擎会自动选择转换参数编码个数最少的版本使用.</p>
<p>普通的函数只需要设置 xFunc 参数，而把 xStep 和 xFinal 设为NULL. 聚合函数则需要设置 xStep 和 xFinal 参数，然后把 xFunc 设为NULL. 该方法和使用sqlite3_create_aggregate() API一样.</p>
<p>sqlite3_create_function16()和sqlite_create_function()的不同就在于自定义的函数名一个要求是 UTF-16 编码，而另一个则要求是 UTF-8.</p>
<p>请注意自定函数的参数目前使用了sqlite3_value结构体指针替代了SQLite version 2.X中的字符串指针. 下面的函数用来从sqlite3_value结构体中提取数据:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">const</span> <span class="type">void</span> *<span class="title function_">sqlite3_value_blob</span><span class="params">(sqlite3_value*)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">sqlite3_value_bytes</span><span class="params">(sqlite3_value*)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">sqlite3_value_bytes16</span><span class="params">(sqlite3_value*)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">double</span> <span class="title function_">sqlite3_value_double</span><span class="params">(sqlite3_value*)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">sqlite3_value_int</span><span class="params">(sqlite3_value*)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">sqlite3_value_int64</span><span class="params">(sqlite3_value*)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">sqlite3_value_text</span><span class="params">(sqlite3_value*)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> <span class="type">void</span> *<span class="title function_">sqlite3_value_text16</span><span class="params">(sqlite3_value*)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">sqlite3_value_type</span><span class="params">(sqlite3_value*)</span>;</span><br></pre></td></tr></table></figure>

<p>上面的函数调用以下的API来获得上下文内容和返回结果:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">void</span> *<span class="title function_">sqlite3_aggregate_context</span><span class="params">(sqlite3_context*, <span class="type">int</span> nbyte)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> *<span class="title function_">sqlite3_user_data</span><span class="params">(sqlite3_context*)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> <span class="title function_">sqlite3_result_blob</span><span class="params">(sqlite3_context*, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span> n, <span class="type">void</span>(*)(<span class="type">void</span>*))</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> <span class="title function_">qlite3_result_double</span><span class="params">(sqlite3_context*, <span class="type">double</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> <span class="title function_">sqlite3_result_error</span><span class="params">(sqlite3_context*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> <span class="title function_">sqlite3_result_error16</span><span class="params">(sqlite3_context*, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> <span class="title function_">sqlite3_result_int</span><span class="params">(sqlite3_context*, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> <span class="title function_">sqlite3_result_int64</span><span class="params">(sqlite3_context*, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> <span class="title function_">sqlite3_result_null</span><span class="params">(sqlite3_context*)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> <span class="title function_">sqlite3_result_text</span><span class="params">(sqlite3_context*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span> n, <span class="type">void</span>(*)(<span class="type">void</span>*))</span>; </span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">sqlite3_result_text16</span><span class="params">(sqlite3_context*, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span> n, <span class="type">void</span>(*)(<span class="type">void</span>*))</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> <span class="title function_">sqlite3_result_value</span><span class="params">(sqlite3_context*, sqlite3_value*)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> *<span class="title function_">sqlite3_get_auxdata</span><span class="params">(sqlite3_context*, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> <span class="title function_">sqlite3_set_auxdata</span><span class="params">(sqlite3_context*, <span class="type">int</span>, <span class="type">void</span>*, <span class="type">void</span> (*)(<span class="type">void</span>*))</span>;</span><br></pre></td></tr></table></figure>

<p>（4）用户自定义排序规则</p>
<p>下面的函数用来实现用户自定义的排序规则:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sqlite3_create_collation(sqlite3*, <span class="type">const</span> <span class="type">char</span> *zName, <span class="type">int</span> eTextRep, <span class="type">void</span>*,</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>(*xCompare)(<span class="type">void</span>*,<span class="type">int</span>,<span class="type">const</span> <span class="type">void</span>*,<span class="type">int</span>,<span class="type">const</span> <span class="type">void</span>*));</span><br><span class="line"></span><br><span class="line">sqlite3_create_collation16(sqlite3*, <span class="type">const</span> <span class="type">void</span> *zName, <span class="type">int</span> eTextRep, <span class="type">void</span>*,</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>(*xCompare)(<span class="type">void</span>*,<span class="type">int</span>,<span class="type">const</span> <span class="type">void</span>*,<span class="type">int</span>,<span class="type">const</span> <span class="type">void</span>*));</span><br><span class="line"></span><br><span class="line">sqlite3_collation_needed(sqlite3*, <span class="type">void</span>*,</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>(*)(<span class="type">void</span>*,sqlite3*,<span class="type">int</span> eTextRep,<span class="type">const</span> <span class="type">char</span>*));</span><br><span class="line"></span><br><span class="line">sqlite3_collation_needed16(sqlite3*, <span class="type">void</span>*,</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>(*)(<span class="type">void</span>*,sqlite3*,<span class="type">int</span> eTextRep,<span class="type">const</span> <span class="type">void</span>*));</span><br></pre></td></tr></table></figure>

<p>sqlite3_create_collation() 函数用来声明一个排序序列和实现它的比较函数. 比较函数只能用来做文本的比较. eTextRep 参数可以取如下的预定义值 SQLITE_UTF8, SQLITE_UTF16LE, SQLITE_UTF16BE, SQLITE_ANY，用来表示比较函数所处理的文本的编码方式. 同一个自定义的排序规则的同一个比较函数可以有 UTF-8, UTF-16LE 和 UTF-16BE 等多个编码的版本. sqlite3_create_collation16()和sqlite3_create_collation() 的区别也仅仅在于排序名称的编码是 UTF-16 还是 UTF-8.</p>
<p>可以使用 sqlite3_collation_needed() 函数来注册一个回调函数，当数据库引擎遇到未知的排序规则时会自动调用该函数. 在回调函数中可以查找一个相似的比较函数，并激活相应的sqlite_3_create_collation()函数. 回调函数的第四个参数是排序规则的名称，同样sqlite3_collation_needed采用 UTF-8 编码. sqlite3_collation_need16() 采用 UTF-16 编码.</p>
<h2 id="五、给数据库加密"><a href="#五、给数据库加密" class="headerlink" title="五、给数据库加密"></a>五、给数据库加密</h2><p>前面所说的内容网上已经有很多资料，虽然比较零散，但是花点时间也还是可以找到的。现在要说的这个——数据库加密，资料就很难找。也可能是我操作水平不够，找不到对应资料。但不管这样，我还是通过网上能找到的很有限的资料，探索出了给sqlite数据库加密的完整步骤。</p>
<p>这里要提一下，虽然 sqlite 很好用，速度快、体积小巧。但是它保存的文件却是明文的。若不信可以用 NotePad 打开数据库文件瞧瞧，里面 insert 的内容几乎一览无余。这样赤裸裸的展现自己，可不是我们的初衷。当然，如果你在嵌入式系统、智能手机上使用 sqlite，最好是不加密，因为这些系统运算能力有限，你做为一个新功能提供者，不能把用户有限的运算能力全部花掉。</p>
<p>Sqlite为了速度而诞生。因此Sqlite本身不对数据库加密，要知道，如果你选择标准AES算法加密，那么一定有接近50%的时间消耗在加解密算法上，甚至更多（性能主要取决于你算法编写水平以及你是否能使用cpu提供的底层运算能力，比如MMX或sse系列指令可以大幅度提升运算速度）。</p>
<p>Sqlite免费版本是不提供加密功能的，当然你也可以选择他们的收费版本，那你得支付2000块钱，而且是USD。我这里也不是说支付钱不好，如果只为了数据库加密就去支付2000块，我觉得划不来。因为下面我将要告诉你如何为免费的Sqlite扩展出加密模块——自己动手扩展，这是Sqlite允许，也是它提倡的。</p>
<p>那么，就让我们一起开始为 sqlite3.c 文件扩展出加密模块。</p>
<p>1 必要的宏</p>
<p>通过阅读 Sqlite 代码（当然没有全部阅读完，6万多行代码，没有一行是我习惯的风格，我可没那么多眼神去看），我搞清楚了两件事：</p>
<p>Sqlite是支持加密扩展的；</p>
<p>需要 #define 一个宏才能使用加密扩展。</p>
<p>这个宏就是  SQLITE_HAS_CODEC。</p>
<p>你在代码最前面（也可以在 sqlite3.h 文件第一行）定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLITE_HAS_CODEC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLITE_HAS_CODEC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果你在代码里定义了此宏，但是还能够正常编译，那么应该是操作没有成功。因为你应该会被编译器提示有一些函数无法链接才对。如果你用的是 VC 2003，你可以在“解决方案”里右键点击你的工程，然后选“属性”，找到“C&#x2F;C++”，再找到“命令行”，在里面手工添加“&#x2F;D “SQLITE_HAS_CODEC””。</p>
<p>定义了这个宏，一些被 Sqlite 故意屏蔽掉的代码就被使用了。这些代码就是加解密的接口。</p>
<p>尝试编译，vc会提示你有一些函数无法链接，因为找不到他们的实现。</p>
<p>如果你也用的是VC2003，那么会得到下面的提示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error LNK2019: 无法解析的外部符号 _sqlite3CodecGetKey ，该符号在函数 _attachFunc 中被引用</span><br><span class="line"></span><br><span class="line">error LNK2019: 无法解析的外部符号 _sqlite3CodecAttach ，该符号在函数 _attachFunc 中被引用</span><br><span class="line"></span><br><span class="line">error LNK2019: 无法解析的外部符号 _sqlite3_activate_see ，该符号在函数 _sqlite3Pragma 中被引用</span><br><span class="line"></span><br><span class="line">error LNK2019: 无法解析的外部符号 _sqlite3_key ，该符号在函数 _sqlite3Pragma 中被引用</span><br><span class="line"></span><br><span class="line">fatal error LNK1120: <span class="number">4</span> 个无法解析的外部命令</span><br></pre></td></tr></table></figure>

<p>这是正常的，因为Sqlite只留了接口而已，并没有给出实现。</p>
<p>下面就让我来实现这些接口。</p>
<p>2自己实现加解密接口函数</p>
<p>如果真要我从一份 <a target="_blank" rel="noopener" href="http://www.sqlite.org/">www.sqlite.org</a> 网上down下来的 sqlite3.c 文件，直接摸索出这些接口的实现，我认为我还没有这个能力。</p>
<p>好在网上还有一些代码已经实现了这个功能。通过参照他们的代码以及不断编译中vc给出的错误提示，最终我把整个接口整理出来。</p>
<p>实现这些预留接口不是那么容易，要重头说一次怎么回事很困难。我把代码都写好了，直接把他们按我下面的说明拷贝到 sqlite3.c 文件对应地方即可。我在下面也提供了sqlite3.c 文件，可以直接参考或取下来使用。</p>
<p>这里要说一点的是，我另外新建了两个文件：crypt.c和crypt.h。</p>
<p>其中crypt.h如此定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span>  DCG_SQLITE_CRYPT_FUNC_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DCG_SQLITE_CRYPT_FUNC_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">董淳光写的 SQLITE 加密关键函数库</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">关键加密函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">My_Encrypt_Func</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> * pData, <span class="type">unsigned</span> <span class="type">int</span> data_len, <span class="type">const</span> <span class="type">char</span> * key, <span class="type">unsigned</span> <span class="type">int</span> len_of_key )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">关键解密函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">My_DeEncrypt_Func</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> * pData, <span class="type">unsigned</span> <span class="type">int</span> data_len, <span class="type">const</span> <span class="type">char</span> * key, <span class="type">unsigned</span> intlen_of_key )</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>其中的 crypt.c 如此定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./crypt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">关键加密函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">My_Encrypt_Func</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> * pData, <span class="type">unsigned</span> <span class="type">int</span> data_len, <span class="type">const</span> <span class="type">char</span> * key, <span class="type">unsigned</span> <span class="type">int</span> len_of_key )</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">关键解密函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">My_DeEncrypt_Func</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> * pData, <span class="type">unsigned</span> <span class="type">int</span> data_len, <span class="type">const</span> <span class="type">char</span> * key, <span class="type">unsigned</span> intlen_of_key )</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个文件很容易看，就两函数，一个加密一个解密。传进来的参数分别是待处理的数据、数据长度、密钥、密钥长度。</p>
<p>处理时直接把结果作用于 pData 指针指向的内容。</p>
<p>你需要定义自己的加解密过程，就改动这两个函数，其它部分不用动。扩展起来很简单。</p>
<p>这里有个特点，data_len 一般总是 1024 字节。正因为如此，你可以在你的算法里使用一些特定长度的加密算法，比如AES要求被加密数据一定是128位（16字节）长。这个1024不是碰巧，而是 Sqlite 的页定义是1024字节，在sqlite3.c文件里有定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> SQLITE_DEFAULT_PAGE_SIZE 1024</span></span><br></pre></td></tr></table></figure>

<p>你可以改动这个值，不过还是建议没有必要不要去改它。</p>
<p>上面写了两个扩展函数，如何把扩展函数跟 Sqlite 挂接起来，这个过程说起来比较麻烦。我直接贴代码。</p>
<p>分3个步骤。</p>
<p>首先，在 sqlite3.c 文件顶部，添加下面内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SQLITE_HAS_CODEC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./crypt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用于在 sqlite3 最后关闭时释放一些内存</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqlite3pager_free_codecarg</span><span class="params">(<span class="type">void</span> *pArg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这个函数之所以要在 sqlite3.c 开头声明，是因为下面在 sqlite3.c 里面某些函数里要插入这个函数调用。所以要提前声明。</p>
<p>其次，在sqlite3.c文件里搜索“sqlite3PagerClose”函数，要找到它的实现代码（而不是声明代码）。</p>
<p>实现代码里一开始是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SQLITE_ENABLE_MEMORY_MANAGEMENT</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* A malloc() cannot fail in sqlite3ThreadData() as one or more calls to</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ** malloc() must have already been made by this thread before it gets</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ** to this point. This means the ThreadData must have been allocated already</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ** so that ThreadData.nAlloc can be set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  ThreadData *pTsd = sqlite3ThreadData();</span><br><span class="line"></span><br><span class="line">  assert( pPager );</span><br><span class="line"></span><br><span class="line">  assert( pTsd &amp;&amp; pTsd-&gt;nAlloc );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>需要在这部分后面紧接着插入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SQLITE_HAS_CODEC</span></span><br><span class="line"></span><br><span class="line">  sqlite3pager_free_codecarg(pPager-&gt;pCodecArg);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这里要注意，sqlite3PagerClose 函数大概也是 3.3.17版本左右才改名的，以前版本里是叫 “sqlite3pager_close”。因此你在老版本sqlite代码里搜索“sqlite3PagerClose”是搜不到的。</p>
<p>类似的还有“sqlite3pager_get”、“sqlite3pager_unref”、“sqlite3pager_write”、“sqlite3pager_pagecount”等都是老版本函数，它们在 pager.h 文件里定义。新版本对应函数是在 sqlite3.h 里定义（因为都合并到 sqlite3.c和sqlite3.h两文件了）。所以，如果你在使用老版本的sqlite，先看看 pager.h 文件，这些函数不是消失了，也不是新蹦出来的，而是老版本函数改名得到的。</p>
<p>最后，往sqlite3.c 文件下找。找到最后一行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************** End of main.c ************************************************/</span></span><br></pre></td></tr></table></figure>

<p>在这一行后面，接上本文最下面的代码段。</p>
<p>这些代码很长，我不再解释，直接接上去就得了。</p>
<p>唯一要提的是 DeriveKey 函数。这个函数是对密钥的扩展。比如，你要求密钥是128位，即是16字节，但是如果用户只输入 1个字节呢？2个字节呢？或输入50个字节呢？你得对密钥进行扩展，使之符合16字节的要求。</p>
<p>DeriveKey 函数就是做这个扩展的。有人把接收到的密钥求md5，这也是一个办法，因为md5运算结果固定16字节，不论你有多少字符，最后就是16字节。这是md5算法的特点。但是我不想用md5，因为还得为它添加包含一些 md5 的.c或.cpp文件。我不想这么做。我自己写了一个算法来扩展密钥，很简单的算法。当然，你也可以使用你的扩展方法，也而可以使用md5 算法。只要修改 DeriveKey 函数就可以了。</p>
<p>在 DeriveKey 函数里，只管申请空间构造所需要的密钥，不需要释放，因为在另一个函数里有释放过程，而那个函数会在数据库关闭时被调用。参考我的 DeriveKey 函数来申请内存。</p>
<p>这里我给出我已经修改好的 sqlite3.c 和 sqlite3.h 文件。</p>
<p>如果太懒，就直接使用这两个文件，编译肯定能通过，运行也正常。当然，你必须按我前面提的，新建 crypt.h 和crypt.c 文件，而且函数要按我前面定义的要求来做。</p>
<p>3 加密使用方法</p>
<p>现在，你代码已经有了加密功能。</p>
<p>你要把加密功能给用上，除了改 sqlite3.c 文件、给你工程添加 SQLITE_HAS_CODEC 宏，还得修改你的数据库调用函数。</p>
<p>前面提到过，要开始一个数据库操作，必须先 sqlite3_open 。</p>
<p>加解密过程就在 sqlite3_open 后面操作。</p>
<p>假设你已经 sqlite3_open 成功了，紧接着写下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">     <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加、使用密码       </span></span><br><span class="line"></span><br><span class="line">     i =  sqlite3_key( db, <span class="string">&quot;dcg&quot;</span>, <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line">     <span class="comment">//修改密码</span></span><br><span class="line"></span><br><span class="line">     i =  sqlite3_rekey( db, <span class="string">&quot;dcg&quot;</span>, <span class="number">0</span> );</span><br></pre></td></tr></table></figure>

<p>用 sqlite3_key 函数来提交密码。</p>
<p>第1个参数是 sqlite3 * 类型变量，代表着用 sqlite3_open 打开的数据库（或新建数据库）。</p>
<p>第2个参数是密钥。</p>
<p>第3个参数是密钥长度。</p>
<p>用 sqlite3_rekey 来修改密码。参数含义同 sqlite3_key。</p>
<p>实际上，你可以在sqlite3_open函数之后，到 sqlite3_close 函数之前任意位置调用 sqlite3_key 来设置密码。</p>
<p>但是如果你没有设置密码，而数据库之前是有密码的，那么你做任何操作都会得到一个返回值：SQLITE_NOTADB，并且得到错误提示：“file is encrypted or is not a database”。</p>
<p>只有当你用 sqlite3_key 设置了正确的密码，数据库才会正常工作。</p>
<p>如果你要修改密码，前提是你必须先 sqlite3_open 打开数据库成功，然后 sqlite3_key 设置密钥成功，之后才能用sqlite3_rekey 来修改密码。</p>
<p>如果数据库有密码，但你没有用 sqlite3_key 设置密码，那么当你尝试用 sqlite3_rekey 来修改密码时会得到SQLITE_NOTADB 返回值。</p>
<p>如果你需要清空密码，可以使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改密码</span></span><br><span class="line"></span><br><span class="line">i =  sqlite3_rekey( db, <span class="literal">NULL</span>, <span class="number">0</span> );</span><br></pre></td></tr></table></figure>

<p>来完成密码清空功能。</p>
<p>4 sqlite3.c 最后添加代码段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">董淳光定义的加密函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SQLITE_HAS_CODEC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">加密结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRYPT_OFFSET 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CryptBlock</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">BYTE*     ReadKey;     <span class="comment">// 读数据库和写入事务的密钥</span></span><br><span class="line"></span><br><span class="line">BYTE*     WriteKey;    <span class="comment">// 写入数据库的密钥</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>       PageSize;    <span class="comment">// 页的大小</span></span><br><span class="line"></span><br><span class="line">BYTE*     Data;</span><br><span class="line"></span><br><span class="line">&#125; CryptBlock, *LPCryptBlock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>  DB_KEY_LENGTH_BYTE         <span class="comment">/*密钥长度*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DB_KEY_LENGTH_BYTE   16   <span class="comment">/*密钥长度*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>  DB_KEY_PADDING             <span class="comment">/*密钥位数不足时补充的字符*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DB_KEY_PADDING       0x33  <span class="comment">/*密钥位数不足时补充的字符*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 下面是编译时提示缺少的函数 ***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 这个函数不需要做任何处理，获取密钥的部分在下面 DeriveKey 函数里实现 **/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqlite3CodecGetKey</span><span class="params">(sqlite3* db, <span class="type">int</span> nDB, <span class="type">void</span>** Key, <span class="type">int</span>* nKey)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*被sqlite 和 sqlite3_key_interop 调用, 附加密钥到数据库.*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3CodecAttach</span><span class="params">(sqlite3 *db, <span class="type">int</span> nDb, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">int</span> nKeyLen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个函数好像是 sqlite 3.3.17前不久才加的，以前版本的sqlite里没有看到这个函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个函数我还没有搞清楚是做什么的，它里面什么都不做直接返回，对加解密没有影响</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqlite3_activate_see</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* right )</span></span><br><span class="line"></span><br><span class="line">&#123;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_key</span><span class="params">(sqlite3 *db, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">int</span> nKey)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_rekey</span><span class="params">(sqlite3 *db, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">int</span> nKey)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">下面是上面的函数的辅助处理函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从用户提供的缓冲区中得到一个加密密钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户提供的密钥可能位数上满足不了要求，使用这个函数来完成密钥扩展</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> * <span class="title function_">DeriveKey</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">int</span> nKeyLen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建或更新一个页的加密算法索引.此函数会申请缓冲区.</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> LPCryptBlock <span class="title function_">CreateCryptBlock</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* hKey, Pager *pager, LPCryptBlock pExisting)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加密/解密函数, 被pager调用</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">sqlite3Codec</span><span class="params">(<span class="type">void</span> *pArg, <span class="type">unsigned</span> <span class="type">char</span> *data, Pgno nPageNum, <span class="type">int</span> nMode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置密码函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __stdcall <span class="title function_">sqlite3_key_interop</span><span class="params">(sqlite3 *db, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">int</span> nKeySize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改密码函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __stdcall <span class="title function_">sqlite3_rekey_interop</span><span class="params">(sqlite3 *db, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">int</span> nKeySize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个加密块及相关的缓冲区,密钥.</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DestroyCryptBlock</span><span class="params">(LPCryptBlock pBlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> * <span class="title function_">sqlite3pager_get_codecarg</span><span class="params">(Pager *pPager)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqlite3pager_set_codec</span><span class="params">(Pager *pPager,<span class="type">void</span> *(*xCodec)(<span class="type">void</span>*,<span class="type">void</span>*,Pgno,<span class="type">int</span>),<span class="type">void</span> *pCodecArg    )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加密/解密函数, 被pager调用</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">sqlite3Codec</span><span class="params">(<span class="type">void</span> *pArg, <span class="type">unsigned</span> <span class="type">char</span> *data, Pgno nPageNum, <span class="type">int</span> nMode)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">LPCryptBlock pBlock = (LPCryptBlock)pArg;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dwPageSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pBlock) <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保pager的页长度和加密块的页长度相等.如果改变,就需要调整.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nMode != <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     PgHdr *pageHeader;</span><br><span class="line"></span><br><span class="line">     pageHeader = DATA_TO_PGHDR(data);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (pageHeader-&gt;pPager-&gt;pageSize != pBlock-&gt;PageSize)</span><br><span class="line"></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">          CreateCryptBlock(<span class="number">0</span>, pageHeader-&gt;pPager, pBlock);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(nMode)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// Undo a &quot;case 7&quot; journal file encryption</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//重载一个页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//载入一个页</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!pBlock-&gt;ReadKey) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">     dwPageSize = pBlock-&gt;PageSize;</span><br><span class="line"></span><br><span class="line">     My_DeEncrypt_Func(data, dwPageSize, pBlock-&gt;ReadKey, DB_KEY_LENGTH_BYTE );  <span class="comment">/*调用我的解密函数*/</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//加密一个主数据库文件的页</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!pBlock-&gt;WriteKey) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">memcpy</span>(pBlock-&gt;Data + CRYPT_OFFSET, data, pBlock-&gt;PageSize);</span><br><span class="line"></span><br><span class="line">     data = pBlock-&gt;Data + CRYPT_OFFSET;</span><br><span class="line"></span><br><span class="line">     dwPageSize = pBlock-&gt;PageSize;</span><br><span class="line"></span><br><span class="line">     My_Encrypt_Func(data , dwPageSize, pBlock-&gt;WriteKey, DB_KEY_LENGTH_BYTE ); <span class="comment">/*调用我的加密函数*/</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: <span class="comment">//加密事务文件的页</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/*在正常环境下, 读密钥和写密钥相同. 当数据库是被重新加密的,读密钥和写密钥未必相同.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     回滚事务必要用数据库文件的原始密钥写入.因此,当一次回滚被写入,总是用数据库的读密钥,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     这是为了保证与读取原始数据的密钥相同.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!pBlock-&gt;ReadKey) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">memcpy</span>(pBlock-&gt;Data + CRYPT_OFFSET, data, pBlock-&gt;PageSize);</span><br><span class="line"></span><br><span class="line">     data = pBlock-&gt;Data + CRYPT_OFFSET;</span><br><span class="line"></span><br><span class="line">     dwPageSize = pBlock-&gt;PageSize;</span><br><span class="line"></span><br><span class="line">     My_Encrypt_Func( data, dwPageSize, pBlock-&gt;ReadKey, DB_KEY_LENGTH_BYTE ); <span class="comment">/*调用我的加密函数*/</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个加密块及相关的缓冲区,密钥.</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DestroyCryptBlock</span><span class="params">(LPCryptBlock pBlock)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁读密钥.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pBlock-&gt;ReadKey)&#123;</span><br><span class="line"></span><br><span class="line">     sqliteFree(pBlock-&gt;ReadKey);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果写密钥存在并且不等于读密钥,也销毁.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pBlock-&gt;WriteKey &amp;&amp; pBlock-&gt;WriteKey != pBlock-&gt;ReadKey)&#123;</span><br><span class="line"></span><br><span class="line">     sqliteFree(pBlock-&gt;WriteKey);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pBlock-&gt;Data)&#123;</span><br><span class="line"></span><br><span class="line">     sqliteFree(pBlock-&gt;Data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放加密块.</span></span><br><span class="line"></span><br><span class="line">sqliteFree(pBlock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> * <span class="title function_">sqlite3pager_get_codecarg</span><span class="params">(Pager *pPager)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (pPager-&gt;xCodec) ? pPager-&gt;pCodecArg: <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从用户提供的缓冲区中得到一个加密密钥</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> * <span class="title function_">DeriveKey</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">int</span> nKeyLen)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *  hKey = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( pKey == <span class="literal">NULL</span> || nKeyLen == <span class="number">0</span> )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hKey = sqliteMalloc( DB_KEY_LENGTH_BYTE + <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( hKey == <span class="literal">NULL</span> )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hKey[ DB_KEY_LENGTH_BYTE ] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( nKeyLen &lt; DB_KEY_LENGTH_BYTE )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">memcpy</span>( hKey, pKey, nKeyLen ); <span class="comment">//先拷贝得到密钥前面的部分</span></span><br><span class="line"></span><br><span class="line">     j = DB_KEY_LENGTH_BYTE - nKeyLen;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//补充密钥后面的部分</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">memset</span>(  hKey + nKeyLen,  DB_KEY_PADDING, j  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">//密钥位数已经足够,直接把密钥取过来</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">memcpy</span>(  hKey, pKey, DB_KEY_LENGTH_BYTE );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hKey;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建或更新一个页的加密算法索引.此函数会申请缓冲区.</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> LPCryptBlock <span class="title function_">CreateCryptBlock</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* hKey, Pager *pager, LPCryptBlock pExisting)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">LPCryptBlock pBlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pExisting) <span class="comment">//创建新加密块</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     pBlock = sqliteMalloc(<span class="keyword">sizeof</span>(CryptBlock));</span><br><span class="line"></span><br><span class="line">     <span class="built_in">memset</span>(pBlock, <span class="number">0</span>, <span class="keyword">sizeof</span>(CryptBlock));</span><br><span class="line"></span><br><span class="line">     pBlock-&gt;ReadKey = hKey;</span><br><span class="line"></span><br><span class="line">     pBlock-&gt;WriteKey = hKey;</span><br><span class="line"></span><br><span class="line">     pBlock-&gt;PageSize = pager-&gt;pageSize;</span><br><span class="line"></span><br><span class="line">     pBlock-&gt;Data = (<span class="type">unsigned</span> <span class="type">char</span>*)sqliteMalloc(pBlock-&gt;PageSize + CRYPT_OFFSET);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="comment">//更新存在的加密块</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     pBlock = pExisting;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ( pBlock-&gt;PageSize != pager-&gt;pageSize &amp;&amp; !pBlock-&gt;Data)&#123;</span><br><span class="line"></span><br><span class="line">          sqliteFree(pBlock-&gt;Data);</span><br><span class="line"></span><br><span class="line">          pBlock-&gt;PageSize = pager-&gt;pageSize;</span><br><span class="line"></span><br><span class="line">          pBlock-&gt;Data = (<span class="type">unsigned</span> <span class="type">char</span>*)sqliteMalloc(pBlock-&gt;PageSize + CRYPT_OFFSET);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(pBlock-&gt;Data, <span class="number">0</span>, pBlock-&gt;PageSize + CRYPT_OFFSET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pBlock;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">** Set the codec for this pager</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqlite3pager_set_codec</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                             Pager *pPager,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                             <span class="type">void</span> *(*xCodec)(<span class="type">void</span>*,<span class="type">void</span>*,Pgno,<span class="type">int</span>),</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                             <span class="type">void</span> *pCodecArg</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                             )</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">pPager-&gt;xCodec = xCodec;</span><br><span class="line"></span><br><span class="line">pPager-&gt;pCodecArg = pCodecArg;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_key</span><span class="params">(sqlite3 *db, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">int</span> nKey)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sqlite3_key_interop(db, pKey, nKey);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_rekey</span><span class="params">(sqlite3 *db, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">int</span> nKey)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sqlite3_rekey_interop(db, pKey, nKey);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*被sqlite 和 sqlite3_key_interop 调用, 附加密钥到数据库.*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3CodecAttach</span><span class="params">(sqlite3 *db, <span class="type">int</span> nDb, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">int</span> nKeyLen)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rc = SQLITE_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* hKey = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有指定密匙,可能标识用了主数据库的加密或没加密.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pKey || !nKeyLen)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!nDb)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SQLITE_OK; <span class="comment">//主数据库, 没有指定密钥所以没有加密.</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//附加数据库,使用主数据库的密钥.</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取主数据库的加密块并复制密钥给附加数据库使用</span></span><br><span class="line"></span><br><span class="line">            LPCryptBlock pBlock = (LPCryptBlock)sqlite3pager_get_codecarg(sqlite3BtreePager(db-&gt;aDb[<span class="number">0</span>].pBt));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!pBlock) <span class="keyword">return</span> SQLITE_OK; <span class="comment">//主数据库没有加密</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!pBlock-&gt;ReadKey) <span class="keyword">return</span> SQLITE_OK; <span class="comment">//没有加密</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(pBlock-&gt;ReadKey, &amp;hKey, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//用户提供了密码,从中创建密钥.</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        hKey = DeriveKey(pKey, nKeyLen);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个新的加密块,并将解码器指向新的附加数据库.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hKey)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        LPCryptBlock pBlock = CreateCryptBlock(hKey, sqlite3BtreePager(db-&gt;aDb[nDb].pBt), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        sqlite3pager_set_codec(sqlite3BtreePager(db-&gt;aDb[nDb].pBt), sqlite3Codec, pBlock);</span><br><span class="line"></span><br><span class="line">        rc = SQLITE_OK;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Changes the encryption key for an existing database.</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __stdcall <span class="title function_">sqlite3_rekey_interop</span><span class="params">(sqlite3 *db, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">int</span> nKeySize)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Btree *pbt = db-&gt;aDb[<span class="number">0</span>].pBt;</span><br><span class="line"></span><br><span class="line">Pager *p = sqlite3BtreePager(pbt);</span><br><span class="line"></span><br><span class="line">LPCryptBlock pBlock = (LPCryptBlock)sqlite3pager_get_codecarg(p);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> * hKey = DeriveKey(pKey, nKeySize);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rc = SQLITE_ERROR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pBlock &amp;&amp; !hKey) <span class="keyword">return</span> SQLITE_OK;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新加密一个数据库,改变pager的写密钥, 读密钥依旧保留.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pBlock) <span class="comment">//加密一个未加密的数据库</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     pBlock = CreateCryptBlock(hKey, p, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">     pBlock-&gt;ReadKey = <span class="number">0</span>; <span class="comment">// 原始数据库未加密</span></span><br><span class="line"></span><br><span class="line">     sqlite3pager_set_codec(sqlite3BtreePager(pbt), sqlite3Codec, pBlock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 改变已加密数据库的写密钥</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     pBlock-&gt;WriteKey = hKey;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始一个事务</span></span><br><span class="line"></span><br><span class="line">rc = sqlite3BtreeBeginTrans(pbt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!rc)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 用新密钥重写所有的页到数据库。</span></span><br><span class="line"></span><br><span class="line">     Pgno nPage = sqlite3PagerPagecount(p);</span><br><span class="line"></span><br><span class="line">     Pgno nSkip = PAGER_MJ_PGNO(p);</span><br><span class="line"></span><br><span class="line">     <span class="type">void</span> *pPage;</span><br><span class="line"></span><br><span class="line">     Pgno n;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(n = <span class="number">1</span>; rc == SQLITE_OK &amp;&amp; n &lt;= nPage; n ++)</span><br><span class="line"></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (n == nSkip) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          rc = sqlite3PagerGet(p, n, &amp;pPage);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(!rc)</span><br><span class="line"></span><br><span class="line">          &#123;</span><br><span class="line"></span><br><span class="line">               rc = sqlite3PagerWrite(pPage);</span><br><span class="line"></span><br><span class="line">               sqlite3PagerUnref(pPage);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果成功，提交事务。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!rc)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     rc = sqlite3BtreeCommit(pbt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果失败，回滚。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     sqlite3BtreeRollback(pbt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果成功，销毁先前的读密钥。并使读密钥等于当前的写密钥。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!rc)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (pBlock-&gt;ReadKey)</span><br><span class="line"></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">          sqliteFree(pBlock-&gt;ReadKey);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     pBlock-&gt;ReadKey = pBlock-&gt;WriteKey;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span><span class="comment">// 如果失败，销毁当前的写密钥，并恢复为当前的读密钥。</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (pBlock-&gt;WriteKey)</span><br><span class="line"></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">          sqliteFree(pBlock-&gt;WriteKey);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     pBlock-&gt;WriteKey = pBlock-&gt;ReadKey;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果读密钥和写密钥皆为空，就不需要再对页进行编解码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁加密块并移除页的编解码器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pBlock-&gt;ReadKey &amp;&amp; !pBlock-&gt;WriteKey)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     sqlite3pager_set_codec(p, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">     DestroyCryptBlock(pBlock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">下面是加密函数的主体</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __stdcall <span class="title function_">sqlite3_key_interop</span><span class="params">(sqlite3 *db, <span class="type">const</span> <span class="type">void</span> *pKey, <span class="type">int</span> nKeySize)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sqlite3CodecAttach(db, <span class="number">0</span>, pKey, nKeySize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放与一个页相关的加密块</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sqlite3pager_free_codecarg</span><span class="params">(<span class="type">void</span> *pArg)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pArg)</span><br><span class="line"></span><br><span class="line">     DestroyCryptBlock((LPCryptBlock)pArg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//#ifdef SQLITE_HAS_CODEC</span></span></span><br></pre></td></tr></table></figure>

<h2 id="五、性能优化"><a href="#五、性能优化" class="headerlink" title="五、性能优化"></a>五、性能优化</h2><p>很多人直接就使用了，并未注意到SQLite也有配置参数，可以对性能进行调整。有时候，产生的结果会有很大影响。</p>
<p>主要通过pragma指令来实现。</p>
<p>比如： 空间释放、磁盘同步、Cache大小等。</p>
<p>不要打开。前文提高了，Vacuum的效率非常低！</p>
<p>1 auto_vacuum</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRAGMA auto_vacuum;   </span><br><span class="line">PRAGMA auto_vacuum = <span class="number">0</span> | <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>查询或设置数据库的auto-vacuum标记。</p>
<p>正常情况下，当提交一个从数据库中删除数据的事务时，数据库文件不改变大小。未使用的文件页被标记并在以后的添加操作中再次使用。这种情况下使用VACUUM命令释放删除得到的空间。</p>
<p>当开启auto-vacuum，当提交一个从数据库中删除数据的事务时，数据库文件自动收缩， (VACUUM命令在auto-vacuum开启的数据库中不起作用)。数据库会在内部存储一些信息以便支持这一功能，这使得数据库文件比不开启该选项时稍微大一些。</p>
<p>只有在数据库中未建任何表时才能改变auto-vacuum标记。试图在已有表的情况下修改不会导致报错。</p>
<p>2 cache_size</p>
<p>建议改为8000</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRAGMA cache_size;   </span><br><span class="line">PRAGMA cache_size = Number-of-pages;</span><br></pre></td></tr></table></figure>

<p>查询或修改SQLite一次存储在内存中的数据库文件页数。每页使用约1.5K内存，缺省的缓存大小是2000. 若需要使用改变大量多行的UPDATE或DELETE命令，并且不介意SQLite使用更多的内存的话，可以增大缓存以提高性能。</p>
<p>当使用cache_size pragma改变缓存大小时，改变仅对当前对话有效，当数据库关闭重新打开时缓存大小恢复到缺省大小。 要想永久改变缓存大小，使用<a target="_blank" rel="noopener" href="http://www.jimmydong.com/blog/">default_cache_size</a> pragma.</p>
<p>3 case_sensitive_like</p>
<p>打开。不然搜索中文字串会出错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRAGMA case_sensitive_like;   </span><br><span class="line">PRAGMA case_sensitive_like = <span class="number">0</span> | <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>LIKE运算符的缺省行为是忽略latin1字符的大小写。因此在缺省情况下’a’ LIKE ‘A’的值为真。可以通过打开case_sensitive_like pragma来改变这一缺省行为。当启用case_sensitive_like，’a’ LIKE ‘A’为假而 ‘a’ LIKE ‘a’依然为真。</p>
<p>4 count_changes</p>
<p>打开。便于调试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRAGMA count_changes;   </span><br><span class="line">PRAGMA count_changes = <span class="number">0</span> | <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>查询或更改count-changes标记。正常情况下INSERT, UPDATE和DELETE语句不返回数据。 当开启count-changes，以上语句返回一行含一个整数值的数据——该语句插入，修改或删除的行数。 返回的行数不包括由触发器产生的插入，修改或删除等改变的行数。</p>
<p>5 page_size</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRAGMA page_size;   </span><br><span class="line">PRAGMA page_size = bytes;</span><br></pre></td></tr></table></figure>

<p>查询或设置page-size值。只有在未创建数据库时才能设置page-size。页面大小必须是2的整数倍且大于等于512小于等于8192。 上限可以通过在编译时修改宏定义SQLITE_MAX_PAGE_SIZE的值来改变。上限的上限是32768.</p>
<p>6 synchronous</p>
<p>如果有定期备份的机制，而且少量数据丢失可接受，用OFF</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PRAGMA synchronous;   </span><br><span class="line">PRAGMA synchronous = FULL; (<span class="number">2</span>)   </span><br><span class="line">PRAGMA synchronous = NORMAL; (<span class="number">1</span>)   </span><br><span class="line">PRAGMA synchronous = OFF; (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>查询或更改”synchronous”标记的设定。第一种形式(查询)返回整数值。 当synchronous设置为FULL (2), SQLite数据库引擎在紧急时刻会暂停以确定数据已经写入磁盘。 这使系统崩溃或电源出问题时能确保数据库在重起后不会损坏。FULL synchronous很安全但很慢。 当synchronous设置为NORMAL, SQLite数据库引擎在大部分紧急时刻会暂停，但不像FULL模式下那么频繁。 NORMAL模式下有很小的几率(但不是不存在)发生电源故障导致数据库损坏的情况。但实际上，在这种情况下很可能你的硬盘已经不能使用，或者发生了其他的不可恢复的硬件错误。 设置为synchronous OFF (0)时，SQLite在传递数据给系统以后直接继续而不暂停。若运行SQLite的应用程序崩溃， 数据不会损伤，但在系统崩溃或写入数据时意外断电的情况下数据库可能会损坏。另一方面，在synchronous OFF时 一些操作可能会快50倍甚至更多。</p>
<p>在SQLite 2中，缺省值为NORMAL.而在3中修改为FULL.</p>
<p>7 temp_store</p>
<p>使用2，内存模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PRAGMA temp_store;   </span><br><span class="line">PRAGMA temp_store = DEFAULT; (<span class="number">0</span>)   </span><br><span class="line">PRAGMA temp_store = FILE; (<span class="number">1</span>)   </span><br><span class="line">PRAGMA temp_store = MEMORY; (<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>查询或更改”temp_store”参数的设置。当temp_store设置为DEFAULT (0),使用编译时的C预处理宏 TEMP_STORE来定义储存临时表和临时索引的位置。当设置为MEMORY (2)临时表和索引存放于内存中。 当设置为FILE (1)则存放于文件中。temp_store_directorypragma 可用于指定存放该文件的目录。当改变temp_store设置，所有已存在的临时表，索引，触发器及视图将被立即删除。</p>
<p>经测试，在类BBS应用上，通过以上调整，效率可以提高2倍以上。</p>
<h2 id="六、后记"><a href="#六、后记" class="headerlink" title="六、后记"></a>六、后记</h2><p><strong>（原文后记）</strong></p>
<p>写此教程，可不是一个累字能解释。</p>
<p>但是我还是觉得欣慰的，因为我很久以前就想写 sqlite 的教程，一来自己备忘，二而已造福大众，大家不用再走弯路。</p>
<p>本人第一次写教程，不足的地方请大家指出。</p>
<p>本文可随意转载、修改、引用。但无论是转载、修改、引用，都请附带我的名字：董淳光。以示对我劳动的肯定。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>C语言SQLite3使用总结</p><p><a href="https://mxts.jiujiuer.xyz/2022/11/22/计算机科学/编程语言/C·C++/C语言SQLite3使用总结/">https://mxts.jiujiuer.xyz/2022/11/22/计算机科学/编程语言/C·C++/C语言SQLite3使用总结/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>xeonds</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-11-22</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-03-02</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="sharethis-inline-share-buttons"></div><script src="https://mxts.jiujiuer.xyz/" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">C语言命令行参数解析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Go%E8%AF%AD%E8%A8%80%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%93urfave-cli%E7%AE%80%E4%BB%8B/"><span class="level-item">Go语言命令行库urfave-cli简介</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "bcdf34faa51a015c48c8560fd2eb2d52",
            repo: "xeonds.github.io",
            owner: "xeonds",
            clientID: "2bfc40bc0b5fef7b0688",
            clientSecret: "475f278f70ff3f0888e047f10766ab6929168f78",
            admin: ["xeonds"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、版本"><span class="level-left"><span class="level-item">1</span><span class="level-item">一、版本</span></span></a></li><li><a class="level is-mobile" href="#二、基本编译"><span class="level-left"><span class="level-item">2</span><span class="level-item">二、基本编译</span></span></a></li><li><a class="level is-mobile" href="#三、SQLITE操作入门"><span class="level-left"><span class="level-item">3</span><span class="level-item">三、SQLITE操作入门</span></span></a></li><li><a class="level is-mobile" href="#四、C-x2F-C-开发接口简介1-总览"><span class="level-left"><span class="level-item">4</span><span class="level-item">四、C/C++开发接口简介1 总览</span></span></a></li><li><a class="level is-mobile" href="#五、给数据库加密"><span class="level-left"><span class="level-item">5</span><span class="level-item">五、给数据库加密</span></span></a></li><li><a class="level is-mobile" href="#五、性能优化"><span class="level-left"><span class="level-item">6</span><span class="level-item">五、性能优化</span></span></a></li><li><a class="level is-mobile" href="#六、后记"><span class="level-left"><span class="level-item">7</span><span class="level-item">六、后记</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="xeonds"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">xeonds</p><p class="is-size-6 is-block">ENJ0Y CREATiNG.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Solaris, Earth</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">172</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">31</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">93</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xeonds" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xeonds"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://holynia.github.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Holynia</span></span><span class="level-right"><span class="level-item tag">holynia.github.io</span></span></a></li><li><a class="level is-mobile" href="https://ray.al" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Ray</span></span><span class="level-right"><span class="level-item tag">ray.al</span></span></a></li><li><a class="level is-mobile" href="https://moefactory.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Robotxm</span></span><span class="level-right"><span class="level-item tag">moefactory.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.dml.ink" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Dimole</span></span><span class="level-right"><span class="level-item tag">blog.dml.ink</span></span></a></li><li><a class="level is-mobile" href="https://mxts.jiujiuer.xyz/links" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">All</span></span><span class="level-right"><span class="level-item tag">mxts.jiujiuer.xyz</span></span></a></li><li><a class="level is-mobile" href="https://blog.iris.al/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">极速版（？</span></span><span class="level-right"><span class="level-item tag">blog.iris.al</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-02T11:40:46.000Z">2025-03-02</time></p><p class="title"><a href="/2025/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/nginx+vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%90%8E%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90/">nginx+vue项目部署后无法加载资源</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-12-25T18:34:14.000Z">2024-12-26</time></p><p class="title"><a href="/2024/12/25/%E6%96%87%E5%AD%A6/%E6%9D%82%E8%B0%88/2024%E4%B9%8B%E6%A2%A6/">2024之梦</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-12T07:41:18.000Z">2024-09-12</time></p><p class="title"><a href="/2024/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E9%BE%99%E8%8A%AF%E4%B9%85%E4%B9%85%E6%B4%BEPlus%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/">龙芯久久派Plus折腾笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-08T03:39:09.000Z">2024-07-08</time></p><p class="title"><a href="/2024/07/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%A1%AC%E4%BB%B6/%E7%A3%81%E5%B8%A6%E6%9C%BA%E5%85%A5%E5%9D%91%E5%B0%8F%E8%AE%B0/">磁带机入坑小记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-05T06:03:13.000Z">2024-07-05</time></p><p class="title"><a href="/2024/07/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Linux%E4%B8%8A%E7%9A%84ESP32+MicroPython%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0/">Linux上的ESP32+MicroPython开发手记</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/"><span class="level-start"><span class="level-item">2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">50</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">56</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/"><span class="level-start"><span class="level-item">2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/favicon.ico" alt="神社的储物间" height="28"></a><p class="is-size-7"><span>&copy; 2025 xeonds</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>